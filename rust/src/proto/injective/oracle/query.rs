// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/oracle/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPythPriceRequest {
    // message fields
    pub price_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPythPriceRequest {
    fn default() -> &'a QueryPythPriceRequest {
        <QueryPythPriceRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPythPriceRequest {
    pub fn new() -> QueryPythPriceRequest {
        ::std::default::Default::default()
    }

    // string price_id = 1;


    pub fn get_price_id(&self) -> &str {
        &self.price_id
    }
    pub fn clear_price_id(&mut self) {
        self.price_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_id(&mut self, v: ::std::string::String) {
        self.price_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_id(&mut self) -> &mut ::std::string::String {
        &mut self.price_id
    }

    // Take field
    pub fn take_price_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryPythPriceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price_id.is_empty() {
            os.write_string(1, &self.price_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPythPriceRequest {
        QueryPythPriceRequest::new()
    }

    fn default_instance() -> &'static QueryPythPriceRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPythPriceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPythPriceRequest::new)
    }
}

impl ::protobuf::Clear for QueryPythPriceRequest {
    fn clear(&mut self) {
        self.price_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPythPriceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPythPriceResponse {
    // message fields
    pub price_state: ::protobuf::SingularPtrField<super::oracle::PythPriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPythPriceResponse {
    fn default() -> &'a QueryPythPriceResponse {
        <QueryPythPriceResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPythPriceResponse {
    pub fn new() -> QueryPythPriceResponse {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.PythPriceState price_state = 1;


    pub fn get_price_state(&self) -> &super::oracle::PythPriceState {
        self.price_state.as_ref().unwrap_or_else(|| <super::oracle::PythPriceState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_price_state(&mut self) {
        self.price_state.clear();
    }

    pub fn has_price_state(&self) -> bool {
        self.price_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_state(&mut self, v: super::oracle::PythPriceState) {
        self.price_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_state(&mut self) -> &mut super::oracle::PythPriceState {
        if self.price_state.is_none() {
            self.price_state.set_default();
        }
        self.price_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_state(&mut self) -> super::oracle::PythPriceState {
        self.price_state.take().unwrap_or_else(|| super::oracle::PythPriceState::new())
    }
}

impl ::protobuf::Message for QueryPythPriceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.price_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.price_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.price_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPythPriceResponse {
        QueryPythPriceResponse::new()
    }

    fn default_instance() -> &'static QueryPythPriceResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPythPriceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPythPriceResponse::new)
    }
}

impl ::protobuf::Clear for QueryPythPriceResponse {
    fn clear(&mut self) {
        self.price_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPythPriceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryParamsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsRequest {
    fn default() -> &'a QueryParamsRequest {
        <QueryParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsRequest {
    pub fn new() -> QueryParamsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsRequest {
        QueryParamsRequest::new()
    }

    fn default_instance() -> &'static QueryParamsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsRequest::new)
    }
}

impl ::protobuf::Clear for QueryParamsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryParamsResponse {
    // message fields
    pub params: ::protobuf::SingularPtrField<super::oracle::Params>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParamsResponse {
    fn default() -> &'a QueryParamsResponse {
        <QueryParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryParamsResponse {
    pub fn new() -> QueryParamsResponse {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.Params params = 1;


    pub fn get_params(&self) -> &super::oracle::Params {
        self.params.as_ref().unwrap_or_else(|| <super::oracle::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::oracle::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::oracle::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::oracle::Params {
        self.params.take().unwrap_or_else(|| super::oracle::Params::new())
    }
}

impl ::protobuf::Message for QueryParamsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParamsResponse {
        QueryParamsResponse::new()
    }

    fn default_instance() -> &'static QueryParamsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParamsResponse::new)
    }
}

impl ::protobuf::Clear for QueryParamsResponse {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandRelayersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandRelayersRequest {
    fn default() -> &'a QueryBandRelayersRequest {
        <QueryBandRelayersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandRelayersRequest {
    pub fn new() -> QueryBandRelayersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryBandRelayersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandRelayersRequest {
        QueryBandRelayersRequest::new()
    }

    fn default_instance() -> &'static QueryBandRelayersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBandRelayersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandRelayersRequest::new)
    }
}

impl ::protobuf::Clear for QueryBandRelayersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandRelayersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandRelayersResponse {
    // message fields
    pub relayers: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandRelayersResponse {
    fn default() -> &'a QueryBandRelayersResponse {
        <QueryBandRelayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandRelayersResponse {
    pub fn new() -> QueryBandRelayersResponse {
        ::std::default::Default::default()
    }

    // repeated string relayers = 1;


    pub fn get_relayers(&self) -> &[::std::string::String] {
        &self.relayers
    }
    pub fn clear_relayers(&mut self) {
        self.relayers.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.relayers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relayers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.relayers
    }

    // Take field
    pub fn take_relayers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.relayers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBandRelayersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.relayers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relayers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relayers {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandRelayersResponse {
        QueryBandRelayersResponse::new()
    }

    fn default_instance() -> &'static QueryBandRelayersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBandRelayersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandRelayersResponse::new)
    }
}

impl ::protobuf::Clear for QueryBandRelayersResponse {
    fn clear(&mut self) {
        self.relayers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandRelayersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandPriceStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandPriceStatesRequest {
    fn default() -> &'a QueryBandPriceStatesRequest {
        <QueryBandPriceStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandPriceStatesRequest {
    pub fn new() -> QueryBandPriceStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryBandPriceStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandPriceStatesRequest {
        QueryBandPriceStatesRequest::new()
    }

    fn default_instance() -> &'static QueryBandPriceStatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBandPriceStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandPriceStatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryBandPriceStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandPriceStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandPriceStatesResponse {
    // message fields
    pub price_states: ::protobuf::RepeatedField<super::oracle::BandPriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandPriceStatesResponse {
    fn default() -> &'a QueryBandPriceStatesResponse {
        <QueryBandPriceStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandPriceStatesResponse {
    pub fn new() -> QueryBandPriceStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.BandPriceState price_states = 1;


    pub fn get_price_states(&self) -> &[super::oracle::BandPriceState] {
        &self.price_states
    }
    pub fn clear_price_states(&mut self) {
        self.price_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_states(&mut self, v: ::protobuf::RepeatedField<super::oracle::BandPriceState>) {
        self.price_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_states(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::BandPriceState> {
        &mut self.price_states
    }

    // Take field
    pub fn take_price_states(&mut self) -> ::protobuf::RepeatedField<super::oracle::BandPriceState> {
        ::std::mem::replace(&mut self.price_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBandPriceStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandPriceStatesResponse {
        QueryBandPriceStatesResponse::new()
    }

    fn default_instance() -> &'static QueryBandPriceStatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBandPriceStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandPriceStatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryBandPriceStatesResponse {
    fn clear(&mut self) {
        self.price_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandPriceStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandIBCPriceStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandIBCPriceStatesRequest {
    fn default() -> &'a QueryBandIBCPriceStatesRequest {
        <QueryBandIBCPriceStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandIBCPriceStatesRequest {
    pub fn new() -> QueryBandIBCPriceStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryBandIBCPriceStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandIBCPriceStatesRequest {
        QueryBandIBCPriceStatesRequest::new()
    }

    fn default_instance() -> &'static QueryBandIBCPriceStatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBandIBCPriceStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandIBCPriceStatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryBandIBCPriceStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandIBCPriceStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBandIBCPriceStatesResponse {
    // message fields
    pub price_states: ::protobuf::RepeatedField<super::oracle::BandPriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBandIBCPriceStatesResponse {
    fn default() -> &'a QueryBandIBCPriceStatesResponse {
        <QueryBandIBCPriceStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBandIBCPriceStatesResponse {
    pub fn new() -> QueryBandIBCPriceStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.BandPriceState price_states = 1;


    pub fn get_price_states(&self) -> &[super::oracle::BandPriceState] {
        &self.price_states
    }
    pub fn clear_price_states(&mut self) {
        self.price_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_states(&mut self, v: ::protobuf::RepeatedField<super::oracle::BandPriceState>) {
        self.price_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_states(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::BandPriceState> {
        &mut self.price_states
    }

    // Take field
    pub fn take_price_states(&mut self) -> ::protobuf::RepeatedField<super::oracle::BandPriceState> {
        ::std::mem::replace(&mut self.price_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBandIBCPriceStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBandIBCPriceStatesResponse {
        QueryBandIBCPriceStatesResponse::new()
    }

    fn default_instance() -> &'static QueryBandIBCPriceStatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBandIBCPriceStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBandIBCPriceStatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryBandIBCPriceStatesResponse {
    fn clear(&mut self) {
        self.price_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBandIBCPriceStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPriceFeedPriceStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPriceFeedPriceStatesRequest {
    fn default() -> &'a QueryPriceFeedPriceStatesRequest {
        <QueryPriceFeedPriceStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPriceFeedPriceStatesRequest {
    pub fn new() -> QueryPriceFeedPriceStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryPriceFeedPriceStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPriceFeedPriceStatesRequest {
        QueryPriceFeedPriceStatesRequest::new()
    }

    fn default_instance() -> &'static QueryPriceFeedPriceStatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPriceFeedPriceStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPriceFeedPriceStatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryPriceFeedPriceStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPriceFeedPriceStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPriceFeedPriceStatesResponse {
    // message fields
    pub price_states: ::protobuf::RepeatedField<super::oracle::PriceFeedState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPriceFeedPriceStatesResponse {
    fn default() -> &'a QueryPriceFeedPriceStatesResponse {
        <QueryPriceFeedPriceStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPriceFeedPriceStatesResponse {
    pub fn new() -> QueryPriceFeedPriceStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.PriceFeedState price_states = 1;


    pub fn get_price_states(&self) -> &[super::oracle::PriceFeedState] {
        &self.price_states
    }
    pub fn clear_price_states(&mut self) {
        self.price_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_states(&mut self, v: ::protobuf::RepeatedField<super::oracle::PriceFeedState>) {
        self.price_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_states(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::PriceFeedState> {
        &mut self.price_states
    }

    // Take field
    pub fn take_price_states(&mut self) -> ::protobuf::RepeatedField<super::oracle::PriceFeedState> {
        ::std::mem::replace(&mut self.price_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryPriceFeedPriceStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPriceFeedPriceStatesResponse {
        QueryPriceFeedPriceStatesResponse::new()
    }

    fn default_instance() -> &'static QueryPriceFeedPriceStatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPriceFeedPriceStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPriceFeedPriceStatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryPriceFeedPriceStatesResponse {
    fn clear(&mut self) {
        self.price_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPriceFeedPriceStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryCoinbasePriceStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryCoinbasePriceStatesRequest {
    fn default() -> &'a QueryCoinbasePriceStatesRequest {
        <QueryCoinbasePriceStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryCoinbasePriceStatesRequest {
    pub fn new() -> QueryCoinbasePriceStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryCoinbasePriceStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryCoinbasePriceStatesRequest {
        QueryCoinbasePriceStatesRequest::new()
    }

    fn default_instance() -> &'static QueryCoinbasePriceStatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryCoinbasePriceStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryCoinbasePriceStatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryCoinbasePriceStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCoinbasePriceStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryCoinbasePriceStatesResponse {
    // message fields
    pub price_states: ::protobuf::RepeatedField<super::oracle::CoinbasePriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryCoinbasePriceStatesResponse {
    fn default() -> &'a QueryCoinbasePriceStatesResponse {
        <QueryCoinbasePriceStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryCoinbasePriceStatesResponse {
    pub fn new() -> QueryCoinbasePriceStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.CoinbasePriceState price_states = 1;


    pub fn get_price_states(&self) -> &[super::oracle::CoinbasePriceState] {
        &self.price_states
    }
    pub fn clear_price_states(&mut self) {
        self.price_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_states(&mut self, v: ::protobuf::RepeatedField<super::oracle::CoinbasePriceState>) {
        self.price_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_states(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::CoinbasePriceState> {
        &mut self.price_states
    }

    // Take field
    pub fn take_price_states(&mut self) -> ::protobuf::RepeatedField<super::oracle::CoinbasePriceState> {
        ::std::mem::replace(&mut self.price_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryCoinbasePriceStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryCoinbasePriceStatesResponse {
        QueryCoinbasePriceStatesResponse::new()
    }

    fn default_instance() -> &'static QueryCoinbasePriceStatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryCoinbasePriceStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryCoinbasePriceStatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryCoinbasePriceStatesResponse {
    fn clear(&mut self) {
        self.price_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCoinbasePriceStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPythPriceStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPythPriceStatesRequest {
    fn default() -> &'a QueryPythPriceStatesRequest {
        <QueryPythPriceStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPythPriceStatesRequest {
    pub fn new() -> QueryPythPriceStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryPythPriceStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPythPriceStatesRequest {
        QueryPythPriceStatesRequest::new()
    }

    fn default_instance() -> &'static QueryPythPriceStatesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPythPriceStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPythPriceStatesRequest::new)
    }
}

impl ::protobuf::Clear for QueryPythPriceStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPythPriceStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPythPriceStatesResponse {
    // message fields
    pub price_states: ::protobuf::RepeatedField<super::oracle::PythPriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPythPriceStatesResponse {
    fn default() -> &'a QueryPythPriceStatesResponse {
        <QueryPythPriceStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPythPriceStatesResponse {
    pub fn new() -> QueryPythPriceStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.PythPriceState price_states = 1;


    pub fn get_price_states(&self) -> &[super::oracle::PythPriceState] {
        &self.price_states
    }
    pub fn clear_price_states(&mut self) {
        self.price_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_states(&mut self, v: ::protobuf::RepeatedField<super::oracle::PythPriceState>) {
        self.price_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_states(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::PythPriceState> {
        &mut self.price_states
    }

    // Take field
    pub fn take_price_states(&mut self) -> ::protobuf::RepeatedField<super::oracle::PythPriceState> {
        ::std::mem::replace(&mut self.price_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryPythPriceStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPythPriceStatesResponse {
        QueryPythPriceStatesResponse::new()
    }

    fn default_instance() -> &'static QueryPythPriceStatesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPythPriceStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPythPriceStatesResponse::new)
    }
}

impl ::protobuf::Clear for QueryPythPriceStatesResponse {
    fn clear(&mut self) {
        self.price_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPythPriceStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryProviderPriceStateRequest {
    // message fields
    pub provider: ::std::string::String,
    pub symbol: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryProviderPriceStateRequest {
    fn default() -> &'a QueryProviderPriceStateRequest {
        <QueryProviderPriceStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryProviderPriceStateRequest {
    pub fn new() -> QueryProviderPriceStateRequest {
        ::std::default::Default::default()
    }

    // string provider = 1;


    pub fn get_provider(&self) -> &str {
        &self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::string::String) {
        self.provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::string::String {
        &mut self.provider
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.provider, ::std::string::String::new())
    }

    // string symbol = 2;


    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::std::string::String) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryProviderPriceStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.provider)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.provider);
        }
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.symbol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.provider.is_empty() {
            os.write_string(1, &self.provider)?;
        }
        if !self.symbol.is_empty() {
            os.write_string(2, &self.symbol)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryProviderPriceStateRequest {
        QueryProviderPriceStateRequest::new()
    }

    fn default_instance() -> &'static QueryProviderPriceStateRequest {
        static instance: ::protobuf::rt::LazyV2<QueryProviderPriceStateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryProviderPriceStateRequest::new)
    }
}

impl ::protobuf::Clear for QueryProviderPriceStateRequest {
    fn clear(&mut self) {
        self.provider.clear();
        self.symbol.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryProviderPriceStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryProviderPriceStateResponse {
    // message fields
    pub price_state: ::protobuf::SingularPtrField<super::oracle::PriceState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryProviderPriceStateResponse {
    fn default() -> &'a QueryProviderPriceStateResponse {
        <QueryProviderPriceStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryProviderPriceStateResponse {
    pub fn new() -> QueryProviderPriceStateResponse {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.PriceState price_state = 1;


    pub fn get_price_state(&self) -> &super::oracle::PriceState {
        self.price_state.as_ref().unwrap_or_else(|| <super::oracle::PriceState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_price_state(&mut self) {
        self.price_state.clear();
    }

    pub fn has_price_state(&self) -> bool {
        self.price_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_state(&mut self, v: super::oracle::PriceState) {
        self.price_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_state(&mut self) -> &mut super::oracle::PriceState {
        if self.price_state.is_none() {
            self.price_state.set_default();
        }
        self.price_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_state(&mut self) -> super::oracle::PriceState {
        self.price_state.take().unwrap_or_else(|| super::oracle::PriceState::new())
    }
}

impl ::protobuf::Message for QueryProviderPriceStateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.price_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.price_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.price_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryProviderPriceStateResponse {
        QueryProviderPriceStateResponse::new()
    }

    fn default_instance() -> &'static QueryProviderPriceStateResponse {
        static instance: ::protobuf::rt::LazyV2<QueryProviderPriceStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryProviderPriceStateResponse::new)
    }
}

impl ::protobuf::Clear for QueryProviderPriceStateResponse {
    fn clear(&mut self) {
        self.price_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryProviderPriceStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryModuleStateRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryModuleStateRequest {
    fn default() -> &'a QueryModuleStateRequest {
        <QueryModuleStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleStateRequest {
    pub fn new() -> QueryModuleStateRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryModuleStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryModuleStateRequest {
        QueryModuleStateRequest::new()
    }

    fn default_instance() -> &'static QueryModuleStateRequest {
        static instance: ::protobuf::rt::LazyV2<QueryModuleStateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryModuleStateRequest::new)
    }
}

impl ::protobuf::Clear for QueryModuleStateRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryModuleStateResponse {
    // message fields
    pub state: ::protobuf::SingularPtrField<super::genesis::GenesisState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryModuleStateResponse {
    fn default() -> &'a QueryModuleStateResponse {
        <QueryModuleStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleStateResponse {
    pub fn new() -> QueryModuleStateResponse {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.GenesisState state = 1;


    pub fn get_state(&self) -> &super::genesis::GenesisState {
        self.state.as_ref().unwrap_or_else(|| <super::genesis::GenesisState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::genesis::GenesisState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::genesis::GenesisState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::genesis::GenesisState {
        self.state.take().unwrap_or_else(|| super::genesis::GenesisState::new())
    }
}

impl ::protobuf::Message for QueryModuleStateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryModuleStateResponse {
        QueryModuleStateResponse::new()
    }

    fn default_instance() -> &'static QueryModuleStateResponse {
        static instance: ::protobuf::rt::LazyV2<QueryModuleStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryModuleStateResponse::new)
    }
}

impl ::protobuf::Clear for QueryModuleStateResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryHistoricalPriceRecordsRequest {
    // message fields
    pub oracle: super::oracle::OracleType,
    pub symbol_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalPriceRecordsRequest {
    fn default() -> &'a QueryHistoricalPriceRecordsRequest {
        <QueryHistoricalPriceRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalPriceRecordsRequest {
    pub fn new() -> QueryHistoricalPriceRecordsRequest {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.OracleType oracle = 1;


    pub fn get_oracle(&self) -> super::oracle::OracleType {
        self.oracle
    }
    pub fn clear_oracle(&mut self) {
        self.oracle = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle(&mut self, v: super::oracle::OracleType) {
        self.oracle = v;
    }

    // string symbol_id = 2;


    pub fn get_symbol_id(&self) -> &str {
        &self.symbol_id
    }
    pub fn clear_symbol_id(&mut self) {
        self.symbol_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol_id(&mut self, v: ::std::string::String) {
        self.symbol_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol_id(&mut self) -> &mut ::std::string::String {
        &mut self.symbol_id
    }

    // Take field
    pub fn take_symbol_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryHistoricalPriceRecordsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.oracle != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(1, self.oracle);
        }
        if !self.symbol_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.symbol_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.oracle != super::oracle::OracleType::Unspecified {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.oracle))?;
        }
        if !self.symbol_id.is_empty() {
            os.write_string(2, &self.symbol_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalPriceRecordsRequest {
        QueryHistoricalPriceRecordsRequest::new()
    }

    fn default_instance() -> &'static QueryHistoricalPriceRecordsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalPriceRecordsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalPriceRecordsRequest::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalPriceRecordsRequest {
    fn clear(&mut self) {
        self.oracle = super::oracle::OracleType::Unspecified;
        self.symbol_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalPriceRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryHistoricalPriceRecordsResponse {
    // message fields
    pub price_records: ::protobuf::RepeatedField<super::oracle::PriceRecords>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalPriceRecordsResponse {
    fn default() -> &'a QueryHistoricalPriceRecordsResponse {
        <QueryHistoricalPriceRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalPriceRecordsResponse {
    pub fn new() -> QueryHistoricalPriceRecordsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.PriceRecords price_records = 1;


    pub fn get_price_records(&self) -> &[super::oracle::PriceRecords] {
        &self.price_records
    }
    pub fn clear_price_records(&mut self) {
        self.price_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_price_records(&mut self, v: ::protobuf::RepeatedField<super::oracle::PriceRecords>) {
        self.price_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_price_records(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::PriceRecords> {
        &mut self.price_records
    }

    // Take field
    pub fn take_price_records(&mut self) -> ::protobuf::RepeatedField<super::oracle::PriceRecords> {
        ::std::mem::replace(&mut self.price_records, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryHistoricalPriceRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.price_records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.price_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.price_records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalPriceRecordsResponse {
        QueryHistoricalPriceRecordsResponse::new()
    }

    fn default_instance() -> &'static QueryHistoricalPriceRecordsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalPriceRecordsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalPriceRecordsResponse::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalPriceRecordsResponse {
    fn clear(&mut self) {
        self.price_records.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalPriceRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OracleHistoryOptions {
    // message fields
    pub max_age: u64,
    pub include_raw_history: bool,
    pub include_metadata: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OracleHistoryOptions {
    fn default() -> &'a OracleHistoryOptions {
        <OracleHistoryOptions as ::protobuf::Message>::default_instance()
    }
}

impl OracleHistoryOptions {
    pub fn new() -> OracleHistoryOptions {
        ::std::default::Default::default()
    }

    // uint64 max_age = 1;


    pub fn get_max_age(&self) -> u64 {
        self.max_age
    }
    pub fn clear_max_age(&mut self) {
        self.max_age = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_age(&mut self, v: u64) {
        self.max_age = v;
    }

    // bool include_raw_history = 2;


    pub fn get_include_raw_history(&self) -> bool {
        self.include_raw_history
    }
    pub fn clear_include_raw_history(&mut self) {
        self.include_raw_history = false;
    }

    // Param is passed by value, moved
    pub fn set_include_raw_history(&mut self, v: bool) {
        self.include_raw_history = v;
    }

    // bool include_metadata = 3;


    pub fn get_include_metadata(&self) -> bool {
        self.include_metadata
    }
    pub fn clear_include_metadata(&mut self) {
        self.include_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_include_metadata(&mut self, v: bool) {
        self.include_metadata = v;
    }
}

impl ::protobuf::Message for OracleHistoryOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_age = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_raw_history = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_metadata = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_age != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_age, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.include_raw_history != false {
            my_size += 2;
        }
        if self.include_metadata != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_age != 0 {
            os.write_uint64(1, self.max_age)?;
        }
        if self.include_raw_history != false {
            os.write_bool(2, self.include_raw_history)?;
        }
        if self.include_metadata != false {
            os.write_bool(3, self.include_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OracleHistoryOptions {
        OracleHistoryOptions::new()
    }

    fn default_instance() -> &'static OracleHistoryOptions {
        static instance: ::protobuf::rt::LazyV2<OracleHistoryOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OracleHistoryOptions::new)
    }
}

impl ::protobuf::Clear for OracleHistoryOptions {
    fn clear(&mut self) {
        self.max_age = 0;
        self.include_raw_history = false;
        self.include_metadata = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OracleHistoryOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleVolatilityRequest {
    // message fields
    pub base_info: ::protobuf::SingularPtrField<super::oracle::OracleInfo>,
    pub quote_info: ::protobuf::SingularPtrField<super::oracle::OracleInfo>,
    pub oracle_history_options: ::protobuf::SingularPtrField<OracleHistoryOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleVolatilityRequest {
    fn default() -> &'a QueryOracleVolatilityRequest {
        <QueryOracleVolatilityRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleVolatilityRequest {
    pub fn new() -> QueryOracleVolatilityRequest {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.OracleInfo base_info = 1;


    pub fn get_base_info(&self) -> &super::oracle::OracleInfo {
        self.base_info.as_ref().unwrap_or_else(|| <super::oracle::OracleInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base_info(&mut self) {
        self.base_info.clear();
    }

    pub fn has_base_info(&self) -> bool {
        self.base_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_info(&mut self, v: super::oracle::OracleInfo) {
        self.base_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_info(&mut self) -> &mut super::oracle::OracleInfo {
        if self.base_info.is_none() {
            self.base_info.set_default();
        }
        self.base_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_info(&mut self) -> super::oracle::OracleInfo {
        self.base_info.take().unwrap_or_else(|| super::oracle::OracleInfo::new())
    }

    // .injective.oracle.v1beta1.OracleInfo quote_info = 2;


    pub fn get_quote_info(&self) -> &super::oracle::OracleInfo {
        self.quote_info.as_ref().unwrap_or_else(|| <super::oracle::OracleInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote_info(&mut self) {
        self.quote_info.clear();
    }

    pub fn has_quote_info(&self) -> bool {
        self.quote_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_info(&mut self, v: super::oracle::OracleInfo) {
        self.quote_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_info(&mut self) -> &mut super::oracle::OracleInfo {
        if self.quote_info.is_none() {
            self.quote_info.set_default();
        }
        self.quote_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote_info(&mut self) -> super::oracle::OracleInfo {
        self.quote_info.take().unwrap_or_else(|| super::oracle::OracleInfo::new())
    }

    // .injective.oracle.v1beta1.OracleHistoryOptions oracle_history_options = 3;


    pub fn get_oracle_history_options(&self) -> &OracleHistoryOptions {
        self.oracle_history_options.as_ref().unwrap_or_else(|| <OracleHistoryOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_oracle_history_options(&mut self) {
        self.oracle_history_options.clear();
    }

    pub fn has_oracle_history_options(&self) -> bool {
        self.oracle_history_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oracle_history_options(&mut self, v: OracleHistoryOptions) {
        self.oracle_history_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_history_options(&mut self) -> &mut OracleHistoryOptions {
        if self.oracle_history_options.is_none() {
            self.oracle_history_options.set_default();
        }
        self.oracle_history_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_oracle_history_options(&mut self) -> OracleHistoryOptions {
        self.oracle_history_options.take().unwrap_or_else(|| OracleHistoryOptions::new())
    }
}

impl ::protobuf::Message for QueryOracleVolatilityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.base_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quote_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oracle_history_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oracle_history_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quote_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.oracle_history_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quote_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.oracle_history_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleVolatilityRequest {
        QueryOracleVolatilityRequest::new()
    }

    fn default_instance() -> &'static QueryOracleVolatilityRequest {
        static instance: ::protobuf::rt::LazyV2<QueryOracleVolatilityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleVolatilityRequest::new)
    }
}

impl ::protobuf::Clear for QueryOracleVolatilityRequest {
    fn clear(&mut self) {
        self.base_info.clear();
        self.quote_info.clear();
        self.oracle_history_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleVolatilityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleVolatilityResponse {
    // message fields
    pub volatility: ::std::string::String,
    pub history_metadata: ::protobuf::SingularPtrField<super::oracle::MetadataStatistics>,
    pub raw_history: ::protobuf::RepeatedField<super::oracle::PriceRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleVolatilityResponse {
    fn default() -> &'a QueryOracleVolatilityResponse {
        <QueryOracleVolatilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleVolatilityResponse {
    pub fn new() -> QueryOracleVolatilityResponse {
        ::std::default::Default::default()
    }

    // string volatility = 1;


    pub fn get_volatility(&self) -> &str {
        &self.volatility
    }
    pub fn clear_volatility(&mut self) {
        self.volatility.clear();
    }

    // Param is passed by value, moved
    pub fn set_volatility(&mut self, v: ::std::string::String) {
        self.volatility = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volatility(&mut self) -> &mut ::std::string::String {
        &mut self.volatility
    }

    // Take field
    pub fn take_volatility(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volatility, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.MetadataStatistics history_metadata = 2;


    pub fn get_history_metadata(&self) -> &super::oracle::MetadataStatistics {
        self.history_metadata.as_ref().unwrap_or_else(|| <super::oracle::MetadataStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_history_metadata(&mut self) {
        self.history_metadata.clear();
    }

    pub fn has_history_metadata(&self) -> bool {
        self.history_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_metadata(&mut self, v: super::oracle::MetadataStatistics) {
        self.history_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_history_metadata(&mut self) -> &mut super::oracle::MetadataStatistics {
        if self.history_metadata.is_none() {
            self.history_metadata.set_default();
        }
        self.history_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_history_metadata(&mut self) -> super::oracle::MetadataStatistics {
        self.history_metadata.take().unwrap_or_else(|| super::oracle::MetadataStatistics::new())
    }

    // repeated .injective.oracle.v1beta1.PriceRecord raw_history = 3;


    pub fn get_raw_history(&self) -> &[super::oracle::PriceRecord] {
        &self.raw_history
    }
    pub fn clear_raw_history(&mut self) {
        self.raw_history.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_history(&mut self, v: ::protobuf::RepeatedField<super::oracle::PriceRecord>) {
        self.raw_history = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_history(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::PriceRecord> {
        &mut self.raw_history
    }

    // Take field
    pub fn take_raw_history(&mut self) -> ::protobuf::RepeatedField<super::oracle::PriceRecord> {
        ::std::mem::replace(&mut self.raw_history, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryOracleVolatilityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.history_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.raw_history {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.volatility)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.history_metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.raw_history)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.volatility.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.volatility);
        }
        if let Some(ref v) = self.history_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.raw_history {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.volatility.is_empty() {
            os.write_string(1, &self.volatility)?;
        }
        if let Some(ref v) = self.history_metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.raw_history {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleVolatilityResponse {
        QueryOracleVolatilityResponse::new()
    }

    fn default_instance() -> &'static QueryOracleVolatilityResponse {
        static instance: ::protobuf::rt::LazyV2<QueryOracleVolatilityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleVolatilityResponse::new)
    }
}

impl ::protobuf::Clear for QueryOracleVolatilityResponse {
    fn clear(&mut self) {
        self.volatility.clear();
        self.history_metadata.clear();
        self.raw_history.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleVolatilityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleProvidersInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleProvidersInfoRequest {
    fn default() -> &'a QueryOracleProvidersInfoRequest {
        <QueryOracleProvidersInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleProvidersInfoRequest {
    pub fn new() -> QueryOracleProvidersInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryOracleProvidersInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleProvidersInfoRequest {
        QueryOracleProvidersInfoRequest::new()
    }

    fn default_instance() -> &'static QueryOracleProvidersInfoRequest {
        static instance: ::protobuf::rt::LazyV2<QueryOracleProvidersInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleProvidersInfoRequest::new)
    }
}

impl ::protobuf::Clear for QueryOracleProvidersInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleProvidersInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleProvidersInfoResponse {
    // message fields
    pub providers: ::protobuf::RepeatedField<super::oracle::ProviderInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleProvidersInfoResponse {
    fn default() -> &'a QueryOracleProvidersInfoResponse {
        <QueryOracleProvidersInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleProvidersInfoResponse {
    pub fn new() -> QueryOracleProvidersInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.ProviderInfo providers = 1;


    pub fn get_providers(&self) -> &[super::oracle::ProviderInfo] {
        &self.providers
    }
    pub fn clear_providers(&mut self) {
        self.providers.clear();
    }

    // Param is passed by value, moved
    pub fn set_providers(&mut self, v: ::protobuf::RepeatedField<super::oracle::ProviderInfo>) {
        self.providers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_providers(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::ProviderInfo> {
        &mut self.providers
    }

    // Take field
    pub fn take_providers(&mut self) -> ::protobuf::RepeatedField<super::oracle::ProviderInfo> {
        ::std::mem::replace(&mut self.providers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryOracleProvidersInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.providers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.providers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.providers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.providers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleProvidersInfoResponse {
        QueryOracleProvidersInfoResponse::new()
    }

    fn default_instance() -> &'static QueryOracleProvidersInfoResponse {
        static instance: ::protobuf::rt::LazyV2<QueryOracleProvidersInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleProvidersInfoResponse::new)
    }
}

impl ::protobuf::Clear for QueryOracleProvidersInfoResponse {
    fn clear(&mut self) {
        self.providers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleProvidersInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleProviderPricesRequest {
    // message fields
    pub provider: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleProviderPricesRequest {
    fn default() -> &'a QueryOracleProviderPricesRequest {
        <QueryOracleProviderPricesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleProviderPricesRequest {
    pub fn new() -> QueryOracleProviderPricesRequest {
        ::std::default::Default::default()
    }

    // string provider = 1;


    pub fn get_provider(&self) -> &str {
        &self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::string::String) {
        self.provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::string::String {
        &mut self.provider
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.provider, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryOracleProviderPricesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.provider)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.provider);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.provider.is_empty() {
            os.write_string(1, &self.provider)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleProviderPricesRequest {
        QueryOracleProviderPricesRequest::new()
    }

    fn default_instance() -> &'static QueryOracleProviderPricesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryOracleProviderPricesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleProviderPricesRequest::new)
    }
}

impl ::protobuf::Clear for QueryOracleProviderPricesRequest {
    fn clear(&mut self) {
        self.provider.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleProviderPricesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOracleProviderPricesResponse {
    // message fields
    pub providerState: ::protobuf::RepeatedField<super::oracle::ProviderState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOracleProviderPricesResponse {
    fn default() -> &'a QueryOracleProviderPricesResponse {
        <QueryOracleProviderPricesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOracleProviderPricesResponse {
    pub fn new() -> QueryOracleProviderPricesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.oracle.v1beta1.ProviderState providerState = 1;


    pub fn get_providerState(&self) -> &[super::oracle::ProviderState] {
        &self.providerState
    }
    pub fn clear_providerState(&mut self) {
        self.providerState.clear();
    }

    // Param is passed by value, moved
    pub fn set_providerState(&mut self, v: ::protobuf::RepeatedField<super::oracle::ProviderState>) {
        self.providerState = v;
    }

    // Mutable pointer to the field.
    pub fn mut_providerState(&mut self) -> &mut ::protobuf::RepeatedField<super::oracle::ProviderState> {
        &mut self.providerState
    }

    // Take field
    pub fn take_providerState(&mut self) -> ::protobuf::RepeatedField<super::oracle::ProviderState> {
        ::std::mem::replace(&mut self.providerState, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryOracleProviderPricesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.providerState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.providerState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.providerState {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.providerState {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOracleProviderPricesResponse {
        QueryOracleProviderPricesResponse::new()
    }

    fn default_instance() -> &'static QueryOracleProviderPricesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryOracleProviderPricesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOracleProviderPricesResponse::new)
    }
}

impl ::protobuf::Clear for QueryOracleProviderPricesResponse {
    fn clear(&mut self) {
        self.providerState.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOracleProviderPricesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOraclePriceRequest {
    // message fields
    pub oracle_type: super::oracle::OracleType,
    pub base: ::std::string::String,
    pub quote: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOraclePriceRequest {
    fn default() -> &'a QueryOraclePriceRequest {
        <QueryOraclePriceRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOraclePriceRequest {
    pub fn new() -> QueryOraclePriceRequest {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 1;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // string base = 2;


    pub fn get_base(&self) -> &str {
        &self.base
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: ::std::string::String) {
        self.base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut ::std::string::String {
        &mut self.base
    }

    // Take field
    pub fn take_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base, ::std::string::String::new())
    }

    // string quote = 3;


    pub fn get_quote(&self) -> &str {
        &self.quote
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::string::String) {
        self.quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut ::std::string::String {
        &mut self.quote
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryOraclePriceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(1, self.oracle_type);
        }
        if !self.base.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base);
        }
        if !self.quote.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if !self.base.is_empty() {
            os.write_string(2, &self.base)?;
        }
        if !self.quote.is_empty() {
            os.write_string(3, &self.quote)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOraclePriceRequest {
        QueryOraclePriceRequest::new()
    }

    fn default_instance() -> &'static QueryOraclePriceRequest {
        static instance: ::protobuf::rt::LazyV2<QueryOraclePriceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOraclePriceRequest::new)
    }
}

impl ::protobuf::Clear for QueryOraclePriceRequest {
    fn clear(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.base.clear();
        self.quote.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOraclePriceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PricePairState {
    // message fields
    pub pair_price: ::std::string::String,
    pub base_price: ::std::string::String,
    pub quote_price: ::std::string::String,
    pub base_cumulative_price: ::std::string::String,
    pub quote_cumulative_price: ::std::string::String,
    pub base_timestamp: i64,
    pub quote_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PricePairState {
    fn default() -> &'a PricePairState {
        <PricePairState as ::protobuf::Message>::default_instance()
    }
}

impl PricePairState {
    pub fn new() -> PricePairState {
        ::std::default::Default::default()
    }

    // string pair_price = 1;


    pub fn get_pair_price(&self) -> &str {
        &self.pair_price
    }
    pub fn clear_pair_price(&mut self) {
        self.pair_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_pair_price(&mut self, v: ::std::string::String) {
        self.pair_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pair_price(&mut self) -> &mut ::std::string::String {
        &mut self.pair_price
    }

    // Take field
    pub fn take_pair_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pair_price, ::std::string::String::new())
    }

    // string base_price = 2;


    pub fn get_base_price(&self) -> &str {
        &self.base_price
    }
    pub fn clear_base_price(&mut self) {
        self.base_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_price(&mut self, v: ::std::string::String) {
        self.base_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_price(&mut self) -> &mut ::std::string::String {
        &mut self.base_price
    }

    // Take field
    pub fn take_base_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_price, ::std::string::String::new())
    }

    // string quote_price = 3;


    pub fn get_quote_price(&self) -> &str {
        &self.quote_price
    }
    pub fn clear_quote_price(&mut self) {
        self.quote_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_price(&mut self, v: ::std::string::String) {
        self.quote_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_price(&mut self) -> &mut ::std::string::String {
        &mut self.quote_price
    }

    // Take field
    pub fn take_quote_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_price, ::std::string::String::new())
    }

    // string base_cumulative_price = 4;


    pub fn get_base_cumulative_price(&self) -> &str {
        &self.base_cumulative_price
    }
    pub fn clear_base_cumulative_price(&mut self) {
        self.base_cumulative_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_cumulative_price(&mut self, v: ::std::string::String) {
        self.base_cumulative_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_cumulative_price(&mut self) -> &mut ::std::string::String {
        &mut self.base_cumulative_price
    }

    // Take field
    pub fn take_base_cumulative_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_cumulative_price, ::std::string::String::new())
    }

    // string quote_cumulative_price = 5;


    pub fn get_quote_cumulative_price(&self) -> &str {
        &self.quote_cumulative_price
    }
    pub fn clear_quote_cumulative_price(&mut self) {
        self.quote_cumulative_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_cumulative_price(&mut self, v: ::std::string::String) {
        self.quote_cumulative_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_cumulative_price(&mut self) -> &mut ::std::string::String {
        &mut self.quote_cumulative_price
    }

    // Take field
    pub fn take_quote_cumulative_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_cumulative_price, ::std::string::String::new())
    }

    // int64 base_timestamp = 6;


    pub fn get_base_timestamp(&self) -> i64 {
        self.base_timestamp
    }
    pub fn clear_base_timestamp(&mut self) {
        self.base_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_timestamp(&mut self, v: i64) {
        self.base_timestamp = v;
    }

    // int64 quote_timestamp = 7;


    pub fn get_quote_timestamp(&self) -> i64 {
        self.quote_timestamp
    }
    pub fn clear_quote_timestamp(&mut self) {
        self.quote_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_quote_timestamp(&mut self, v: i64) {
        self.quote_timestamp = v;
    }
}

impl ::protobuf::Message for PricePairState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pair_price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_price)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_cumulative_price)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_cumulative_price)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_timestamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quote_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pair_price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pair_price);
        }
        if !self.base_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_price);
        }
        if !self.quote_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_price);
        }
        if !self.base_cumulative_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.base_cumulative_price);
        }
        if !self.quote_cumulative_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.quote_cumulative_price);
        }
        if self.base_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.base_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.quote_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.quote_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pair_price.is_empty() {
            os.write_string(1, &self.pair_price)?;
        }
        if !self.base_price.is_empty() {
            os.write_string(2, &self.base_price)?;
        }
        if !self.quote_price.is_empty() {
            os.write_string(3, &self.quote_price)?;
        }
        if !self.base_cumulative_price.is_empty() {
            os.write_string(4, &self.base_cumulative_price)?;
        }
        if !self.quote_cumulative_price.is_empty() {
            os.write_string(5, &self.quote_cumulative_price)?;
        }
        if self.base_timestamp != 0 {
            os.write_int64(6, self.base_timestamp)?;
        }
        if self.quote_timestamp != 0 {
            os.write_int64(7, self.quote_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PricePairState {
        PricePairState::new()
    }

    fn default_instance() -> &'static PricePairState {
        static instance: ::protobuf::rt::LazyV2<PricePairState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PricePairState::new)
    }
}

impl ::protobuf::Clear for PricePairState {
    fn clear(&mut self) {
        self.pair_price.clear();
        self.base_price.clear();
        self.quote_price.clear();
        self.base_cumulative_price.clear();
        self.quote_cumulative_price.clear();
        self.base_timestamp = 0;
        self.quote_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PricePairState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOraclePriceResponse {
    // message fields
    pub price_pair_state: ::protobuf::SingularPtrField<PricePairState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOraclePriceResponse {
    fn default() -> &'a QueryOraclePriceResponse {
        <QueryOraclePriceResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOraclePriceResponse {
    pub fn new() -> QueryOraclePriceResponse {
        ::std::default::Default::default()
    }

    // .injective.oracle.v1beta1.PricePairState price_pair_state = 1;


    pub fn get_price_pair_state(&self) -> &PricePairState {
        self.price_pair_state.as_ref().unwrap_or_else(|| <PricePairState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_price_pair_state(&mut self) {
        self.price_pair_state.clear();
    }

    pub fn has_price_pair_state(&self) -> bool {
        self.price_pair_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_pair_state(&mut self, v: PricePairState) {
        self.price_pair_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_pair_state(&mut self) -> &mut PricePairState {
        if self.price_pair_state.is_none() {
            self.price_pair_state.set_default();
        }
        self.price_pair_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_pair_state(&mut self) -> PricePairState {
        self.price_pair_state.take().unwrap_or_else(|| PricePairState::new())
    }
}

impl ::protobuf::Message for QueryOraclePriceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.price_pair_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.price_pair_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.price_pair_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.price_pair_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOraclePriceResponse {
        QueryOraclePriceResponse::new()
    }

    fn default_instance() -> &'static QueryOraclePriceResponse {
        static instance: ::protobuf::rt::LazyV2<QueryOraclePriceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOraclePriceResponse::new)
    }
}

impl ::protobuf::Clear for QueryOraclePriceResponse {
    fn clear(&mut self) {
        self.price_pair_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOraclePriceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
