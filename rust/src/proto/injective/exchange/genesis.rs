// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/exchange/v1beta1/genesis.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GenesisState {
    // message fields
    pub params: ::protobuf::SingularPtrField<super::exchange::Params>,
    pub spot_markets: ::protobuf::RepeatedField<super::exchange::SpotMarket>,
    pub derivative_markets: ::protobuf::RepeatedField<super::exchange::DerivativeMarket>,
    pub spot_orderbook: ::protobuf::RepeatedField<SpotOrderBook>,
    pub derivative_orderbook: ::protobuf::RepeatedField<DerivativeOrderBook>,
    pub balances: ::protobuf::RepeatedField<Balance>,
    pub positions: ::protobuf::RepeatedField<DerivativePosition>,
    pub subaccount_trade_nonces: ::protobuf::RepeatedField<SubaccountNonce>,
    pub expiry_futures_market_info_state: ::protobuf::RepeatedField<ExpiryFuturesMarketInfoState>,
    pub perpetual_market_info: ::protobuf::RepeatedField<super::exchange::PerpetualMarketInfo>,
    pub perpetual_market_funding_state: ::protobuf::RepeatedField<PerpetualMarketFundingState>,
    pub derivative_market_settlement_scheduled: ::protobuf::RepeatedField<super::exchange::DerivativeMarketSettlementInfo>,
    pub is_spot_exchange_enabled: bool,
    pub is_derivatives_exchange_enabled: bool,
    pub trading_reward_campaign_info: ::protobuf::SingularPtrField<super::exchange::TradingRewardCampaignInfo>,
    pub trading_reward_pool_campaign_schedule: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    pub trading_reward_campaign_account_points: ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints>,
    pub fee_discount_schedule: ::protobuf::SingularPtrField<super::exchange::FeeDiscountSchedule>,
    pub fee_discount_account_tier_ttl: ::protobuf::RepeatedField<FeeDiscountAccountTierTTL>,
    pub fee_discount_bucket_volume_accounts: ::protobuf::RepeatedField<FeeDiscountBucketVolumeAccounts>,
    pub is_first_fee_cycle_finished: bool,
    pub pending_trading_reward_pool_campaign_schedule: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    pub pending_trading_reward_campaign_account_points: ::protobuf::RepeatedField<TradingRewardCampaignAccountPendingPoints>,
    pub rewards_opt_out_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub historical_trade_records: ::protobuf::RepeatedField<super::exchange::TradeRecords>,
    pub binary_options_markets: ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket>,
    pub binary_options_market_ids_scheduled_for_settlement: ::protobuf::RepeatedField<::std::string::String>,
    pub spot_market_ids_scheduled_to_force_close: ::protobuf::RepeatedField<::std::string::String>,
    pub denom_decimals: ::protobuf::RepeatedField<super::exchange::DenomDecimals>,
    pub conditional_derivative_orderbooks: ::protobuf::RepeatedField<ConditionalDerivativeOrderBook>,
    pub market_fee_multipliers: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>,
    pub orderbook_sequences: ::protobuf::RepeatedField<OrderbookSequence>,
    pub subaccount_volumes: ::protobuf::RepeatedField<super::exchange::AggregateSubaccountVolumeRecord>,
    pub market_volumes: ::protobuf::RepeatedField<super::exchange::MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenesisState {
    fn default() -> &'a GenesisState {
        <GenesisState as ::protobuf::Message>::default_instance()
    }
}

impl GenesisState {
    pub fn new() -> GenesisState {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.Params params = 1;


    pub fn get_params(&self) -> &super::exchange::Params {
        self.params.as_ref().unwrap_or_else(|| <super::exchange::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::exchange::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::exchange::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::exchange::Params {
        self.params.take().unwrap_or_else(|| super::exchange::Params::new())
    }

    // repeated .injective.exchange.v1beta1.SpotMarket spot_markets = 2;


    pub fn get_spot_markets(&self) -> &[super::exchange::SpotMarket] {
        &self.spot_markets
    }
    pub fn clear_spot_markets(&mut self) {
        self.spot_markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_markets(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotMarket>) {
        self.spot_markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_markets(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotMarket> {
        &mut self.spot_markets
    }

    // Take field
    pub fn take_spot_markets(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotMarket> {
        ::std::mem::replace(&mut self.spot_markets, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeMarket derivative_markets = 3;


    pub fn get_derivative_markets(&self) -> &[super::exchange::DerivativeMarket] {
        &self.derivative_markets
    }
    pub fn clear_derivative_markets(&mut self) {
        self.derivative_markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_markets(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeMarket>) {
        self.derivative_markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_markets(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeMarket> {
        &mut self.derivative_markets
    }

    // Take field
    pub fn take_derivative_markets(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeMarket> {
        ::std::mem::replace(&mut self.derivative_markets, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SpotOrderBook spot_orderbook = 4;


    pub fn get_spot_orderbook(&self) -> &[SpotOrderBook] {
        &self.spot_orderbook
    }
    pub fn clear_spot_orderbook(&mut self) {
        self.spot_orderbook.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_orderbook(&mut self, v: ::protobuf::RepeatedField<SpotOrderBook>) {
        self.spot_orderbook = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_orderbook(&mut self) -> &mut ::protobuf::RepeatedField<SpotOrderBook> {
        &mut self.spot_orderbook
    }

    // Take field
    pub fn take_spot_orderbook(&mut self) -> ::protobuf::RepeatedField<SpotOrderBook> {
        ::std::mem::replace(&mut self.spot_orderbook, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeOrderBook derivative_orderbook = 5;


    pub fn get_derivative_orderbook(&self) -> &[DerivativeOrderBook] {
        &self.derivative_orderbook
    }
    pub fn clear_derivative_orderbook(&mut self) {
        self.derivative_orderbook.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_orderbook(&mut self, v: ::protobuf::RepeatedField<DerivativeOrderBook>) {
        self.derivative_orderbook = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_orderbook(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeOrderBook> {
        &mut self.derivative_orderbook
    }

    // Take field
    pub fn take_derivative_orderbook(&mut self) -> ::protobuf::RepeatedField<DerivativeOrderBook> {
        ::std::mem::replace(&mut self.derivative_orderbook, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.Balance balances = 6;


    pub fn get_balances(&self) -> &[Balance] {
        &self.balances
    }
    pub fn clear_balances(&mut self) {
        self.balances.clear();
    }

    // Param is passed by value, moved
    pub fn set_balances(&mut self, v: ::protobuf::RepeatedField<Balance>) {
        self.balances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_balances(&mut self) -> &mut ::protobuf::RepeatedField<Balance> {
        &mut self.balances
    }

    // Take field
    pub fn take_balances(&mut self) -> ::protobuf::RepeatedField<Balance> {
        ::std::mem::replace(&mut self.balances, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativePosition positions = 7;


    pub fn get_positions(&self) -> &[DerivativePosition] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::protobuf::RepeatedField<DerivativePosition>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::protobuf::RepeatedField<DerivativePosition> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::protobuf::RepeatedField<DerivativePosition> {
        ::std::mem::replace(&mut self.positions, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SubaccountNonce subaccount_trade_nonces = 8;


    pub fn get_subaccount_trade_nonces(&self) -> &[SubaccountNonce] {
        &self.subaccount_trade_nonces
    }
    pub fn clear_subaccount_trade_nonces(&mut self) {
        self.subaccount_trade_nonces.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_trade_nonces(&mut self, v: ::protobuf::RepeatedField<SubaccountNonce>) {
        self.subaccount_trade_nonces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_trade_nonces(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountNonce> {
        &mut self.subaccount_trade_nonces
    }

    // Take field
    pub fn take_subaccount_trade_nonces(&mut self) -> ::protobuf::RepeatedField<SubaccountNonce> {
        ::std::mem::replace(&mut self.subaccount_trade_nonces, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketInfoState expiry_futures_market_info_state = 9;


    pub fn get_expiry_futures_market_info_state(&self) -> &[ExpiryFuturesMarketInfoState] {
        &self.expiry_futures_market_info_state
    }
    pub fn clear_expiry_futures_market_info_state(&mut self) {
        self.expiry_futures_market_info_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_expiry_futures_market_info_state(&mut self, v: ::protobuf::RepeatedField<ExpiryFuturesMarketInfoState>) {
        self.expiry_futures_market_info_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expiry_futures_market_info_state(&mut self) -> &mut ::protobuf::RepeatedField<ExpiryFuturesMarketInfoState> {
        &mut self.expiry_futures_market_info_state
    }

    // Take field
    pub fn take_expiry_futures_market_info_state(&mut self) -> ::protobuf::RepeatedField<ExpiryFuturesMarketInfoState> {
        ::std::mem::replace(&mut self.expiry_futures_market_info_state, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 10;


    pub fn get_perpetual_market_info(&self) -> &[super::exchange::PerpetualMarketInfo] {
        &self.perpetual_market_info
    }
    pub fn clear_perpetual_market_info(&mut self) {
        self.perpetual_market_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_info(&mut self, v: ::protobuf::RepeatedField<super::exchange::PerpetualMarketInfo>) {
        self.perpetual_market_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perpetual_market_info(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::PerpetualMarketInfo> {
        &mut self.perpetual_market_info
    }

    // Take field
    pub fn take_perpetual_market_info(&mut self) -> ::protobuf::RepeatedField<super::exchange::PerpetualMarketInfo> {
        ::std::mem::replace(&mut self.perpetual_market_info, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.PerpetualMarketFundingState perpetual_market_funding_state = 11;


    pub fn get_perpetual_market_funding_state(&self) -> &[PerpetualMarketFundingState] {
        &self.perpetual_market_funding_state
    }
    pub fn clear_perpetual_market_funding_state(&mut self) {
        self.perpetual_market_funding_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_funding_state(&mut self, v: ::protobuf::RepeatedField<PerpetualMarketFundingState>) {
        self.perpetual_market_funding_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perpetual_market_funding_state(&mut self) -> &mut ::protobuf::RepeatedField<PerpetualMarketFundingState> {
        &mut self.perpetual_market_funding_state
    }

    // Take field
    pub fn take_perpetual_market_funding_state(&mut self) -> ::protobuf::RepeatedField<PerpetualMarketFundingState> {
        ::std::mem::replace(&mut self.perpetual_market_funding_state, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeMarketSettlementInfo derivative_market_settlement_scheduled = 12;


    pub fn get_derivative_market_settlement_scheduled(&self) -> &[super::exchange::DerivativeMarketSettlementInfo] {
        &self.derivative_market_settlement_scheduled
    }
    pub fn clear_derivative_market_settlement_scheduled(&mut self) {
        self.derivative_market_settlement_scheduled.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_market_settlement_scheduled(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeMarketSettlementInfo>) {
        self.derivative_market_settlement_scheduled = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_market_settlement_scheduled(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeMarketSettlementInfo> {
        &mut self.derivative_market_settlement_scheduled
    }

    // Take field
    pub fn take_derivative_market_settlement_scheduled(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeMarketSettlementInfo> {
        ::std::mem::replace(&mut self.derivative_market_settlement_scheduled, ::protobuf::RepeatedField::new())
    }

    // bool is_spot_exchange_enabled = 13;


    pub fn get_is_spot_exchange_enabled(&self) -> bool {
        self.is_spot_exchange_enabled
    }
    pub fn clear_is_spot_exchange_enabled(&mut self) {
        self.is_spot_exchange_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_spot_exchange_enabled(&mut self, v: bool) {
        self.is_spot_exchange_enabled = v;
    }

    // bool is_derivatives_exchange_enabled = 14;


    pub fn get_is_derivatives_exchange_enabled(&self) -> bool {
        self.is_derivatives_exchange_enabled
    }
    pub fn clear_is_derivatives_exchange_enabled(&mut self) {
        self.is_derivatives_exchange_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_derivatives_exchange_enabled(&mut self, v: bool) {
        self.is_derivatives_exchange_enabled = v;
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 15;


    pub fn get_trading_reward_campaign_info(&self) -> &super::exchange::TradingRewardCampaignInfo {
        self.trading_reward_campaign_info.as_ref().unwrap_or_else(|| <super::exchange::TradingRewardCampaignInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trading_reward_campaign_info(&mut self) {
        self.trading_reward_campaign_info.clear();
    }

    pub fn has_trading_reward_campaign_info(&self) -> bool {
        self.trading_reward_campaign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_campaign_info(&mut self, v: super::exchange::TradingRewardCampaignInfo) {
        self.trading_reward_campaign_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_reward_campaign_info(&mut self) -> &mut super::exchange::TradingRewardCampaignInfo {
        if self.trading_reward_campaign_info.is_none() {
            self.trading_reward_campaign_info.set_default();
        }
        self.trading_reward_campaign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_reward_campaign_info(&mut self) -> super::exchange::TradingRewardCampaignInfo {
        self.trading_reward_campaign_info.take().unwrap_or_else(|| super::exchange::TradingRewardCampaignInfo::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 16;


    pub fn get_trading_reward_pool_campaign_schedule(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.trading_reward_pool_campaign_schedule
    }
    pub fn clear_trading_reward_pool_campaign_schedule(&mut self) {
        self.trading_reward_pool_campaign_schedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_pool_campaign_schedule(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.trading_reward_pool_campaign_schedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trading_reward_pool_campaign_schedule(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.trading_reward_pool_campaign_schedule
    }

    // Take field
    pub fn take_trading_reward_pool_campaign_schedule(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.trading_reward_pool_campaign_schedule, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints trading_reward_campaign_account_points = 17;


    pub fn get_trading_reward_campaign_account_points(&self) -> &[TradingRewardCampaignAccountPoints] {
        &self.trading_reward_campaign_account_points
    }
    pub fn clear_trading_reward_campaign_account_points(&mut self) {
        self.trading_reward_campaign_account_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_campaign_account_points(&mut self, v: ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints>) {
        self.trading_reward_campaign_account_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trading_reward_campaign_account_points(&mut self) -> &mut ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints> {
        &mut self.trading_reward_campaign_account_points
    }

    // Take field
    pub fn take_trading_reward_campaign_account_points(&mut self) -> ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints> {
        ::std::mem::replace(&mut self.trading_reward_campaign_account_points, ::protobuf::RepeatedField::new())
    }

    // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 18;


    pub fn get_fee_discount_schedule(&self) -> &super::exchange::FeeDiscountSchedule {
        self.fee_discount_schedule.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fee_discount_schedule(&mut self) {
        self.fee_discount_schedule.clear();
    }

    pub fn has_fee_discount_schedule(&self) -> bool {
        self.fee_discount_schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_discount_schedule(&mut self, v: super::exchange::FeeDiscountSchedule) {
        self.fee_discount_schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_discount_schedule(&mut self) -> &mut super::exchange::FeeDiscountSchedule {
        if self.fee_discount_schedule.is_none() {
            self.fee_discount_schedule.set_default();
        }
        self.fee_discount_schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_discount_schedule(&mut self) -> super::exchange::FeeDiscountSchedule {
        self.fee_discount_schedule.take().unwrap_or_else(|| super::exchange::FeeDiscountSchedule::new())
    }

    // repeated .injective.exchange.v1beta1.FeeDiscountAccountTierTTL fee_discount_account_tier_ttl = 19;


    pub fn get_fee_discount_account_tier_ttl(&self) -> &[FeeDiscountAccountTierTTL] {
        &self.fee_discount_account_tier_ttl
    }
    pub fn clear_fee_discount_account_tier_ttl(&mut self) {
        self.fee_discount_account_tier_ttl.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_discount_account_tier_ttl(&mut self, v: ::protobuf::RepeatedField<FeeDiscountAccountTierTTL>) {
        self.fee_discount_account_tier_ttl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fee_discount_account_tier_ttl(&mut self) -> &mut ::protobuf::RepeatedField<FeeDiscountAccountTierTTL> {
        &mut self.fee_discount_account_tier_ttl
    }

    // Take field
    pub fn take_fee_discount_account_tier_ttl(&mut self) -> ::protobuf::RepeatedField<FeeDiscountAccountTierTTL> {
        ::std::mem::replace(&mut self.fee_discount_account_tier_ttl, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.FeeDiscountBucketVolumeAccounts fee_discount_bucket_volume_accounts = 20;


    pub fn get_fee_discount_bucket_volume_accounts(&self) -> &[FeeDiscountBucketVolumeAccounts] {
        &self.fee_discount_bucket_volume_accounts
    }
    pub fn clear_fee_discount_bucket_volume_accounts(&mut self) {
        self.fee_discount_bucket_volume_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_discount_bucket_volume_accounts(&mut self, v: ::protobuf::RepeatedField<FeeDiscountBucketVolumeAccounts>) {
        self.fee_discount_bucket_volume_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fee_discount_bucket_volume_accounts(&mut self) -> &mut ::protobuf::RepeatedField<FeeDiscountBucketVolumeAccounts> {
        &mut self.fee_discount_bucket_volume_accounts
    }

    // Take field
    pub fn take_fee_discount_bucket_volume_accounts(&mut self) -> ::protobuf::RepeatedField<FeeDiscountBucketVolumeAccounts> {
        ::std::mem::replace(&mut self.fee_discount_bucket_volume_accounts, ::protobuf::RepeatedField::new())
    }

    // bool is_first_fee_cycle_finished = 21;


    pub fn get_is_first_fee_cycle_finished(&self) -> bool {
        self.is_first_fee_cycle_finished
    }
    pub fn clear_is_first_fee_cycle_finished(&mut self) {
        self.is_first_fee_cycle_finished = false;
    }

    // Param is passed by value, moved
    pub fn set_is_first_fee_cycle_finished(&mut self, v: bool) {
        self.is_first_fee_cycle_finished = v;
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 22;


    pub fn get_pending_trading_reward_pool_campaign_schedule(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.pending_trading_reward_pool_campaign_schedule
    }
    pub fn clear_pending_trading_reward_pool_campaign_schedule(&mut self) {
        self.pending_trading_reward_pool_campaign_schedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_trading_reward_pool_campaign_schedule(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.pending_trading_reward_pool_campaign_schedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_trading_reward_pool_campaign_schedule(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.pending_trading_reward_pool_campaign_schedule
    }

    // Take field
    pub fn take_pending_trading_reward_pool_campaign_schedule(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.pending_trading_reward_pool_campaign_schedule, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPendingPoints pending_trading_reward_campaign_account_points = 23;


    pub fn get_pending_trading_reward_campaign_account_points(&self) -> &[TradingRewardCampaignAccountPendingPoints] {
        &self.pending_trading_reward_campaign_account_points
    }
    pub fn clear_pending_trading_reward_campaign_account_points(&mut self) {
        self.pending_trading_reward_campaign_account_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_trading_reward_campaign_account_points(&mut self, v: ::protobuf::RepeatedField<TradingRewardCampaignAccountPendingPoints>) {
        self.pending_trading_reward_campaign_account_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_trading_reward_campaign_account_points(&mut self) -> &mut ::protobuf::RepeatedField<TradingRewardCampaignAccountPendingPoints> {
        &mut self.pending_trading_reward_campaign_account_points
    }

    // Take field
    pub fn take_pending_trading_reward_campaign_account_points(&mut self) -> ::protobuf::RepeatedField<TradingRewardCampaignAccountPendingPoints> {
        ::std::mem::replace(&mut self.pending_trading_reward_campaign_account_points, ::protobuf::RepeatedField::new())
    }

    // repeated string rewards_opt_out_addresses = 24;


    pub fn get_rewards_opt_out_addresses(&self) -> &[::std::string::String] {
        &self.rewards_opt_out_addresses
    }
    pub fn clear_rewards_opt_out_addresses(&mut self) {
        self.rewards_opt_out_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewards_opt_out_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.rewards_opt_out_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewards_opt_out_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.rewards_opt_out_addresses
    }

    // Take field
    pub fn take_rewards_opt_out_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.rewards_opt_out_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.TradeRecords historical_trade_records = 25;


    pub fn get_historical_trade_records(&self) -> &[super::exchange::TradeRecords] {
        &self.historical_trade_records
    }
    pub fn clear_historical_trade_records(&mut self) {
        self.historical_trade_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_historical_trade_records(&mut self, v: ::protobuf::RepeatedField<super::exchange::TradeRecords>) {
        self.historical_trade_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_historical_trade_records(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::TradeRecords> {
        &mut self.historical_trade_records
    }

    // Take field
    pub fn take_historical_trade_records(&mut self) -> ::protobuf::RepeatedField<super::exchange::TradeRecords> {
        ::std::mem::replace(&mut self.historical_trade_records, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.BinaryOptionsMarket binary_options_markets = 26;


    pub fn get_binary_options_markets(&self) -> &[super::exchange::BinaryOptionsMarket] {
        &self.binary_options_markets
    }
    pub fn clear_binary_options_markets(&mut self) {
        self.binary_options_markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_markets(&mut self, v: ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket>) {
        self.binary_options_markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_markets(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket> {
        &mut self.binary_options_markets
    }

    // Take field
    pub fn take_binary_options_markets(&mut self) -> ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket> {
        ::std::mem::replace(&mut self.binary_options_markets, ::protobuf::RepeatedField::new())
    }

    // repeated string binary_options_market_ids_scheduled_for_settlement = 27;


    pub fn get_binary_options_market_ids_scheduled_for_settlement(&self) -> &[::std::string::String] {
        &self.binary_options_market_ids_scheduled_for_settlement
    }
    pub fn clear_binary_options_market_ids_scheduled_for_settlement(&mut self) {
        self.binary_options_market_ids_scheduled_for_settlement.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_market_ids_scheduled_for_settlement(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.binary_options_market_ids_scheduled_for_settlement = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_market_ids_scheduled_for_settlement(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.binary_options_market_ids_scheduled_for_settlement
    }

    // Take field
    pub fn take_binary_options_market_ids_scheduled_for_settlement(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.binary_options_market_ids_scheduled_for_settlement, ::protobuf::RepeatedField::new())
    }

    // repeated string spot_market_ids_scheduled_to_force_close = 28;


    pub fn get_spot_market_ids_scheduled_to_force_close(&self) -> &[::std::string::String] {
        &self.spot_market_ids_scheduled_to_force_close
    }
    pub fn clear_spot_market_ids_scheduled_to_force_close(&mut self) {
        self.spot_market_ids_scheduled_to_force_close.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_market_ids_scheduled_to_force_close(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.spot_market_ids_scheduled_to_force_close = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_market_ids_scheduled_to_force_close(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.spot_market_ids_scheduled_to_force_close
    }

    // Take field
    pub fn take_spot_market_ids_scheduled_to_force_close(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.spot_market_ids_scheduled_to_force_close, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 29;


    pub fn get_denom_decimals(&self) -> &[super::exchange::DenomDecimals] {
        &self.denom_decimals
    }
    pub fn clear_denom_decimals(&mut self) {
        self.denom_decimals.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom_decimals(&mut self, v: ::protobuf::RepeatedField<super::exchange::DenomDecimals>) {
        self.denom_decimals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denom_decimals(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        &mut self.denom_decimals
    }

    // Take field
    pub fn take_denom_decimals(&mut self) -> ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        ::std::mem::replace(&mut self.denom_decimals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.ConditionalDerivativeOrderBook conditional_derivative_orderbooks = 30;


    pub fn get_conditional_derivative_orderbooks(&self) -> &[ConditionalDerivativeOrderBook] {
        &self.conditional_derivative_orderbooks
    }
    pub fn clear_conditional_derivative_orderbooks(&mut self) {
        self.conditional_derivative_orderbooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditional_derivative_orderbooks(&mut self, v: ::protobuf::RepeatedField<ConditionalDerivativeOrderBook>) {
        self.conditional_derivative_orderbooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditional_derivative_orderbooks(&mut self) -> &mut ::protobuf::RepeatedField<ConditionalDerivativeOrderBook> {
        &mut self.conditional_derivative_orderbooks
    }

    // Take field
    pub fn take_conditional_derivative_orderbooks(&mut self) -> ::protobuf::RepeatedField<ConditionalDerivativeOrderBook> {
        ::std::mem::replace(&mut self.conditional_derivative_orderbooks, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 31;


    pub fn get_market_fee_multipliers(&self) -> &[super::exchange::MarketFeeMultiplier] {
        &self.market_fee_multipliers
    }
    pub fn clear_market_fee_multipliers(&mut self) {
        self.market_fee_multipliers.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_fee_multipliers(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>) {
        self.market_fee_multipliers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_fee_multipliers(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        &mut self.market_fee_multipliers
    }

    // Take field
    pub fn take_market_fee_multipliers(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        ::std::mem::replace(&mut self.market_fee_multipliers, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.OrderbookSequence orderbook_sequences = 32;


    pub fn get_orderbook_sequences(&self) -> &[OrderbookSequence] {
        &self.orderbook_sequences
    }
    pub fn clear_orderbook_sequences(&mut self) {
        self.orderbook_sequences.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderbook_sequences(&mut self, v: ::protobuf::RepeatedField<OrderbookSequence>) {
        self.orderbook_sequences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderbook_sequences(&mut self) -> &mut ::protobuf::RepeatedField<OrderbookSequence> {
        &mut self.orderbook_sequences
    }

    // Take field
    pub fn take_orderbook_sequences(&mut self) -> ::protobuf::RepeatedField<OrderbookSequence> {
        ::std::mem::replace(&mut self.orderbook_sequences, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.AggregateSubaccountVolumeRecord subaccount_volumes = 33;


    pub fn get_subaccount_volumes(&self) -> &[super::exchange::AggregateSubaccountVolumeRecord] {
        &self.subaccount_volumes
    }
    pub fn clear_subaccount_volumes(&mut self) {
        self.subaccount_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::AggregateSubaccountVolumeRecord>) {
        self.subaccount_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::AggregateSubaccountVolumeRecord> {
        &mut self.subaccount_volumes
    }

    // Take field
    pub fn take_subaccount_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::AggregateSubaccountVolumeRecord> {
        ::std::mem::replace(&mut self.subaccount_volumes, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 34;


    pub fn get_market_volumes(&self) -> &[super::exchange::MarketVolume] {
        &self.market_volumes
    }
    pub fn clear_market_volumes(&mut self) {
        self.market_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketVolume>) {
        self.market_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        &mut self.market_volumes
    }

    // Take field
    pub fn take_market_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        ::std::mem::replace(&mut self.market_volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenesisState {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spot_markets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_markets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spot_orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.balances {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.positions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subaccount_trade_nonces {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiry_futures_market_info_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_funding_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_market_settlement_scheduled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trading_reward_campaign_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trading_reward_pool_campaign_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trading_reward_campaign_account_points {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fee_discount_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fee_discount_account_tier_ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fee_discount_bucket_volume_accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_trading_reward_pool_campaign_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_trading_reward_campaign_account_points {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.historical_trade_records {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_markets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denom_decimals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditional_derivative_orderbooks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_fee_multipliers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.orderbook_sequences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subaccount_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_markets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_markets)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_orderbook)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_orderbook)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.balances)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.positions)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subaccount_trade_nonces)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.expiry_futures_market_info_state)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.perpetual_market_info)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.perpetual_market_funding_state)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_market_settlement_scheduled)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_spot_exchange_enabled = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_derivatives_exchange_enabled = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trading_reward_campaign_info)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trading_reward_pool_campaign_schedule)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trading_reward_campaign_account_points)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_discount_schedule)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fee_discount_account_tier_ttl)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fee_discount_bucket_volume_accounts)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_first_fee_cycle_finished = tmp;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_trading_reward_pool_campaign_schedule)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_trading_reward_campaign_account_points)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.rewards_opt_out_addresses)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.historical_trade_records)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_options_markets)?;
                },
                27 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.binary_options_market_ids_scheduled_for_settlement)?;
                },
                28 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.spot_market_ids_scheduled_to_force_close)?;
                },
                29 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.denom_decimals)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditional_derivative_orderbooks)?;
                },
                31 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_fee_multipliers)?;
                },
                32 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orderbook_sequences)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subaccount_volumes)?;
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.spot_markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.spot_orderbook {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_orderbook {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.balances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.subaccount_trade_nonces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.expiry_futures_market_info_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.perpetual_market_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.perpetual_market_funding_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_market_settlement_scheduled {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_spot_exchange_enabled != false {
            my_size += 2;
        }
        if self.is_derivatives_exchange_enabled != false {
            my_size += 2;
        }
        if let Some(ref v) = self.trading_reward_campaign_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.trading_reward_pool_campaign_schedule {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.trading_reward_campaign_account_points {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fee_discount_schedule.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.fee_discount_account_tier_ttl {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.fee_discount_bucket_volume_accounts {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_first_fee_cycle_finished != false {
            my_size += 3;
        }
        for value in &self.pending_trading_reward_pool_campaign_schedule {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_trading_reward_campaign_account_points {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rewards_opt_out_addresses {
            my_size += ::protobuf::rt::string_size(24, &value);
        };
        for value in &self.historical_trade_records {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_options_markets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_options_market_ids_scheduled_for_settlement {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.spot_market_ids_scheduled_to_force_close {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        for value in &self.denom_decimals {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.conditional_derivative_orderbooks {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.market_fee_multipliers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.orderbook_sequences {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.subaccount_volumes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.market_volumes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.spot_markets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_markets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.spot_orderbook {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_orderbook {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.balances {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.positions {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.subaccount_trade_nonces {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.expiry_futures_market_info_state {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.perpetual_market_info {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.perpetual_market_funding_state {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_market_settlement_scheduled {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_spot_exchange_enabled != false {
            os.write_bool(13, self.is_spot_exchange_enabled)?;
        }
        if self.is_derivatives_exchange_enabled != false {
            os.write_bool(14, self.is_derivatives_exchange_enabled)?;
        }
        if let Some(ref v) = self.trading_reward_campaign_info.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.trading_reward_pool_campaign_schedule {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.trading_reward_campaign_account_points {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fee_discount_schedule.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.fee_discount_account_tier_ttl {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.fee_discount_bucket_volume_accounts {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_first_fee_cycle_finished != false {
            os.write_bool(21, self.is_first_fee_cycle_finished)?;
        }
        for v in &self.pending_trading_reward_pool_campaign_schedule {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_trading_reward_campaign_account_points {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rewards_opt_out_addresses {
            os.write_string(24, &v)?;
        };
        for v in &self.historical_trade_records {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_options_markets {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_options_market_ids_scheduled_for_settlement {
            os.write_string(27, &v)?;
        };
        for v in &self.spot_market_ids_scheduled_to_force_close {
            os.write_string(28, &v)?;
        };
        for v in &self.denom_decimals {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.conditional_derivative_orderbooks {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.market_fee_multipliers {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.orderbook_sequences {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.subaccount_volumes {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.market_volumes {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenesisState {
        GenesisState::new()
    }

    fn default_instance() -> &'static GenesisState {
        static instance: ::protobuf::rt::LazyV2<GenesisState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenesisState::new)
    }
}

impl ::protobuf::Clear for GenesisState {
    fn clear(&mut self) {
        self.params.clear();
        self.spot_markets.clear();
        self.derivative_markets.clear();
        self.spot_orderbook.clear();
        self.derivative_orderbook.clear();
        self.balances.clear();
        self.positions.clear();
        self.subaccount_trade_nonces.clear();
        self.expiry_futures_market_info_state.clear();
        self.perpetual_market_info.clear();
        self.perpetual_market_funding_state.clear();
        self.derivative_market_settlement_scheduled.clear();
        self.is_spot_exchange_enabled = false;
        self.is_derivatives_exchange_enabled = false;
        self.trading_reward_campaign_info.clear();
        self.trading_reward_pool_campaign_schedule.clear();
        self.trading_reward_campaign_account_points.clear();
        self.fee_discount_schedule.clear();
        self.fee_discount_account_tier_ttl.clear();
        self.fee_discount_bucket_volume_accounts.clear();
        self.is_first_fee_cycle_finished = false;
        self.pending_trading_reward_pool_campaign_schedule.clear();
        self.pending_trading_reward_campaign_account_points.clear();
        self.rewards_opt_out_addresses.clear();
        self.historical_trade_records.clear();
        self.binary_options_markets.clear();
        self.binary_options_market_ids_scheduled_for_settlement.clear();
        self.spot_market_ids_scheduled_to_force_close.clear();
        self.denom_decimals.clear();
        self.conditional_derivative_orderbooks.clear();
        self.market_fee_multipliers.clear();
        self.orderbook_sequences.clear();
        self.subaccount_volumes.clear();
        self.market_volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GenesisState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookSequence {
    // message fields
    pub sequence: u64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookSequence {
    fn default() -> &'a OrderbookSequence {
        <OrderbookSequence as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookSequence {
    pub fn new() -> OrderbookSequence {
        ::std::default::Default::default()
    }

    // uint64 sequence = 1;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderbookSequence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sequence != 0 {
            os.write_uint64(1, self.sequence)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookSequence {
        OrderbookSequence::new()
    }

    fn default_instance() -> &'static OrderbookSequence {
        static instance: ::protobuf::rt::LazyV2<OrderbookSequence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookSequence::new)
    }
}

impl ::protobuf::Clear for OrderbookSequence {
    fn clear(&mut self) {
        self.sequence = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookSequence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountAccountTierTTL {
    // message fields
    pub account: ::std::string::String,
    pub tier_ttl: ::protobuf::SingularPtrField<super::exchange::FeeDiscountTierTTL>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountAccountTierTTL {
    fn default() -> &'a FeeDiscountAccountTierTTL {
        <FeeDiscountAccountTierTTL as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountAccountTierTTL {
    pub fn new() -> FeeDiscountAccountTierTTL {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.FeeDiscountTierTTL tier_ttl = 2;


    pub fn get_tier_ttl(&self) -> &super::exchange::FeeDiscountTierTTL {
        self.tier_ttl.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountTierTTL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tier_ttl(&mut self) {
        self.tier_ttl.clear();
    }

    pub fn has_tier_ttl(&self) -> bool {
        self.tier_ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier_ttl(&mut self, v: super::exchange::FeeDiscountTierTTL) {
        self.tier_ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tier_ttl(&mut self) -> &mut super::exchange::FeeDiscountTierTTL {
        if self.tier_ttl.is_none() {
            self.tier_ttl.set_default();
        }
        self.tier_ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_tier_ttl(&mut self) -> super::exchange::FeeDiscountTierTTL {
        self.tier_ttl.take().unwrap_or_else(|| super::exchange::FeeDiscountTierTTL::new())
    }
}

impl ::protobuf::Message for FeeDiscountAccountTierTTL {
    fn is_initialized(&self) -> bool {
        for v in &self.tier_ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tier_ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        if let Some(ref v) = self.tier_ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        if let Some(ref v) = self.tier_ttl.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountAccountTierTTL {
        FeeDiscountAccountTierTTL::new()
    }

    fn default_instance() -> &'static FeeDiscountAccountTierTTL {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountAccountTierTTL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountAccountTierTTL::new)
    }
}

impl ::protobuf::Clear for FeeDiscountAccountTierTTL {
    fn clear(&mut self) {
        self.account.clear();
        self.tier_ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountAccountTierTTL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountBucketVolumeAccounts {
    // message fields
    pub bucket_start_timestamp: i64,
    pub account_volume: ::protobuf::RepeatedField<AccountVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountBucketVolumeAccounts {
    fn default() -> &'a FeeDiscountBucketVolumeAccounts {
        <FeeDiscountBucketVolumeAccounts as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountBucketVolumeAccounts {
    pub fn new() -> FeeDiscountBucketVolumeAccounts {
        ::std::default::Default::default()
    }

    // int64 bucket_start_timestamp = 1;


    pub fn get_bucket_start_timestamp(&self) -> i64 {
        self.bucket_start_timestamp
    }
    pub fn clear_bucket_start_timestamp(&mut self) {
        self.bucket_start_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_bucket_start_timestamp(&mut self, v: i64) {
        self.bucket_start_timestamp = v;
    }

    // repeated .injective.exchange.v1beta1.AccountVolume account_volume = 2;


    pub fn get_account_volume(&self) -> &[AccountVolume] {
        &self.account_volume
    }
    pub fn clear_account_volume(&mut self) {
        self.account_volume.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_volume(&mut self, v: ::protobuf::RepeatedField<AccountVolume>) {
        self.account_volume = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_volume(&mut self) -> &mut ::protobuf::RepeatedField<AccountVolume> {
        &mut self.account_volume
    }

    // Take field
    pub fn take_account_volume(&mut self) -> ::protobuf::RepeatedField<AccountVolume> {
        ::std::mem::replace(&mut self.account_volume, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FeeDiscountBucketVolumeAccounts {
    fn is_initialized(&self) -> bool {
        for v in &self.account_volume {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucket_start_timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bucket_start_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bucket_start_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_volume {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bucket_start_timestamp != 0 {
            os.write_int64(1, self.bucket_start_timestamp)?;
        }
        for v in &self.account_volume {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountBucketVolumeAccounts {
        FeeDiscountBucketVolumeAccounts::new()
    }

    fn default_instance() -> &'static FeeDiscountBucketVolumeAccounts {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountBucketVolumeAccounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountBucketVolumeAccounts::new)
    }
}

impl ::protobuf::Clear for FeeDiscountBucketVolumeAccounts {
    fn clear(&mut self) {
        self.bucket_start_timestamp = 0;
        self.account_volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountBucketVolumeAccounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountVolume {
    // message fields
    pub account: ::std::string::String,
    pub volume: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountVolume {
    fn default() -> &'a AccountVolume {
        <AccountVolume as ::protobuf::Message>::default_instance()
    }
}

impl AccountVolume {
    pub fn new() -> AccountVolume {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // string volume = 2;


    pub fn get_volume(&self) -> &str {
        &self.volume
    }
    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        &mut self.volume
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volume, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AccountVolume {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        if !self.volume.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.volume);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        if !self.volume.is_empty() {
            os.write_string(2, &self.volume)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountVolume {
        AccountVolume::new()
    }

    fn default_instance() -> &'static AccountVolume {
        static instance: ::protobuf::rt::LazyV2<AccountVolume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountVolume::new)
    }
}

impl ::protobuf::Clear for AccountVolume {
    fn clear(&mut self) {
        self.account.clear();
        self.volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignAccountPoints {
    // message fields
    pub account: ::std::string::String,
    pub points: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignAccountPoints {
    fn default() -> &'a TradingRewardCampaignAccountPoints {
        <TradingRewardCampaignAccountPoints as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignAccountPoints {
    pub fn new() -> TradingRewardCampaignAccountPoints {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // string points = 2;


    pub fn get_points(&self) -> &str {
        &self.points
    }
    pub fn clear_points(&mut self) {
        self.points.clear();
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: ::std::string::String) {
        self.points = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_points(&mut self) -> &mut ::std::string::String {
        &mut self.points
    }

    // Take field
    pub fn take_points(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.points, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignAccountPoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        if !self.points.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.points);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        if !self.points.is_empty() {
            os.write_string(2, &self.points)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignAccountPoints {
        TradingRewardCampaignAccountPoints::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignAccountPoints {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignAccountPoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignAccountPoints::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignAccountPoints {
    fn clear(&mut self) {
        self.account.clear();
        self.points.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignAccountPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignAccountPendingPoints {
    // message fields
    pub reward_pool_start_timestamp: i64,
    pub account_points: ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignAccountPendingPoints {
    fn default() -> &'a TradingRewardCampaignAccountPendingPoints {
        <TradingRewardCampaignAccountPendingPoints as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignAccountPendingPoints {
    pub fn new() -> TradingRewardCampaignAccountPendingPoints {
        ::std::default::Default::default()
    }

    // int64 reward_pool_start_timestamp = 1;


    pub fn get_reward_pool_start_timestamp(&self) -> i64 {
        self.reward_pool_start_timestamp
    }
    pub fn clear_reward_pool_start_timestamp(&mut self) {
        self.reward_pool_start_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_reward_pool_start_timestamp(&mut self, v: i64) {
        self.reward_pool_start_timestamp = v;
    }

    // repeated .injective.exchange.v1beta1.TradingRewardCampaignAccountPoints account_points = 2;


    pub fn get_account_points(&self) -> &[TradingRewardCampaignAccountPoints] {
        &self.account_points
    }
    pub fn clear_account_points(&mut self) {
        self.account_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_points(&mut self, v: ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints>) {
        self.account_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_points(&mut self) -> &mut ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints> {
        &mut self.account_points
    }

    // Take field
    pub fn take_account_points(&mut self) -> ::protobuf::RepeatedField<TradingRewardCampaignAccountPoints> {
        ::std::mem::replace(&mut self.account_points, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignAccountPendingPoints {
    fn is_initialized(&self) -> bool {
        for v in &self.account_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.reward_pool_start_timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reward_pool_start_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.reward_pool_start_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reward_pool_start_timestamp != 0 {
            os.write_int64(1, self.reward_pool_start_timestamp)?;
        }
        for v in &self.account_points {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignAccountPendingPoints {
        TradingRewardCampaignAccountPendingPoints::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignAccountPendingPoints {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignAccountPendingPoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignAccountPendingPoints::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignAccountPendingPoints {
    fn clear(&mut self) {
        self.reward_pool_start_timestamp = 0;
        self.account_points.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignAccountPendingPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotOrderBook {
    // message fields
    pub market_id: ::std::string::String,
    pub isBuySide: bool,
    pub orders: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotOrderBook {
    fn default() -> &'a SpotOrderBook {
        <SpotOrderBook as ::protobuf::Message>::default_instance()
    }
}

impl SpotOrderBook {
    pub fn new() -> SpotOrderBook {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isBuySide = 2;


    pub fn get_isBuySide(&self) -> bool {
        self.isBuySide
    }
    pub fn clear_isBuySide(&mut self) {
        self.isBuySide = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuySide(&mut self, v: bool) {
        self.isBuySide = v;
    }

    // repeated .injective.exchange.v1beta1.SpotLimitOrder orders = 3;


    pub fn get_orders(&self) -> &[super::exchange::SpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SpotOrderBook {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuySide = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.isBuySide != false {
            my_size += 2;
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.isBuySide != false {
            os.write_bool(2, self.isBuySide)?;
        }
        for v in &self.orders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotOrderBook {
        SpotOrderBook::new()
    }

    fn default_instance() -> &'static SpotOrderBook {
        static instance: ::protobuf::rt::LazyV2<SpotOrderBook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotOrderBook::new)
    }
}

impl ::protobuf::Clear for SpotOrderBook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isBuySide = false;
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotOrderBook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeOrderBook {
    // message fields
    pub market_id: ::std::string::String,
    pub isBuySide: bool,
    pub orders: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeOrderBook {
    fn default() -> &'a DerivativeOrderBook {
        <DerivativeOrderBook as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeOrderBook {
    pub fn new() -> DerivativeOrderBook {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isBuySide = 2;


    pub fn get_isBuySide(&self) -> bool {
        self.isBuySide
    }
    pub fn clear_isBuySide(&mut self) {
        self.isBuySide = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuySide(&mut self, v: bool) {
        self.isBuySide = v;
    }

    // repeated .injective.exchange.v1beta1.DerivativeLimitOrder orders = 3;


    pub fn get_orders(&self) -> &[super::exchange::DerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DerivativeOrderBook {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuySide = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.isBuySide != false {
            my_size += 2;
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.isBuySide != false {
            os.write_bool(2, self.isBuySide)?;
        }
        for v in &self.orders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeOrderBook {
        DerivativeOrderBook::new()
    }

    fn default_instance() -> &'static DerivativeOrderBook {
        static instance: ::protobuf::rt::LazyV2<DerivativeOrderBook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeOrderBook::new)
    }
}

impl ::protobuf::Clear for DerivativeOrderBook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isBuySide = false;
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeOrderBook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConditionalDerivativeOrderBook {
    // message fields
    pub market_id: ::std::string::String,
    pub limit_buy_orders: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>,
    pub market_buy_orders: ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder>,
    pub limit_sell_orders: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>,
    pub market_sell_orders: ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConditionalDerivativeOrderBook {
    fn default() -> &'a ConditionalDerivativeOrderBook {
        <ConditionalDerivativeOrderBook as ::protobuf::Message>::default_instance()
    }
}

impl ConditionalDerivativeOrderBook {
    pub fn new() -> ConditionalDerivativeOrderBook {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_buy_orders = 2;


    pub fn get_limit_buy_orders(&self) -> &[super::exchange::DerivativeLimitOrder] {
        &self.limit_buy_orders
    }
    pub fn clear_limit_buy_orders(&mut self) {
        self.limit_buy_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit_buy_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>) {
        self.limit_buy_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limit_buy_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        &mut self.limit_buy_orders
    }

    // Take field
    pub fn take_limit_buy_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.limit_buy_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_buy_orders = 3;


    pub fn get_market_buy_orders(&self) -> &[super::exchange::DerivativeMarketOrder] {
        &self.market_buy_orders
    }
    pub fn clear_market_buy_orders(&mut self) {
        self.market_buy_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_buy_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder>) {
        self.market_buy_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_buy_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder> {
        &mut self.market_buy_orders
    }

    // Take field
    pub fn take_market_buy_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder> {
        ::std::mem::replace(&mut self.market_buy_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeLimitOrder limit_sell_orders = 4;


    pub fn get_limit_sell_orders(&self) -> &[super::exchange::DerivativeLimitOrder] {
        &self.limit_sell_orders
    }
    pub fn clear_limit_sell_orders(&mut self) {
        self.limit_sell_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit_sell_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>) {
        self.limit_sell_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limit_sell_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        &mut self.limit_sell_orders
    }

    // Take field
    pub fn take_limit_sell_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.limit_sell_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeMarketOrder market_sell_orders = 5;


    pub fn get_market_sell_orders(&self) -> &[super::exchange::DerivativeMarketOrder] {
        &self.market_sell_orders
    }
    pub fn clear_market_sell_orders(&mut self) {
        self.market_sell_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_sell_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder>) {
        self.market_sell_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_sell_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder> {
        &mut self.market_sell_orders
    }

    // Take field
    pub fn take_market_sell_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeMarketOrder> {
        ::std::mem::replace(&mut self.market_sell_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConditionalDerivativeOrderBook {
    fn is_initialized(&self) -> bool {
        for v in &self.limit_buy_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_buy_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limit_sell_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_sell_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limit_buy_orders)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_buy_orders)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limit_sell_orders)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_sell_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.limit_buy_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.market_buy_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.limit_sell_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.market_sell_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.limit_buy_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.market_buy_orders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.limit_sell_orders {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.market_sell_orders {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionalDerivativeOrderBook {
        ConditionalDerivativeOrderBook::new()
    }

    fn default_instance() -> &'static ConditionalDerivativeOrderBook {
        static instance: ::protobuf::rt::LazyV2<ConditionalDerivativeOrderBook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConditionalDerivativeOrderBook::new)
    }
}

impl ::protobuf::Clear for ConditionalDerivativeOrderBook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.limit_buy_orders.clear();
        self.market_buy_orders.clear();
        self.limit_sell_orders.clear();
        self.market_sell_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionalDerivativeOrderBook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Balance {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denom: ::std::string::String,
    pub deposits: ::protobuf::SingularPtrField<super::exchange::Deposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Balance {
    fn default() -> &'a Balance {
        <Balance as ::protobuf::Message>::default_instance()
    }
}

impl Balance {
    pub fn new() -> Balance {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.Deposit deposits = 3;


    pub fn get_deposits(&self) -> &super::exchange::Deposit {
        self.deposits.as_ref().unwrap_or_else(|| <super::exchange::Deposit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deposits(&mut self) {
        self.deposits.clear();
    }

    pub fn has_deposits(&self) -> bool {
        self.deposits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deposits(&mut self, v: super::exchange::Deposit) {
        self.deposits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposits(&mut self) -> &mut super::exchange::Deposit {
        if self.deposits.is_none() {
            self.deposits.set_default();
        }
        self.deposits.as_mut().unwrap()
    }

    // Take field
    pub fn take_deposits(&mut self) -> super::exchange::Deposit {
        self.deposits.take().unwrap_or_else(|| super::exchange::Deposit::new())
    }
}

impl ::protobuf::Message for Balance {
    fn is_initialized(&self) -> bool {
        for v in &self.deposits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deposits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        if let Some(ref v) = self.deposits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        if let Some(ref v) = self.deposits.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Balance {
        Balance::new()
    }

    fn default_instance() -> &'static Balance {
        static instance: ::protobuf::rt::LazyV2<Balance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Balance::new)
    }
}

impl ::protobuf::Clear for Balance {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denom.clear();
        self.deposits.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Balance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativePosition {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub position: ::protobuf::SingularPtrField<super::exchange::Position>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativePosition {
    fn default() -> &'a DerivativePosition {
        <DerivativePosition as ::protobuf::Message>::default_instance()
    }
}

impl DerivativePosition {
    pub fn new() -> DerivativePosition {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.Position position = 3;


    pub fn get_position(&self) -> &super::exchange::Position {
        self.position.as_ref().unwrap_or_else(|| <super::exchange::Position as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::exchange::Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::exchange::Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::exchange::Position {
        self.position.take().unwrap_or_else(|| super::exchange::Position::new())
    }
}

impl ::protobuf::Message for DerivativePosition {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativePosition {
        DerivativePosition::new()
    }

    fn default_instance() -> &'static DerivativePosition {
        static instance: ::protobuf::rt::LazyV2<DerivativePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativePosition::new)
    }
}

impl ::protobuf::Clear for DerivativePosition {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountNonce {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub subaccount_trade_nonce: ::protobuf::SingularPtrField<super::exchange::SubaccountTradeNonce>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountNonce {
    fn default() -> &'a SubaccountNonce {
        <SubaccountNonce as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountNonce {
    pub fn new() -> SubaccountNonce {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.SubaccountTradeNonce subaccount_trade_nonce = 2;


    pub fn get_subaccount_trade_nonce(&self) -> &super::exchange::SubaccountTradeNonce {
        self.subaccount_trade_nonce.as_ref().unwrap_or_else(|| <super::exchange::SubaccountTradeNonce as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subaccount_trade_nonce(&mut self) {
        self.subaccount_trade_nonce.clear();
    }

    pub fn has_subaccount_trade_nonce(&self) -> bool {
        self.subaccount_trade_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subaccount_trade_nonce(&mut self, v: super::exchange::SubaccountTradeNonce) {
        self.subaccount_trade_nonce = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_trade_nonce(&mut self) -> &mut super::exchange::SubaccountTradeNonce {
        if self.subaccount_trade_nonce.is_none() {
            self.subaccount_trade_nonce.set_default();
        }
        self.subaccount_trade_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_subaccount_trade_nonce(&mut self) -> super::exchange::SubaccountTradeNonce {
        self.subaccount_trade_nonce.take().unwrap_or_else(|| super::exchange::SubaccountTradeNonce::new())
    }
}

impl ::protobuf::Message for SubaccountNonce {
    fn is_initialized(&self) -> bool {
        for v in &self.subaccount_trade_nonce {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subaccount_trade_nonce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if let Some(ref v) = self.subaccount_trade_nonce.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.subaccount_trade_nonce.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountNonce {
        SubaccountNonce::new()
    }

    fn default_instance() -> &'static SubaccountNonce {
        static instance: ::protobuf::rt::LazyV2<SubaccountNonce> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountNonce::new)
    }
}

impl ::protobuf::Clear for SubaccountNonce {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.subaccount_trade_nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountNonce {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpiryFuturesMarketInfoState {
    // message fields
    pub market_id: ::std::string::String,
    pub market_info: ::protobuf::SingularPtrField<super::exchange::ExpiryFuturesMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpiryFuturesMarketInfoState {
    fn default() -> &'a ExpiryFuturesMarketInfoState {
        <ExpiryFuturesMarketInfoState as ::protobuf::Message>::default_instance()
    }
}

impl ExpiryFuturesMarketInfoState {
    pub fn new() -> ExpiryFuturesMarketInfoState {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo market_info = 2;


    pub fn get_market_info(&self) -> &super::exchange::ExpiryFuturesMarketInfo {
        self.market_info.as_ref().unwrap_or_else(|| <super::exchange::ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market_info(&mut self) {
        self.market_info.clear();
    }

    pub fn has_market_info(&self) -> bool {
        self.market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market_info(&mut self, v: super::exchange::ExpiryFuturesMarketInfo) {
        self.market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_info(&mut self) -> &mut super::exchange::ExpiryFuturesMarketInfo {
        if self.market_info.is_none() {
            self.market_info.set_default();
        }
        self.market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_market_info(&mut self) -> super::exchange::ExpiryFuturesMarketInfo {
        self.market_info.take().unwrap_or_else(|| super::exchange::ExpiryFuturesMarketInfo::new())
    }
}

impl ::protobuf::Message for ExpiryFuturesMarketInfoState {
    fn is_initialized(&self) -> bool {
        for v in &self.market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.market_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.market_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpiryFuturesMarketInfoState {
        ExpiryFuturesMarketInfoState::new()
    }

    fn default_instance() -> &'static ExpiryFuturesMarketInfoState {
        static instance: ::protobuf::rt::LazyV2<ExpiryFuturesMarketInfoState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpiryFuturesMarketInfoState::new)
    }
}

impl ::protobuf::Clear for ExpiryFuturesMarketInfoState {
    fn clear(&mut self) {
        self.market_id.clear();
        self.market_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpiryFuturesMarketInfoState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketFundingState {
    // message fields
    pub market_id: ::std::string::String,
    pub funding: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketFunding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketFundingState {
    fn default() -> &'a PerpetualMarketFundingState {
        <PerpetualMarketFundingState as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketFundingState {
    pub fn new() -> PerpetualMarketFundingState {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2;


    pub fn get_funding(&self) -> &super::exchange::PerpetualMarketFunding {
        self.funding.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_funding(&mut self) {
        self.funding.clear();
    }

    pub fn has_funding(&self) -> bool {
        self.funding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_funding(&mut self, v: super::exchange::PerpetualMarketFunding) {
        self.funding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding(&mut self) -> &mut super::exchange::PerpetualMarketFunding {
        if self.funding.is_none() {
            self.funding.set_default();
        }
        self.funding.as_mut().unwrap()
    }

    // Take field
    pub fn take_funding(&mut self) -> super::exchange::PerpetualMarketFunding {
        self.funding.take().unwrap_or_else(|| super::exchange::PerpetualMarketFunding::new())
    }
}

impl ::protobuf::Message for PerpetualMarketFundingState {
    fn is_initialized(&self) -> bool {
        for v in &self.funding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.funding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.funding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.funding.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketFundingState {
        PerpetualMarketFundingState::new()
    }

    fn default_instance() -> &'static PerpetualMarketFundingState {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketFundingState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketFundingState::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketFundingState {
    fn clear(&mut self) {
        self.market_id.clear();
        self.funding.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketFundingState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
