// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/exchange/v1beta1/events.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventBatchSpotExecution {
    // message fields
    pub market_id: ::std::string::String,
    pub is_buy: bool,
    pub executionType: super::exchange::ExecutionType,
    pub trades: ::protobuf::RepeatedField<super::exchange::TradeLog>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventBatchSpotExecution {
    fn default() -> &'a EventBatchSpotExecution {
        <EventBatchSpotExecution as ::protobuf::Message>::default_instance()
    }
}

impl EventBatchSpotExecution {
    pub fn new() -> EventBatchSpotExecution {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool is_buy = 2;


    pub fn get_is_buy(&self) -> bool {
        self.is_buy
    }
    pub fn clear_is_buy(&mut self) {
        self.is_buy = false;
    }

    // Param is passed by value, moved
    pub fn set_is_buy(&mut self, v: bool) {
        self.is_buy = v;
    }

    // .injective.exchange.v1beta1.ExecutionType executionType = 3;


    pub fn get_executionType(&self) -> super::exchange::ExecutionType {
        self.executionType
    }
    pub fn clear_executionType(&mut self) {
        self.executionType = super::exchange::ExecutionType::UnspecifiedExecutionType;
    }

    // Param is passed by value, moved
    pub fn set_executionType(&mut self, v: super::exchange::ExecutionType) {
        self.executionType = v;
    }

    // repeated .injective.exchange.v1beta1.TradeLog trades = 4;


    pub fn get_trades(&self) -> &[super::exchange::TradeLog] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<super::exchange::TradeLog>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::TradeLog> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<super::exchange::TradeLog> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventBatchSpotExecution {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_buy = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.executionType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.is_buy != false {
            my_size += 2;
        }
        if self.executionType != super::exchange::ExecutionType::UnspecifiedExecutionType {
            my_size += ::protobuf::rt::enum_size(3, self.executionType);
        }
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.is_buy != false {
            os.write_bool(2, self.is_buy)?;
        }
        if self.executionType != super::exchange::ExecutionType::UnspecifiedExecutionType {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.executionType))?;
        }
        for v in &self.trades {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventBatchSpotExecution {
        EventBatchSpotExecution::new()
    }

    fn default_instance() -> &'static EventBatchSpotExecution {
        static instance: ::protobuf::rt::LazyV2<EventBatchSpotExecution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventBatchSpotExecution::new)
    }
}

impl ::protobuf::Clear for EventBatchSpotExecution {
    fn clear(&mut self) {
        self.market_id.clear();
        self.is_buy = false;
        self.executionType = super::exchange::ExecutionType::UnspecifiedExecutionType;
        self.trades.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventBatchSpotExecution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventBatchDerivativeExecution {
    // message fields
    pub market_id: ::std::string::String,
    pub is_buy: bool,
    pub is_liquidation: bool,
    pub cumulative_funding: ::std::string::String,
    pub executionType: super::exchange::ExecutionType,
    pub trades: ::protobuf::RepeatedField<super::exchange::DerivativeTradeLog>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventBatchDerivativeExecution {
    fn default() -> &'a EventBatchDerivativeExecution {
        <EventBatchDerivativeExecution as ::protobuf::Message>::default_instance()
    }
}

impl EventBatchDerivativeExecution {
    pub fn new() -> EventBatchDerivativeExecution {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool is_buy = 2;


    pub fn get_is_buy(&self) -> bool {
        self.is_buy
    }
    pub fn clear_is_buy(&mut self) {
        self.is_buy = false;
    }

    // Param is passed by value, moved
    pub fn set_is_buy(&mut self, v: bool) {
        self.is_buy = v;
    }

    // bool is_liquidation = 3;


    pub fn get_is_liquidation(&self) -> bool {
        self.is_liquidation
    }
    pub fn clear_is_liquidation(&mut self) {
        self.is_liquidation = false;
    }

    // Param is passed by value, moved
    pub fn set_is_liquidation(&mut self, v: bool) {
        self.is_liquidation = v;
    }

    // string cumulative_funding = 4;


    pub fn get_cumulative_funding(&self) -> &str {
        &self.cumulative_funding
    }
    pub fn clear_cumulative_funding(&mut self) {
        self.cumulative_funding.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_funding(&mut self, v: ::std::string::String) {
        self.cumulative_funding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_funding(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_funding
    }

    // Take field
    pub fn take_cumulative_funding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_funding, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.ExecutionType executionType = 5;


    pub fn get_executionType(&self) -> super::exchange::ExecutionType {
        self.executionType
    }
    pub fn clear_executionType(&mut self) {
        self.executionType = super::exchange::ExecutionType::UnspecifiedExecutionType;
    }

    // Param is passed by value, moved
    pub fn set_executionType(&mut self, v: super::exchange::ExecutionType) {
        self.executionType = v;
    }

    // repeated .injective.exchange.v1beta1.DerivativeTradeLog trades = 6;


    pub fn get_trades(&self) -> &[super::exchange::DerivativeTradeLog] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeTradeLog>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeTradeLog> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeTradeLog> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventBatchDerivativeExecution {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_buy = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_liquidation = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_funding)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.executionType, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.is_buy != false {
            my_size += 2;
        }
        if self.is_liquidation != false {
            my_size += 2;
        }
        if !self.cumulative_funding.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cumulative_funding);
        }
        if self.executionType != super::exchange::ExecutionType::UnspecifiedExecutionType {
            my_size += ::protobuf::rt::enum_size(5, self.executionType);
        }
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.is_buy != false {
            os.write_bool(2, self.is_buy)?;
        }
        if self.is_liquidation != false {
            os.write_bool(3, self.is_liquidation)?;
        }
        if !self.cumulative_funding.is_empty() {
            os.write_string(4, &self.cumulative_funding)?;
        }
        if self.executionType != super::exchange::ExecutionType::UnspecifiedExecutionType {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.executionType))?;
        }
        for v in &self.trades {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventBatchDerivativeExecution {
        EventBatchDerivativeExecution::new()
    }

    fn default_instance() -> &'static EventBatchDerivativeExecution {
        static instance: ::protobuf::rt::LazyV2<EventBatchDerivativeExecution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventBatchDerivativeExecution::new)
    }
}

impl ::protobuf::Clear for EventBatchDerivativeExecution {
    fn clear(&mut self) {
        self.market_id.clear();
        self.is_buy = false;
        self.is_liquidation = false;
        self.cumulative_funding.clear();
        self.executionType = super::exchange::ExecutionType::UnspecifiedExecutionType;
        self.trades.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventBatchDerivativeExecution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventLostFundsFromLiquidation {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub lost_funds_from_available_during_payout: ::std::string::String,
    pub lost_funds_from_order_cancels: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventLostFundsFromLiquidation {
    fn default() -> &'a EventLostFundsFromLiquidation {
        <EventLostFundsFromLiquidation as ::protobuf::Message>::default_instance()
    }
}

impl EventLostFundsFromLiquidation {
    pub fn new() -> EventLostFundsFromLiquidation {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bytes subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // string lost_funds_from_available_during_payout = 3;


    pub fn get_lost_funds_from_available_during_payout(&self) -> &str {
        &self.lost_funds_from_available_during_payout
    }
    pub fn clear_lost_funds_from_available_during_payout(&mut self) {
        self.lost_funds_from_available_during_payout.clear();
    }

    // Param is passed by value, moved
    pub fn set_lost_funds_from_available_during_payout(&mut self, v: ::std::string::String) {
        self.lost_funds_from_available_during_payout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lost_funds_from_available_during_payout(&mut self) -> &mut ::std::string::String {
        &mut self.lost_funds_from_available_during_payout
    }

    // Take field
    pub fn take_lost_funds_from_available_during_payout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lost_funds_from_available_during_payout, ::std::string::String::new())
    }

    // string lost_funds_from_order_cancels = 4;


    pub fn get_lost_funds_from_order_cancels(&self) -> &str {
        &self.lost_funds_from_order_cancels
    }
    pub fn clear_lost_funds_from_order_cancels(&mut self) {
        self.lost_funds_from_order_cancels.clear();
    }

    // Param is passed by value, moved
    pub fn set_lost_funds_from_order_cancels(&mut self, v: ::std::string::String) {
        self.lost_funds_from_order_cancels = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lost_funds_from_order_cancels(&mut self) -> &mut ::std::string::String {
        &mut self.lost_funds_from_order_cancels
    }

    // Take field
    pub fn take_lost_funds_from_order_cancels(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lost_funds_from_order_cancels, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventLostFundsFromLiquidation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lost_funds_from_available_during_payout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lost_funds_from_order_cancels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.subaccount_id);
        }
        if !self.lost_funds_from_available_during_payout.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.lost_funds_from_available_during_payout);
        }
        if !self.lost_funds_from_order_cancels.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.lost_funds_from_order_cancels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_bytes(2, &self.subaccount_id)?;
        }
        if !self.lost_funds_from_available_during_payout.is_empty() {
            os.write_string(3, &self.lost_funds_from_available_during_payout)?;
        }
        if !self.lost_funds_from_order_cancels.is_empty() {
            os.write_string(4, &self.lost_funds_from_order_cancels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventLostFundsFromLiquidation {
        EventLostFundsFromLiquidation::new()
    }

    fn default_instance() -> &'static EventLostFundsFromLiquidation {
        static instance: ::protobuf::rt::LazyV2<EventLostFundsFromLiquidation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventLostFundsFromLiquidation::new)
    }
}

impl ::protobuf::Clear for EventLostFundsFromLiquidation {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.lost_funds_from_available_during_payout.clear();
        self.lost_funds_from_order_cancels.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventLostFundsFromLiquidation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventBatchDerivativePosition {
    // message fields
    pub market_id: ::std::string::String,
    pub positions: ::protobuf::RepeatedField<super::exchange::SubaccountPosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventBatchDerivativePosition {
    fn default() -> &'a EventBatchDerivativePosition {
        <EventBatchDerivativePosition as ::protobuf::Message>::default_instance()
    }
}

impl EventBatchDerivativePosition {
    pub fn new() -> EventBatchDerivativePosition {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.SubaccountPosition positions = 2;


    pub fn get_positions(&self) -> &[super::exchange::SubaccountPosition] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::protobuf::RepeatedField<super::exchange::SubaccountPosition>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SubaccountPosition> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::protobuf::RepeatedField<super::exchange::SubaccountPosition> {
        ::std::mem::replace(&mut self.positions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventBatchDerivativePosition {
    fn is_initialized(&self) -> bool {
        for v in &self.positions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.positions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.positions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventBatchDerivativePosition {
        EventBatchDerivativePosition::new()
    }

    fn default_instance() -> &'static EventBatchDerivativePosition {
        static instance: ::protobuf::rt::LazyV2<EventBatchDerivativePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventBatchDerivativePosition::new)
    }
}

impl ::protobuf::Clear for EventBatchDerivativePosition {
    fn clear(&mut self) {
        self.market_id.clear();
        self.positions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventBatchDerivativePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventDerivativeMarketPaused {
    // message fields
    pub market_id: ::std::string::String,
    pub settle_price: ::std::string::String,
    pub total_missing_funds: ::std::string::String,
    pub missing_funds_rate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventDerivativeMarketPaused {
    fn default() -> &'a EventDerivativeMarketPaused {
        <EventDerivativeMarketPaused as ::protobuf::Message>::default_instance()
    }
}

impl EventDerivativeMarketPaused {
    pub fn new() -> EventDerivativeMarketPaused {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settle_price = 2;


    pub fn get_settle_price(&self) -> &str {
        &self.settle_price
    }
    pub fn clear_settle_price(&mut self) {
        self.settle_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settle_price(&mut self, v: ::std::string::String) {
        self.settle_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settle_price(&mut self) -> &mut ::std::string::String {
        &mut self.settle_price
    }

    // Take field
    pub fn take_settle_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settle_price, ::std::string::String::new())
    }

    // string total_missing_funds = 3;


    pub fn get_total_missing_funds(&self) -> &str {
        &self.total_missing_funds
    }
    pub fn clear_total_missing_funds(&mut self) {
        self.total_missing_funds.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_missing_funds(&mut self, v: ::std::string::String) {
        self.total_missing_funds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_missing_funds(&mut self) -> &mut ::std::string::String {
        &mut self.total_missing_funds
    }

    // Take field
    pub fn take_total_missing_funds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_missing_funds, ::std::string::String::new())
    }

    // string missing_funds_rate = 4;


    pub fn get_missing_funds_rate(&self) -> &str {
        &self.missing_funds_rate
    }
    pub fn clear_missing_funds_rate(&mut self) {
        self.missing_funds_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_missing_funds_rate(&mut self, v: ::std::string::String) {
        self.missing_funds_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_missing_funds_rate(&mut self) -> &mut ::std::string::String {
        &mut self.missing_funds_rate
    }

    // Take field
    pub fn take_missing_funds_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.missing_funds_rate, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventDerivativeMarketPaused {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settle_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_missing_funds)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.missing_funds_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.settle_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.settle_price);
        }
        if !self.total_missing_funds.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.total_missing_funds);
        }
        if !self.missing_funds_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.missing_funds_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            os.write_string(2, &self.settle_price)?;
        }
        if !self.total_missing_funds.is_empty() {
            os.write_string(3, &self.total_missing_funds)?;
        }
        if !self.missing_funds_rate.is_empty() {
            os.write_string(4, &self.missing_funds_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventDerivativeMarketPaused {
        EventDerivativeMarketPaused::new()
    }

    fn default_instance() -> &'static EventDerivativeMarketPaused {
        static instance: ::protobuf::rt::LazyV2<EventDerivativeMarketPaused> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventDerivativeMarketPaused::new)
    }
}

impl ::protobuf::Clear for EventDerivativeMarketPaused {
    fn clear(&mut self) {
        self.market_id.clear();
        self.settle_price.clear();
        self.total_missing_funds.clear();
        self.missing_funds_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventDerivativeMarketPaused {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventMarketBeyondBankruptcy {
    // message fields
    pub market_id: ::std::string::String,
    pub settle_price: ::std::string::String,
    pub missing_market_funds: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventMarketBeyondBankruptcy {
    fn default() -> &'a EventMarketBeyondBankruptcy {
        <EventMarketBeyondBankruptcy as ::protobuf::Message>::default_instance()
    }
}

impl EventMarketBeyondBankruptcy {
    pub fn new() -> EventMarketBeyondBankruptcy {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settle_price = 2;


    pub fn get_settle_price(&self) -> &str {
        &self.settle_price
    }
    pub fn clear_settle_price(&mut self) {
        self.settle_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settle_price(&mut self, v: ::std::string::String) {
        self.settle_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settle_price(&mut self) -> &mut ::std::string::String {
        &mut self.settle_price
    }

    // Take field
    pub fn take_settle_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settle_price, ::std::string::String::new())
    }

    // string missing_market_funds = 3;


    pub fn get_missing_market_funds(&self) -> &str {
        &self.missing_market_funds
    }
    pub fn clear_missing_market_funds(&mut self) {
        self.missing_market_funds.clear();
    }

    // Param is passed by value, moved
    pub fn set_missing_market_funds(&mut self, v: ::std::string::String) {
        self.missing_market_funds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_missing_market_funds(&mut self) -> &mut ::std::string::String {
        &mut self.missing_market_funds
    }

    // Take field
    pub fn take_missing_market_funds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.missing_market_funds, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventMarketBeyondBankruptcy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settle_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.missing_market_funds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.settle_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.settle_price);
        }
        if !self.missing_market_funds.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.missing_market_funds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            os.write_string(2, &self.settle_price)?;
        }
        if !self.missing_market_funds.is_empty() {
            os.write_string(3, &self.missing_market_funds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventMarketBeyondBankruptcy {
        EventMarketBeyondBankruptcy::new()
    }

    fn default_instance() -> &'static EventMarketBeyondBankruptcy {
        static instance: ::protobuf::rt::LazyV2<EventMarketBeyondBankruptcy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventMarketBeyondBankruptcy::new)
    }
}

impl ::protobuf::Clear for EventMarketBeyondBankruptcy {
    fn clear(&mut self) {
        self.market_id.clear();
        self.settle_price.clear();
        self.missing_market_funds.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventMarketBeyondBankruptcy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventAllPositionsHaircut {
    // message fields
    pub market_id: ::std::string::String,
    pub settle_price: ::std::string::String,
    pub missing_funds_rate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventAllPositionsHaircut {
    fn default() -> &'a EventAllPositionsHaircut {
        <EventAllPositionsHaircut as ::protobuf::Message>::default_instance()
    }
}

impl EventAllPositionsHaircut {
    pub fn new() -> EventAllPositionsHaircut {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settle_price = 2;


    pub fn get_settle_price(&self) -> &str {
        &self.settle_price
    }
    pub fn clear_settle_price(&mut self) {
        self.settle_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settle_price(&mut self, v: ::std::string::String) {
        self.settle_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settle_price(&mut self) -> &mut ::std::string::String {
        &mut self.settle_price
    }

    // Take field
    pub fn take_settle_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settle_price, ::std::string::String::new())
    }

    // string missing_funds_rate = 3;


    pub fn get_missing_funds_rate(&self) -> &str {
        &self.missing_funds_rate
    }
    pub fn clear_missing_funds_rate(&mut self) {
        self.missing_funds_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_missing_funds_rate(&mut self, v: ::std::string::String) {
        self.missing_funds_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_missing_funds_rate(&mut self) -> &mut ::std::string::String {
        &mut self.missing_funds_rate
    }

    // Take field
    pub fn take_missing_funds_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.missing_funds_rate, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventAllPositionsHaircut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settle_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.missing_funds_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.settle_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.settle_price);
        }
        if !self.missing_funds_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.missing_funds_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.settle_price.is_empty() {
            os.write_string(2, &self.settle_price)?;
        }
        if !self.missing_funds_rate.is_empty() {
            os.write_string(3, &self.missing_funds_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventAllPositionsHaircut {
        EventAllPositionsHaircut::new()
    }

    fn default_instance() -> &'static EventAllPositionsHaircut {
        static instance: ::protobuf::rt::LazyV2<EventAllPositionsHaircut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventAllPositionsHaircut::new)
    }
}

impl ::protobuf::Clear for EventAllPositionsHaircut {
    fn clear(&mut self) {
        self.market_id.clear();
        self.settle_price.clear();
        self.missing_funds_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventAllPositionsHaircut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventBinaryOptionsMarketUpdate {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::BinaryOptionsMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventBinaryOptionsMarketUpdate {
    fn default() -> &'a EventBinaryOptionsMarketUpdate {
        <EventBinaryOptionsMarketUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventBinaryOptionsMarketUpdate {
    pub fn new() -> EventBinaryOptionsMarketUpdate {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.BinaryOptionsMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::BinaryOptionsMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::BinaryOptionsMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::BinaryOptionsMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::BinaryOptionsMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::BinaryOptionsMarket {
        self.market.take().unwrap_or_else(|| super::exchange::BinaryOptionsMarket::new())
    }
}

impl ::protobuf::Message for EventBinaryOptionsMarketUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventBinaryOptionsMarketUpdate {
        EventBinaryOptionsMarketUpdate::new()
    }

    fn default_instance() -> &'static EventBinaryOptionsMarketUpdate {
        static instance: ::protobuf::rt::LazyV2<EventBinaryOptionsMarketUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventBinaryOptionsMarketUpdate::new)
    }
}

impl ::protobuf::Clear for EventBinaryOptionsMarketUpdate {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventBinaryOptionsMarketUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventNewSpotOrders {
    // message fields
    pub market_id: ::std::string::String,
    pub buy_orders: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>,
    pub sell_orders: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventNewSpotOrders {
    fn default() -> &'a EventNewSpotOrders {
        <EventNewSpotOrders as ::protobuf::Message>::default_instance()
    }
}

impl EventNewSpotOrders {
    pub fn new() -> EventNewSpotOrders {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.SpotLimitOrder buy_orders = 2;


    pub fn get_buy_orders(&self) -> &[super::exchange::SpotLimitOrder] {
        &self.buy_orders
    }
    pub fn clear_buy_orders(&mut self) {
        self.buy_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>) {
        self.buy_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buy_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        &mut self.buy_orders
    }

    // Take field
    pub fn take_buy_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        ::std::mem::replace(&mut self.buy_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SpotLimitOrder sell_orders = 3;


    pub fn get_sell_orders(&self) -> &[super::exchange::SpotLimitOrder] {
        &self.sell_orders
    }
    pub fn clear_sell_orders(&mut self) {
        self.sell_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotLimitOrder>) {
        self.sell_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sell_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        &mut self.sell_orders
    }

    // Take field
    pub fn take_sell_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotLimitOrder> {
        ::std::mem::replace(&mut self.sell_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventNewSpotOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.buy_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sell_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buy_orders)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sell_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.buy_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sell_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.buy_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sell_orders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventNewSpotOrders {
        EventNewSpotOrders::new()
    }

    fn default_instance() -> &'static EventNewSpotOrders {
        static instance: ::protobuf::rt::LazyV2<EventNewSpotOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventNewSpotOrders::new)
    }
}

impl ::protobuf::Clear for EventNewSpotOrders {
    fn clear(&mut self) {
        self.market_id.clear();
        self.buy_orders.clear();
        self.sell_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNewSpotOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventNewDerivativeOrders {
    // message fields
    pub market_id: ::std::string::String,
    pub buy_orders: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>,
    pub sell_orders: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventNewDerivativeOrders {
    fn default() -> &'a EventNewDerivativeOrders {
        <EventNewDerivativeOrders as ::protobuf::Message>::default_instance()
    }
}

impl EventNewDerivativeOrders {
    pub fn new() -> EventNewDerivativeOrders {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeLimitOrder buy_orders = 2;


    pub fn get_buy_orders(&self) -> &[super::exchange::DerivativeLimitOrder] {
        &self.buy_orders
    }
    pub fn clear_buy_orders(&mut self) {
        self.buy_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>) {
        self.buy_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buy_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        &mut self.buy_orders
    }

    // Take field
    pub fn take_buy_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.buy_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeLimitOrder sell_orders = 3;


    pub fn get_sell_orders(&self) -> &[super::exchange::DerivativeLimitOrder] {
        &self.sell_orders
    }
    pub fn clear_sell_orders(&mut self) {
        self.sell_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder>) {
        self.sell_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sell_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        &mut self.sell_orders
    }

    // Take field
    pub fn take_sell_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.sell_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventNewDerivativeOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.buy_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sell_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buy_orders)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sell_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.buy_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sell_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.buy_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sell_orders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventNewDerivativeOrders {
        EventNewDerivativeOrders::new()
    }

    fn default_instance() -> &'static EventNewDerivativeOrders {
        static instance: ::protobuf::rt::LazyV2<EventNewDerivativeOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventNewDerivativeOrders::new)
    }
}

impl ::protobuf::Clear for EventNewDerivativeOrders {
    fn clear(&mut self) {
        self.market_id.clear();
        self.buy_orders.clear();
        self.sell_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNewDerivativeOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventCancelSpotOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::SpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventCancelSpotOrder {
    fn default() -> &'a EventCancelSpotOrder {
        <EventCancelSpotOrder as ::protobuf::Message>::default_instance()
    }
}

impl EventCancelSpotOrder {
    pub fn new() -> EventCancelSpotOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.SpotLimitOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::SpotLimitOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::SpotLimitOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::SpotLimitOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::SpotLimitOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::SpotLimitOrder {
        self.order.take().unwrap_or_else(|| super::exchange::SpotLimitOrder::new())
    }
}

impl ::protobuf::Message for EventCancelSpotOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventCancelSpotOrder {
        EventCancelSpotOrder::new()
    }

    fn default_instance() -> &'static EventCancelSpotOrder {
        static instance: ::protobuf::rt::LazyV2<EventCancelSpotOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventCancelSpotOrder::new)
    }
}

impl ::protobuf::Clear for EventCancelSpotOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventCancelSpotOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSpotMarketUpdate {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::SpotMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSpotMarketUpdate {
    fn default() -> &'a EventSpotMarketUpdate {
        <EventSpotMarketUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventSpotMarketUpdate {
    pub fn new() -> EventSpotMarketUpdate {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.SpotMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::SpotMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::SpotMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::SpotMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::SpotMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::SpotMarket {
        self.market.take().unwrap_or_else(|| super::exchange::SpotMarket::new())
    }
}

impl ::protobuf::Message for EventSpotMarketUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSpotMarketUpdate {
        EventSpotMarketUpdate::new()
    }

    fn default_instance() -> &'static EventSpotMarketUpdate {
        static instance: ::protobuf::rt::LazyV2<EventSpotMarketUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSpotMarketUpdate::new)
    }
}

impl ::protobuf::Clear for EventSpotMarketUpdate {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSpotMarketUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventPerpetualMarketUpdate {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::DerivativeMarket>,
    pub perpetual_market_info: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketInfo>,
    pub funding: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketFunding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventPerpetualMarketUpdate {
    fn default() -> &'a EventPerpetualMarketUpdate {
        <EventPerpetualMarketUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventPerpetualMarketUpdate {
    pub fn new() -> EventPerpetualMarketUpdate {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.DerivativeMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::DerivativeMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::DerivativeMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::DerivativeMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::DerivativeMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::DerivativeMarket {
        self.market.take().unwrap_or_else(|| super::exchange::DerivativeMarket::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketInfo perpetual_market_info = 2;


    pub fn get_perpetual_market_info(&self) -> &super::exchange::PerpetualMarketInfo {
        self.perpetual_market_info.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_perpetual_market_info(&mut self) {
        self.perpetual_market_info.clear();
    }

    pub fn has_perpetual_market_info(&self) -> bool {
        self.perpetual_market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_info(&mut self, v: super::exchange::PerpetualMarketInfo) {
        self.perpetual_market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perpetual_market_info(&mut self) -> &mut super::exchange::PerpetualMarketInfo {
        if self.perpetual_market_info.is_none() {
            self.perpetual_market_info.set_default();
        }
        self.perpetual_market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_perpetual_market_info(&mut self) -> super::exchange::PerpetualMarketInfo {
        self.perpetual_market_info.take().unwrap_or_else(|| super::exchange::PerpetualMarketInfo::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 3;


    pub fn get_funding(&self) -> &super::exchange::PerpetualMarketFunding {
        self.funding.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_funding(&mut self) {
        self.funding.clear();
    }

    pub fn has_funding(&self) -> bool {
        self.funding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_funding(&mut self, v: super::exchange::PerpetualMarketFunding) {
        self.funding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding(&mut self) -> &mut super::exchange::PerpetualMarketFunding {
        if self.funding.is_none() {
            self.funding.set_default();
        }
        self.funding.as_mut().unwrap()
    }

    // Take field
    pub fn take_funding(&mut self) -> super::exchange::PerpetualMarketFunding {
        self.funding.take().unwrap_or_else(|| super::exchange::PerpetualMarketFunding::new())
    }
}

impl ::protobuf::Message for EventPerpetualMarketUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.funding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perpetual_market_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.funding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.perpetual_market_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.funding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.perpetual_market_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.funding.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventPerpetualMarketUpdate {
        EventPerpetualMarketUpdate::new()
    }

    fn default_instance() -> &'static EventPerpetualMarketUpdate {
        static instance: ::protobuf::rt::LazyV2<EventPerpetualMarketUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventPerpetualMarketUpdate::new)
    }
}

impl ::protobuf::Clear for EventPerpetualMarketUpdate {
    fn clear(&mut self) {
        self.market.clear();
        self.perpetual_market_info.clear();
        self.funding.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventPerpetualMarketUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventExpiryFuturesMarketUpdate {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::DerivativeMarket>,
    pub expiry_futures_market_info: ::protobuf::SingularPtrField<super::exchange::ExpiryFuturesMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventExpiryFuturesMarketUpdate {
    fn default() -> &'a EventExpiryFuturesMarketUpdate {
        <EventExpiryFuturesMarketUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventExpiryFuturesMarketUpdate {
    pub fn new() -> EventExpiryFuturesMarketUpdate {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.DerivativeMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::DerivativeMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::DerivativeMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::DerivativeMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::DerivativeMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::DerivativeMarket {
        self.market.take().unwrap_or_else(|| super::exchange::DerivativeMarket::new())
    }

    // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo expiry_futures_market_info = 3;


    pub fn get_expiry_futures_market_info(&self) -> &super::exchange::ExpiryFuturesMarketInfo {
        self.expiry_futures_market_info.as_ref().unwrap_or_else(|| <super::exchange::ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expiry_futures_market_info(&mut self) {
        self.expiry_futures_market_info.clear();
    }

    pub fn has_expiry_futures_market_info(&self) -> bool {
        self.expiry_futures_market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_futures_market_info(&mut self, v: super::exchange::ExpiryFuturesMarketInfo) {
        self.expiry_futures_market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiry_futures_market_info(&mut self) -> &mut super::exchange::ExpiryFuturesMarketInfo {
        if self.expiry_futures_market_info.is_none() {
            self.expiry_futures_market_info.set_default();
        }
        self.expiry_futures_market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiry_futures_market_info(&mut self) -> super::exchange::ExpiryFuturesMarketInfo {
        self.expiry_futures_market_info.take().unwrap_or_else(|| super::exchange::ExpiryFuturesMarketInfo::new())
    }
}

impl ::protobuf::Message for EventExpiryFuturesMarketUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiry_futures_market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiry_futures_market_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expiry_futures_market_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expiry_futures_market_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventExpiryFuturesMarketUpdate {
        EventExpiryFuturesMarketUpdate::new()
    }

    fn default_instance() -> &'static EventExpiryFuturesMarketUpdate {
        static instance: ::protobuf::rt::LazyV2<EventExpiryFuturesMarketUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventExpiryFuturesMarketUpdate::new)
    }
}

impl ::protobuf::Clear for EventExpiryFuturesMarketUpdate {
    fn clear(&mut self) {
        self.market.clear();
        self.expiry_futures_market_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventExpiryFuturesMarketUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventPerpetualMarketFundingUpdate {
    // message fields
    pub market_id: ::std::string::String,
    pub funding: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketFunding>,
    pub is_hourly_funding: bool,
    pub funding_rate: ::std::string::String,
    pub mark_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventPerpetualMarketFundingUpdate {
    fn default() -> &'a EventPerpetualMarketFundingUpdate {
        <EventPerpetualMarketFundingUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventPerpetualMarketFundingUpdate {
    pub fn new() -> EventPerpetualMarketFundingUpdate {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding funding = 2;


    pub fn get_funding(&self) -> &super::exchange::PerpetualMarketFunding {
        self.funding.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_funding(&mut self) {
        self.funding.clear();
    }

    pub fn has_funding(&self) -> bool {
        self.funding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_funding(&mut self, v: super::exchange::PerpetualMarketFunding) {
        self.funding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding(&mut self) -> &mut super::exchange::PerpetualMarketFunding {
        if self.funding.is_none() {
            self.funding.set_default();
        }
        self.funding.as_mut().unwrap()
    }

    // Take field
    pub fn take_funding(&mut self) -> super::exchange::PerpetualMarketFunding {
        self.funding.take().unwrap_or_else(|| super::exchange::PerpetualMarketFunding::new())
    }

    // bool is_hourly_funding = 3;


    pub fn get_is_hourly_funding(&self) -> bool {
        self.is_hourly_funding
    }
    pub fn clear_is_hourly_funding(&mut self) {
        self.is_hourly_funding = false;
    }

    // Param is passed by value, moved
    pub fn set_is_hourly_funding(&mut self, v: bool) {
        self.is_hourly_funding = v;
    }

    // string funding_rate = 4;


    pub fn get_funding_rate(&self) -> &str {
        &self.funding_rate
    }
    pub fn clear_funding_rate(&mut self) {
        self.funding_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_funding_rate(&mut self, v: ::std::string::String) {
        self.funding_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding_rate(&mut self) -> &mut ::std::string::String {
        &mut self.funding_rate
    }

    // Take field
    pub fn take_funding_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.funding_rate, ::std::string::String::new())
    }

    // string mark_price = 5;


    pub fn get_mark_price(&self) -> &str {
        &self.mark_price
    }
    pub fn clear_mark_price(&mut self) {
        self.mark_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mark_price(&mut self, v: ::std::string::String) {
        self.mark_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mark_price(&mut self) -> &mut ::std::string::String {
        &mut self.mark_price
    }

    // Take field
    pub fn take_mark_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mark_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventPerpetualMarketFundingUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.funding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.funding)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_hourly_funding = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.funding_rate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mark_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.funding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_hourly_funding != false {
            my_size += 2;
        }
        if !self.funding_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.funding_rate);
        }
        if !self.mark_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mark_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.funding.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_hourly_funding != false {
            os.write_bool(3, self.is_hourly_funding)?;
        }
        if !self.funding_rate.is_empty() {
            os.write_string(4, &self.funding_rate)?;
        }
        if !self.mark_price.is_empty() {
            os.write_string(5, &self.mark_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventPerpetualMarketFundingUpdate {
        EventPerpetualMarketFundingUpdate::new()
    }

    fn default_instance() -> &'static EventPerpetualMarketFundingUpdate {
        static instance: ::protobuf::rt::LazyV2<EventPerpetualMarketFundingUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventPerpetualMarketFundingUpdate::new)
    }
}

impl ::protobuf::Clear for EventPerpetualMarketFundingUpdate {
    fn clear(&mut self) {
        self.market_id.clear();
        self.funding.clear();
        self.is_hourly_funding = false;
        self.funding_rate.clear();
        self.mark_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventPerpetualMarketFundingUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSubaccountDeposit {
    // message fields
    pub src_address: ::std::string::String,
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSubaccountDeposit {
    fn default() -> &'a EventSubaccountDeposit {
        <EventSubaccountDeposit as ::protobuf::Message>::default_instance()
    }
}

impl EventSubaccountDeposit {
    pub fn new() -> EventSubaccountDeposit {
        ::std::default::Default::default()
    }

    // string src_address = 1;


    pub fn get_src_address(&self) -> &str {
        &self.src_address
    }
    pub fn clear_src_address(&mut self) {
        self.src_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_address(&mut self, v: ::std::string::String) {
        self.src_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_address(&mut self) -> &mut ::std::string::String {
        &mut self.src_address
    }

    // Take field
    pub fn take_src_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_address, ::std::string::String::new())
    }

    // bytes subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for EventSubaccountDeposit {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.src_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.src_address);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.src_address.is_empty() {
            os.write_string(1, &self.src_address)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_bytes(2, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSubaccountDeposit {
        EventSubaccountDeposit::new()
    }

    fn default_instance() -> &'static EventSubaccountDeposit {
        static instance: ::protobuf::rt::LazyV2<EventSubaccountDeposit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSubaccountDeposit::new)
    }
}

impl ::protobuf::Clear for EventSubaccountDeposit {
    fn clear(&mut self) {
        self.src_address.clear();
        self.subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSubaccountDeposit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSubaccountWithdraw {
    // message fields
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub dst_address: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSubaccountWithdraw {
    fn default() -> &'a EventSubaccountWithdraw {
        <EventSubaccountWithdraw as ::protobuf::Message>::default_instance()
    }
}

impl EventSubaccountWithdraw {
    pub fn new() -> EventSubaccountWithdraw {
        ::std::default::Default::default()
    }

    // bytes subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // string dst_address = 2;


    pub fn get_dst_address(&self) -> &str {
        &self.dst_address
    }
    pub fn clear_dst_address(&mut self) {
        self.dst_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_address(&mut self, v: ::std::string::String) {
        self.dst_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_address(&mut self) -> &mut ::std::string::String {
        &mut self.dst_address
    }

    // Take field
    pub fn take_dst_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_address, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for EventSubaccountWithdraw {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.subaccount_id);
        }
        if !self.dst_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dst_address);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_bytes(1, &self.subaccount_id)?;
        }
        if !self.dst_address.is_empty() {
            os.write_string(2, &self.dst_address)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSubaccountWithdraw {
        EventSubaccountWithdraw::new()
    }

    fn default_instance() -> &'static EventSubaccountWithdraw {
        static instance: ::protobuf::rt::LazyV2<EventSubaccountWithdraw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSubaccountWithdraw::new)
    }
}

impl ::protobuf::Clear for EventSubaccountWithdraw {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.dst_address.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSubaccountWithdraw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventSubaccountBalanceTransfer {
    // message fields
    pub src_subaccount_id: ::std::string::String,
    pub dst_subaccount_id: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSubaccountBalanceTransfer {
    fn default() -> &'a EventSubaccountBalanceTransfer {
        <EventSubaccountBalanceTransfer as ::protobuf::Message>::default_instance()
    }
}

impl EventSubaccountBalanceTransfer {
    pub fn new() -> EventSubaccountBalanceTransfer {
        ::std::default::Default::default()
    }

    // string src_subaccount_id = 1;


    pub fn get_src_subaccount_id(&self) -> &str {
        &self.src_subaccount_id
    }
    pub fn clear_src_subaccount_id(&mut self) {
        self.src_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_subaccount_id(&mut self, v: ::std::string::String) {
        self.src_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.src_subaccount_id
    }

    // Take field
    pub fn take_src_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_subaccount_id, ::std::string::String::new())
    }

    // string dst_subaccount_id = 2;


    pub fn get_dst_subaccount_id(&self) -> &str {
        &self.dst_subaccount_id
    }
    pub fn clear_dst_subaccount_id(&mut self) {
        self.dst_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_subaccount_id(&mut self, v: ::std::string::String) {
        self.dst_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.dst_subaccount_id
    }

    // Take field
    pub fn take_dst_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_subaccount_id, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for EventSubaccountBalanceTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.src_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.src_subaccount_id);
        }
        if !self.dst_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dst_subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.src_subaccount_id.is_empty() {
            os.write_string(1, &self.src_subaccount_id)?;
        }
        if !self.dst_subaccount_id.is_empty() {
            os.write_string(2, &self.dst_subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSubaccountBalanceTransfer {
        EventSubaccountBalanceTransfer::new()
    }

    fn default_instance() -> &'static EventSubaccountBalanceTransfer {
        static instance: ::protobuf::rt::LazyV2<EventSubaccountBalanceTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSubaccountBalanceTransfer::new)
    }
}

impl ::protobuf::Clear for EventSubaccountBalanceTransfer {
    fn clear(&mut self) {
        self.src_subaccount_id.clear();
        self.dst_subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSubaccountBalanceTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventBatchDepositUpdate {
    // message fields
    pub deposit_updates: ::protobuf::RepeatedField<super::exchange::DepositUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventBatchDepositUpdate {
    fn default() -> &'a EventBatchDepositUpdate {
        <EventBatchDepositUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventBatchDepositUpdate {
    pub fn new() -> EventBatchDepositUpdate {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.DepositUpdate deposit_updates = 1;


    pub fn get_deposit_updates(&self) -> &[super::exchange::DepositUpdate] {
        &self.deposit_updates
    }
    pub fn clear_deposit_updates(&mut self) {
        self.deposit_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposit_updates(&mut self, v: ::protobuf::RepeatedField<super::exchange::DepositUpdate>) {
        self.deposit_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deposit_updates(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DepositUpdate> {
        &mut self.deposit_updates
    }

    // Take field
    pub fn take_deposit_updates(&mut self) -> ::protobuf::RepeatedField<super::exchange::DepositUpdate> {
        ::std::mem::replace(&mut self.deposit_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventBatchDepositUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.deposit_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deposit_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.deposit_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.deposit_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventBatchDepositUpdate {
        EventBatchDepositUpdate::new()
    }

    fn default_instance() -> &'static EventBatchDepositUpdate {
        static instance: ::protobuf::rt::LazyV2<EventBatchDepositUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventBatchDepositUpdate::new)
    }
}

impl ::protobuf::Clear for EventBatchDepositUpdate {
    fn clear(&mut self) {
        self.deposit_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventBatchDepositUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketOrderCancel {
    // message fields
    pub market_order: ::protobuf::SingularPtrField<super::exchange::DerivativeMarketOrder>,
    pub cancel_quantity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketOrderCancel {
    fn default() -> &'a DerivativeMarketOrderCancel {
        <DerivativeMarketOrderCancel as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketOrderCancel {
    pub fn new() -> DerivativeMarketOrderCancel {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 1;


    pub fn get_market_order(&self) -> &super::exchange::DerivativeMarketOrder {
        self.market_order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeMarketOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market_order(&mut self) {
        self.market_order.clear();
    }

    pub fn has_market_order(&self) -> bool {
        self.market_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market_order(&mut self, v: super::exchange::DerivativeMarketOrder) {
        self.market_order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_order(&mut self) -> &mut super::exchange::DerivativeMarketOrder {
        if self.market_order.is_none() {
            self.market_order.set_default();
        }
        self.market_order.as_mut().unwrap()
    }

    // Take field
    pub fn take_market_order(&mut self) -> super::exchange::DerivativeMarketOrder {
        self.market_order.take().unwrap_or_else(|| super::exchange::DerivativeMarketOrder::new())
    }

    // string cancel_quantity = 2;


    pub fn get_cancel_quantity(&self) -> &str {
        &self.cancel_quantity
    }
    pub fn clear_cancel_quantity(&mut self) {
        self.cancel_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_cancel_quantity(&mut self, v: ::std::string::String) {
        self.cancel_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.cancel_quantity
    }

    // Take field
    pub fn take_cancel_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cancel_quantity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeMarketOrderCancel {
    fn is_initialized(&self) -> bool {
        for v in &self.market_order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market_order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cancel_quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cancel_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cancel_quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market_order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cancel_quantity.is_empty() {
            os.write_string(2, &self.cancel_quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketOrderCancel {
        DerivativeMarketOrderCancel::new()
    }

    fn default_instance() -> &'static DerivativeMarketOrderCancel {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketOrderCancel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketOrderCancel::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketOrderCancel {
    fn clear(&mut self) {
        self.market_order.clear();
        self.cancel_quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketOrderCancel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventCancelDerivativeOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub isLimitCancel: bool,
    pub limit_order: ::protobuf::SingularPtrField<super::exchange::DerivativeLimitOrder>,
    pub market_order_cancel: ::protobuf::SingularPtrField<DerivativeMarketOrderCancel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventCancelDerivativeOrder {
    fn default() -> &'a EventCancelDerivativeOrder {
        <EventCancelDerivativeOrder as ::protobuf::Message>::default_instance()
    }
}

impl EventCancelDerivativeOrder {
    pub fn new() -> EventCancelDerivativeOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isLimitCancel = 2;


    pub fn get_isLimitCancel(&self) -> bool {
        self.isLimitCancel
    }
    pub fn clear_isLimitCancel(&mut self) {
        self.isLimitCancel = false;
    }

    // Param is passed by value, moved
    pub fn set_isLimitCancel(&mut self, v: bool) {
        self.isLimitCancel = v;
    }

    // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3;


    pub fn get_limit_order(&self) -> &super::exchange::DerivativeLimitOrder {
        self.limit_order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeLimitOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limit_order(&mut self) {
        self.limit_order.clear();
    }

    pub fn has_limit_order(&self) -> bool {
        self.limit_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit_order(&mut self, v: super::exchange::DerivativeLimitOrder) {
        self.limit_order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit_order(&mut self) -> &mut super::exchange::DerivativeLimitOrder {
        if self.limit_order.is_none() {
            self.limit_order.set_default();
        }
        self.limit_order.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit_order(&mut self) -> super::exchange::DerivativeLimitOrder {
        self.limit_order.take().unwrap_or_else(|| super::exchange::DerivativeLimitOrder::new())
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrderCancel market_order_cancel = 4;


    pub fn get_market_order_cancel(&self) -> &DerivativeMarketOrderCancel {
        self.market_order_cancel.as_ref().unwrap_or_else(|| <DerivativeMarketOrderCancel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market_order_cancel(&mut self) {
        self.market_order_cancel.clear();
    }

    pub fn has_market_order_cancel(&self) -> bool {
        self.market_order_cancel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market_order_cancel(&mut self, v: DerivativeMarketOrderCancel) {
        self.market_order_cancel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_order_cancel(&mut self) -> &mut DerivativeMarketOrderCancel {
        if self.market_order_cancel.is_none() {
            self.market_order_cancel.set_default();
        }
        self.market_order_cancel.as_mut().unwrap()
    }

    // Take field
    pub fn take_market_order_cancel(&mut self) -> DerivativeMarketOrderCancel {
        self.market_order_cancel.take().unwrap_or_else(|| DerivativeMarketOrderCancel::new())
    }
}

impl ::protobuf::Message for EventCancelDerivativeOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.limit_order {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_order_cancel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLimitCancel = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit_order)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market_order_cancel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.isLimitCancel != false {
            my_size += 2;
        }
        if let Some(ref v) = self.limit_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.market_order_cancel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.isLimitCancel != false {
            os.write_bool(2, self.isLimitCancel)?;
        }
        if let Some(ref v) = self.limit_order.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.market_order_cancel.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventCancelDerivativeOrder {
        EventCancelDerivativeOrder::new()
    }

    fn default_instance() -> &'static EventCancelDerivativeOrder {
        static instance: ::protobuf::rt::LazyV2<EventCancelDerivativeOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventCancelDerivativeOrder::new)
    }
}

impl ::protobuf::Clear for EventCancelDerivativeOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isLimitCancel = false;
        self.limit_order.clear();
        self.market_order_cancel.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventCancelDerivativeOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventFeeDiscountSchedule {
    // message fields
    pub schedule: ::protobuf::SingularPtrField<super::exchange::FeeDiscountSchedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventFeeDiscountSchedule {
    fn default() -> &'a EventFeeDiscountSchedule {
        <EventFeeDiscountSchedule as ::protobuf::Message>::default_instance()
    }
}

impl EventFeeDiscountSchedule {
    pub fn new() -> EventFeeDiscountSchedule {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 1;


    pub fn get_schedule(&self) -> &super::exchange::FeeDiscountSchedule {
        self.schedule.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schedule(&mut self) {
        self.schedule.clear();
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: super::exchange::FeeDiscountSchedule) {
        self.schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut super::exchange::FeeDiscountSchedule {
        if self.schedule.is_none() {
            self.schedule.set_default();
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> super::exchange::FeeDiscountSchedule {
        self.schedule.take().unwrap_or_else(|| super::exchange::FeeDiscountSchedule::new())
    }
}

impl ::protobuf::Message for EventFeeDiscountSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.schedule.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventFeeDiscountSchedule {
        EventFeeDiscountSchedule::new()
    }

    fn default_instance() -> &'static EventFeeDiscountSchedule {
        static instance: ::protobuf::rt::LazyV2<EventFeeDiscountSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventFeeDiscountSchedule::new)
    }
}

impl ::protobuf::Clear for EventFeeDiscountSchedule {
    fn clear(&mut self) {
        self.schedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventFeeDiscountSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventTradingRewardCampaignUpdate {
    // message fields
    pub campaign_info: ::protobuf::SingularPtrField<super::exchange::TradingRewardCampaignInfo>,
    pub campaign_reward_pools: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventTradingRewardCampaignUpdate {
    fn default() -> &'a EventTradingRewardCampaignUpdate {
        <EventTradingRewardCampaignUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventTradingRewardCampaignUpdate {
    pub fn new() -> EventTradingRewardCampaignUpdate {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 1;


    pub fn get_campaign_info(&self) -> &super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.as_ref().unwrap_or_else(|| <super::exchange::TradingRewardCampaignInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_campaign_info(&mut self) {
        self.campaign_info.clear();
    }

    pub fn has_campaign_info(&self) -> bool {
        self.campaign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_info(&mut self, v: super::exchange::TradingRewardCampaignInfo) {
        self.campaign_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_campaign_info(&mut self) -> &mut super::exchange::TradingRewardCampaignInfo {
        if self.campaign_info.is_none() {
            self.campaign_info.set_default();
        }
        self.campaign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_campaign_info(&mut self) -> super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.take().unwrap_or_else(|| super::exchange::TradingRewardCampaignInfo::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 2;


    pub fn get_campaign_reward_pools(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.campaign_reward_pools
    }
    pub fn clear_campaign_reward_pools(&mut self) {
        self.campaign_reward_pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_campaign_reward_pools(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.campaign_reward_pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_campaign_reward_pools(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.campaign_reward_pools
    }

    // Take field
    pub fn take_campaign_reward_pools(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.campaign_reward_pools, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventTradingRewardCampaignUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.campaign_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.campaign_reward_pools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.campaign_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.campaign_reward_pools)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.campaign_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.campaign_reward_pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.campaign_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.campaign_reward_pools {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventTradingRewardCampaignUpdate {
        EventTradingRewardCampaignUpdate::new()
    }

    fn default_instance() -> &'static EventTradingRewardCampaignUpdate {
        static instance: ::protobuf::rt::LazyV2<EventTradingRewardCampaignUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventTradingRewardCampaignUpdate::new)
    }
}

impl ::protobuf::Clear for EventTradingRewardCampaignUpdate {
    fn clear(&mut self) {
        self.campaign_info.clear();
        self.campaign_reward_pools.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTradingRewardCampaignUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventTradingRewardDistribution {
    // message fields
    pub account_rewards: ::protobuf::RepeatedField<super::exchange::AccountRewards>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventTradingRewardDistribution {
    fn default() -> &'a EventTradingRewardDistribution {
        <EventTradingRewardDistribution as ::protobuf::Message>::default_instance()
    }
}

impl EventTradingRewardDistribution {
    pub fn new() -> EventTradingRewardDistribution {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.AccountRewards account_rewards = 1;


    pub fn get_account_rewards(&self) -> &[super::exchange::AccountRewards] {
        &self.account_rewards
    }
    pub fn clear_account_rewards(&mut self) {
        self.account_rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_rewards(&mut self, v: ::protobuf::RepeatedField<super::exchange::AccountRewards>) {
        self.account_rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_rewards(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::AccountRewards> {
        &mut self.account_rewards
    }

    // Take field
    pub fn take_account_rewards(&mut self) -> ::protobuf::RepeatedField<super::exchange::AccountRewards> {
        ::std::mem::replace(&mut self.account_rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventTradingRewardDistribution {
    fn is_initialized(&self) -> bool {
        for v in &self.account_rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account_rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_rewards {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventTradingRewardDistribution {
        EventTradingRewardDistribution::new()
    }

    fn default_instance() -> &'static EventTradingRewardDistribution {
        static instance: ::protobuf::rt::LazyV2<EventTradingRewardDistribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventTradingRewardDistribution::new)
    }
}

impl ::protobuf::Clear for EventTradingRewardDistribution {
    fn clear(&mut self) {
        self.account_rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTradingRewardDistribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventNewConditionalDerivativeOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    pub hash: ::std::vec::Vec<u8>,
    pub is_market: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventNewConditionalDerivativeOrder {
    fn default() -> &'a EventNewConditionalDerivativeOrder {
        <EventNewConditionalDerivativeOrder as ::protobuf::Message>::default_instance()
    }
}

impl EventNewConditionalDerivativeOrder {
    pub fn new() -> EventNewConditionalDerivativeOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }

    // bytes hash = 3;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bool is_market = 4;


    pub fn get_is_market(&self) -> bool {
        self.is_market
    }
    pub fn clear_is_market(&mut self) {
        self.is_market = false;
    }

    // Param is passed by value, moved
    pub fn set_is_market(&mut self, v: bool) {
        self.is_market = v;
    }
}

impl ::protobuf::Message for EventNewConditionalDerivativeOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_market = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash);
        }
        if self.is_market != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(3, &self.hash)?;
        }
        if self.is_market != false {
            os.write_bool(4, self.is_market)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventNewConditionalDerivativeOrder {
        EventNewConditionalDerivativeOrder::new()
    }

    fn default_instance() -> &'static EventNewConditionalDerivativeOrder {
        static instance: ::protobuf::rt::LazyV2<EventNewConditionalDerivativeOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventNewConditionalDerivativeOrder::new)
    }
}

impl ::protobuf::Clear for EventNewConditionalDerivativeOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order.clear();
        self.hash.clear();
        self.is_market = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNewConditionalDerivativeOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventCancelConditionalDerivativeOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub isLimitCancel: bool,
    pub limit_order: ::protobuf::SingularPtrField<super::exchange::DerivativeLimitOrder>,
    pub market_order: ::protobuf::SingularPtrField<super::exchange::DerivativeMarketOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventCancelConditionalDerivativeOrder {
    fn default() -> &'a EventCancelConditionalDerivativeOrder {
        <EventCancelConditionalDerivativeOrder as ::protobuf::Message>::default_instance()
    }
}

impl EventCancelConditionalDerivativeOrder {
    pub fn new() -> EventCancelConditionalDerivativeOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isLimitCancel = 2;


    pub fn get_isLimitCancel(&self) -> bool {
        self.isLimitCancel
    }
    pub fn clear_isLimitCancel(&mut self) {
        self.isLimitCancel = false;
    }

    // Param is passed by value, moved
    pub fn set_isLimitCancel(&mut self, v: bool) {
        self.isLimitCancel = v;
    }

    // .injective.exchange.v1beta1.DerivativeLimitOrder limit_order = 3;


    pub fn get_limit_order(&self) -> &super::exchange::DerivativeLimitOrder {
        self.limit_order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeLimitOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limit_order(&mut self) {
        self.limit_order.clear();
    }

    pub fn has_limit_order(&self) -> bool {
        self.limit_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit_order(&mut self, v: super::exchange::DerivativeLimitOrder) {
        self.limit_order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit_order(&mut self) -> &mut super::exchange::DerivativeLimitOrder {
        if self.limit_order.is_none() {
            self.limit_order.set_default();
        }
        self.limit_order.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit_order(&mut self) -> super::exchange::DerivativeLimitOrder {
        self.limit_order.take().unwrap_or_else(|| super::exchange::DerivativeLimitOrder::new())
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrder market_order = 4;


    pub fn get_market_order(&self) -> &super::exchange::DerivativeMarketOrder {
        self.market_order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeMarketOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market_order(&mut self) {
        self.market_order.clear();
    }

    pub fn has_market_order(&self) -> bool {
        self.market_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market_order(&mut self, v: super::exchange::DerivativeMarketOrder) {
        self.market_order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_order(&mut self) -> &mut super::exchange::DerivativeMarketOrder {
        if self.market_order.is_none() {
            self.market_order.set_default();
        }
        self.market_order.as_mut().unwrap()
    }

    // Take field
    pub fn take_market_order(&mut self) -> super::exchange::DerivativeMarketOrder {
        self.market_order.take().unwrap_or_else(|| super::exchange::DerivativeMarketOrder::new())
    }
}

impl ::protobuf::Message for EventCancelConditionalDerivativeOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.limit_order {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.market_order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLimitCancel = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit_order)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market_order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.isLimitCancel != false {
            my_size += 2;
        }
        if let Some(ref v) = self.limit_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.market_order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.isLimitCancel != false {
            os.write_bool(2, self.isLimitCancel)?;
        }
        if let Some(ref v) = self.limit_order.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.market_order.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventCancelConditionalDerivativeOrder {
        EventCancelConditionalDerivativeOrder::new()
    }

    fn default_instance() -> &'static EventCancelConditionalDerivativeOrder {
        static instance: ::protobuf::rt::LazyV2<EventCancelConditionalDerivativeOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventCancelConditionalDerivativeOrder::new)
    }
}

impl ::protobuf::Clear for EventCancelConditionalDerivativeOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isLimitCancel = false;
        self.limit_order.clear();
        self.market_order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventCancelConditionalDerivativeOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventConditionalDerivativeOrderTrigger {
    // message fields
    pub market_id: ::std::vec::Vec<u8>,
    pub isLimitTrigger: bool,
    pub triggered_order_hash: ::std::vec::Vec<u8>,
    pub placed_order_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventConditionalDerivativeOrderTrigger {
    fn default() -> &'a EventConditionalDerivativeOrderTrigger {
        <EventConditionalDerivativeOrderTrigger as ::protobuf::Message>::default_instance()
    }
}

impl EventConditionalDerivativeOrderTrigger {
    pub fn new() -> EventConditionalDerivativeOrderTrigger {
        ::std::default::Default::default()
    }

    // bytes market_id = 1;


    pub fn get_market_id(&self) -> &[u8] {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.market_id, ::std::vec::Vec::new())
    }

    // bool isLimitTrigger = 2;


    pub fn get_isLimitTrigger(&self) -> bool {
        self.isLimitTrigger
    }
    pub fn clear_isLimitTrigger(&mut self) {
        self.isLimitTrigger = false;
    }

    // Param is passed by value, moved
    pub fn set_isLimitTrigger(&mut self, v: bool) {
        self.isLimitTrigger = v;
    }

    // bytes triggered_order_hash = 3;


    pub fn get_triggered_order_hash(&self) -> &[u8] {
        &self.triggered_order_hash
    }
    pub fn clear_triggered_order_hash(&mut self) {
        self.triggered_order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_triggered_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.triggered_order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_triggered_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.triggered_order_hash
    }

    // Take field
    pub fn take_triggered_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.triggered_order_hash, ::std::vec::Vec::new())
    }

    // bytes placed_order_hash = 4;


    pub fn get_placed_order_hash(&self) -> &[u8] {
        &self.placed_order_hash
    }
    pub fn clear_placed_order_hash(&mut self) {
        self.placed_order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_placed_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.placed_order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placed_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.placed_order_hash
    }

    // Take field
    pub fn take_placed_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.placed_order_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EventConditionalDerivativeOrderTrigger {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLimitTrigger = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.triggered_order_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.placed_order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.market_id);
        }
        if self.isLimitTrigger != false {
            my_size += 2;
        }
        if !self.triggered_order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.triggered_order_hash);
        }
        if !self.placed_order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.placed_order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_bytes(1, &self.market_id)?;
        }
        if self.isLimitTrigger != false {
            os.write_bool(2, self.isLimitTrigger)?;
        }
        if !self.triggered_order_hash.is_empty() {
            os.write_bytes(3, &self.triggered_order_hash)?;
        }
        if !self.placed_order_hash.is_empty() {
            os.write_bytes(4, &self.placed_order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventConditionalDerivativeOrderTrigger {
        EventConditionalDerivativeOrderTrigger::new()
    }

    fn default_instance() -> &'static EventConditionalDerivativeOrderTrigger {
        static instance: ::protobuf::rt::LazyV2<EventConditionalDerivativeOrderTrigger> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventConditionalDerivativeOrderTrigger::new)
    }
}

impl ::protobuf::Clear for EventConditionalDerivativeOrderTrigger {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isLimitTrigger = false;
        self.triggered_order_hash.clear();
        self.placed_order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventConditionalDerivativeOrderTrigger {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventOrderFail {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub hashes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub flags: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventOrderFail {
    fn default() -> &'a EventOrderFail {
        <EventOrderFail as ::protobuf::Message>::default_instance()
    }
}

impl EventOrderFail {
    pub fn new() -> EventOrderFail {
        ::std::default::Default::default()
    }

    // bytes account = 1;


    pub fn get_account(&self) -> &[u8] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    // repeated bytes hashes = 2;


    pub fn get_hashes(&self) -> &[::std::vec::Vec<u8>] {
        &self.hashes
    }
    pub fn clear_hashes(&mut self) {
        self.hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_hashes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hashes
    }

    // Take field
    pub fn take_hashes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hashes, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 flags = 3;


    pub fn get_flags(&self) -> &[u32] {
        &self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<u32>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EventOrderFail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hashes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.flags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        for value in &self.hashes {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.flags {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        for v in &self.hashes {
            os.write_bytes(2, &v)?;
        };
        for v in &self.flags {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventOrderFail {
        EventOrderFail::new()
    }

    fn default_instance() -> &'static EventOrderFail {
        static instance: ::protobuf::rt::LazyV2<EventOrderFail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventOrderFail::new)
    }
}

impl ::protobuf::Clear for EventOrderFail {
    fn clear(&mut self) {
        self.account.clear();
        self.hashes.clear();
        self.flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventOrderFail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventAtomicMarketOrderFeeMultipliersUpdated {
    // message fields
    pub market_fee_multipliers: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventAtomicMarketOrderFeeMultipliersUpdated {
    fn default() -> &'a EventAtomicMarketOrderFeeMultipliersUpdated {
        <EventAtomicMarketOrderFeeMultipliersUpdated as ::protobuf::Message>::default_instance()
    }
}

impl EventAtomicMarketOrderFeeMultipliersUpdated {
    pub fn new() -> EventAtomicMarketOrderFeeMultipliersUpdated {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 1;


    pub fn get_market_fee_multipliers(&self) -> &[super::exchange::MarketFeeMultiplier] {
        &self.market_fee_multipliers
    }
    pub fn clear_market_fee_multipliers(&mut self) {
        self.market_fee_multipliers.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_fee_multipliers(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>) {
        self.market_fee_multipliers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_fee_multipliers(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        &mut self.market_fee_multipliers
    }

    // Take field
    pub fn take_market_fee_multipliers(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        ::std::mem::replace(&mut self.market_fee_multipliers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventAtomicMarketOrderFeeMultipliersUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.market_fee_multipliers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_fee_multipliers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_fee_multipliers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_fee_multipliers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventAtomicMarketOrderFeeMultipliersUpdated {
        EventAtomicMarketOrderFeeMultipliersUpdated::new()
    }

    fn default_instance() -> &'static EventAtomicMarketOrderFeeMultipliersUpdated {
        static instance: ::protobuf::rt::LazyV2<EventAtomicMarketOrderFeeMultipliersUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventAtomicMarketOrderFeeMultipliersUpdated::new)
    }
}

impl ::protobuf::Clear for EventAtomicMarketOrderFeeMultipliersUpdated {
    fn clear(&mut self) {
        self.market_fee_multipliers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventAtomicMarketOrderFeeMultipliersUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventOrderbookUpdate {
    // message fields
    pub spot_updates: ::protobuf::RepeatedField<OrderbookUpdate>,
    pub derivative_updates: ::protobuf::RepeatedField<OrderbookUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventOrderbookUpdate {
    fn default() -> &'a EventOrderbookUpdate {
        <EventOrderbookUpdate as ::protobuf::Message>::default_instance()
    }
}

impl EventOrderbookUpdate {
    pub fn new() -> EventOrderbookUpdate {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.OrderbookUpdate spot_updates = 1;


    pub fn get_spot_updates(&self) -> &[OrderbookUpdate] {
        &self.spot_updates
    }
    pub fn clear_spot_updates(&mut self) {
        self.spot_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_updates(&mut self, v: ::protobuf::RepeatedField<OrderbookUpdate>) {
        self.spot_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_updates(&mut self) -> &mut ::protobuf::RepeatedField<OrderbookUpdate> {
        &mut self.spot_updates
    }

    // Take field
    pub fn take_spot_updates(&mut self) -> ::protobuf::RepeatedField<OrderbookUpdate> {
        ::std::mem::replace(&mut self.spot_updates, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.OrderbookUpdate derivative_updates = 2;


    pub fn get_derivative_updates(&self) -> &[OrderbookUpdate] {
        &self.derivative_updates
    }
    pub fn clear_derivative_updates(&mut self) {
        self.derivative_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_updates(&mut self, v: ::protobuf::RepeatedField<OrderbookUpdate>) {
        self.derivative_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_updates(&mut self) -> &mut ::protobuf::RepeatedField<OrderbookUpdate> {
        &mut self.derivative_updates
    }

    // Take field
    pub fn take_derivative_updates(&mut self) -> ::protobuf::RepeatedField<OrderbookUpdate> {
        ::std::mem::replace(&mut self.derivative_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventOrderbookUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.spot_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spot_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventOrderbookUpdate {
        EventOrderbookUpdate::new()
    }

    fn default_instance() -> &'static EventOrderbookUpdate {
        static instance: ::protobuf::rt::LazyV2<EventOrderbookUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventOrderbookUpdate::new)
    }
}

impl ::protobuf::Clear for EventOrderbookUpdate {
    fn clear(&mut self) {
        self.spot_updates.clear();
        self.derivative_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventOrderbookUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookUpdate {
    // message fields
    pub seq: u64,
    pub orderbook: ::protobuf::SingularPtrField<Orderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookUpdate {
    fn default() -> &'a OrderbookUpdate {
        <OrderbookUpdate as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookUpdate {
    pub fn new() -> OrderbookUpdate {
        ::std::default::Default::default()
    }

    // uint64 seq = 1;


    pub fn get_seq(&self) -> u64 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: u64) {
        self.seq = v;
    }

    // .injective.exchange.v1beta1.Orderbook orderbook = 2;


    pub fn get_orderbook(&self) -> &Orderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <Orderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: Orderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut Orderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> Orderbook {
        self.orderbook.take().unwrap_or_else(|| Orderbook::new())
    }
}

impl ::protobuf::Message for OrderbookUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seq = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.seq != 0 {
            os.write_uint64(1, self.seq)?;
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookUpdate {
        OrderbookUpdate::new()
    }

    fn default_instance() -> &'static OrderbookUpdate {
        static instance: ::protobuf::rt::LazyV2<OrderbookUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookUpdate::new)
    }
}

impl ::protobuf::Clear for OrderbookUpdate {
    fn clear(&mut self) {
        self.seq = 0;
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Orderbook {
    // message fields
    pub market_id: ::std::vec::Vec<u8>,
    pub buy_levels: ::protobuf::RepeatedField<super::exchange::Level>,
    pub sell_levels: ::protobuf::RepeatedField<super::exchange::Level>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Orderbook {
    fn default() -> &'a Orderbook {
        <Orderbook as ::protobuf::Message>::default_instance()
    }
}

impl Orderbook {
    pub fn new() -> Orderbook {
        ::std::default::Default::default()
    }

    // bytes market_id = 1;


    pub fn get_market_id(&self) -> &[u8] {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.market_id, ::std::vec::Vec::new())
    }

    // repeated .injective.exchange.v1beta1.Level buy_levels = 2;


    pub fn get_buy_levels(&self) -> &[super::exchange::Level] {
        &self.buy_levels
    }
    pub fn clear_buy_levels(&mut self) {
        self.buy_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_levels(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.buy_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buy_levels(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.buy_levels
    }

    // Take field
    pub fn take_buy_levels(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.buy_levels, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.Level sell_levels = 3;


    pub fn get_sell_levels(&self) -> &[super::exchange::Level] {
        &self.sell_levels
    }
    pub fn clear_sell_levels(&mut self) {
        self.sell_levels.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_levels(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.sell_levels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sell_levels(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.sell_levels
    }

    // Take field
    pub fn take_sell_levels(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.sell_levels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Orderbook {
    fn is_initialized(&self) -> bool {
        for v in &self.buy_levels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sell_levels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buy_levels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sell_levels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.market_id);
        }
        for value in &self.buy_levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sell_levels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_bytes(1, &self.market_id)?;
        }
        for v in &self.buy_levels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sell_levels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Orderbook {
        Orderbook::new()
    }

    fn default_instance() -> &'static Orderbook {
        static instance: ::protobuf::rt::LazyV2<Orderbook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Orderbook::new)
    }
}

impl ::protobuf::Clear for Orderbook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.buy_levels.clear();
        self.sell_levels.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Orderbook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
