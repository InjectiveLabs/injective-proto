// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective_explorer_rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAccountTxsRequest {
    // message fields
    pub address: ::std::string::String,
    pub before: u64,
    pub after: u64,
    pub limit: i32,
    pub skip: u64,
    pub field_type: ::std::string::String,
    pub module: ::std::string::String,
    pub from_number: i64,
    pub to_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountTxsRequest {
    fn default() -> &'a GetAccountTxsRequest {
        <GetAccountTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountTxsRequest {
    pub fn new() -> GetAccountTxsRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 before = 2;


    pub fn get_before(&self) -> u64 {
        self.before
    }
    pub fn clear_before(&mut self) {
        self.before = 0;
    }

    // Param is passed by value, moved
    pub fn set_before(&mut self, v: u64) {
        self.before = v;
    }

    // uint64 after = 3;


    pub fn get_after(&self) -> u64 {
        self.after
    }
    pub fn clear_after(&mut self) {
        self.after = 0;
    }

    // Param is passed by value, moved
    pub fn set_after(&mut self, v: u64) {
        self.after = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // string type = 6;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string module = 7;


    pub fn get_module(&self) -> &str {
        &self.module
    }
    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::string::String) {
        self.module = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ::std::string::String {
        &mut self.module
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module, ::std::string::String::new())
    }

    // sint64 from_number = 8;


    pub fn get_from_number(&self) -> i64 {
        self.from_number
    }
    pub fn clear_from_number(&mut self) {
        self.from_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_number(&mut self, v: i64) {
        self.from_number = v;
    }

    // sint64 to_number = 9;


    pub fn get_to_number(&self) -> i64 {
        self.to_number
    }
    pub fn clear_to_number(&mut self) {
        self.to_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_number(&mut self, v: i64) {
        self.to_number = v;
    }
}

impl ::protobuf::Message for GetAccountTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.before = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.after = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.from_number = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.to_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.before != 0 {
            my_size += ::protobuf::rt::value_size(2, self.before, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.after != 0 {
            my_size += ::protobuf::rt::value_size(3, self.after, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.field_type);
        }
        if !self.module.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.module);
        }
        if self.from_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.from_number);
        }
        if self.to_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.to_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.before != 0 {
            os.write_uint64(2, self.before)?;
        }
        if self.after != 0 {
            os.write_uint64(3, self.after)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(6, &self.field_type)?;
        }
        if !self.module.is_empty() {
            os.write_string(7, &self.module)?;
        }
        if self.from_number != 0 {
            os.write_sint64(8, self.from_number)?;
        }
        if self.to_number != 0 {
            os.write_sint64(9, self.to_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountTxsRequest {
        GetAccountTxsRequest::new()
    }

    fn default_instance() -> &'static GetAccountTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetAccountTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccountTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetAccountTxsRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.before = 0;
        self.after = 0;
        self.limit = 0;
        self.skip = 0;
        self.field_type.clear();
        self.module.clear();
        self.from_number = 0;
        self.to_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAccountTxsResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<TxDetailData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountTxsResponse {
    fn default() -> &'a GetAccountTxsResponse {
        <GetAccountTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountTxsResponse {
    pub fn new() -> GetAccountTxsResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.TxDetailData data = 2;


    pub fn get_data(&self) -> &[TxDetailData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<TxDetailData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<TxDetailData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<TxDetailData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetAccountTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountTxsResponse {
        GetAccountTxsResponse::new()
    }

    fn default_instance() -> &'static GetAccountTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetAccountTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccountTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetAccountTxsResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Paging {
    // message fields
    pub total: i64,
    pub from: i32,
    pub to: i32,
    pub count_by_subaccount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Paging {
    fn default() -> &'a Paging {
        <Paging as ::protobuf::Message>::default_instance()
    }
}

impl Paging {
    pub fn new() -> Paging {
        ::std::default::Default::default()
    }

    // sint64 total = 1;


    pub fn get_total(&self) -> i64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i64) {
        self.total = v;
    }

    // sint32 from = 2;


    pub fn get_from(&self) -> i32 {
        self.from
    }
    pub fn clear_from(&mut self) {
        self.from = 0;
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = v;
    }

    // sint32 to = 3;


    pub fn get_to(&self) -> i32 {
        self.to
    }
    pub fn clear_to(&mut self) {
        self.to = 0;
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = v;
    }

    // sint64 count_by_subaccount = 4;


    pub fn get_count_by_subaccount(&self) -> i64 {
        self.count_by_subaccount
    }
    pub fn clear_count_by_subaccount(&mut self) {
        self.count_by_subaccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_by_subaccount(&mut self, v: i64) {
        self.count_by_subaccount = v;
    }
}

impl ::protobuf::Message for Paging {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.from = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.to = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.count_by_subaccount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.total);
        }
        if self.from != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.from);
        }
        if self.to != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.to);
        }
        if self.count_by_subaccount != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.count_by_subaccount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_sint64(1, self.total)?;
        }
        if self.from != 0 {
            os.write_sint32(2, self.from)?;
        }
        if self.to != 0 {
            os.write_sint32(3, self.to)?;
        }
        if self.count_by_subaccount != 0 {
            os.write_sint64(4, self.count_by_subaccount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Paging {
        Paging::new()
    }

    fn default_instance() -> &'static Paging {
        static instance: ::protobuf::rt::LazyV2<Paging> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Paging::new)
    }
}

impl ::protobuf::Clear for Paging {
    fn clear(&mut self) {
        self.total = 0;
        self.from = 0;
        self.to = 0;
        self.count_by_subaccount = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Paging {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TxDetailData {
    // message fields
    pub id: ::std::string::String,
    pub block_number: u64,
    pub block_timestamp: ::std::string::String,
    pub hash: ::std::string::String,
    pub code: u32,
    pub data: ::std::vec::Vec<u8>,
    pub info: ::std::string::String,
    pub gas_wanted: i64,
    pub gas_used: i64,
    pub gas_fee: ::protobuf::SingularPtrField<GasFee>,
    pub codespace: ::std::string::String,
    pub events: ::protobuf::RepeatedField<Event>,
    pub tx_type: ::std::string::String,
    pub messages: ::std::vec::Vec<u8>,
    pub signatures: ::protobuf::RepeatedField<Signature>,
    pub memo: ::std::string::String,
    pub tx_number: u64,
    pub block_unix_timestamp: u64,
    pub error_log: ::std::string::String,
    pub logs: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxDetailData {
    fn default() -> &'a TxDetailData {
        <TxDetailData as ::protobuf::Message>::default_instance()
    }
}

impl TxDetailData {
    pub fn new() -> TxDetailData {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // uint64 block_number = 2;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string block_timestamp = 3;


    pub fn get_block_timestamp(&self) -> &str {
        &self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: ::std::string::String) {
        self.block_timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.block_timestamp
    }

    // Take field
    pub fn take_block_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_timestamp, ::std::string::String::new())
    }

    // string hash = 4;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // uint32 code = 5;


    pub fn get_code(&self) -> u32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u32) {
        self.code = v;
    }

    // bytes data = 6;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string info = 8;


    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }

    // sint64 gas_wanted = 9;


    pub fn get_gas_wanted(&self) -> i64 {
        self.gas_wanted
    }
    pub fn clear_gas_wanted(&mut self) {
        self.gas_wanted = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_wanted(&mut self, v: i64) {
        self.gas_wanted = v;
    }

    // sint64 gas_used = 10;


    pub fn get_gas_used(&self) -> i64 {
        self.gas_used
    }
    pub fn clear_gas_used(&mut self) {
        self.gas_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_used(&mut self, v: i64) {
        self.gas_used = v;
    }

    // .injective_explorer_rpc.GasFee gas_fee = 11;


    pub fn get_gas_fee(&self) -> &GasFee {
        self.gas_fee.as_ref().unwrap_or_else(|| <GasFee as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gas_fee(&mut self) {
        self.gas_fee.clear();
    }

    pub fn has_gas_fee(&self) -> bool {
        self.gas_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_fee(&mut self, v: GasFee) {
        self.gas_fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gas_fee(&mut self) -> &mut GasFee {
        if self.gas_fee.is_none() {
            self.gas_fee.set_default();
        }
        self.gas_fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_gas_fee(&mut self) -> GasFee {
        self.gas_fee.take().unwrap_or_else(|| GasFee::new())
    }

    // string codespace = 12;


    pub fn get_codespace(&self) -> &str {
        &self.codespace
    }
    pub fn clear_codespace(&mut self) {
        self.codespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_codespace(&mut self, v: ::std::string::String) {
        self.codespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codespace(&mut self) -> &mut ::std::string::String {
        &mut self.codespace
    }

    // Take field
    pub fn take_codespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codespace, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.Event events = 13;


    pub fn get_events(&self) -> &[Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // string tx_type = 14;


    pub fn get_tx_type(&self) -> &str {
        &self.tx_type
    }
    pub fn clear_tx_type(&mut self) {
        self.tx_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_type(&mut self, v: ::std::string::String) {
        self.tx_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_type(&mut self) -> &mut ::std::string::String {
        &mut self.tx_type
    }

    // Take field
    pub fn take_tx_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_type, ::std::string::String::new())
    }

    // bytes messages = 15;


    pub fn get_messages(&self) -> &[u8] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<u8>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    // repeated .injective_explorer_rpc.Signature signatures = 16;


    pub fn get_signatures(&self) -> &[Signature] {
        &self.signatures
    }
    pub fn clear_signatures(&mut self) {
        self.signatures.clear();
    }

    // Param is passed by value, moved
    pub fn set_signatures(&mut self, v: ::protobuf::RepeatedField<Signature>) {
        self.signatures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signatures(&mut self) -> &mut ::protobuf::RepeatedField<Signature> {
        &mut self.signatures
    }

    // Take field
    pub fn take_signatures(&mut self) -> ::protobuf::RepeatedField<Signature> {
        ::std::mem::replace(&mut self.signatures, ::protobuf::RepeatedField::new())
    }

    // string memo = 17;


    pub fn get_memo(&self) -> &str {
        &self.memo
    }
    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.memo, ::std::string::String::new())
    }

    // uint64 tx_number = 18;


    pub fn get_tx_number(&self) -> u64 {
        self.tx_number
    }
    pub fn clear_tx_number(&mut self) {
        self.tx_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_number(&mut self, v: u64) {
        self.tx_number = v;
    }

    // uint64 block_unix_timestamp = 19;


    pub fn get_block_unix_timestamp(&self) -> u64 {
        self.block_unix_timestamp
    }
    pub fn clear_block_unix_timestamp(&mut self) {
        self.block_unix_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_unix_timestamp(&mut self, v: u64) {
        self.block_unix_timestamp = v;
    }

    // string error_log = 20;


    pub fn get_error_log(&self) -> &str {
        &self.error_log
    }
    pub fn clear_error_log(&mut self) {
        self.error_log.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_log(&mut self, v: ::std::string::String) {
        self.error_log = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_log(&mut self) -> &mut ::std::string::String {
        &mut self.error_log
    }

    // Take field
    pub fn take_error_log(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_log, ::std::string::String::new())
    }

    // bytes logs = 21;


    pub fn get_logs(&self) -> &[u8] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::std::vec::Vec<u8>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TxDetailData {
    fn is_initialized(&self) -> bool {
        for v in &self.gas_fee {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatures {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_timestamp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.info)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.gas_wanted = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.gas_used = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gas_fee)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codespace)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_type)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.messages)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.signatures)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.memo)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_number = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_unix_timestamp = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_log)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.block_timestamp);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.hash);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(5, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.data);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.info);
        }
        if self.gas_wanted != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.gas_wanted);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(10, self.gas_used);
        }
        if let Some(ref v) = self.gas_fee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.codespace);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.tx_type.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.tx_type);
        }
        if !self.messages.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.messages);
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.memo);
        }
        if self.tx_number != 0 {
            my_size += ::protobuf::rt::value_size(18, self.tx_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_unix_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(19, self.block_unix_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_log.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.error_log);
        }
        if !self.logs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.logs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        if !self.block_timestamp.is_empty() {
            os.write_string(3, &self.block_timestamp)?;
        }
        if !self.hash.is_empty() {
            os.write_string(4, &self.hash)?;
        }
        if self.code != 0 {
            os.write_uint32(5, self.code)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(6, &self.data)?;
        }
        if !self.info.is_empty() {
            os.write_string(8, &self.info)?;
        }
        if self.gas_wanted != 0 {
            os.write_sint64(9, self.gas_wanted)?;
        }
        if self.gas_used != 0 {
            os.write_sint64(10, self.gas_used)?;
        }
        if let Some(ref v) = self.gas_fee.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.codespace.is_empty() {
            os.write_string(12, &self.codespace)?;
        }
        for v in &self.events {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.tx_type.is_empty() {
            os.write_string(14, &self.tx_type)?;
        }
        if !self.messages.is_empty() {
            os.write_bytes(15, &self.messages)?;
        }
        for v in &self.signatures {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.memo.is_empty() {
            os.write_string(17, &self.memo)?;
        }
        if self.tx_number != 0 {
            os.write_uint64(18, self.tx_number)?;
        }
        if self.block_unix_timestamp != 0 {
            os.write_uint64(19, self.block_unix_timestamp)?;
        }
        if !self.error_log.is_empty() {
            os.write_string(20, &self.error_log)?;
        }
        if !self.logs.is_empty() {
            os.write_bytes(21, &self.logs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxDetailData {
        TxDetailData::new()
    }

    fn default_instance() -> &'static TxDetailData {
        static instance: ::protobuf::rt::LazyV2<TxDetailData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxDetailData::new)
    }
}

impl ::protobuf::Clear for TxDetailData {
    fn clear(&mut self) {
        self.id.clear();
        self.block_number = 0;
        self.block_timestamp.clear();
        self.hash.clear();
        self.code = 0;
        self.data.clear();
        self.info.clear();
        self.gas_wanted = 0;
        self.gas_used = 0;
        self.gas_fee.clear();
        self.codespace.clear();
        self.events.clear();
        self.tx_type.clear();
        self.messages.clear();
        self.signatures.clear();
        self.memo.clear();
        self.tx_number = 0;
        self.block_unix_timestamp = 0;
        self.error_log.clear();
        self.logs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TxDetailData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GasFee {
    // message fields
    pub amount: ::protobuf::RepeatedField<CosmosCoin>,
    pub gas_limit: u64,
    pub payer: ::std::string::String,
    pub granter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GasFee {
    fn default() -> &'a GasFee {
        <GasFee as ::protobuf::Message>::default_instance()
    }
}

impl GasFee {
    pub fn new() -> GasFee {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.CosmosCoin amount = 1;


    pub fn get_amount(&self) -> &[CosmosCoin] {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::protobuf::RepeatedField<CosmosCoin>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_amount(&mut self) -> &mut ::protobuf::RepeatedField<CosmosCoin> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::protobuf::RepeatedField<CosmosCoin> {
        ::std::mem::replace(&mut self.amount, ::protobuf::RepeatedField::new())
    }

    // uint64 gas_limit = 2;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = v;
    }

    // string payer = 3;


    pub fn get_payer(&self) -> &str {
        &self.payer
    }
    pub fn clear_payer(&mut self) {
        self.payer.clear();
    }

    // Param is passed by value, moved
    pub fn set_payer(&mut self, v: ::std::string::String) {
        self.payer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payer(&mut self) -> &mut ::std::string::String {
        &mut self.payer
    }

    // Take field
    pub fn take_payer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payer, ::std::string::String::new())
    }

    // string granter = 4;


    pub fn get_granter(&self) -> &str {
        &self.granter
    }
    pub fn clear_granter(&mut self) {
        self.granter.clear();
    }

    // Param is passed by value, moved
    pub fn set_granter(&mut self, v: ::std::string::String) {
        self.granter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_granter(&mut self) -> &mut ::std::string::String {
        &mut self.granter
    }

    // Take field
    pub fn take_granter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.granter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GasFee {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.amount)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.granter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.amount {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.gas_limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.gas_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payer);
        }
        if !self.granter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.granter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.amount {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.gas_limit != 0 {
            os.write_uint64(2, self.gas_limit)?;
        }
        if !self.payer.is_empty() {
            os.write_string(3, &self.payer)?;
        }
        if !self.granter.is_empty() {
            os.write_string(4, &self.granter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GasFee {
        GasFee::new()
    }

    fn default_instance() -> &'static GasFee {
        static instance: ::protobuf::rt::LazyV2<GasFee> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GasFee::new)
    }
}

impl ::protobuf::Clear for GasFee {
    fn clear(&mut self) {
        self.amount.clear();
        self.gas_limit = 0;
        self.payer.clear();
        self.granter.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GasFee {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CosmosCoin {
    // message fields
    pub denom: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CosmosCoin {
    fn default() -> &'a CosmosCoin {
        <CosmosCoin as ::protobuf::Message>::default_instance()
    }
}

impl CosmosCoin {
    pub fn new() -> CosmosCoin {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string amount = 2;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CosmosCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        if !self.amount.is_empty() {
            os.write_string(2, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CosmosCoin {
        CosmosCoin::new()
    }

    fn default_instance() -> &'static CosmosCoin {
        static instance: ::protobuf::rt::LazyV2<CosmosCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CosmosCoin::new)
    }
}

impl ::protobuf::Clear for CosmosCoin {
    fn clear(&mut self) {
        self.denom.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CosmosCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Event {
    // message fields
    pub field_type: ::std::string::String,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.Event.attributes_MapEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.field_type.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Signature {
    // message fields
    pub pubkey: ::std::string::String,
    pub address: ::std::string::String,
    pub sequence: u64,
    pub signature: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // string pubkey = 1;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // string signature = 4;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Signature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pubkey);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pubkey.is_empty() {
            os.write_string(1, &self.pubkey)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if !self.signature.is_empty() {
            os.write_string(4, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn default_instance() -> &'static Signature {
        static instance: ::protobuf::rt::LazyV2<Signature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Signature::new)
    }
}

impl ::protobuf::Clear for Signature {
    fn clear(&mut self) {
        self.pubkey.clear();
        self.address.clear();
        self.sequence = 0;
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetContractTxsRequest {
    // message fields
    pub address: ::std::string::String,
    pub limit: i32,
    pub skip: u64,
    pub from_number: i64,
    pub to_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContractTxsRequest {
    fn default() -> &'a GetContractTxsRequest {
        <GetContractTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetContractTxsRequest {
    pub fn new() -> GetContractTxsRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // sint32 limit = 2;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint64 from_number = 4;


    pub fn get_from_number(&self) -> i64 {
        self.from_number
    }
    pub fn clear_from_number(&mut self) {
        self.from_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_number(&mut self, v: i64) {
        self.from_number = v;
    }

    // sint64 to_number = 5;


    pub fn get_to_number(&self) -> i64 {
        self.to_number
    }
    pub fn clear_to_number(&mut self) {
        self.to_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_number(&mut self, v: i64) {
        self.to_number = v;
    }
}

impl ::protobuf::Message for GetContractTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.from_number = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.to_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.from_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.from_number);
        }
        if self.to_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.to_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.limit != 0 {
            os.write_sint32(2, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.from_number != 0 {
            os.write_sint64(4, self.from_number)?;
        }
        if self.to_number != 0 {
            os.write_sint64(5, self.to_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContractTxsRequest {
        GetContractTxsRequest::new()
    }

    fn default_instance() -> &'static GetContractTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetContractTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetContractTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetContractTxsRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.limit = 0;
        self.skip = 0;
        self.from_number = 0;
        self.to_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContractTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetContractTxsResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<TxDetailData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContractTxsResponse {
    fn default() -> &'a GetContractTxsResponse {
        <GetContractTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetContractTxsResponse {
    pub fn new() -> GetContractTxsResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.TxDetailData data = 2;


    pub fn get_data(&self) -> &[TxDetailData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<TxDetailData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<TxDetailData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<TxDetailData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetContractTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContractTxsResponse {
        GetContractTxsResponse::new()
    }

    fn default_instance() -> &'static GetContractTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetContractTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetContractTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetContractTxsResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContractTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlocksRequest {
    // message fields
    pub before: u64,
    pub after: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksRequest {
    fn default() -> &'a GetBlocksRequest {
        <GetBlocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksRequest {
    pub fn new() -> GetBlocksRequest {
        ::std::default::Default::default()
    }

    // uint64 before = 1;


    pub fn get_before(&self) -> u64 {
        self.before
    }
    pub fn clear_before(&mut self) {
        self.before = 0;
    }

    // Param is passed by value, moved
    pub fn set_before(&mut self, v: u64) {
        self.before = v;
    }

    // uint64 after = 2;


    pub fn get_after(&self) -> u64 {
        self.after
    }
    pub fn clear_after(&mut self) {
        self.after = 0;
    }

    // Param is passed by value, moved
    pub fn set_after(&mut self, v: u64) {
        self.after = v;
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for GetBlocksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.before = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.after = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.before != 0 {
            my_size += ::protobuf::rt::value_size(1, self.before, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.after != 0 {
            my_size += ::protobuf::rt::value_size(2, self.after, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.before != 0 {
            os.write_uint64(1, self.before)?;
        }
        if self.after != 0 {
            os.write_uint64(2, self.after)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksRequest {
        GetBlocksRequest::new()
    }

    fn default_instance() -> &'static GetBlocksRequest {
        static instance: ::protobuf::rt::LazyV2<GetBlocksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlocksRequest::new)
    }
}

impl ::protobuf::Clear for GetBlocksRequest {
    fn clear(&mut self) {
        self.before = 0;
        self.after = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlocksResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<BlockInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlocksResponse {
    fn default() -> &'a GetBlocksResponse {
        <GetBlocksResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocksResponse {
    pub fn new() -> GetBlocksResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.BlockInfo data = 2;


    pub fn get_data(&self) -> &[BlockInfo] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<BlockInfo>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<BlockInfo> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<BlockInfo> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksResponse {
        GetBlocksResponse::new()
    }

    fn default_instance() -> &'static GetBlocksResponse {
        static instance: ::protobuf::rt::LazyV2<GetBlocksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlocksResponse::new)
    }
}

impl ::protobuf::Clear for GetBlocksResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockInfo {
    // message fields
    pub height: u64,
    pub proposer: ::std::string::String,
    pub moniker: ::std::string::String,
    pub block_hash: ::std::string::String,
    pub parent_hash: ::std::string::String,
    pub num_pre_commits: i64,
    pub num_txs: i64,
    pub txs: ::protobuf::RepeatedField<TxDataRPC>,
    pub timestamp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockInfo {
    fn default() -> &'a BlockInfo {
        <BlockInfo as ::protobuf::Message>::default_instance()
    }
}

impl BlockInfo {
    pub fn new() -> BlockInfo {
        ::std::default::Default::default()
    }

    // uint64 height = 1;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    // string proposer = 2;


    pub fn get_proposer(&self) -> &str {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::string::String) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::string::String {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proposer, ::std::string::String::new())
    }

    // string moniker = 3;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string block_hash = 4;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // string parent_hash = 5;


    pub fn get_parent_hash(&self) -> &str {
        &self.parent_hash
    }
    pub fn clear_parent_hash(&mut self) {
        self.parent_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_hash(&mut self, v: ::std::string::String) {
        self.parent_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_hash(&mut self) -> &mut ::std::string::String {
        &mut self.parent_hash
    }

    // Take field
    pub fn take_parent_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_hash, ::std::string::String::new())
    }

    // sint64 num_pre_commits = 6;


    pub fn get_num_pre_commits(&self) -> i64 {
        self.num_pre_commits
    }
    pub fn clear_num_pre_commits(&mut self) {
        self.num_pre_commits = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pre_commits(&mut self, v: i64) {
        self.num_pre_commits = v;
    }

    // sint64 num_txs = 7;


    pub fn get_num_txs(&self) -> i64 {
        self.num_txs
    }
    pub fn clear_num_txs(&mut self) {
        self.num_txs = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_txs(&mut self, v: i64) {
        self.num_txs = v;
    }

    // repeated .injective_explorer_rpc.TxDataRPC txs = 8;


    pub fn get_txs(&self) -> &[TxDataRPC] {
        &self.txs
    }
    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<TxDataRPC>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<TxDataRPC> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<TxDataRPC> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    // string timestamp = 9;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlockInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proposer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_hash)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_pre_commits = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_txs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.proposer);
        }
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.moniker);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parent_hash);
        }
        if self.num_pre_commits != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.num_pre_commits);
        }
        if self.num_txs != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.num_txs);
        }
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if !self.proposer.is_empty() {
            os.write_string(2, &self.proposer)?;
        }
        if !self.moniker.is_empty() {
            os.write_string(3, &self.moniker)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_string(5, &self.parent_hash)?;
        }
        if self.num_pre_commits != 0 {
            os.write_sint64(6, self.num_pre_commits)?;
        }
        if self.num_txs != 0 {
            os.write_sint64(7, self.num_txs)?;
        }
        for v in &self.txs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.timestamp.is_empty() {
            os.write_string(9, &self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockInfo {
        BlockInfo::new()
    }

    fn default_instance() -> &'static BlockInfo {
        static instance: ::protobuf::rt::LazyV2<BlockInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockInfo::new)
    }
}

impl ::protobuf::Clear for BlockInfo {
    fn clear(&mut self) {
        self.height = 0;
        self.proposer.clear();
        self.moniker.clear();
        self.block_hash.clear();
        self.parent_hash.clear();
        self.num_pre_commits = 0;
        self.num_txs = 0;
        self.txs.clear();
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TxDataRPC {
    // message fields
    pub id: ::std::string::String,
    pub block_number: u64,
    pub block_timestamp: ::std::string::String,
    pub hash: ::std::string::String,
    pub codespace: ::std::string::String,
    pub messages: ::std::string::String,
    pub tx_number: u64,
    pub error_log: ::std::string::String,
    pub code: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxDataRPC {
    fn default() -> &'a TxDataRPC {
        <TxDataRPC as ::protobuf::Message>::default_instance()
    }
}

impl TxDataRPC {
    pub fn new() -> TxDataRPC {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // uint64 block_number = 2;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string block_timestamp = 3;


    pub fn get_block_timestamp(&self) -> &str {
        &self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: ::std::string::String) {
        self.block_timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.block_timestamp
    }

    // Take field
    pub fn take_block_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_timestamp, ::std::string::String::new())
    }

    // string hash = 4;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // string codespace = 5;


    pub fn get_codespace(&self) -> &str {
        &self.codespace
    }
    pub fn clear_codespace(&mut self) {
        self.codespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_codespace(&mut self, v: ::std::string::String) {
        self.codespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codespace(&mut self) -> &mut ::std::string::String {
        &mut self.codespace
    }

    // Take field
    pub fn take_codespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codespace, ::std::string::String::new())
    }

    // string messages = 6;


    pub fn get_messages(&self) -> &str {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::string::String) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&mut self) -> &mut ::std::string::String {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.messages, ::std::string::String::new())
    }

    // uint64 tx_number = 7;


    pub fn get_tx_number(&self) -> u64 {
        self.tx_number
    }
    pub fn clear_tx_number(&mut self) {
        self.tx_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_number(&mut self, v: u64) {
        self.tx_number = v;
    }

    // string error_log = 8;


    pub fn get_error_log(&self) -> &str {
        &self.error_log
    }
    pub fn clear_error_log(&mut self) {
        self.error_log.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_log(&mut self, v: ::std::string::String) {
        self.error_log = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_log(&mut self) -> &mut ::std::string::String {
        &mut self.error_log
    }

    // Take field
    pub fn take_error_log(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_log, ::std::string::String::new())
    }

    // uint32 code = 9;


    pub fn get_code(&self) -> u32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u32) {
        self.code = v;
    }
}

impl ::protobuf::Message for TxDataRPC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_timestamp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codespace)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.messages)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_number = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_log)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.block_timestamp);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.hash);
        }
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.codespace);
        }
        if !self.messages.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.messages);
        }
        if self.tx_number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_log.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.error_log);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(9, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        if !self.block_timestamp.is_empty() {
            os.write_string(3, &self.block_timestamp)?;
        }
        if !self.hash.is_empty() {
            os.write_string(4, &self.hash)?;
        }
        if !self.codespace.is_empty() {
            os.write_string(5, &self.codespace)?;
        }
        if !self.messages.is_empty() {
            os.write_string(6, &self.messages)?;
        }
        if self.tx_number != 0 {
            os.write_uint64(7, self.tx_number)?;
        }
        if !self.error_log.is_empty() {
            os.write_string(8, &self.error_log)?;
        }
        if self.code != 0 {
            os.write_uint32(9, self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxDataRPC {
        TxDataRPC::new()
    }

    fn default_instance() -> &'static TxDataRPC {
        static instance: ::protobuf::rt::LazyV2<TxDataRPC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxDataRPC::new)
    }
}

impl ::protobuf::Clear for TxDataRPC {
    fn clear(&mut self) {
        self.id.clear();
        self.block_number = 0;
        self.block_timestamp.clear();
        self.hash.clear();
        self.codespace.clear();
        self.messages.clear();
        self.tx_number = 0;
        self.error_log.clear();
        self.code = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TxDataRPC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlockRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockRequest {
    fn default() -> &'a GetBlockRequest {
        <GetBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockRequest {
    pub fn new() -> GetBlockRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetBlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockRequest {
        GetBlockRequest::new()
    }

    fn default_instance() -> &'static GetBlockRequest {
        static instance: ::protobuf::rt::LazyV2<GetBlockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockRequest::new)
    }
}

impl ::protobuf::Clear for GetBlockRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlockResponse {
    // message fields
    pub s: ::std::string::String,
    pub errmsg: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<BlockDetailInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockResponse {
    fn default() -> &'a GetBlockResponse {
        <GetBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockResponse {
    pub fn new() -> GetBlockResponse {
        ::std::default::Default::default()
    }

    // string s = 1;


    pub fn get_s(&self) -> &str {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::string::String) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::string::String {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s, ::std::string::String::new())
    }

    // string errmsg = 2;


    pub fn get_errmsg(&self) -> &str {
        &self.errmsg
    }
    pub fn clear_errmsg(&mut self) {
        self.errmsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errmsg(&mut self, v: ::std::string::String) {
        self.errmsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errmsg(&mut self) -> &mut ::std::string::String {
        &mut self.errmsg
    }

    // Take field
    pub fn take_errmsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errmsg, ::std::string::String::new())
    }

    // .injective_explorer_rpc.BlockDetailInfo data = 3;


    pub fn get_data(&self) -> &BlockDetailInfo {
        self.data.as_ref().unwrap_or_else(|| <BlockDetailInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: BlockDetailInfo) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut BlockDetailInfo {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> BlockDetailInfo {
        self.data.take().unwrap_or_else(|| BlockDetailInfo::new())
    }
}

impl ::protobuf::Message for GetBlockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errmsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.s);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.s.is_empty() {
            os.write_string(1, &self.s)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockResponse {
        GetBlockResponse::new()
    }

    fn default_instance() -> &'static GetBlockResponse {
        static instance: ::protobuf::rt::LazyV2<GetBlockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockResponse::new)
    }
}

impl ::protobuf::Clear for GetBlockResponse {
    fn clear(&mut self) {
        self.s.clear();
        self.errmsg.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockDetailInfo {
    // message fields
    pub height: u64,
    pub proposer: ::std::string::String,
    pub moniker: ::std::string::String,
    pub block_hash: ::std::string::String,
    pub parent_hash: ::std::string::String,
    pub num_pre_commits: i64,
    pub num_txs: i64,
    pub total_txs: i64,
    pub txs: ::protobuf::RepeatedField<TxData>,
    pub timestamp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockDetailInfo {
    fn default() -> &'a BlockDetailInfo {
        <BlockDetailInfo as ::protobuf::Message>::default_instance()
    }
}

impl BlockDetailInfo {
    pub fn new() -> BlockDetailInfo {
        ::std::default::Default::default()
    }

    // uint64 height = 1;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    // string proposer = 2;


    pub fn get_proposer(&self) -> &str {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::string::String) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::string::String {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proposer, ::std::string::String::new())
    }

    // string moniker = 3;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string block_hash = 4;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // string parent_hash = 5;


    pub fn get_parent_hash(&self) -> &str {
        &self.parent_hash
    }
    pub fn clear_parent_hash(&mut self) {
        self.parent_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_hash(&mut self, v: ::std::string::String) {
        self.parent_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_hash(&mut self) -> &mut ::std::string::String {
        &mut self.parent_hash
    }

    // Take field
    pub fn take_parent_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_hash, ::std::string::String::new())
    }

    // sint64 num_pre_commits = 6;


    pub fn get_num_pre_commits(&self) -> i64 {
        self.num_pre_commits
    }
    pub fn clear_num_pre_commits(&mut self) {
        self.num_pre_commits = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pre_commits(&mut self, v: i64) {
        self.num_pre_commits = v;
    }

    // sint64 num_txs = 7;


    pub fn get_num_txs(&self) -> i64 {
        self.num_txs
    }
    pub fn clear_num_txs(&mut self) {
        self.num_txs = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_txs(&mut self, v: i64) {
        self.num_txs = v;
    }

    // sint64 total_txs = 8;


    pub fn get_total_txs(&self) -> i64 {
        self.total_txs
    }
    pub fn clear_total_txs(&mut self) {
        self.total_txs = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_txs(&mut self, v: i64) {
        self.total_txs = v;
    }

    // repeated .injective_explorer_rpc.TxData txs = 9;


    pub fn get_txs(&self) -> &[TxData] {
        &self.txs
    }
    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<TxData>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<TxData> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<TxData> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    // string timestamp = 10;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BlockDetailInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proposer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_hash)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_pre_commits = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_txs = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.total_txs = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.proposer);
        }
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.moniker);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parent_hash);
        }
        if self.num_pre_commits != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.num_pre_commits);
        }
        if self.num_txs != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.num_txs);
        }
        if self.total_txs != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.total_txs);
        }
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if !self.proposer.is_empty() {
            os.write_string(2, &self.proposer)?;
        }
        if !self.moniker.is_empty() {
            os.write_string(3, &self.moniker)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_string(5, &self.parent_hash)?;
        }
        if self.num_pre_commits != 0 {
            os.write_sint64(6, self.num_pre_commits)?;
        }
        if self.num_txs != 0 {
            os.write_sint64(7, self.num_txs)?;
        }
        if self.total_txs != 0 {
            os.write_sint64(8, self.total_txs)?;
        }
        for v in &self.txs {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.timestamp.is_empty() {
            os.write_string(10, &self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockDetailInfo {
        BlockDetailInfo::new()
    }

    fn default_instance() -> &'static BlockDetailInfo {
        static instance: ::protobuf::rt::LazyV2<BlockDetailInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockDetailInfo::new)
    }
}

impl ::protobuf::Clear for BlockDetailInfo {
    fn clear(&mut self) {
        self.height = 0;
        self.proposer.clear();
        self.moniker.clear();
        self.block_hash.clear();
        self.parent_hash.clear();
        self.num_pre_commits = 0;
        self.num_txs = 0;
        self.total_txs = 0;
        self.txs.clear();
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockDetailInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TxData {
    // message fields
    pub id: ::std::string::String,
    pub block_number: u64,
    pub block_timestamp: ::std::string::String,
    pub hash: ::std::string::String,
    pub codespace: ::std::string::String,
    pub messages: ::std::vec::Vec<u8>,
    pub tx_number: u64,
    pub error_log: ::std::string::String,
    pub code: u32,
    pub tx_msg_types: ::std::vec::Vec<u8>,
    pub logs: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxData {
    fn default() -> &'a TxData {
        <TxData as ::protobuf::Message>::default_instance()
    }
}

impl TxData {
    pub fn new() -> TxData {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // uint64 block_number = 2;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string block_timestamp = 3;


    pub fn get_block_timestamp(&self) -> &str {
        &self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: ::std::string::String) {
        self.block_timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.block_timestamp
    }

    // Take field
    pub fn take_block_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_timestamp, ::std::string::String::new())
    }

    // string hash = 4;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // string codespace = 5;


    pub fn get_codespace(&self) -> &str {
        &self.codespace
    }
    pub fn clear_codespace(&mut self) {
        self.codespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_codespace(&mut self, v: ::std::string::String) {
        self.codespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codespace(&mut self) -> &mut ::std::string::String {
        &mut self.codespace
    }

    // Take field
    pub fn take_codespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codespace, ::std::string::String::new())
    }

    // bytes messages = 6;


    pub fn get_messages(&self) -> &[u8] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<u8>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    // uint64 tx_number = 7;


    pub fn get_tx_number(&self) -> u64 {
        self.tx_number
    }
    pub fn clear_tx_number(&mut self) {
        self.tx_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_number(&mut self, v: u64) {
        self.tx_number = v;
    }

    // string error_log = 8;


    pub fn get_error_log(&self) -> &str {
        &self.error_log
    }
    pub fn clear_error_log(&mut self) {
        self.error_log.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_log(&mut self, v: ::std::string::String) {
        self.error_log = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_log(&mut self) -> &mut ::std::string::String {
        &mut self.error_log
    }

    // Take field
    pub fn take_error_log(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_log, ::std::string::String::new())
    }

    // uint32 code = 9;


    pub fn get_code(&self) -> u32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u32) {
        self.code = v;
    }

    // bytes tx_msg_types = 10;


    pub fn get_tx_msg_types(&self) -> &[u8] {
        &self.tx_msg_types
    }
    pub fn clear_tx_msg_types(&mut self) {
        self.tx_msg_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_msg_types(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_msg_types = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_msg_types(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_msg_types
    }

    // Take field
    pub fn take_tx_msg_types(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_msg_types, ::std::vec::Vec::new())
    }

    // bytes logs = 11;


    pub fn get_logs(&self) -> &[u8] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::std::vec::Vec<u8>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TxData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_timestamp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codespace)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.messages)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_number = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_log)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_msg_types)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.block_timestamp);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.hash);
        }
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.codespace);
        }
        if !self.messages.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.messages);
        }
        if self.tx_number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_log.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.error_log);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(9, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_msg_types.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.tx_msg_types);
        }
        if !self.logs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.logs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        if !self.block_timestamp.is_empty() {
            os.write_string(3, &self.block_timestamp)?;
        }
        if !self.hash.is_empty() {
            os.write_string(4, &self.hash)?;
        }
        if !self.codespace.is_empty() {
            os.write_string(5, &self.codespace)?;
        }
        if !self.messages.is_empty() {
            os.write_bytes(6, &self.messages)?;
        }
        if self.tx_number != 0 {
            os.write_uint64(7, self.tx_number)?;
        }
        if !self.error_log.is_empty() {
            os.write_string(8, &self.error_log)?;
        }
        if self.code != 0 {
            os.write_uint32(9, self.code)?;
        }
        if !self.tx_msg_types.is_empty() {
            os.write_bytes(10, &self.tx_msg_types)?;
        }
        if !self.logs.is_empty() {
            os.write_bytes(11, &self.logs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxData {
        TxData::new()
    }

    fn default_instance() -> &'static TxData {
        static instance: ::protobuf::rt::LazyV2<TxData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxData::new)
    }
}

impl ::protobuf::Clear for TxData {
    fn clear(&mut self) {
        self.id.clear();
        self.block_number = 0;
        self.block_timestamp.clear();
        self.hash.clear();
        self.codespace.clear();
        self.messages.clear();
        self.tx_number = 0;
        self.error_log.clear();
        self.code = 0;
        self.tx_msg_types.clear();
        self.logs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TxData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorsRequest {
    fn default() -> &'a GetValidatorsRequest {
        <GetValidatorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorsRequest {
    pub fn new() -> GetValidatorsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetValidatorsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorsRequest {
        GetValidatorsRequest::new()
    }

    fn default_instance() -> &'static GetValidatorsRequest {
        static instance: ::protobuf::rt::LazyV2<GetValidatorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorsRequest::new)
    }
}

impl ::protobuf::Clear for GetValidatorsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorsResponse {
    // message fields
    pub s: ::std::string::String,
    pub errmsg: ::std::string::String,
    pub data: ::protobuf::RepeatedField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorsResponse {
    fn default() -> &'a GetValidatorsResponse {
        <GetValidatorsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorsResponse {
    pub fn new() -> GetValidatorsResponse {
        ::std::default::Default::default()
    }

    // string s = 1;


    pub fn get_s(&self) -> &str {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::string::String) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::string::String {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s, ::std::string::String::new())
    }

    // string errmsg = 2;


    pub fn get_errmsg(&self) -> &str {
        &self.errmsg
    }
    pub fn clear_errmsg(&mut self) {
        self.errmsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errmsg(&mut self, v: ::std::string::String) {
        self.errmsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errmsg(&mut self) -> &mut ::std::string::String {
        &mut self.errmsg
    }

    // Take field
    pub fn take_errmsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errmsg, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.Validator data = 3;


    pub fn get_data(&self) -> &[Validator] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<Validator>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<Validator> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<Validator> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetValidatorsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errmsg)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.s);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.s.is_empty() {
            os.write_string(1, &self.s)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        for v in &self.data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorsResponse {
        GetValidatorsResponse::new()
    }

    fn default_instance() -> &'static GetValidatorsResponse {
        static instance: ::protobuf::rt::LazyV2<GetValidatorsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorsResponse::new)
    }
}

impl ::protobuf::Clear for GetValidatorsResponse {
    fn clear(&mut self) {
        self.s.clear();
        self.errmsg.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Validator {
    // message fields
    pub id: ::std::string::String,
    pub moniker: ::std::string::String,
    pub operator_address: ::std::string::String,
    pub consensus_address: ::std::string::String,
    pub jailed: bool,
    pub status: i32,
    pub tokens: ::std::string::String,
    pub delegator_shares: ::std::string::String,
    pub description: ::protobuf::SingularPtrField<ValidatorDescription>,
    pub unbonding_height: i64,
    pub unbonding_time: ::std::string::String,
    pub commission_rate: ::std::string::String,
    pub commission_max_rate: ::std::string::String,
    pub commission_max_change_rate: ::std::string::String,
    pub commission_update_time: ::std::string::String,
    pub proposed: u64,
    pub signed: u64,
    pub missed: u64,
    pub timestamp: ::std::string::String,
    pub uptimes: ::protobuf::RepeatedField<ValidatorUptime>,
    pub slashing_events: ::protobuf::RepeatedField<SlashingEvent>,
    pub uptime_percentage: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validator {
    fn default() -> &'a Validator {
        <Validator as ::protobuf::Message>::default_instance()
    }
}

impl Validator {
    pub fn new() -> Validator {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string moniker = 2;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string operator_address = 3;


    pub fn get_operator_address(&self) -> &str {
        &self.operator_address
    }
    pub fn clear_operator_address(&mut self) {
        self.operator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_operator_address(&mut self, v: ::std::string::String) {
        self.operator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator_address(&mut self) -> &mut ::std::string::String {
        &mut self.operator_address
    }

    // Take field
    pub fn take_operator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operator_address, ::std::string::String::new())
    }

    // string consensus_address = 4;


    pub fn get_consensus_address(&self) -> &str {
        &self.consensus_address
    }
    pub fn clear_consensus_address(&mut self) {
        self.consensus_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_consensus_address(&mut self, v: ::std::string::String) {
        self.consensus_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consensus_address(&mut self) -> &mut ::std::string::String {
        &mut self.consensus_address
    }

    // Take field
    pub fn take_consensus_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consensus_address, ::std::string::String::new())
    }

    // bool jailed = 5;


    pub fn get_jailed(&self) -> bool {
        self.jailed
    }
    pub fn clear_jailed(&mut self) {
        self.jailed = false;
    }

    // Param is passed by value, moved
    pub fn set_jailed(&mut self, v: bool) {
        self.jailed = v;
    }

    // sint32 status = 6;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    // string tokens = 7;


    pub fn get_tokens(&self) -> &str {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::std::string::String) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tokens(&mut self) -> &mut ::std::string::String {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tokens, ::std::string::String::new())
    }

    // string delegator_shares = 8;


    pub fn get_delegator_shares(&self) -> &str {
        &self.delegator_shares
    }
    pub fn clear_delegator_shares(&mut self) {
        self.delegator_shares.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegator_shares(&mut self, v: ::std::string::String) {
        self.delegator_shares = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegator_shares(&mut self) -> &mut ::std::string::String {
        &mut self.delegator_shares
    }

    // Take field
    pub fn take_delegator_shares(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delegator_shares, ::std::string::String::new())
    }

    // .injective_explorer_rpc.ValidatorDescription description = 9;


    pub fn get_description(&self) -> &ValidatorDescription {
        self.description.as_ref().unwrap_or_else(|| <ValidatorDescription as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ValidatorDescription) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ValidatorDescription {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ValidatorDescription {
        self.description.take().unwrap_or_else(|| ValidatorDescription::new())
    }

    // sint64 unbonding_height = 10;


    pub fn get_unbonding_height(&self) -> i64 {
        self.unbonding_height
    }
    pub fn clear_unbonding_height(&mut self) {
        self.unbonding_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_unbonding_height(&mut self, v: i64) {
        self.unbonding_height = v;
    }

    // string unbonding_time = 11;


    pub fn get_unbonding_time(&self) -> &str {
        &self.unbonding_time
    }
    pub fn clear_unbonding_time(&mut self) {
        self.unbonding_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_unbonding_time(&mut self, v: ::std::string::String) {
        self.unbonding_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unbonding_time(&mut self) -> &mut ::std::string::String {
        &mut self.unbonding_time
    }

    // Take field
    pub fn take_unbonding_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unbonding_time, ::std::string::String::new())
    }

    // string commission_rate = 12;


    pub fn get_commission_rate(&self) -> &str {
        &self.commission_rate
    }
    pub fn clear_commission_rate(&mut self) {
        self.commission_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_commission_rate(&mut self, v: ::std::string::String) {
        self.commission_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission_rate(&mut self) -> &mut ::std::string::String {
        &mut self.commission_rate
    }

    // Take field
    pub fn take_commission_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commission_rate, ::std::string::String::new())
    }

    // string commission_max_rate = 13;


    pub fn get_commission_max_rate(&self) -> &str {
        &self.commission_max_rate
    }
    pub fn clear_commission_max_rate(&mut self) {
        self.commission_max_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_commission_max_rate(&mut self, v: ::std::string::String) {
        self.commission_max_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission_max_rate(&mut self) -> &mut ::std::string::String {
        &mut self.commission_max_rate
    }

    // Take field
    pub fn take_commission_max_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commission_max_rate, ::std::string::String::new())
    }

    // string commission_max_change_rate = 14;


    pub fn get_commission_max_change_rate(&self) -> &str {
        &self.commission_max_change_rate
    }
    pub fn clear_commission_max_change_rate(&mut self) {
        self.commission_max_change_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_commission_max_change_rate(&mut self, v: ::std::string::String) {
        self.commission_max_change_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission_max_change_rate(&mut self) -> &mut ::std::string::String {
        &mut self.commission_max_change_rate
    }

    // Take field
    pub fn take_commission_max_change_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commission_max_change_rate, ::std::string::String::new())
    }

    // string commission_update_time = 15;


    pub fn get_commission_update_time(&self) -> &str {
        &self.commission_update_time
    }
    pub fn clear_commission_update_time(&mut self) {
        self.commission_update_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_commission_update_time(&mut self, v: ::std::string::String) {
        self.commission_update_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commission_update_time(&mut self) -> &mut ::std::string::String {
        &mut self.commission_update_time
    }

    // Take field
    pub fn take_commission_update_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.commission_update_time, ::std::string::String::new())
    }

    // uint64 proposed = 16;


    pub fn get_proposed(&self) -> u64 {
        self.proposed
    }
    pub fn clear_proposed(&mut self) {
        self.proposed = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposed(&mut self, v: u64) {
        self.proposed = v;
    }

    // uint64 signed = 17;


    pub fn get_signed(&self) -> u64 {
        self.signed
    }
    pub fn clear_signed(&mut self) {
        self.signed = 0;
    }

    // Param is passed by value, moved
    pub fn set_signed(&mut self, v: u64) {
        self.signed = v;
    }

    // uint64 missed = 18;


    pub fn get_missed(&self) -> u64 {
        self.missed
    }
    pub fn clear_missed(&mut self) {
        self.missed = 0;
    }

    // Param is passed by value, moved
    pub fn set_missed(&mut self, v: u64) {
        self.missed = v;
    }

    // string timestamp = 19;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.ValidatorUptime uptimes = 20;


    pub fn get_uptimes(&self) -> &[ValidatorUptime] {
        &self.uptimes
    }
    pub fn clear_uptimes(&mut self) {
        self.uptimes.clear();
    }

    // Param is passed by value, moved
    pub fn set_uptimes(&mut self, v: ::protobuf::RepeatedField<ValidatorUptime>) {
        self.uptimes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uptimes(&mut self) -> &mut ::protobuf::RepeatedField<ValidatorUptime> {
        &mut self.uptimes
    }

    // Take field
    pub fn take_uptimes(&mut self) -> ::protobuf::RepeatedField<ValidatorUptime> {
        ::std::mem::replace(&mut self.uptimes, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_explorer_rpc.SlashingEvent slashing_events = 21;


    pub fn get_slashing_events(&self) -> &[SlashingEvent] {
        &self.slashing_events
    }
    pub fn clear_slashing_events(&mut self) {
        self.slashing_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_slashing_events(&mut self, v: ::protobuf::RepeatedField<SlashingEvent>) {
        self.slashing_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slashing_events(&mut self) -> &mut ::protobuf::RepeatedField<SlashingEvent> {
        &mut self.slashing_events
    }

    // Take field
    pub fn take_slashing_events(&mut self) -> ::protobuf::RepeatedField<SlashingEvent> {
        ::std::mem::replace(&mut self.slashing_events, ::protobuf::RepeatedField::new())
    }

    // double uptime_percentage = 22;


    pub fn get_uptime_percentage(&self) -> f64 {
        self.uptime_percentage
    }
    pub fn clear_uptime_percentage(&mut self) {
        self.uptime_percentage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_uptime_percentage(&mut self, v: f64) {
        self.uptime_percentage = v;
    }
}

impl ::protobuf::Message for Validator {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.uptimes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slashing_events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operator_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consensus_address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.jailed = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.status = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tokens)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delegator_shares)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.unbonding_height = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unbonding_time)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commission_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commission_max_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commission_max_change_rate)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.commission_update_time)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.proposed = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.signed = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missed = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uptimes)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slashing_events)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.uptime_percentage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.moniker);
        }
        if !self.operator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.operator_address);
        }
        if !self.consensus_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.consensus_address);
        }
        if self.jailed != false {
            my_size += 2;
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.status);
        }
        if !self.tokens.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.tokens);
        }
        if !self.delegator_shares.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.delegator_shares);
        }
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unbonding_height != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(10, self.unbonding_height);
        }
        if !self.unbonding_time.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.unbonding_time);
        }
        if !self.commission_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.commission_rate);
        }
        if !self.commission_max_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.commission_max_rate);
        }
        if !self.commission_max_change_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.commission_max_change_rate);
        }
        if !self.commission_update_time.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.commission_update_time);
        }
        if self.proposed != 0 {
            my_size += ::protobuf::rt::value_size(16, self.proposed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.signed != 0 {
            my_size += ::protobuf::rt::value_size(17, self.signed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.missed != 0 {
            my_size += ::protobuf::rt::value_size(18, self.missed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.timestamp);
        }
        for value in &self.uptimes {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.slashing_events {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.uptime_percentage != 0. {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.moniker.is_empty() {
            os.write_string(2, &self.moniker)?;
        }
        if !self.operator_address.is_empty() {
            os.write_string(3, &self.operator_address)?;
        }
        if !self.consensus_address.is_empty() {
            os.write_string(4, &self.consensus_address)?;
        }
        if self.jailed != false {
            os.write_bool(5, self.jailed)?;
        }
        if self.status != 0 {
            os.write_sint32(6, self.status)?;
        }
        if !self.tokens.is_empty() {
            os.write_string(7, &self.tokens)?;
        }
        if !self.delegator_shares.is_empty() {
            os.write_string(8, &self.delegator_shares)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unbonding_height != 0 {
            os.write_sint64(10, self.unbonding_height)?;
        }
        if !self.unbonding_time.is_empty() {
            os.write_string(11, &self.unbonding_time)?;
        }
        if !self.commission_rate.is_empty() {
            os.write_string(12, &self.commission_rate)?;
        }
        if !self.commission_max_rate.is_empty() {
            os.write_string(13, &self.commission_max_rate)?;
        }
        if !self.commission_max_change_rate.is_empty() {
            os.write_string(14, &self.commission_max_change_rate)?;
        }
        if !self.commission_update_time.is_empty() {
            os.write_string(15, &self.commission_update_time)?;
        }
        if self.proposed != 0 {
            os.write_uint64(16, self.proposed)?;
        }
        if self.signed != 0 {
            os.write_uint64(17, self.signed)?;
        }
        if self.missed != 0 {
            os.write_uint64(18, self.missed)?;
        }
        if !self.timestamp.is_empty() {
            os.write_string(19, &self.timestamp)?;
        }
        for v in &self.uptimes {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.slashing_events {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.uptime_percentage != 0. {
            os.write_double(22, self.uptime_percentage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validator {
        Validator::new()
    }

    fn default_instance() -> &'static Validator {
        static instance: ::protobuf::rt::LazyV2<Validator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Validator::new)
    }
}

impl ::protobuf::Clear for Validator {
    fn clear(&mut self) {
        self.id.clear();
        self.moniker.clear();
        self.operator_address.clear();
        self.consensus_address.clear();
        self.jailed = false;
        self.status = 0;
        self.tokens.clear();
        self.delegator_shares.clear();
        self.description.clear();
        self.unbonding_height = 0;
        self.unbonding_time.clear();
        self.commission_rate.clear();
        self.commission_max_rate.clear();
        self.commission_max_change_rate.clear();
        self.commission_update_time.clear();
        self.proposed = 0;
        self.signed = 0;
        self.missed = 0;
        self.timestamp.clear();
        self.uptimes.clear();
        self.slashing_events.clear();
        self.uptime_percentage = 0.;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Validator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatorDescription {
    // message fields
    pub moniker: ::std::string::String,
    pub identity: ::std::string::String,
    pub website: ::std::string::String,
    pub security_contact: ::std::string::String,
    pub details: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorDescription {
    fn default() -> &'a ValidatorDescription {
        <ValidatorDescription as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorDescription {
    pub fn new() -> ValidatorDescription {
        ::std::default::Default::default()
    }

    // string moniker = 1;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string identity = 2;


    pub fn get_identity(&self) -> &str {
        &self.identity
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: ::std::string::String) {
        self.identity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut ::std::string::String {
        &mut self.identity
    }

    // Take field
    pub fn take_identity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity, ::std::string::String::new())
    }

    // string website = 3;


    pub fn get_website(&self) -> &str {
        &self.website
    }
    pub fn clear_website(&mut self) {
        self.website.clear();
    }

    // Param is passed by value, moved
    pub fn set_website(&mut self, v: ::std::string::String) {
        self.website = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website(&mut self) -> &mut ::std::string::String {
        &mut self.website
    }

    // Take field
    pub fn take_website(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.website, ::std::string::String::new())
    }

    // string security_contact = 4;


    pub fn get_security_contact(&self) -> &str {
        &self.security_contact
    }
    pub fn clear_security_contact(&mut self) {
        self.security_contact.clear();
    }

    // Param is passed by value, moved
    pub fn set_security_contact(&mut self, v: ::std::string::String) {
        self.security_contact = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_contact(&mut self) -> &mut ::std::string::String {
        &mut self.security_contact
    }

    // Take field
    pub fn take_security_contact(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.security_contact, ::std::string::String::new())
    }

    // string details = 5;


    pub fn get_details(&self) -> &str {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.details, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ValidatorDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.website)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.security_contact)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.moniker);
        }
        if !self.identity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity);
        }
        if !self.website.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.website);
        }
        if !self.security_contact.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security_contact);
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.moniker.is_empty() {
            os.write_string(1, &self.moniker)?;
        }
        if !self.identity.is_empty() {
            os.write_string(2, &self.identity)?;
        }
        if !self.website.is_empty() {
            os.write_string(3, &self.website)?;
        }
        if !self.security_contact.is_empty() {
            os.write_string(4, &self.security_contact)?;
        }
        if !self.details.is_empty() {
            os.write_string(5, &self.details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorDescription {
        ValidatorDescription::new()
    }

    fn default_instance() -> &'static ValidatorDescription {
        static instance: ::protobuf::rt::LazyV2<ValidatorDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorDescription::new)
    }
}

impl ::protobuf::Clear for ValidatorDescription {
    fn clear(&mut self) {
        self.moniker.clear();
        self.identity.clear();
        self.website.clear();
        self.security_contact.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidatorUptime {
    // message fields
    pub block_number: u64,
    pub status: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorUptime {
    fn default() -> &'a ValidatorUptime {
        <ValidatorUptime as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorUptime {
    pub fn new() -> ValidatorUptime {
        ::std::default::Default::default()
    }

    // uint64 block_number = 1;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string status = 2;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ValidatorUptime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_number != 0 {
            os.write_uint64(1, self.block_number)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorUptime {
        ValidatorUptime::new()
    }

    fn default_instance() -> &'static ValidatorUptime {
        static instance: ::protobuf::rt::LazyV2<ValidatorUptime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorUptime::new)
    }
}

impl ::protobuf::Clear for ValidatorUptime {
    fn clear(&mut self) {
        self.block_number = 0;
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorUptime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SlashingEvent {
    // message fields
    pub block_number: u64,
    pub block_timestamp: ::std::string::String,
    pub address: ::std::string::String,
    pub power: u64,
    pub reason: ::std::string::String,
    pub jailed: ::std::string::String,
    pub missed_blocks: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SlashingEvent {
    fn default() -> &'a SlashingEvent {
        <SlashingEvent as ::protobuf::Message>::default_instance()
    }
}

impl SlashingEvent {
    pub fn new() -> SlashingEvent {
        ::std::default::Default::default()
    }

    // uint64 block_number = 1;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string block_timestamp = 2;


    pub fn get_block_timestamp(&self) -> &str {
        &self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: ::std::string::String) {
        self.block_timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.block_timestamp
    }

    // Take field
    pub fn take_block_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_timestamp, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 power = 4;


    pub fn get_power(&self) -> u64 {
        self.power
    }
    pub fn clear_power(&mut self) {
        self.power = 0;
    }

    // Param is passed by value, moved
    pub fn set_power(&mut self, v: u64) {
        self.power = v;
    }

    // string reason = 5;


    pub fn get_reason(&self) -> &str {
        &self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        &mut self.reason
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reason, ::std::string::String::new())
    }

    // string jailed = 6;


    pub fn get_jailed(&self) -> &str {
        &self.jailed
    }
    pub fn clear_jailed(&mut self) {
        self.jailed.clear();
    }

    // Param is passed by value, moved
    pub fn set_jailed(&mut self, v: ::std::string::String) {
        self.jailed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jailed(&mut self) -> &mut ::std::string::String {
        &mut self.jailed
    }

    // Take field
    pub fn take_jailed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jailed, ::std::string::String::new())
    }

    // uint64 missed_blocks = 7;


    pub fn get_missed_blocks(&self) -> u64 {
        self.missed_blocks
    }
    pub fn clear_missed_blocks(&mut self) {
        self.missed_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_missed_blocks(&mut self, v: u64) {
        self.missed_blocks = v;
    }
}

impl ::protobuf::Message for SlashingEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_timestamp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.power = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jailed)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missed_blocks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block_timestamp);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.power != 0 {
            my_size += ::protobuf::rt::value_size(4, self.power, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.reason.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.reason);
        }
        if !self.jailed.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.jailed);
        }
        if self.missed_blocks != 0 {
            my_size += ::protobuf::rt::value_size(7, self.missed_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_number != 0 {
            os.write_uint64(1, self.block_number)?;
        }
        if !self.block_timestamp.is_empty() {
            os.write_string(2, &self.block_timestamp)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.power != 0 {
            os.write_uint64(4, self.power)?;
        }
        if !self.reason.is_empty() {
            os.write_string(5, &self.reason)?;
        }
        if !self.jailed.is_empty() {
            os.write_string(6, &self.jailed)?;
        }
        if self.missed_blocks != 0 {
            os.write_uint64(7, self.missed_blocks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SlashingEvent {
        SlashingEvent::new()
    }

    fn default_instance() -> &'static SlashingEvent {
        static instance: ::protobuf::rt::LazyV2<SlashingEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SlashingEvent::new)
    }
}

impl ::protobuf::Clear for SlashingEvent {
    fn clear(&mut self) {
        self.block_number = 0;
        self.block_timestamp.clear();
        self.address.clear();
        self.power = 0;
        self.reason.clear();
        self.jailed.clear();
        self.missed_blocks = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SlashingEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorRequest {
    fn default() -> &'a GetValidatorRequest {
        <GetValidatorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorRequest {
    pub fn new() -> GetValidatorRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetValidatorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorRequest {
        GetValidatorRequest::new()
    }

    fn default_instance() -> &'static GetValidatorRequest {
        static instance: ::protobuf::rt::LazyV2<GetValidatorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorRequest::new)
    }
}

impl ::protobuf::Clear for GetValidatorRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorResponse {
    // message fields
    pub s: ::std::string::String,
    pub errmsg: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<Validator>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorResponse {
    fn default() -> &'a GetValidatorResponse {
        <GetValidatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorResponse {
    pub fn new() -> GetValidatorResponse {
        ::std::default::Default::default()
    }

    // string s = 1;


    pub fn get_s(&self) -> &str {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::string::String) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::string::String {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s, ::std::string::String::new())
    }

    // string errmsg = 2;


    pub fn get_errmsg(&self) -> &str {
        &self.errmsg
    }
    pub fn clear_errmsg(&mut self) {
        self.errmsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errmsg(&mut self, v: ::std::string::String) {
        self.errmsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errmsg(&mut self) -> &mut ::std::string::String {
        &mut self.errmsg
    }

    // Take field
    pub fn take_errmsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errmsg, ::std::string::String::new())
    }

    // .injective_explorer_rpc.Validator data = 3;


    pub fn get_data(&self) -> &Validator {
        self.data.as_ref().unwrap_or_else(|| <Validator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Validator) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Validator {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Validator {
        self.data.take().unwrap_or_else(|| Validator::new())
    }
}

impl ::protobuf::Message for GetValidatorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errmsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.s);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.s.is_empty() {
            os.write_string(1, &self.s)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorResponse {
        GetValidatorResponse::new()
    }

    fn default_instance() -> &'static GetValidatorResponse {
        static instance: ::protobuf::rt::LazyV2<GetValidatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorResponse::new)
    }
}

impl ::protobuf::Clear for GetValidatorResponse {
    fn clear(&mut self) {
        self.s.clear();
        self.errmsg.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorUptimeRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorUptimeRequest {
    fn default() -> &'a GetValidatorUptimeRequest {
        <GetValidatorUptimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorUptimeRequest {
    pub fn new() -> GetValidatorUptimeRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetValidatorUptimeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorUptimeRequest {
        GetValidatorUptimeRequest::new()
    }

    fn default_instance() -> &'static GetValidatorUptimeRequest {
        static instance: ::protobuf::rt::LazyV2<GetValidatorUptimeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorUptimeRequest::new)
    }
}

impl ::protobuf::Clear for GetValidatorUptimeRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorUptimeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetValidatorUptimeResponse {
    // message fields
    pub s: ::std::string::String,
    pub errmsg: ::std::string::String,
    pub data: ::protobuf::RepeatedField<ValidatorUptime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetValidatorUptimeResponse {
    fn default() -> &'a GetValidatorUptimeResponse {
        <GetValidatorUptimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetValidatorUptimeResponse {
    pub fn new() -> GetValidatorUptimeResponse {
        ::std::default::Default::default()
    }

    // string s = 1;


    pub fn get_s(&self) -> &str {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::string::String) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::string::String {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s, ::std::string::String::new())
    }

    // string errmsg = 2;


    pub fn get_errmsg(&self) -> &str {
        &self.errmsg
    }
    pub fn clear_errmsg(&mut self) {
        self.errmsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errmsg(&mut self, v: ::std::string::String) {
        self.errmsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errmsg(&mut self) -> &mut ::std::string::String {
        &mut self.errmsg
    }

    // Take field
    pub fn take_errmsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errmsg, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.ValidatorUptime data = 3;


    pub fn get_data(&self) -> &[ValidatorUptime] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<ValidatorUptime>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<ValidatorUptime> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<ValidatorUptime> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetValidatorUptimeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errmsg)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.s);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.s.is_empty() {
            os.write_string(1, &self.s)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        for v in &self.data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetValidatorUptimeResponse {
        GetValidatorUptimeResponse::new()
    }

    fn default_instance() -> &'static GetValidatorUptimeResponse {
        static instance: ::protobuf::rt::LazyV2<GetValidatorUptimeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetValidatorUptimeResponse::new)
    }
}

impl ::protobuf::Clear for GetValidatorUptimeResponse {
    fn clear(&mut self) {
        self.s.clear();
        self.errmsg.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetValidatorUptimeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTxsRequest {
    // message fields
    pub before: u64,
    pub after: u64,
    pub limit: i32,
    pub skip: u64,
    pub field_type: ::std::string::String,
    pub module: ::std::string::String,
    pub from_number: i64,
    pub to_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxsRequest {
    fn default() -> &'a GetTxsRequest {
        <GetTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTxsRequest {
    pub fn new() -> GetTxsRequest {
        ::std::default::Default::default()
    }

    // uint64 before = 1;


    pub fn get_before(&self) -> u64 {
        self.before
    }
    pub fn clear_before(&mut self) {
        self.before = 0;
    }

    // Param is passed by value, moved
    pub fn set_before(&mut self, v: u64) {
        self.before = v;
    }

    // uint64 after = 2;


    pub fn get_after(&self) -> u64 {
        self.after
    }
    pub fn clear_after(&mut self) {
        self.after = 0;
    }

    // Param is passed by value, moved
    pub fn set_after(&mut self, v: u64) {
        self.after = v;
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // string type = 5;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string module = 6;


    pub fn get_module(&self) -> &str {
        &self.module
    }
    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::string::String) {
        self.module = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ::std::string::String {
        &mut self.module
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module, ::std::string::String::new())
    }

    // sint64 from_number = 7;


    pub fn get_from_number(&self) -> i64 {
        self.from_number
    }
    pub fn clear_from_number(&mut self) {
        self.from_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_number(&mut self, v: i64) {
        self.from_number = v;
    }

    // sint64 to_number = 8;


    pub fn get_to_number(&self) -> i64 {
        self.to_number
    }
    pub fn clear_to_number(&mut self) {
        self.to_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_number(&mut self, v: i64) {
        self.to_number = v;
    }
}

impl ::protobuf::Message for GetTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.before = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.after = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.from_number = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.to_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.before != 0 {
            my_size += ::protobuf::rt::value_size(1, self.before, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.after != 0 {
            my_size += ::protobuf::rt::value_size(2, self.after, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.field_type);
        }
        if !self.module.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.module);
        }
        if self.from_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.from_number);
        }
        if self.to_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.to_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.before != 0 {
            os.write_uint64(1, self.before)?;
        }
        if self.after != 0 {
            os.write_uint64(2, self.after)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(5, &self.field_type)?;
        }
        if !self.module.is_empty() {
            os.write_string(6, &self.module)?;
        }
        if self.from_number != 0 {
            os.write_sint64(7, self.from_number)?;
        }
        if self.to_number != 0 {
            os.write_sint64(8, self.to_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxsRequest {
        GetTxsRequest::new()
    }

    fn default_instance() -> &'static GetTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetTxsRequest {
    fn clear(&mut self) {
        self.before = 0;
        self.after = 0;
        self.limit = 0;
        self.skip = 0;
        self.field_type.clear();
        self.module.clear();
        self.from_number = 0;
        self.to_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTxsResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<TxData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxsResponse {
    fn default() -> &'a GetTxsResponse {
        <GetTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTxsResponse {
    pub fn new() -> GetTxsResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.TxData data = 2;


    pub fn get_data(&self) -> &[TxData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<TxData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<TxData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<TxData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxsResponse {
        GetTxsResponse::new()
    }

    fn default_instance() -> &'static GetTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetTxsResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTxByTxHashRequest {
    // message fields
    pub hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxByTxHashRequest {
    fn default() -> &'a GetTxByTxHashRequest {
        <GetTxByTxHashRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTxByTxHashRequest {
    pub fn new() -> GetTxByTxHashRequest {
        ::std::default::Default::default()
    }

    // string hash = 1;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTxByTxHashRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxByTxHashRequest {
        GetTxByTxHashRequest::new()
    }

    fn default_instance() -> &'static GetTxByTxHashRequest {
        static instance: ::protobuf::rt::LazyV2<GetTxByTxHashRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxByTxHashRequest::new)
    }
}

impl ::protobuf::Clear for GetTxByTxHashRequest {
    fn clear(&mut self) {
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxByTxHashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTxByTxHashResponse {
    // message fields
    pub s: ::std::string::String,
    pub errmsg: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<TxDetailData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTxByTxHashResponse {
    fn default() -> &'a GetTxByTxHashResponse {
        <GetTxByTxHashResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTxByTxHashResponse {
    pub fn new() -> GetTxByTxHashResponse {
        ::std::default::Default::default()
    }

    // string s = 1;


    pub fn get_s(&self) -> &str {
        &self.s
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::string::String) {
        self.s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::string::String {
        &mut self.s
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.s, ::std::string::String::new())
    }

    // string errmsg = 2;


    pub fn get_errmsg(&self) -> &str {
        &self.errmsg
    }
    pub fn clear_errmsg(&mut self) {
        self.errmsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errmsg(&mut self, v: ::std::string::String) {
        self.errmsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errmsg(&mut self) -> &mut ::std::string::String {
        &mut self.errmsg
    }

    // Take field
    pub fn take_errmsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errmsg, ::std::string::String::new())
    }

    // .injective_explorer_rpc.TxDetailData data = 3;


    pub fn get_data(&self) -> &TxDetailData {
        self.data.as_ref().unwrap_or_else(|| <TxDetailData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: TxDetailData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut TxDetailData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> TxDetailData {
        self.data.take().unwrap_or_else(|| TxDetailData::new())
    }
}

impl ::protobuf::Message for GetTxByTxHashResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.s)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errmsg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.s.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.s);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.s.is_empty() {
            os.write_string(1, &self.s)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxByTxHashResponse {
        GetTxByTxHashResponse::new()
    }

    fn default_instance() -> &'static GetTxByTxHashResponse {
        static instance: ::protobuf::rt::LazyV2<GetTxByTxHashResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTxByTxHashResponse::new)
    }
}

impl ::protobuf::Clear for GetTxByTxHashResponse {
    fn clear(&mut self) {
        self.s.clear();
        self.errmsg.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxByTxHashResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPeggyDepositTxsRequest {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub limit: i32,
    pub skip: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeggyDepositTxsRequest {
    fn default() -> &'a GetPeggyDepositTxsRequest {
        <GetPeggyDepositTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeggyDepositTxsRequest {
    pub fn new() -> GetPeggyDepositTxsRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }
}

impl ::protobuf::Message for GetPeggyDepositTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeggyDepositTxsRequest {
        GetPeggyDepositTxsRequest::new()
    }

    fn default_instance() -> &'static GetPeggyDepositTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetPeggyDepositTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPeggyDepositTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetPeggyDepositTxsRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.limit = 0;
        self.skip = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeggyDepositTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPeggyDepositTxsResponse {
    // message fields
    pub field: ::protobuf::RepeatedField<PeggyDepositTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeggyDepositTxsResponse {
    fn default() -> &'a GetPeggyDepositTxsResponse {
        <GetPeggyDepositTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeggyDepositTxsResponse {
    pub fn new() -> GetPeggyDepositTxsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.PeggyDepositTx field = 1;


    pub fn get_field(&self) -> &[PeggyDepositTx] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<PeggyDepositTx>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<PeggyDepositTx> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<PeggyDepositTx> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeggyDepositTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeggyDepositTxsResponse {
        GetPeggyDepositTxsResponse::new()
    }

    fn default_instance() -> &'static GetPeggyDepositTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetPeggyDepositTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPeggyDepositTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetPeggyDepositTxsResponse {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeggyDepositTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeggyDepositTx {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub event_nonce: u64,
    pub event_height: u64,
    pub amount: ::std::string::String,
    pub denom: ::std::string::String,
    pub orchestrator_address: ::std::string::String,
    pub state: ::std::string::String,
    pub claim_type: i32,
    pub tx_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::std::string::String,
    pub updated_at: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeggyDepositTx {
    fn default() -> &'a PeggyDepositTx {
        <PeggyDepositTx as ::protobuf::Message>::default_instance()
    }
}

impl PeggyDepositTx {
    pub fn new() -> PeggyDepositTx {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // uint64 event_nonce = 3;


    pub fn get_event_nonce(&self) -> u64 {
        self.event_nonce
    }
    pub fn clear_event_nonce(&mut self) {
        self.event_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_nonce(&mut self, v: u64) {
        self.event_nonce = v;
    }

    // uint64 event_height = 4;


    pub fn get_event_height(&self) -> u64 {
        self.event_height
    }
    pub fn clear_event_height(&mut self) {
        self.event_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_height(&mut self, v: u64) {
        self.event_height = v;
    }

    // string amount = 5;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    // string denom = 6;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string orchestrator_address = 7;


    pub fn get_orchestrator_address(&self) -> &str {
        &self.orchestrator_address
    }
    pub fn clear_orchestrator_address(&mut self) {
        self.orchestrator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_orchestrator_address(&mut self, v: ::std::string::String) {
        self.orchestrator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orchestrator_address(&mut self) -> &mut ::std::string::String {
        &mut self.orchestrator_address
    }

    // Take field
    pub fn take_orchestrator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.orchestrator_address, ::std::string::String::new())
    }

    // string state = 8;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint32 claim_type = 9;


    pub fn get_claim_type(&self) -> i32 {
        self.claim_type
    }
    pub fn clear_claim_type(&mut self) {
        self.claim_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_claim_type(&mut self, v: i32) {
        self.claim_type = v;
    }

    // repeated string tx_hashes = 10;


    pub fn get_tx_hashes(&self) -> &[::std::string::String] {
        &self.tx_hashes
    }
    pub fn clear_tx_hashes(&mut self) {
        self.tx_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tx_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tx_hashes
    }

    // Take field
    pub fn take_tx_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tx_hashes, ::protobuf::RepeatedField::new())
    }

    // string created_at = 11;


    pub fn get_created_at(&self) -> &str {
        &self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::std::string::String) {
        self.created_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::std::string::String {
        &mut self.created_at
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.created_at, ::std::string::String::new())
    }

    // string updated_at = 12;


    pub fn get_updated_at(&self) -> &str {
        &self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::std::string::String) {
        self.updated_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::std::string::String {
        &mut self.updated_at
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.updated_at, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PeggyDepositTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_nonce = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_height = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.orchestrator_address)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.claim_type = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tx_hashes)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.created_at)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if self.event_nonce != 0 {
            my_size += ::protobuf::rt::value_size(3, self.event_nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.event_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.amount);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.denom);
        }
        if !self.orchestrator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.orchestrator_address);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.state);
        }
        if self.claim_type != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.claim_type);
        }
        for value in &self.tx_hashes {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if self.event_nonce != 0 {
            os.write_uint64(3, self.event_nonce)?;
        }
        if self.event_height != 0 {
            os.write_uint64(4, self.event_height)?;
        }
        if !self.amount.is_empty() {
            os.write_string(5, &self.amount)?;
        }
        if !self.denom.is_empty() {
            os.write_string(6, &self.denom)?;
        }
        if !self.orchestrator_address.is_empty() {
            os.write_string(7, &self.orchestrator_address)?;
        }
        if !self.state.is_empty() {
            os.write_string(8, &self.state)?;
        }
        if self.claim_type != 0 {
            os.write_sint32(9, self.claim_type)?;
        }
        for v in &self.tx_hashes {
            os.write_string(10, &v)?;
        };
        if !self.created_at.is_empty() {
            os.write_string(11, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(12, &self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeggyDepositTx {
        PeggyDepositTx::new()
    }

    fn default_instance() -> &'static PeggyDepositTx {
        static instance: ::protobuf::rt::LazyV2<PeggyDepositTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeggyDepositTx::new)
    }
}

impl ::protobuf::Clear for PeggyDepositTx {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.event_nonce = 0;
        self.event_height = 0;
        self.amount.clear();
        self.denom.clear();
        self.orchestrator_address.clear();
        self.state.clear();
        self.claim_type = 0;
        self.tx_hashes.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PeggyDepositTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPeggyWithdrawalTxsRequest {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub limit: i32,
    pub skip: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeggyWithdrawalTxsRequest {
    fn default() -> &'a GetPeggyWithdrawalTxsRequest {
        <GetPeggyWithdrawalTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeggyWithdrawalTxsRequest {
    pub fn new() -> GetPeggyWithdrawalTxsRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }
}

impl ::protobuf::Message for GetPeggyWithdrawalTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeggyWithdrawalTxsRequest {
        GetPeggyWithdrawalTxsRequest::new()
    }

    fn default_instance() -> &'static GetPeggyWithdrawalTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetPeggyWithdrawalTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPeggyWithdrawalTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetPeggyWithdrawalTxsRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.limit = 0;
        self.skip = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeggyWithdrawalTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetPeggyWithdrawalTxsResponse {
    // message fields
    pub field: ::protobuf::RepeatedField<PeggyWithdrawalTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeggyWithdrawalTxsResponse {
    fn default() -> &'a GetPeggyWithdrawalTxsResponse {
        <GetPeggyWithdrawalTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeggyWithdrawalTxsResponse {
    pub fn new() -> GetPeggyWithdrawalTxsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.PeggyWithdrawalTx field = 1;


    pub fn get_field(&self) -> &[PeggyWithdrawalTx] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<PeggyWithdrawalTx>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<PeggyWithdrawalTx> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<PeggyWithdrawalTx> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeggyWithdrawalTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeggyWithdrawalTxsResponse {
        GetPeggyWithdrawalTxsResponse::new()
    }

    fn default_instance() -> &'static GetPeggyWithdrawalTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetPeggyWithdrawalTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPeggyWithdrawalTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetPeggyWithdrawalTxsResponse {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeggyWithdrawalTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PeggyWithdrawalTx {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub amount: ::std::string::String,
    pub denom: ::std::string::String,
    pub bridge_fee: ::std::string::String,
    pub outgoing_tx_id: u64,
    pub batch_timeout: u64,
    pub batch_nonce: u64,
    pub orchestrator_address: ::std::string::String,
    pub event_nonce: u64,
    pub event_height: u64,
    pub state: ::std::string::String,
    pub claim_type: i32,
    pub tx_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::std::string::String,
    pub updated_at: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeggyWithdrawalTx {
    fn default() -> &'a PeggyWithdrawalTx {
        <PeggyWithdrawalTx as ::protobuf::Message>::default_instance()
    }
}

impl PeggyWithdrawalTx {
    pub fn new() -> PeggyWithdrawalTx {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // string amount = 3;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    // string denom = 4;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string bridge_fee = 5;


    pub fn get_bridge_fee(&self) -> &str {
        &self.bridge_fee
    }
    pub fn clear_bridge_fee(&mut self) {
        self.bridge_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_bridge_fee(&mut self, v: ::std::string::String) {
        self.bridge_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bridge_fee(&mut self) -> &mut ::std::string::String {
        &mut self.bridge_fee
    }

    // Take field
    pub fn take_bridge_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bridge_fee, ::std::string::String::new())
    }

    // uint64 outgoing_tx_id = 6;


    pub fn get_outgoing_tx_id(&self) -> u64 {
        self.outgoing_tx_id
    }
    pub fn clear_outgoing_tx_id(&mut self) {
        self.outgoing_tx_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_tx_id(&mut self, v: u64) {
        self.outgoing_tx_id = v;
    }

    // uint64 batch_timeout = 7;


    pub fn get_batch_timeout(&self) -> u64 {
        self.batch_timeout
    }
    pub fn clear_batch_timeout(&mut self) {
        self.batch_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_timeout(&mut self, v: u64) {
        self.batch_timeout = v;
    }

    // uint64 batch_nonce = 8;


    pub fn get_batch_nonce(&self) -> u64 {
        self.batch_nonce
    }
    pub fn clear_batch_nonce(&mut self) {
        self.batch_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_nonce(&mut self, v: u64) {
        self.batch_nonce = v;
    }

    // string orchestrator_address = 9;


    pub fn get_orchestrator_address(&self) -> &str {
        &self.orchestrator_address
    }
    pub fn clear_orchestrator_address(&mut self) {
        self.orchestrator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_orchestrator_address(&mut self, v: ::std::string::String) {
        self.orchestrator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orchestrator_address(&mut self) -> &mut ::std::string::String {
        &mut self.orchestrator_address
    }

    // Take field
    pub fn take_orchestrator_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.orchestrator_address, ::std::string::String::new())
    }

    // uint64 event_nonce = 10;


    pub fn get_event_nonce(&self) -> u64 {
        self.event_nonce
    }
    pub fn clear_event_nonce(&mut self) {
        self.event_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_nonce(&mut self, v: u64) {
        self.event_nonce = v;
    }

    // uint64 event_height = 11;


    pub fn get_event_height(&self) -> u64 {
        self.event_height
    }
    pub fn clear_event_height(&mut self) {
        self.event_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_event_height(&mut self, v: u64) {
        self.event_height = v;
    }

    // string state = 12;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint32 claim_type = 13;


    pub fn get_claim_type(&self) -> i32 {
        self.claim_type
    }
    pub fn clear_claim_type(&mut self) {
        self.claim_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_claim_type(&mut self, v: i32) {
        self.claim_type = v;
    }

    // repeated string tx_hashes = 14;


    pub fn get_tx_hashes(&self) -> &[::std::string::String] {
        &self.tx_hashes
    }
    pub fn clear_tx_hashes(&mut self) {
        self.tx_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tx_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tx_hashes
    }

    // Take field
    pub fn take_tx_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tx_hashes, ::protobuf::RepeatedField::new())
    }

    // string created_at = 15;


    pub fn get_created_at(&self) -> &str {
        &self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::std::string::String) {
        self.created_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::std::string::String {
        &mut self.created_at
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.created_at, ::std::string::String::new())
    }

    // string updated_at = 16;


    pub fn get_updated_at(&self) -> &str {
        &self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::std::string::String) {
        self.updated_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::std::string::String {
        &mut self.updated_at
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.updated_at, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PeggyWithdrawalTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bridge_fee)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_tx_id = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.batch_timeout = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.batch_nonce = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.orchestrator_address)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_nonce = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_height = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.claim_type = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tx_hashes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.created_at)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.amount);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.denom);
        }
        if !self.bridge_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.bridge_fee);
        }
        if self.outgoing_tx_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.outgoing_tx_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.batch_timeout != 0 {
            my_size += ::protobuf::rt::value_size(7, self.batch_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.batch_nonce != 0 {
            my_size += ::protobuf::rt::value_size(8, self.batch_nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.orchestrator_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.orchestrator_address);
        }
        if self.event_nonce != 0 {
            my_size += ::protobuf::rt::value_size(10, self.event_nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_height != 0 {
            my_size += ::protobuf::rt::value_size(11, self.event_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.state);
        }
        if self.claim_type != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.claim_type);
        }
        for value in &self.tx_hashes {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.amount.is_empty() {
            os.write_string(3, &self.amount)?;
        }
        if !self.denom.is_empty() {
            os.write_string(4, &self.denom)?;
        }
        if !self.bridge_fee.is_empty() {
            os.write_string(5, &self.bridge_fee)?;
        }
        if self.outgoing_tx_id != 0 {
            os.write_uint64(6, self.outgoing_tx_id)?;
        }
        if self.batch_timeout != 0 {
            os.write_uint64(7, self.batch_timeout)?;
        }
        if self.batch_nonce != 0 {
            os.write_uint64(8, self.batch_nonce)?;
        }
        if !self.orchestrator_address.is_empty() {
            os.write_string(9, &self.orchestrator_address)?;
        }
        if self.event_nonce != 0 {
            os.write_uint64(10, self.event_nonce)?;
        }
        if self.event_height != 0 {
            os.write_uint64(11, self.event_height)?;
        }
        if !self.state.is_empty() {
            os.write_string(12, &self.state)?;
        }
        if self.claim_type != 0 {
            os.write_sint32(13, self.claim_type)?;
        }
        for v in &self.tx_hashes {
            os.write_string(14, &v)?;
        };
        if !self.created_at.is_empty() {
            os.write_string(15, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(16, &self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeggyWithdrawalTx {
        PeggyWithdrawalTx::new()
    }

    fn default_instance() -> &'static PeggyWithdrawalTx {
        static instance: ::protobuf::rt::LazyV2<PeggyWithdrawalTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PeggyWithdrawalTx::new)
    }
}

impl ::protobuf::Clear for PeggyWithdrawalTx {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.amount.clear();
        self.denom.clear();
        self.bridge_fee.clear();
        self.outgoing_tx_id = 0;
        self.batch_timeout = 0;
        self.batch_nonce = 0;
        self.orchestrator_address.clear();
        self.event_nonce = 0;
        self.event_height = 0;
        self.state.clear();
        self.claim_type = 0;
        self.tx_hashes.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PeggyWithdrawalTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetIBCTransferTxsRequest {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub src_channel: ::std::string::String,
    pub src_port: ::std::string::String,
    pub dest_channel: ::std::string::String,
    pub dest_port: ::std::string::String,
    pub limit: i32,
    pub skip: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIBCTransferTxsRequest {
    fn default() -> &'a GetIBCTransferTxsRequest {
        <GetIBCTransferTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIBCTransferTxsRequest {
    pub fn new() -> GetIBCTransferTxsRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // string src_channel = 3;


    pub fn get_src_channel(&self) -> &str {
        &self.src_channel
    }
    pub fn clear_src_channel(&mut self) {
        self.src_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_channel(&mut self, v: ::std::string::String) {
        self.src_channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_channel(&mut self) -> &mut ::std::string::String {
        &mut self.src_channel
    }

    // Take field
    pub fn take_src_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_channel, ::std::string::String::new())
    }

    // string src_port = 4;


    pub fn get_src_port(&self) -> &str {
        &self.src_port
    }
    pub fn clear_src_port(&mut self) {
        self.src_port.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_port(&mut self, v: ::std::string::String) {
        self.src_port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_port(&mut self) -> &mut ::std::string::String {
        &mut self.src_port
    }

    // Take field
    pub fn take_src_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_port, ::std::string::String::new())
    }

    // string dest_channel = 5;


    pub fn get_dest_channel(&self) -> &str {
        &self.dest_channel
    }
    pub fn clear_dest_channel(&mut self) {
        self.dest_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_channel(&mut self, v: ::std::string::String) {
        self.dest_channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_channel(&mut self) -> &mut ::std::string::String {
        &mut self.dest_channel
    }

    // Take field
    pub fn take_dest_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest_channel, ::std::string::String::new())
    }

    // string dest_port = 6;


    pub fn get_dest_port(&self) -> &str {
        &self.dest_port
    }
    pub fn clear_dest_port(&mut self) {
        self.dest_port.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_port(&mut self, v: ::std::string::String) {
        self.dest_port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_port(&mut self) -> &mut ::std::string::String {
        &mut self.dest_port
    }

    // Take field
    pub fn take_dest_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest_port, ::std::string::String::new())
    }

    // sint32 limit = 7;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // uint64 skip = 8;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }
}

impl ::protobuf::Message for GetIBCTransferTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_channel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_port)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest_channel)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest_port)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.src_channel.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.src_channel);
        }
        if !self.src_port.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.src_port);
        }
        if !self.dest_channel.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dest_channel);
        }
        if !self.dest_port.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.dest_port);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.limit);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(8, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.src_channel.is_empty() {
            os.write_string(3, &self.src_channel)?;
        }
        if !self.src_port.is_empty() {
            os.write_string(4, &self.src_port)?;
        }
        if !self.dest_channel.is_empty() {
            os.write_string(5, &self.dest_channel)?;
        }
        if !self.dest_port.is_empty() {
            os.write_string(6, &self.dest_port)?;
        }
        if self.limit != 0 {
            os.write_sint32(7, self.limit)?;
        }
        if self.skip != 0 {
            os.write_uint64(8, self.skip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIBCTransferTxsRequest {
        GetIBCTransferTxsRequest::new()
    }

    fn default_instance() -> &'static GetIBCTransferTxsRequest {
        static instance: ::protobuf::rt::LazyV2<GetIBCTransferTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIBCTransferTxsRequest::new)
    }
}

impl ::protobuf::Clear for GetIBCTransferTxsRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.src_channel.clear();
        self.src_port.clear();
        self.dest_channel.clear();
        self.dest_port.clear();
        self.limit = 0;
        self.skip = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIBCTransferTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetIBCTransferTxsResponse {
    // message fields
    pub field: ::protobuf::RepeatedField<IBCTransferTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIBCTransferTxsResponse {
    fn default() -> &'a GetIBCTransferTxsResponse {
        <GetIBCTransferTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIBCTransferTxsResponse {
    pub fn new() -> GetIBCTransferTxsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.IBCTransferTx field = 1;


    pub fn get_field(&self) -> &[IBCTransferTx] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<IBCTransferTx>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<IBCTransferTx> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<IBCTransferTx> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetIBCTransferTxsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIBCTransferTxsResponse {
        GetIBCTransferTxsResponse::new()
    }

    fn default_instance() -> &'static GetIBCTransferTxsResponse {
        static instance: ::protobuf::rt::LazyV2<GetIBCTransferTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIBCTransferTxsResponse::new)
    }
}

impl ::protobuf::Clear for GetIBCTransferTxsResponse {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIBCTransferTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IBCTransferTx {
    // message fields
    pub sender: ::std::string::String,
    pub receiver: ::std::string::String,
    pub source_port: ::std::string::String,
    pub source_channel: ::std::string::String,
    pub destination_port: ::std::string::String,
    pub destination_channel: ::std::string::String,
    pub amount: ::std::string::String,
    pub denom: ::std::string::String,
    pub timeout_height: ::std::string::String,
    pub timeout_timestamp: u64,
    pub packet_sequence: u64,
    pub data_hex: ::std::vec::Vec<u8>,
    pub state: ::std::string::String,
    pub tx_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::std::string::String,
    pub updated_at: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IBCTransferTx {
    fn default() -> &'a IBCTransferTx {
        <IBCTransferTx as ::protobuf::Message>::default_instance()
    }
}

impl IBCTransferTx {
    pub fn new() -> IBCTransferTx {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string receiver = 2;


    pub fn get_receiver(&self) -> &str {
        &self.receiver
    }
    pub fn clear_receiver(&mut self) {
        self.receiver.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: ::std::string::String) {
        self.receiver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver(&mut self) -> &mut ::std::string::String {
        &mut self.receiver
    }

    // Take field
    pub fn take_receiver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receiver, ::std::string::String::new())
    }

    // string source_port = 3;


    pub fn get_source_port(&self) -> &str {
        &self.source_port
    }
    pub fn clear_source_port(&mut self) {
        self.source_port.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_port(&mut self, v: ::std::string::String) {
        self.source_port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_port(&mut self) -> &mut ::std::string::String {
        &mut self.source_port
    }

    // Take field
    pub fn take_source_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_port, ::std::string::String::new())
    }

    // string source_channel = 4;


    pub fn get_source_channel(&self) -> &str {
        &self.source_channel
    }
    pub fn clear_source_channel(&mut self) {
        self.source_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_channel(&mut self, v: ::std::string::String) {
        self.source_channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_channel(&mut self) -> &mut ::std::string::String {
        &mut self.source_channel
    }

    // Take field
    pub fn take_source_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_channel, ::std::string::String::new())
    }

    // string destination_port = 5;


    pub fn get_destination_port(&self) -> &str {
        &self.destination_port
    }
    pub fn clear_destination_port(&mut self) {
        self.destination_port.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_port(&mut self, v: ::std::string::String) {
        self.destination_port = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_port(&mut self) -> &mut ::std::string::String {
        &mut self.destination_port
    }

    // Take field
    pub fn take_destination_port(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_port, ::std::string::String::new())
    }

    // string destination_channel = 6;


    pub fn get_destination_channel(&self) -> &str {
        &self.destination_channel
    }
    pub fn clear_destination_channel(&mut self) {
        self.destination_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_channel(&mut self, v: ::std::string::String) {
        self.destination_channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_channel(&mut self) -> &mut ::std::string::String {
        &mut self.destination_channel
    }

    // Take field
    pub fn take_destination_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_channel, ::std::string::String::new())
    }

    // string amount = 7;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    // string denom = 8;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string timeout_height = 9;


    pub fn get_timeout_height(&self) -> &str {
        &self.timeout_height
    }
    pub fn clear_timeout_height(&mut self) {
        self.timeout_height.clear();
    }

    // Param is passed by value, moved
    pub fn set_timeout_height(&mut self, v: ::std::string::String) {
        self.timeout_height = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout_height(&mut self) -> &mut ::std::string::String {
        &mut self.timeout_height
    }

    // Take field
    pub fn take_timeout_height(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timeout_height, ::std::string::String::new())
    }

    // uint64 timeout_timestamp = 10;


    pub fn get_timeout_timestamp(&self) -> u64 {
        self.timeout_timestamp
    }
    pub fn clear_timeout_timestamp(&mut self) {
        self.timeout_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_timestamp(&mut self, v: u64) {
        self.timeout_timestamp = v;
    }

    // uint64 packet_sequence = 11;


    pub fn get_packet_sequence(&self) -> u64 {
        self.packet_sequence
    }
    pub fn clear_packet_sequence(&mut self) {
        self.packet_sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_packet_sequence(&mut self, v: u64) {
        self.packet_sequence = v;
    }

    // bytes data_hex = 12;


    pub fn get_data_hex(&self) -> &[u8] {
        &self.data_hex
    }
    pub fn clear_data_hex(&mut self) {
        self.data_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_hex(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_hex(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data_hex
    }

    // Take field
    pub fn take_data_hex(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data_hex, ::std::vec::Vec::new())
    }

    // string state = 13;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // repeated string tx_hashes = 14;


    pub fn get_tx_hashes(&self) -> &[::std::string::String] {
        &self.tx_hashes
    }
    pub fn clear_tx_hashes(&mut self) {
        self.tx_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tx_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tx_hashes
    }

    // Take field
    pub fn take_tx_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tx_hashes, ::protobuf::RepeatedField::new())
    }

    // string created_at = 15;


    pub fn get_created_at(&self) -> &str {
        &self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::std::string::String) {
        self.created_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::std::string::String {
        &mut self.created_at
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.created_at, ::std::string::String::new())
    }

    // string updated_at = 16;


    pub fn get_updated_at(&self) -> &str {
        &self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::std::string::String) {
        self.updated_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::std::string::String {
        &mut self.updated_at
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.updated_at, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IBCTransferTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receiver)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_port)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_channel)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_port)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_channel)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timeout_height)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout_timestamp = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.packet_sequence = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data_hex)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tx_hashes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.created_at)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.receiver.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receiver);
        }
        if !self.source_port.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_port);
        }
        if !self.source_channel.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.source_channel);
        }
        if !self.destination_port.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.destination_port);
        }
        if !self.destination_channel.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.destination_channel);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.amount);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.denom);
        }
        if !self.timeout_height.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.timeout_height);
        }
        if self.timeout_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.timeout_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.packet_sequence != 0 {
            my_size += ::protobuf::rt::value_size(11, self.packet_sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data_hex.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.data_hex);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.state);
        }
        for value in &self.tx_hashes {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.receiver.is_empty() {
            os.write_string(2, &self.receiver)?;
        }
        if !self.source_port.is_empty() {
            os.write_string(3, &self.source_port)?;
        }
        if !self.source_channel.is_empty() {
            os.write_string(4, &self.source_channel)?;
        }
        if !self.destination_port.is_empty() {
            os.write_string(5, &self.destination_port)?;
        }
        if !self.destination_channel.is_empty() {
            os.write_string(6, &self.destination_channel)?;
        }
        if !self.amount.is_empty() {
            os.write_string(7, &self.amount)?;
        }
        if !self.denom.is_empty() {
            os.write_string(8, &self.denom)?;
        }
        if !self.timeout_height.is_empty() {
            os.write_string(9, &self.timeout_height)?;
        }
        if self.timeout_timestamp != 0 {
            os.write_uint64(10, self.timeout_timestamp)?;
        }
        if self.packet_sequence != 0 {
            os.write_uint64(11, self.packet_sequence)?;
        }
        if !self.data_hex.is_empty() {
            os.write_bytes(12, &self.data_hex)?;
        }
        if !self.state.is_empty() {
            os.write_string(13, &self.state)?;
        }
        for v in &self.tx_hashes {
            os.write_string(14, &v)?;
        };
        if !self.created_at.is_empty() {
            os.write_string(15, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(16, &self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IBCTransferTx {
        IBCTransferTx::new()
    }

    fn default_instance() -> &'static IBCTransferTx {
        static instance: ::protobuf::rt::LazyV2<IBCTransferTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IBCTransferTx::new)
    }
}

impl ::protobuf::Clear for IBCTransferTx {
    fn clear(&mut self) {
        self.sender.clear();
        self.receiver.clear();
        self.source_port.clear();
        self.source_channel.clear();
        self.destination_port.clear();
        self.destination_channel.clear();
        self.amount.clear();
        self.denom.clear();
        self.timeout_height.clear();
        self.timeout_timestamp = 0;
        self.packet_sequence = 0;
        self.data_hex.clear();
        self.state.clear();
        self.tx_hashes.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IBCTransferTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmCodesRequest {
    // message fields
    pub limit: i32,
    pub from_number: i64,
    pub to_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmCodesRequest {
    fn default() -> &'a GetWasmCodesRequest {
        <GetWasmCodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmCodesRequest {
    pub fn new() -> GetWasmCodesRequest {
        ::std::default::Default::default()
    }

    // sint32 limit = 1;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 from_number = 2;


    pub fn get_from_number(&self) -> i64 {
        self.from_number
    }
    pub fn clear_from_number(&mut self) {
        self.from_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_number(&mut self, v: i64) {
        self.from_number = v;
    }

    // sint64 to_number = 3;


    pub fn get_to_number(&self) -> i64 {
        self.to_number
    }
    pub fn clear_to_number(&mut self) {
        self.to_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_number(&mut self, v: i64) {
        self.to_number = v;
    }
}

impl ::protobuf::Message for GetWasmCodesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.from_number = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.to_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.limit);
        }
        if self.from_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.from_number);
        }
        if self.to_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.to_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_sint32(1, self.limit)?;
        }
        if self.from_number != 0 {
            os.write_sint64(2, self.from_number)?;
        }
        if self.to_number != 0 {
            os.write_sint64(3, self.to_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmCodesRequest {
        GetWasmCodesRequest::new()
    }

    fn default_instance() -> &'static GetWasmCodesRequest {
        static instance: ::protobuf::rt::LazyV2<GetWasmCodesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmCodesRequest::new)
    }
}

impl ::protobuf::Clear for GetWasmCodesRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.from_number = 0;
        self.to_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmCodesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmCodesResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<WasmCode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmCodesResponse {
    fn default() -> &'a GetWasmCodesResponse {
        <GetWasmCodesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmCodesResponse {
    pub fn new() -> GetWasmCodesResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.WasmCode data = 2;


    pub fn get_data(&self) -> &[WasmCode] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<WasmCode>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<WasmCode> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<WasmCode> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetWasmCodesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmCodesResponse {
        GetWasmCodesResponse::new()
    }

    fn default_instance() -> &'static GetWasmCodesResponse {
        static instance: ::protobuf::rt::LazyV2<GetWasmCodesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmCodesResponse::new)
    }
}

impl ::protobuf::Clear for GetWasmCodesResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmCodesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct WasmCode {
    // message fields
    pub code_id: u64,
    pub tx_hash: ::std::string::String,
    pub checksum: ::protobuf::SingularPtrField<Checksum>,
    pub created_at: u64,
    pub contract_type: ::std::string::String,
    pub version: ::std::string::String,
    pub permission: ::protobuf::SingularPtrField<ContractPermission>,
    pub code_schema: ::std::string::String,
    pub code_view: ::std::string::String,
    pub instantiates: u64,
    pub creator: ::std::string::String,
    pub code_number: i64,
    pub proposal_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WasmCode {
    fn default() -> &'a WasmCode {
        <WasmCode as ::protobuf::Message>::default_instance()
    }
}

impl WasmCode {
    pub fn new() -> WasmCode {
        ::std::default::Default::default()
    }

    // uint64 code_id = 1;


    pub fn get_code_id(&self) -> u64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: u64) {
        self.code_id = v;
    }

    // string tx_hash = 2;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // .injective_explorer_rpc.Checksum checksum = 3;


    pub fn get_checksum(&self) -> &Checksum {
        self.checksum.as_ref().unwrap_or_else(|| <Checksum as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: Checksum) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut Checksum {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> Checksum {
        self.checksum.take().unwrap_or_else(|| Checksum::new())
    }

    // uint64 created_at = 4;


    pub fn get_created_at(&self) -> u64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: u64) {
        self.created_at = v;
    }

    // string contract_type = 5;


    pub fn get_contract_type(&self) -> &str {
        &self.contract_type
    }
    pub fn clear_contract_type(&mut self) {
        self.contract_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_type(&mut self, v: ::std::string::String) {
        self.contract_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_type(&mut self) -> &mut ::std::string::String {
        &mut self.contract_type
    }

    // Take field
    pub fn take_contract_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_type, ::std::string::String::new())
    }

    // string version = 6;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // .injective_explorer_rpc.ContractPermission permission = 7;


    pub fn get_permission(&self) -> &ContractPermission {
        self.permission.as_ref().unwrap_or_else(|| <ContractPermission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: ContractPermission) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut ContractPermission {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> ContractPermission {
        self.permission.take().unwrap_or_else(|| ContractPermission::new())
    }

    // string code_schema = 8;


    pub fn get_code_schema(&self) -> &str {
        &self.code_schema
    }
    pub fn clear_code_schema(&mut self) {
        self.code_schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_schema(&mut self, v: ::std::string::String) {
        self.code_schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_schema(&mut self) -> &mut ::std::string::String {
        &mut self.code_schema
    }

    // Take field
    pub fn take_code_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_schema, ::std::string::String::new())
    }

    // string code_view = 9;


    pub fn get_code_view(&self) -> &str {
        &self.code_view
    }
    pub fn clear_code_view(&mut self) {
        self.code_view.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_view(&mut self, v: ::std::string::String) {
        self.code_view = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_view(&mut self) -> &mut ::std::string::String {
        &mut self.code_view
    }

    // Take field
    pub fn take_code_view(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_view, ::std::string::String::new())
    }

    // uint64 instantiates = 10;


    pub fn get_instantiates(&self) -> u64 {
        self.instantiates
    }
    pub fn clear_instantiates(&mut self) {
        self.instantiates = 0;
    }

    // Param is passed by value, moved
    pub fn set_instantiates(&mut self, v: u64) {
        self.instantiates = v;
    }

    // string creator = 11;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // sint64 code_number = 12;


    pub fn get_code_number(&self) -> i64 {
        self.code_number
    }
    pub fn clear_code_number(&mut self) {
        self.code_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_number(&mut self, v: i64) {
        self.code_number = v;
    }

    // sint64 proposal_id = 13;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for WasmCode {
    fn is_initialized(&self) -> bool {
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.created_at = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_schema)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_view)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instantiates = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.code_number = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_hash);
        }
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.contract_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.contract_type);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.version);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.code_schema.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.code_schema);
        }
        if !self.code_view.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.code_view);
        }
        if self.instantiates != 0 {
            my_size += ::protobuf::rt::value_size(10, self.instantiates, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.creator);
        }
        if self.code_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.code_number);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.proposal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code_id != 0 {
            os.write_uint64(1, self.code_id)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(2, &self.tx_hash)?;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.created_at != 0 {
            os.write_uint64(4, self.created_at)?;
        }
        if !self.contract_type.is_empty() {
            os.write_string(5, &self.contract_type)?;
        }
        if !self.version.is_empty() {
            os.write_string(6, &self.version)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.code_schema.is_empty() {
            os.write_string(8, &self.code_schema)?;
        }
        if !self.code_view.is_empty() {
            os.write_string(9, &self.code_view)?;
        }
        if self.instantiates != 0 {
            os.write_uint64(10, self.instantiates)?;
        }
        if !self.creator.is_empty() {
            os.write_string(11, &self.creator)?;
        }
        if self.code_number != 0 {
            os.write_sint64(12, self.code_number)?;
        }
        if self.proposal_id != 0 {
            os.write_sint64(13, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WasmCode {
        WasmCode::new()
    }

    fn default_instance() -> &'static WasmCode {
        static instance: ::protobuf::rt::LazyV2<WasmCode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WasmCode::new)
    }
}

impl ::protobuf::Clear for WasmCode {
    fn clear(&mut self) {
        self.code_id = 0;
        self.tx_hash.clear();
        self.checksum.clear();
        self.created_at = 0;
        self.contract_type.clear();
        self.version.clear();
        self.permission.clear();
        self.code_schema.clear();
        self.code_view.clear();
        self.instantiates = 0;
        self.creator.clear();
        self.code_number = 0;
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for WasmCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Checksum {
    // message fields
    pub algorithm: ::std::string::String,
    pub hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Checksum {
    fn default() -> &'a Checksum {
        <Checksum as ::protobuf::Message>::default_instance()
    }
}

impl Checksum {
    pub fn new() -> Checksum {
        ::std::default::Default::default()
    }

    // string algorithm = 1;


    pub fn get_algorithm(&self) -> &str {
        &self.algorithm
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ::std::string::String) {
        self.algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.algorithm
    }

    // Take field
    pub fn take_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.algorithm, ::std::string::String::new())
    }

    // string hash = 2;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Checksum {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.algorithm)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.algorithm);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.algorithm.is_empty() {
            os.write_string(1, &self.algorithm)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Checksum {
        Checksum::new()
    }

    fn default_instance() -> &'static Checksum {
        static instance: ::protobuf::rt::LazyV2<Checksum> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Checksum::new)
    }
}

impl ::protobuf::Clear for Checksum {
    fn clear(&mut self) {
        self.algorithm.clear();
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Checksum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContractPermission {
    // message fields
    pub access_type: i32,
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractPermission {
    fn default() -> &'a ContractPermission {
        <ContractPermission as ::protobuf::Message>::default_instance()
    }
}

impl ContractPermission {
    pub fn new() -> ContractPermission {
        ::std::default::Default::default()
    }

    // sint32 access_type = 1;


    pub fn get_access_type(&self) -> i32 {
        self.access_type
    }
    pub fn clear_access_type(&mut self) {
        self.access_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_access_type(&mut self, v: i32) {
        self.access_type = v;
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContractPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.access_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.access_type != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.access_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.access_type != 0 {
            os.write_sint32(1, self.access_type)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractPermission {
        ContractPermission::new()
    }

    fn default_instance() -> &'static ContractPermission {
        static instance: ::protobuf::rt::LazyV2<ContractPermission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractPermission::new)
    }
}

impl ::protobuf::Clear for ContractPermission {
    fn clear(&mut self) {
        self.access_type = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmCodeByIDRequest {
    // message fields
    pub code_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmCodeByIDRequest {
    fn default() -> &'a GetWasmCodeByIDRequest {
        <GetWasmCodeByIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmCodeByIDRequest {
    pub fn new() -> GetWasmCodeByIDRequest {
        ::std::default::Default::default()
    }

    // sint64 code_id = 1;


    pub fn get_code_id(&self) -> i64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: i64) {
        self.code_id = v;
    }
}

impl ::protobuf::Message for GetWasmCodeByIDRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.code_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.code_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code_id != 0 {
            os.write_sint64(1, self.code_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmCodeByIDRequest {
        GetWasmCodeByIDRequest::new()
    }

    fn default_instance() -> &'static GetWasmCodeByIDRequest {
        static instance: ::protobuf::rt::LazyV2<GetWasmCodeByIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmCodeByIDRequest::new)
    }
}

impl ::protobuf::Clear for GetWasmCodeByIDRequest {
    fn clear(&mut self) {
        self.code_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmCodeByIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmCodeByIDResponse {
    // message fields
    pub code_id: u64,
    pub tx_hash: ::std::string::String,
    pub checksum: ::protobuf::SingularPtrField<Checksum>,
    pub created_at: u64,
    pub contract_type: ::std::string::String,
    pub version: ::std::string::String,
    pub permission: ::protobuf::SingularPtrField<ContractPermission>,
    pub code_schema: ::std::string::String,
    pub code_view: ::std::string::String,
    pub instantiates: u64,
    pub creator: ::std::string::String,
    pub code_number: i64,
    pub proposal_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmCodeByIDResponse {
    fn default() -> &'a GetWasmCodeByIDResponse {
        <GetWasmCodeByIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmCodeByIDResponse {
    pub fn new() -> GetWasmCodeByIDResponse {
        ::std::default::Default::default()
    }

    // uint64 code_id = 1;


    pub fn get_code_id(&self) -> u64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: u64) {
        self.code_id = v;
    }

    // string tx_hash = 2;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // .injective_explorer_rpc.Checksum checksum = 3;


    pub fn get_checksum(&self) -> &Checksum {
        self.checksum.as_ref().unwrap_or_else(|| <Checksum as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: Checksum) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut Checksum {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> Checksum {
        self.checksum.take().unwrap_or_else(|| Checksum::new())
    }

    // uint64 created_at = 4;


    pub fn get_created_at(&self) -> u64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: u64) {
        self.created_at = v;
    }

    // string contract_type = 5;


    pub fn get_contract_type(&self) -> &str {
        &self.contract_type
    }
    pub fn clear_contract_type(&mut self) {
        self.contract_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_type(&mut self, v: ::std::string::String) {
        self.contract_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_type(&mut self) -> &mut ::std::string::String {
        &mut self.contract_type
    }

    // Take field
    pub fn take_contract_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_type, ::std::string::String::new())
    }

    // string version = 6;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // .injective_explorer_rpc.ContractPermission permission = 7;


    pub fn get_permission(&self) -> &ContractPermission {
        self.permission.as_ref().unwrap_or_else(|| <ContractPermission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: ContractPermission) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut ContractPermission {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> ContractPermission {
        self.permission.take().unwrap_or_else(|| ContractPermission::new())
    }

    // string code_schema = 8;


    pub fn get_code_schema(&self) -> &str {
        &self.code_schema
    }
    pub fn clear_code_schema(&mut self) {
        self.code_schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_schema(&mut self, v: ::std::string::String) {
        self.code_schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_schema(&mut self) -> &mut ::std::string::String {
        &mut self.code_schema
    }

    // Take field
    pub fn take_code_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_schema, ::std::string::String::new())
    }

    // string code_view = 9;


    pub fn get_code_view(&self) -> &str {
        &self.code_view
    }
    pub fn clear_code_view(&mut self) {
        self.code_view.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_view(&mut self, v: ::std::string::String) {
        self.code_view = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_view(&mut self) -> &mut ::std::string::String {
        &mut self.code_view
    }

    // Take field
    pub fn take_code_view(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code_view, ::std::string::String::new())
    }

    // uint64 instantiates = 10;


    pub fn get_instantiates(&self) -> u64 {
        self.instantiates
    }
    pub fn clear_instantiates(&mut self) {
        self.instantiates = 0;
    }

    // Param is passed by value, moved
    pub fn set_instantiates(&mut self, v: u64) {
        self.instantiates = v;
    }

    // string creator = 11;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // sint64 code_number = 12;


    pub fn get_code_number(&self) -> i64 {
        self.code_number
    }
    pub fn clear_code_number(&mut self) {
        self.code_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_number(&mut self, v: i64) {
        self.code_number = v;
    }

    // sint64 proposal_id = 13;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for GetWasmCodeByIDResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.created_at = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_schema)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code_view)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instantiates = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.code_number = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_hash);
        }
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_size(4, self.created_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.contract_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.contract_type);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.version);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.code_schema.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.code_schema);
        }
        if !self.code_view.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.code_view);
        }
        if self.instantiates != 0 {
            my_size += ::protobuf::rt::value_size(10, self.instantiates, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.creator);
        }
        if self.code_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.code_number);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.proposal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code_id != 0 {
            os.write_uint64(1, self.code_id)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(2, &self.tx_hash)?;
        }
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.created_at != 0 {
            os.write_uint64(4, self.created_at)?;
        }
        if !self.contract_type.is_empty() {
            os.write_string(5, &self.contract_type)?;
        }
        if !self.version.is_empty() {
            os.write_string(6, &self.version)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.code_schema.is_empty() {
            os.write_string(8, &self.code_schema)?;
        }
        if !self.code_view.is_empty() {
            os.write_string(9, &self.code_view)?;
        }
        if self.instantiates != 0 {
            os.write_uint64(10, self.instantiates)?;
        }
        if !self.creator.is_empty() {
            os.write_string(11, &self.creator)?;
        }
        if self.code_number != 0 {
            os.write_sint64(12, self.code_number)?;
        }
        if self.proposal_id != 0 {
            os.write_sint64(13, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmCodeByIDResponse {
        GetWasmCodeByIDResponse::new()
    }

    fn default_instance() -> &'static GetWasmCodeByIDResponse {
        static instance: ::protobuf::rt::LazyV2<GetWasmCodeByIDResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmCodeByIDResponse::new)
    }
}

impl ::protobuf::Clear for GetWasmCodeByIDResponse {
    fn clear(&mut self) {
        self.code_id = 0;
        self.tx_hash.clear();
        self.checksum.clear();
        self.created_at = 0;
        self.contract_type.clear();
        self.version.clear();
        self.permission.clear();
        self.code_schema.clear();
        self.code_view.clear();
        self.instantiates = 0;
        self.creator.clear();
        self.code_number = 0;
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmCodeByIDResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmContractsRequest {
    // message fields
    pub limit: i32,
    pub code_id: i64,
    pub from_number: i64,
    pub to_number: i64,
    pub assets_only: bool,
    pub skip: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmContractsRequest {
    fn default() -> &'a GetWasmContractsRequest {
        <GetWasmContractsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmContractsRequest {
    pub fn new() -> GetWasmContractsRequest {
        ::std::default::Default::default()
    }

    // sint32 limit = 1;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 code_id = 2;


    pub fn get_code_id(&self) -> i64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: i64) {
        self.code_id = v;
    }

    // sint64 from_number = 3;


    pub fn get_from_number(&self) -> i64 {
        self.from_number
    }
    pub fn clear_from_number(&mut self) {
        self.from_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_number(&mut self, v: i64) {
        self.from_number = v;
    }

    // sint64 to_number = 4;


    pub fn get_to_number(&self) -> i64 {
        self.to_number
    }
    pub fn clear_to_number(&mut self) {
        self.to_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_number(&mut self, v: i64) {
        self.to_number = v;
    }

    // bool assets_only = 5;


    pub fn get_assets_only(&self) -> bool {
        self.assets_only
    }
    pub fn clear_assets_only(&mut self) {
        self.assets_only = false;
    }

    // Param is passed by value, moved
    pub fn set_assets_only(&mut self, v: bool) {
        self.assets_only = v;
    }

    // sint64 skip = 6;


    pub fn get_skip(&self) -> i64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: i64) {
        self.skip = v;
    }
}

impl ::protobuf::Message for GetWasmContractsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.code_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.from_number = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.to_number = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assets_only = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.skip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.limit);
        }
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.code_id);
        }
        if self.from_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.from_number);
        }
        if self.to_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.to_number);
        }
        if self.assets_only != false {
            my_size += 2;
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.skip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.limit != 0 {
            os.write_sint32(1, self.limit)?;
        }
        if self.code_id != 0 {
            os.write_sint64(2, self.code_id)?;
        }
        if self.from_number != 0 {
            os.write_sint64(3, self.from_number)?;
        }
        if self.to_number != 0 {
            os.write_sint64(4, self.to_number)?;
        }
        if self.assets_only != false {
            os.write_bool(5, self.assets_only)?;
        }
        if self.skip != 0 {
            os.write_sint64(6, self.skip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmContractsRequest {
        GetWasmContractsRequest::new()
    }

    fn default_instance() -> &'static GetWasmContractsRequest {
        static instance: ::protobuf::rt::LazyV2<GetWasmContractsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmContractsRequest::new)
    }
}

impl ::protobuf::Clear for GetWasmContractsRequest {
    fn clear(&mut self) {
        self.limit = 0;
        self.code_id = 0;
        self.from_number = 0;
        self.to_number = 0;
        self.assets_only = false;
        self.skip = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmContractsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmContractsResponse {
    // message fields
    pub paging: ::protobuf::SingularPtrField<Paging>,
    pub data: ::protobuf::RepeatedField<WasmContract>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmContractsResponse {
    fn default() -> &'a GetWasmContractsResponse {
        <GetWasmContractsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmContractsResponse {
    pub fn new() -> GetWasmContractsResponse {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Paging paging = 1;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }

    // repeated .injective_explorer_rpc.WasmContract data = 2;


    pub fn get_data(&self) -> &[WasmContract] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<WasmContract>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<WasmContract> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<WasmContract> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetWasmContractsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmContractsResponse {
        GetWasmContractsResponse::new()
    }

    fn default_instance() -> &'static GetWasmContractsResponse {
        static instance: ::protobuf::rt::LazyV2<GetWasmContractsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmContractsResponse::new)
    }
}

impl ::protobuf::Clear for GetWasmContractsResponse {
    fn clear(&mut self) {
        self.paging.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmContractsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct WasmContract {
    // message fields
    pub label: ::std::string::String,
    pub address: ::std::string::String,
    pub tx_hash: ::std::string::String,
    pub creator: ::std::string::String,
    pub executes: u64,
    pub instantiated_at: u64,
    pub init_message: ::std::string::String,
    pub last_executed_at: u64,
    pub funds: ::protobuf::RepeatedField<ContractFund>,
    pub code_id: u64,
    pub admin: ::std::string::String,
    pub current_migrate_message: ::std::string::String,
    pub contract_number: i64,
    pub version: ::std::string::String,
    pub field_type: ::std::string::String,
    pub cw20_metadata: ::protobuf::SingularPtrField<Cw20Metadata>,
    pub proposal_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WasmContract {
    fn default() -> &'a WasmContract {
        <WasmContract as ::protobuf::Message>::default_instance()
    }
}

impl WasmContract {
    pub fn new() -> WasmContract {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string tx_hash = 3;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // string creator = 4;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // uint64 executes = 5;


    pub fn get_executes(&self) -> u64 {
        self.executes
    }
    pub fn clear_executes(&mut self) {
        self.executes = 0;
    }

    // Param is passed by value, moved
    pub fn set_executes(&mut self, v: u64) {
        self.executes = v;
    }

    // uint64 instantiated_at = 6;


    pub fn get_instantiated_at(&self) -> u64 {
        self.instantiated_at
    }
    pub fn clear_instantiated_at(&mut self) {
        self.instantiated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_instantiated_at(&mut self, v: u64) {
        self.instantiated_at = v;
    }

    // string init_message = 7;


    pub fn get_init_message(&self) -> &str {
        &self.init_message
    }
    pub fn clear_init_message(&mut self) {
        self.init_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_init_message(&mut self, v: ::std::string::String) {
        self.init_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_message(&mut self) -> &mut ::std::string::String {
        &mut self.init_message
    }

    // Take field
    pub fn take_init_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.init_message, ::std::string::String::new())
    }

    // uint64 last_executed_at = 8;


    pub fn get_last_executed_at(&self) -> u64 {
        self.last_executed_at
    }
    pub fn clear_last_executed_at(&mut self) {
        self.last_executed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_executed_at(&mut self, v: u64) {
        self.last_executed_at = v;
    }

    // repeated .injective_explorer_rpc.ContractFund funds = 9;


    pub fn get_funds(&self) -> &[ContractFund] {
        &self.funds
    }
    pub fn clear_funds(&mut self) {
        self.funds.clear();
    }

    // Param is passed by value, moved
    pub fn set_funds(&mut self, v: ::protobuf::RepeatedField<ContractFund>) {
        self.funds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_funds(&mut self) -> &mut ::protobuf::RepeatedField<ContractFund> {
        &mut self.funds
    }

    // Take field
    pub fn take_funds(&mut self) -> ::protobuf::RepeatedField<ContractFund> {
        ::std::mem::replace(&mut self.funds, ::protobuf::RepeatedField::new())
    }

    // uint64 code_id = 10;


    pub fn get_code_id(&self) -> u64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: u64) {
        self.code_id = v;
    }

    // string admin = 11;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // string current_migrate_message = 12;


    pub fn get_current_migrate_message(&self) -> &str {
        &self.current_migrate_message
    }
    pub fn clear_current_migrate_message(&mut self) {
        self.current_migrate_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_migrate_message(&mut self, v: ::std::string::String) {
        self.current_migrate_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_migrate_message(&mut self) -> &mut ::std::string::String {
        &mut self.current_migrate_message
    }

    // Take field
    pub fn take_current_migrate_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_migrate_message, ::std::string::String::new())
    }

    // sint64 contract_number = 13;


    pub fn get_contract_number(&self) -> i64 {
        self.contract_number
    }
    pub fn clear_contract_number(&mut self) {
        self.contract_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_contract_number(&mut self, v: i64) {
        self.contract_number = v;
    }

    // string version = 14;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string type = 15;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16;


    pub fn get_cw20_metadata(&self) -> &Cw20Metadata {
        self.cw20_metadata.as_ref().unwrap_or_else(|| <Cw20Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cw20_metadata(&mut self) {
        self.cw20_metadata.clear();
    }

    pub fn has_cw20_metadata(&self) -> bool {
        self.cw20_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cw20_metadata(&mut self, v: Cw20Metadata) {
        self.cw20_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cw20_metadata(&mut self) -> &mut Cw20Metadata {
        if self.cw20_metadata.is_none() {
            self.cw20_metadata.set_default();
        }
        self.cw20_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_cw20_metadata(&mut self) -> Cw20Metadata {
        self.cw20_metadata.take().unwrap_or_else(|| Cw20Metadata::new())
    }

    // sint64 proposal_id = 17;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for WasmContract {
    fn is_initialized(&self) -> bool {
        for v in &self.funds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cw20_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.executes = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instantiated_at = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.init_message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_executed_at = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.funds)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code_id = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_migrate_message)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.contract_number = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cw20_metadata)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.tx_hash);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.creator);
        }
        if self.executes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.executes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.instantiated_at != 0 {
            my_size += ::protobuf::rt::value_size(6, self.instantiated_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.init_message.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.init_message);
        }
        if self.last_executed_at != 0 {
            my_size += ::protobuf::rt::value_size(8, self.last_executed_at, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.funds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_size(10, self.code_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.admin);
        }
        if !self.current_migrate_message.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.current_migrate_message);
        }
        if self.contract_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.contract_number);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.field_type);
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(17, self.proposal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(3, &self.tx_hash)?;
        }
        if !self.creator.is_empty() {
            os.write_string(4, &self.creator)?;
        }
        if self.executes != 0 {
            os.write_uint64(5, self.executes)?;
        }
        if self.instantiated_at != 0 {
            os.write_uint64(6, self.instantiated_at)?;
        }
        if !self.init_message.is_empty() {
            os.write_string(7, &self.init_message)?;
        }
        if self.last_executed_at != 0 {
            os.write_uint64(8, self.last_executed_at)?;
        }
        for v in &self.funds {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.code_id != 0 {
            os.write_uint64(10, self.code_id)?;
        }
        if !self.admin.is_empty() {
            os.write_string(11, &self.admin)?;
        }
        if !self.current_migrate_message.is_empty() {
            os.write_string(12, &self.current_migrate_message)?;
        }
        if self.contract_number != 0 {
            os.write_sint64(13, self.contract_number)?;
        }
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(15, &self.field_type)?;
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.proposal_id != 0 {
            os.write_sint64(17, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WasmContract {
        WasmContract::new()
    }

    fn default_instance() -> &'static WasmContract {
        static instance: ::protobuf::rt::LazyV2<WasmContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WasmContract::new)
    }
}

impl ::protobuf::Clear for WasmContract {
    fn clear(&mut self) {
        self.label.clear();
        self.address.clear();
        self.tx_hash.clear();
        self.creator.clear();
        self.executes = 0;
        self.instantiated_at = 0;
        self.init_message.clear();
        self.last_executed_at = 0;
        self.funds.clear();
        self.code_id = 0;
        self.admin.clear();
        self.current_migrate_message.clear();
        self.contract_number = 0;
        self.version.clear();
        self.field_type.clear();
        self.cw20_metadata.clear();
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for WasmContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContractFund {
    // message fields
    pub denom: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractFund {
    fn default() -> &'a ContractFund {
        <ContractFund as ::protobuf::Message>::default_instance()
    }
}

impl ContractFund {
    pub fn new() -> ContractFund {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string amount = 2;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContractFund {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        if !self.amount.is_empty() {
            os.write_string(2, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractFund {
        ContractFund::new()
    }

    fn default_instance() -> &'static ContractFund {
        static instance: ::protobuf::rt::LazyV2<ContractFund> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractFund::new)
    }
}

impl ::protobuf::Clear for ContractFund {
    fn clear(&mut self) {
        self.denom.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractFund {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cw20Metadata {
    // message fields
    pub token_info: ::protobuf::SingularPtrField<Cw20TokenInfo>,
    pub marketing_info: ::protobuf::SingularPtrField<Cw20MarketingInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cw20Metadata {
    fn default() -> &'a Cw20Metadata {
        <Cw20Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Cw20Metadata {
    pub fn new() -> Cw20Metadata {
        ::std::default::Default::default()
    }

    // .injective_explorer_rpc.Cw20TokenInfo token_info = 1;


    pub fn get_token_info(&self) -> &Cw20TokenInfo {
        self.token_info.as_ref().unwrap_or_else(|| <Cw20TokenInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_token_info(&mut self) {
        self.token_info.clear();
    }

    pub fn has_token_info(&self) -> bool {
        self.token_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_info(&mut self, v: Cw20TokenInfo) {
        self.token_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_info(&mut self) -> &mut Cw20TokenInfo {
        if self.token_info.is_none() {
            self.token_info.set_default();
        }
        self.token_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_token_info(&mut self) -> Cw20TokenInfo {
        self.token_info.take().unwrap_or_else(|| Cw20TokenInfo::new())
    }

    // .injective_explorer_rpc.Cw20MarketingInfo marketing_info = 2;


    pub fn get_marketing_info(&self) -> &Cw20MarketingInfo {
        self.marketing_info.as_ref().unwrap_or_else(|| <Cw20MarketingInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_marketing_info(&mut self) {
        self.marketing_info.clear();
    }

    pub fn has_marketing_info(&self) -> bool {
        self.marketing_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marketing_info(&mut self, v: Cw20MarketingInfo) {
        self.marketing_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_marketing_info(&mut self) -> &mut Cw20MarketingInfo {
        if self.marketing_info.is_none() {
            self.marketing_info.set_default();
        }
        self.marketing_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_marketing_info(&mut self) -> Cw20MarketingInfo {
        self.marketing_info.take().unwrap_or_else(|| Cw20MarketingInfo::new())
    }
}

impl ::protobuf::Message for Cw20Metadata {
    fn is_initialized(&self) -> bool {
        for v in &self.token_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.marketing_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.token_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.marketing_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.token_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.marketing_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.token_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.marketing_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cw20Metadata {
        Cw20Metadata::new()
    }

    fn default_instance() -> &'static Cw20Metadata {
        static instance: ::protobuf::rt::LazyV2<Cw20Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cw20Metadata::new)
    }
}

impl ::protobuf::Clear for Cw20Metadata {
    fn clear(&mut self) {
        self.token_info.clear();
        self.marketing_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Cw20Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cw20TokenInfo {
    // message fields
    pub name: ::std::string::String,
    pub symbol: ::std::string::String,
    pub decimals: i64,
    pub total_supply: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cw20TokenInfo {
    fn default() -> &'a Cw20TokenInfo {
        <Cw20TokenInfo as ::protobuf::Message>::default_instance()
    }
}

impl Cw20TokenInfo {
    pub fn new() -> Cw20TokenInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string symbol = 2;


    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::std::string::String) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol, ::std::string::String::new())
    }

    // sint64 decimals = 3;


    pub fn get_decimals(&self) -> i64 {
        self.decimals
    }
    pub fn clear_decimals(&mut self) {
        self.decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_decimals(&mut self, v: i64) {
        self.decimals = v;
    }

    // string total_supply = 4;


    pub fn get_total_supply(&self) -> &str {
        &self.total_supply
    }
    pub fn clear_total_supply(&mut self) {
        self.total_supply.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_supply(&mut self, v: ::std::string::String) {
        self.total_supply = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_supply(&mut self) -> &mut ::std::string::String {
        &mut self.total_supply
    }

    // Take field
    pub fn take_total_supply(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_supply, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Cw20TokenInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.decimals = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_supply)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.symbol);
        }
        if self.decimals != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.decimals);
        }
        if !self.total_supply.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.total_supply);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.symbol.is_empty() {
            os.write_string(2, &self.symbol)?;
        }
        if self.decimals != 0 {
            os.write_sint64(3, self.decimals)?;
        }
        if !self.total_supply.is_empty() {
            os.write_string(4, &self.total_supply)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cw20TokenInfo {
        Cw20TokenInfo::new()
    }

    fn default_instance() -> &'static Cw20TokenInfo {
        static instance: ::protobuf::rt::LazyV2<Cw20TokenInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cw20TokenInfo::new)
    }
}

impl ::protobuf::Clear for Cw20TokenInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.symbol.clear();
        self.decimals = 0;
        self.total_supply.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Cw20TokenInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cw20MarketingInfo {
    // message fields
    pub project: ::std::string::String,
    pub description: ::std::string::String,
    pub logo: ::std::string::String,
    pub marketing: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cw20MarketingInfo {
    fn default() -> &'a Cw20MarketingInfo {
        <Cw20MarketingInfo as ::protobuf::Message>::default_instance()
    }
}

impl Cw20MarketingInfo {
    pub fn new() -> Cw20MarketingInfo {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string logo = 3;


    pub fn get_logo(&self) -> &str {
        &self.logo
    }
    pub fn clear_logo(&mut self) {
        self.logo.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: ::std::string::String) {
        self.logo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo(&mut self) -> &mut ::std::string::String {
        &mut self.logo
    }

    // Take field
    pub fn take_logo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo, ::std::string::String::new())
    }

    // bytes marketing = 4;


    pub fn get_marketing(&self) -> &[u8] {
        &self.marketing
    }
    pub fn clear_marketing(&mut self) {
        self.marketing.clear();
    }

    // Param is passed by value, moved
    pub fn set_marketing(&mut self, v: ::std::vec::Vec<u8>) {
        self.marketing = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_marketing(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.marketing
    }

    // Take field
    pub fn take_marketing(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.marketing, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Cw20MarketingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.marketing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.logo.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.logo);
        }
        if !self.marketing.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.marketing);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.logo.is_empty() {
            os.write_string(3, &self.logo)?;
        }
        if !self.marketing.is_empty() {
            os.write_bytes(4, &self.marketing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cw20MarketingInfo {
        Cw20MarketingInfo::new()
    }

    fn default_instance() -> &'static Cw20MarketingInfo {
        static instance: ::protobuf::rt::LazyV2<Cw20MarketingInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cw20MarketingInfo::new)
    }
}

impl ::protobuf::Clear for Cw20MarketingInfo {
    fn clear(&mut self) {
        self.project.clear();
        self.description.clear();
        self.logo.clear();
        self.marketing.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Cw20MarketingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmContractByAddressRequest {
    // message fields
    pub contract_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmContractByAddressRequest {
    fn default() -> &'a GetWasmContractByAddressRequest {
        <GetWasmContractByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmContractByAddressRequest {
    pub fn new() -> GetWasmContractByAddressRequest {
        ::std::default::Default::default()
    }

    // string contract_address = 1;


    pub fn get_contract_address(&self) -> &str {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::string::String) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::string::String {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetWasmContractByAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.contract_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.contract_address.is_empty() {
            os.write_string(1, &self.contract_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmContractByAddressRequest {
        GetWasmContractByAddressRequest::new()
    }

    fn default_instance() -> &'static GetWasmContractByAddressRequest {
        static instance: ::protobuf::rt::LazyV2<GetWasmContractByAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmContractByAddressRequest::new)
    }
}

impl ::protobuf::Clear for GetWasmContractByAddressRequest {
    fn clear(&mut self) {
        self.contract_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmContractByAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWasmContractByAddressResponse {
    // message fields
    pub label: ::std::string::String,
    pub address: ::std::string::String,
    pub tx_hash: ::std::string::String,
    pub creator: ::std::string::String,
    pub executes: u64,
    pub instantiated_at: u64,
    pub init_message: ::std::string::String,
    pub last_executed_at: u64,
    pub funds: ::protobuf::RepeatedField<ContractFund>,
    pub code_id: u64,
    pub admin: ::std::string::String,
    pub current_migrate_message: ::std::string::String,
    pub contract_number: i64,
    pub version: ::std::string::String,
    pub field_type: ::std::string::String,
    pub cw20_metadata: ::protobuf::SingularPtrField<Cw20Metadata>,
    pub proposal_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWasmContractByAddressResponse {
    fn default() -> &'a GetWasmContractByAddressResponse {
        <GetWasmContractByAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWasmContractByAddressResponse {
    pub fn new() -> GetWasmContractByAddressResponse {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string tx_hash = 3;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // string creator = 4;


    pub fn get_creator(&self) -> &str {
        &self.creator
    }
    pub fn clear_creator(&mut self) {
        self.creator.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: ::std::string::String) {
        self.creator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator(&mut self) -> &mut ::std::string::String {
        &mut self.creator
    }

    // Take field
    pub fn take_creator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.creator, ::std::string::String::new())
    }

    // uint64 executes = 5;


    pub fn get_executes(&self) -> u64 {
        self.executes
    }
    pub fn clear_executes(&mut self) {
        self.executes = 0;
    }

    // Param is passed by value, moved
    pub fn set_executes(&mut self, v: u64) {
        self.executes = v;
    }

    // uint64 instantiated_at = 6;


    pub fn get_instantiated_at(&self) -> u64 {
        self.instantiated_at
    }
    pub fn clear_instantiated_at(&mut self) {
        self.instantiated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_instantiated_at(&mut self, v: u64) {
        self.instantiated_at = v;
    }

    // string init_message = 7;


    pub fn get_init_message(&self) -> &str {
        &self.init_message
    }
    pub fn clear_init_message(&mut self) {
        self.init_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_init_message(&mut self, v: ::std::string::String) {
        self.init_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_message(&mut self) -> &mut ::std::string::String {
        &mut self.init_message
    }

    // Take field
    pub fn take_init_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.init_message, ::std::string::String::new())
    }

    // uint64 last_executed_at = 8;


    pub fn get_last_executed_at(&self) -> u64 {
        self.last_executed_at
    }
    pub fn clear_last_executed_at(&mut self) {
        self.last_executed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_executed_at(&mut self, v: u64) {
        self.last_executed_at = v;
    }

    // repeated .injective_explorer_rpc.ContractFund funds = 9;


    pub fn get_funds(&self) -> &[ContractFund] {
        &self.funds
    }
    pub fn clear_funds(&mut self) {
        self.funds.clear();
    }

    // Param is passed by value, moved
    pub fn set_funds(&mut self, v: ::protobuf::RepeatedField<ContractFund>) {
        self.funds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_funds(&mut self) -> &mut ::protobuf::RepeatedField<ContractFund> {
        &mut self.funds
    }

    // Take field
    pub fn take_funds(&mut self) -> ::protobuf::RepeatedField<ContractFund> {
        ::std::mem::replace(&mut self.funds, ::protobuf::RepeatedField::new())
    }

    // uint64 code_id = 10;


    pub fn get_code_id(&self) -> u64 {
        self.code_id
    }
    pub fn clear_code_id(&mut self) {
        self.code_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_code_id(&mut self, v: u64) {
        self.code_id = v;
    }

    // string admin = 11;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // string current_migrate_message = 12;


    pub fn get_current_migrate_message(&self) -> &str {
        &self.current_migrate_message
    }
    pub fn clear_current_migrate_message(&mut self) {
        self.current_migrate_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_migrate_message(&mut self, v: ::std::string::String) {
        self.current_migrate_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_migrate_message(&mut self) -> &mut ::std::string::String {
        &mut self.current_migrate_message
    }

    // Take field
    pub fn take_current_migrate_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_migrate_message, ::std::string::String::new())
    }

    // sint64 contract_number = 13;


    pub fn get_contract_number(&self) -> i64 {
        self.contract_number
    }
    pub fn clear_contract_number(&mut self) {
        self.contract_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_contract_number(&mut self, v: i64) {
        self.contract_number = v;
    }

    // string version = 14;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string type = 15;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16;


    pub fn get_cw20_metadata(&self) -> &Cw20Metadata {
        self.cw20_metadata.as_ref().unwrap_or_else(|| <Cw20Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cw20_metadata(&mut self) {
        self.cw20_metadata.clear();
    }

    pub fn has_cw20_metadata(&self) -> bool {
        self.cw20_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cw20_metadata(&mut self, v: Cw20Metadata) {
        self.cw20_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cw20_metadata(&mut self) -> &mut Cw20Metadata {
        if self.cw20_metadata.is_none() {
            self.cw20_metadata.set_default();
        }
        self.cw20_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_cw20_metadata(&mut self) -> Cw20Metadata {
        self.cw20_metadata.take().unwrap_or_else(|| Cw20Metadata::new())
    }

    // sint64 proposal_id = 17;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for GetWasmContractByAddressResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.funds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cw20_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.creator)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.executes = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instantiated_at = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.init_message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_executed_at = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.funds)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code_id = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_migrate_message)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.contract_number = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cw20_metadata)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.tx_hash);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.creator);
        }
        if self.executes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.executes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.instantiated_at != 0 {
            my_size += ::protobuf::rt::value_size(6, self.instantiated_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.init_message.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.init_message);
        }
        if self.last_executed_at != 0 {
            my_size += ::protobuf::rt::value_size(8, self.last_executed_at, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.funds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.code_id != 0 {
            my_size += ::protobuf::rt::value_size(10, self.code_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.admin);
        }
        if !self.current_migrate_message.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.current_migrate_message);
        }
        if self.contract_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.contract_number);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.field_type);
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(17, self.proposal_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(3, &self.tx_hash)?;
        }
        if !self.creator.is_empty() {
            os.write_string(4, &self.creator)?;
        }
        if self.executes != 0 {
            os.write_uint64(5, self.executes)?;
        }
        if self.instantiated_at != 0 {
            os.write_uint64(6, self.instantiated_at)?;
        }
        if !self.init_message.is_empty() {
            os.write_string(7, &self.init_message)?;
        }
        if self.last_executed_at != 0 {
            os.write_uint64(8, self.last_executed_at)?;
        }
        for v in &self.funds {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.code_id != 0 {
            os.write_uint64(10, self.code_id)?;
        }
        if !self.admin.is_empty() {
            os.write_string(11, &self.admin)?;
        }
        if !self.current_migrate_message.is_empty() {
            os.write_string(12, &self.current_migrate_message)?;
        }
        if self.contract_number != 0 {
            os.write_sint64(13, self.contract_number)?;
        }
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(15, &self.field_type)?;
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.proposal_id != 0 {
            os.write_sint64(17, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWasmContractByAddressResponse {
        GetWasmContractByAddressResponse::new()
    }

    fn default_instance() -> &'static GetWasmContractByAddressResponse {
        static instance: ::protobuf::rt::LazyV2<GetWasmContractByAddressResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWasmContractByAddressResponse::new)
    }
}

impl ::protobuf::Clear for GetWasmContractByAddressResponse {
    fn clear(&mut self) {
        self.label.clear();
        self.address.clear();
        self.tx_hash.clear();
        self.creator.clear();
        self.executes = 0;
        self.instantiated_at = 0;
        self.init_message.clear();
        self.last_executed_at = 0;
        self.funds.clear();
        self.code_id = 0;
        self.admin.clear();
        self.current_migrate_message.clear();
        self.contract_number = 0;
        self.version.clear();
        self.field_type.clear();
        self.cw20_metadata.clear();
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWasmContractByAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCw20BalanceRequest {
    // message fields
    pub address: ::std::string::String,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCw20BalanceRequest {
    fn default() -> &'a GetCw20BalanceRequest {
        <GetCw20BalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCw20BalanceRequest {
    pub fn new() -> GetCw20BalanceRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // sint32 limit = 2;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for GetCw20BalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.limit != 0 {
            os.write_sint32(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCw20BalanceRequest {
        GetCw20BalanceRequest::new()
    }

    fn default_instance() -> &'static GetCw20BalanceRequest {
        static instance: ::protobuf::rt::LazyV2<GetCw20BalanceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCw20BalanceRequest::new)
    }
}

impl ::protobuf::Clear for GetCw20BalanceRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCw20BalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCw20BalanceResponse {
    // message fields
    pub field: ::protobuf::RepeatedField<WasmCw20Balance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCw20BalanceResponse {
    fn default() -> &'a GetCw20BalanceResponse {
        <GetCw20BalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCw20BalanceResponse {
    pub fn new() -> GetCw20BalanceResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.WasmCw20Balance field = 1;


    pub fn get_field(&self) -> &[WasmCw20Balance] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<WasmCw20Balance>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<WasmCw20Balance> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<WasmCw20Balance> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetCw20BalanceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCw20BalanceResponse {
        GetCw20BalanceResponse::new()
    }

    fn default_instance() -> &'static GetCw20BalanceResponse {
        static instance: ::protobuf::rt::LazyV2<GetCw20BalanceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCw20BalanceResponse::new)
    }
}

impl ::protobuf::Clear for GetCw20BalanceResponse {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCw20BalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct WasmCw20Balance {
    // message fields
    pub contract_address: ::std::string::String,
    pub account: ::std::string::String,
    pub balance: ::std::string::String,
    pub updated_at: i64,
    pub cw20_metadata: ::protobuf::SingularPtrField<Cw20Metadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WasmCw20Balance {
    fn default() -> &'a WasmCw20Balance {
        <WasmCw20Balance as ::protobuf::Message>::default_instance()
    }
}

impl WasmCw20Balance {
    pub fn new() -> WasmCw20Balance {
        ::std::default::Default::default()
    }

    // string contract_address = 1;


    pub fn get_contract_address(&self) -> &str {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::string::String) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::string::String {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_address, ::std::string::String::new())
    }

    // string account = 2;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // string balance = 3;


    pub fn get_balance(&self) -> &str {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::string::String) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::string::String {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance, ::std::string::String::new())
    }

    // sint64 updated_at = 4;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }

    // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 5;


    pub fn get_cw20_metadata(&self) -> &Cw20Metadata {
        self.cw20_metadata.as_ref().unwrap_or_else(|| <Cw20Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cw20_metadata(&mut self) {
        self.cw20_metadata.clear();
    }

    pub fn has_cw20_metadata(&self) -> bool {
        self.cw20_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cw20_metadata(&mut self, v: Cw20Metadata) {
        self.cw20_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cw20_metadata(&mut self) -> &mut Cw20Metadata {
        if self.cw20_metadata.is_none() {
            self.cw20_metadata.set_default();
        }
        self.cw20_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_cw20_metadata(&mut self) -> Cw20Metadata {
        self.cw20_metadata.take().unwrap_or_else(|| Cw20Metadata::new())
    }
}

impl ::protobuf::Message for WasmCw20Balance {
    fn is_initialized(&self) -> bool {
        for v in &self.cw20_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cw20_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.contract_address);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.balance);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.updated_at);
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.contract_address.is_empty() {
            os.write_string(1, &self.contract_address)?;
        }
        if !self.account.is_empty() {
            os.write_string(2, &self.account)?;
        }
        if !self.balance.is_empty() {
            os.write_string(3, &self.balance)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(4, self.updated_at)?;
        }
        if let Some(ref v) = self.cw20_metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WasmCw20Balance {
        WasmCw20Balance::new()
    }

    fn default_instance() -> &'static WasmCw20Balance {
        static instance: ::protobuf::rt::LazyV2<WasmCw20Balance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WasmCw20Balance::new)
    }
}

impl ::protobuf::Clear for WasmCw20Balance {
    fn clear(&mut self) {
        self.contract_address.clear();
        self.account.clear();
        self.balance.clear();
        self.updated_at = 0;
        self.cw20_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for WasmCw20Balance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelayersRequest {
    // message fields
    pub market_i_ds: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayersRequest {
    fn default() -> &'a RelayersRequest {
        <RelayersRequest as ::protobuf::Message>::default_instance()
    }
}

impl RelayersRequest {
    pub fn new() -> RelayersRequest {
        ::std::default::Default::default()
    }

    // repeated string market_i_ds = 1;


    pub fn get_market_i_ds(&self) -> &[::std::string::String] {
        &self.market_i_ds
    }
    pub fn clear_market_i_ds(&mut self) {
        self.market_i_ds.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_i_ds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_i_ds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_i_ds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_i_ds
    }

    // Take field
    pub fn take_market_i_ds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_i_ds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RelayersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_i_ds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_i_ds {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_i_ds {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayersRequest {
        RelayersRequest::new()
    }

    fn default_instance() -> &'static RelayersRequest {
        static instance: ::protobuf::rt::LazyV2<RelayersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayersRequest::new)
    }
}

impl ::protobuf::Clear for RelayersRequest {
    fn clear(&mut self) {
        self.market_i_ds.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelayersResponse {
    // message fields
    pub field: ::protobuf::RepeatedField<RelayerMarkets>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayersResponse {
    fn default() -> &'a RelayersResponse {
        <RelayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl RelayersResponse {
    pub fn new() -> RelayersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_explorer_rpc.RelayerMarkets field = 1;


    pub fn get_field(&self) -> &[RelayerMarkets] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<RelayerMarkets>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<RelayerMarkets> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<RelayerMarkets> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RelayersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayersResponse {
        RelayersResponse::new()
    }

    fn default_instance() -> &'static RelayersResponse {
        static instance: ::protobuf::rt::LazyV2<RelayersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayersResponse::new)
    }
}

impl ::protobuf::Clear for RelayersResponse {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelayerMarkets {
    // message fields
    pub market_id: ::std::string::String,
    pub relayers: ::protobuf::RepeatedField<Relayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayerMarkets {
    fn default() -> &'a RelayerMarkets {
        <RelayerMarkets as ::protobuf::Message>::default_instance()
    }
}

impl RelayerMarkets {
    pub fn new() -> RelayerMarkets {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective_explorer_rpc.Relayer relayers = 2;


    pub fn get_relayers(&self) -> &[Relayer] {
        &self.relayers
    }
    pub fn clear_relayers(&mut self) {
        self.relayers.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayers(&mut self, v: ::protobuf::RepeatedField<Relayer>) {
        self.relayers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relayers(&mut self) -> &mut ::protobuf::RepeatedField<Relayer> {
        &mut self.relayers
    }

    // Take field
    pub fn take_relayers(&mut self) -> ::protobuf::RepeatedField<Relayer> {
        ::std::mem::replace(&mut self.relayers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RelayerMarkets {
    fn is_initialized(&self) -> bool {
        for v in &self.relayers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relayers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.relayers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.relayers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayerMarkets {
        RelayerMarkets::new()
    }

    fn default_instance() -> &'static RelayerMarkets {
        static instance: ::protobuf::rt::LazyV2<RelayerMarkets> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayerMarkets::new)
    }
}

impl ::protobuf::Clear for RelayerMarkets {
    fn clear(&mut self) {
        self.market_id.clear();
        self.relayers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayerMarkets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Relayer {
    // message fields
    pub name: ::std::string::String,
    pub cta: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Relayer {
    fn default() -> &'a Relayer {
        <Relayer as ::protobuf::Message>::default_instance()
    }
}

impl Relayer {
    pub fn new() -> Relayer {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cta = 2;


    pub fn get_cta(&self) -> &str {
        &self.cta
    }
    pub fn clear_cta(&mut self) {
        self.cta.clear();
    }

    // Param is passed by value, moved
    pub fn set_cta(&mut self, v: ::std::string::String) {
        self.cta = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cta(&mut self) -> &mut ::std::string::String {
        &mut self.cta
    }

    // Take field
    pub fn take_cta(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cta, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Relayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cta.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cta);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cta.is_empty() {
            os.write_string(2, &self.cta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Relayer {
        Relayer::new()
    }

    fn default_instance() -> &'static Relayer {
        static instance: ::protobuf::rt::LazyV2<Relayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Relayer::new)
    }
}

impl ::protobuf::Clear for Relayer {
    fn clear(&mut self) {
        self.name.clear();
        self.cta.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Relayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTxsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTxsRequest {
    fn default() -> &'a StreamTxsRequest {
        <StreamTxsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamTxsRequest {
    pub fn new() -> StreamTxsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StreamTxsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTxsRequest {
        StreamTxsRequest::new()
    }

    fn default_instance() -> &'static StreamTxsRequest {
        static instance: ::protobuf::rt::LazyV2<StreamTxsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTxsRequest::new)
    }
}

impl ::protobuf::Clear for StreamTxsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTxsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTxsResponse {
    // message fields
    pub id: ::std::string::String,
    pub block_number: u64,
    pub block_timestamp: ::std::string::String,
    pub hash: ::std::string::String,
    pub codespace: ::std::string::String,
    pub messages: ::std::string::String,
    pub tx_number: u64,
    pub error_log: ::std::string::String,
    pub code: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTxsResponse {
    fn default() -> &'a StreamTxsResponse {
        <StreamTxsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamTxsResponse {
    pub fn new() -> StreamTxsResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // uint64 block_number = 2;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }

    // string block_timestamp = 3;


    pub fn get_block_timestamp(&self) -> &str {
        &self.block_timestamp
    }
    pub fn clear_block_timestamp(&mut self) {
        self.block_timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_timestamp(&mut self, v: ::std::string::String) {
        self.block_timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.block_timestamp
    }

    // Take field
    pub fn take_block_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_timestamp, ::std::string::String::new())
    }

    // string hash = 4;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // string codespace = 5;


    pub fn get_codespace(&self) -> &str {
        &self.codespace
    }
    pub fn clear_codespace(&mut self) {
        self.codespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_codespace(&mut self, v: ::std::string::String) {
        self.codespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codespace(&mut self) -> &mut ::std::string::String {
        &mut self.codespace
    }

    // Take field
    pub fn take_codespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codespace, ::std::string::String::new())
    }

    // string messages = 6;


    pub fn get_messages(&self) -> &str {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::string::String) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&mut self) -> &mut ::std::string::String {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.messages, ::std::string::String::new())
    }

    // uint64 tx_number = 7;


    pub fn get_tx_number(&self) -> u64 {
        self.tx_number
    }
    pub fn clear_tx_number(&mut self) {
        self.tx_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_number(&mut self, v: u64) {
        self.tx_number = v;
    }

    // string error_log = 8;


    pub fn get_error_log(&self) -> &str {
        &self.error_log
    }
    pub fn clear_error_log(&mut self) {
        self.error_log.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_log(&mut self, v: ::std::string::String) {
        self.error_log = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_log(&mut self) -> &mut ::std::string::String {
        &mut self.error_log
    }

    // Take field
    pub fn take_error_log(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_log, ::std::string::String::new())
    }

    // uint32 code = 9;


    pub fn get_code(&self) -> u32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u32) {
        self.code = v;
    }
}

impl ::protobuf::Message for StreamTxsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_timestamp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codespace)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.messages)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tx_number = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_log)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.block_timestamp);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.hash);
        }
        if !self.codespace.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.codespace);
        }
        if !self.messages.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.messages);
        }
        if self.tx_number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tx_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_log.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.error_log);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(9, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.block_number != 0 {
            os.write_uint64(2, self.block_number)?;
        }
        if !self.block_timestamp.is_empty() {
            os.write_string(3, &self.block_timestamp)?;
        }
        if !self.hash.is_empty() {
            os.write_string(4, &self.hash)?;
        }
        if !self.codespace.is_empty() {
            os.write_string(5, &self.codespace)?;
        }
        if !self.messages.is_empty() {
            os.write_string(6, &self.messages)?;
        }
        if self.tx_number != 0 {
            os.write_uint64(7, self.tx_number)?;
        }
        if !self.error_log.is_empty() {
            os.write_string(8, &self.error_log)?;
        }
        if self.code != 0 {
            os.write_uint32(9, self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTxsResponse {
        StreamTxsResponse::new()
    }

    fn default_instance() -> &'static StreamTxsResponse {
        static instance: ::protobuf::rt::LazyV2<StreamTxsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTxsResponse::new)
    }
}

impl ::protobuf::Clear for StreamTxsResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.block_number = 0;
        self.block_timestamp.clear();
        self.hash.clear();
        self.codespace.clear();
        self.messages.clear();
        self.tx_number = 0;
        self.error_log.clear();
        self.code = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTxsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamBlocksRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamBlocksRequest {
    fn default() -> &'a StreamBlocksRequest {
        <StreamBlocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamBlocksRequest {
    pub fn new() -> StreamBlocksRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StreamBlocksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamBlocksRequest {
        StreamBlocksRequest::new()
    }

    fn default_instance() -> &'static StreamBlocksRequest {
        static instance: ::protobuf::rt::LazyV2<StreamBlocksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamBlocksRequest::new)
    }
}

impl ::protobuf::Clear for StreamBlocksRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamBlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamBlocksResponse {
    // message fields
    pub height: u64,
    pub proposer: ::std::string::String,
    pub moniker: ::std::string::String,
    pub block_hash: ::std::string::String,
    pub parent_hash: ::std::string::String,
    pub num_pre_commits: i64,
    pub num_txs: i64,
    pub txs: ::protobuf::RepeatedField<TxDataRPC>,
    pub timestamp: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamBlocksResponse {
    fn default() -> &'a StreamBlocksResponse {
        <StreamBlocksResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamBlocksResponse {
    pub fn new() -> StreamBlocksResponse {
        ::std::default::Default::default()
    }

    // uint64 height = 1;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    // string proposer = 2;


    pub fn get_proposer(&self) -> &str {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::string::String) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::string::String {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proposer, ::std::string::String::new())
    }

    // string moniker = 3;


    pub fn get_moniker(&self) -> &str {
        &self.moniker
    }
    pub fn clear_moniker(&mut self) {
        self.moniker.clear();
    }

    // Param is passed by value, moved
    pub fn set_moniker(&mut self, v: ::std::string::String) {
        self.moniker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moniker(&mut self) -> &mut ::std::string::String {
        &mut self.moniker
    }

    // Take field
    pub fn take_moniker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moniker, ::std::string::String::new())
    }

    // string block_hash = 4;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // string parent_hash = 5;


    pub fn get_parent_hash(&self) -> &str {
        &self.parent_hash
    }
    pub fn clear_parent_hash(&mut self) {
        self.parent_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_hash(&mut self, v: ::std::string::String) {
        self.parent_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_hash(&mut self) -> &mut ::std::string::String {
        &mut self.parent_hash
    }

    // Take field
    pub fn take_parent_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_hash, ::std::string::String::new())
    }

    // sint64 num_pre_commits = 6;


    pub fn get_num_pre_commits(&self) -> i64 {
        self.num_pre_commits
    }
    pub fn clear_num_pre_commits(&mut self) {
        self.num_pre_commits = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pre_commits(&mut self, v: i64) {
        self.num_pre_commits = v;
    }

    // sint64 num_txs = 7;


    pub fn get_num_txs(&self) -> i64 {
        self.num_txs
    }
    pub fn clear_num_txs(&mut self) {
        self.num_txs = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_txs(&mut self, v: i64) {
        self.num_txs = v;
    }

    // repeated .injective_explorer_rpc.TxDataRPC txs = 8;


    pub fn get_txs(&self) -> &[TxDataRPC] {
        &self.txs
    }
    pub fn clear_txs(&mut self) {
        self.txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_txs(&mut self, v: ::protobuf::RepeatedField<TxDataRPC>) {
        self.txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txs(&mut self) -> &mut ::protobuf::RepeatedField<TxDataRPC> {
        &mut self.txs
    }

    // Take field
    pub fn take_txs(&mut self) -> ::protobuf::RepeatedField<TxDataRPC> {
        ::std::mem::replace(&mut self.txs, ::protobuf::RepeatedField::new())
    }

    // string timestamp = 9;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proposer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moniker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_hash)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_pre_commits = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.num_txs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txs)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.proposer);
        }
        if !self.moniker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.moniker);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if !self.parent_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parent_hash);
        }
        if self.num_pre_commits != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.num_pre_commits);
        }
        if self.num_txs != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.num_txs);
        }
        for value in &self.txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_uint64(1, self.height)?;
        }
        if !self.proposer.is_empty() {
            os.write_string(2, &self.proposer)?;
        }
        if !self.moniker.is_empty() {
            os.write_string(3, &self.moniker)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if !self.parent_hash.is_empty() {
            os.write_string(5, &self.parent_hash)?;
        }
        if self.num_pre_commits != 0 {
            os.write_sint64(6, self.num_pre_commits)?;
        }
        if self.num_txs != 0 {
            os.write_sint64(7, self.num_txs)?;
        }
        for v in &self.txs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.timestamp.is_empty() {
            os.write_string(9, &self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamBlocksResponse {
        StreamBlocksResponse::new()
    }

    fn default_instance() -> &'static StreamBlocksResponse {
        static instance: ::protobuf::rt::LazyV2<StreamBlocksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamBlocksResponse::new)
    }
}

impl ::protobuf::Clear for StreamBlocksResponse {
    fn clear(&mut self) {
        self.height = 0;
        self.proposer.clear();
        self.moniker.clear();
        self.block_hash.clear();
        self.parent_hash.clear();
        self.num_pre_commits = 0;
        self.num_txs = 0;
        self.txs.clear();
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
