// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective_derivative_exchange_rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketsRequest {
    // message fields
    pub market_status: ::std::string::String,
    pub quote_denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketsRequest {
    fn default() -> &'a MarketsRequest {
        <MarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarketsRequest {
    pub fn new() -> MarketsRequest {
        ::std::default::Default::default()
    }

    // string market_status = 1;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string quote_denom = 2;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_status);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quote_denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_status.is_empty() {
            os.write_string(1, &self.market_status)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(2, &self.quote_denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketsRequest {
        MarketsRequest::new()
    }

    fn default_instance() -> &'static MarketsRequest {
        static instance: ::protobuf::rt::LazyV2<MarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketsRequest::new)
    }
}

impl ::protobuf::Clear for MarketsRequest {
    fn clear(&mut self) {
        self.market_status.clear();
        self.quote_denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<DerivativeMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketsResponse {
    fn default() -> &'a MarketsResponse {
        <MarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarketsResponse {
    pub fn new() -> MarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1;


    pub fn get_markets(&self) -> &[DerivativeMarketInfo] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<DerivativeMarketInfo>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeMarketInfo> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<DerivativeMarketInfo> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketsResponse {
        MarketsResponse::new()
    }

    fn default_instance() -> &'static MarketsResponse {
        static instance: ::protobuf::rt::LazyV2<MarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketsResponse::new)
    }
}

impl ::protobuf::Clear for MarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub market_status: ::std::string::String,
    pub ticker: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_type: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub quote_token_meta: ::protobuf::SingularPtrField<TokenMeta>,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub service_provider_fee: ::std::string::String,
    pub is_perpetual: bool,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub perpetual_market_info: ::protobuf::SingularPtrField<PerpetualMarketInfo>,
    pub perpetual_market_funding: ::protobuf::SingularPtrField<PerpetualMarketFunding>,
    pub expiry_futures_market_info: ::protobuf::SingularPtrField<ExpiryFuturesMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketInfo {
    fn default() -> &'a DerivativeMarketInfo {
        <DerivativeMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketInfo {
    pub fn new() -> DerivativeMarketInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string market_status = 2;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_base = 4;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 5;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // string oracle_type = 6;


    pub fn get_oracle_type(&self) -> &str {
        &self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: ::std::string::String) {
        self.oracle_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_type(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_type
    }

    // Take field
    pub fn take_oracle_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_type, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // string initial_margin_ratio = 8;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 9;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string quote_denom = 10;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11;


    pub fn get_quote_token_meta(&self) -> &TokenMeta {
        self.quote_token_meta.as_ref().unwrap_or_else(|| <TokenMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote_token_meta(&mut self) {
        self.quote_token_meta.clear();
    }

    pub fn has_quote_token_meta(&self) -> bool {
        self.quote_token_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_token_meta(&mut self, v: TokenMeta) {
        self.quote_token_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_token_meta(&mut self) -> &mut TokenMeta {
        if self.quote_token_meta.is_none() {
            self.quote_token_meta.set_default();
        }
        self.quote_token_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote_token_meta(&mut self) -> TokenMeta {
        self.quote_token_meta.take().unwrap_or_else(|| TokenMeta::new())
    }

    // string maker_fee_rate = 12;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 13;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string service_provider_fee = 14;


    pub fn get_service_provider_fee(&self) -> &str {
        &self.service_provider_fee
    }
    pub fn clear_service_provider_fee(&mut self) {
        self.service_provider_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_provider_fee(&mut self, v: ::std::string::String) {
        self.service_provider_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_provider_fee(&mut self) -> &mut ::std::string::String {
        &mut self.service_provider_fee
    }

    // Take field
    pub fn take_service_provider_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_provider_fee, ::std::string::String::new())
    }

    // bool is_perpetual = 15;


    pub fn get_is_perpetual(&self) -> bool {
        self.is_perpetual
    }
    pub fn clear_is_perpetual(&mut self) {
        self.is_perpetual = false;
    }

    // Param is passed by value, moved
    pub fn set_is_perpetual(&mut self, v: bool) {
        self.is_perpetual = v;
    }

    // string min_price_tick_size = 16;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 17;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // .injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18;


    pub fn get_perpetual_market_info(&self) -> &PerpetualMarketInfo {
        self.perpetual_market_info.as_ref().unwrap_or_else(|| <PerpetualMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_perpetual_market_info(&mut self) {
        self.perpetual_market_info.clear();
    }

    pub fn has_perpetual_market_info(&self) -> bool {
        self.perpetual_market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_info(&mut self, v: PerpetualMarketInfo) {
        self.perpetual_market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perpetual_market_info(&mut self) -> &mut PerpetualMarketInfo {
        if self.perpetual_market_info.is_none() {
            self.perpetual_market_info.set_default();
        }
        self.perpetual_market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_perpetual_market_info(&mut self) -> PerpetualMarketInfo {
        self.perpetual_market_info.take().unwrap_or_else(|| PerpetualMarketInfo::new())
    }

    // .injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19;


    pub fn get_perpetual_market_funding(&self) -> &PerpetualMarketFunding {
        self.perpetual_market_funding.as_ref().unwrap_or_else(|| <PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_perpetual_market_funding(&mut self) {
        self.perpetual_market_funding.clear();
    }

    pub fn has_perpetual_market_funding(&self) -> bool {
        self.perpetual_market_funding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_funding(&mut self, v: PerpetualMarketFunding) {
        self.perpetual_market_funding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perpetual_market_funding(&mut self) -> &mut PerpetualMarketFunding {
        if self.perpetual_market_funding.is_none() {
            self.perpetual_market_funding.set_default();
        }
        self.perpetual_market_funding.as_mut().unwrap()
    }

    // Take field
    pub fn take_perpetual_market_funding(&mut self) -> PerpetualMarketFunding {
        self.perpetual_market_funding.take().unwrap_or_else(|| PerpetualMarketFunding::new())
    }

    // .injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20;


    pub fn get_expiry_futures_market_info(&self) -> &ExpiryFuturesMarketInfo {
        self.expiry_futures_market_info.as_ref().unwrap_or_else(|| <ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expiry_futures_market_info(&mut self) {
        self.expiry_futures_market_info.clear();
    }

    pub fn has_expiry_futures_market_info(&self) -> bool {
        self.expiry_futures_market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_futures_market_info(&mut self, v: ExpiryFuturesMarketInfo) {
        self.expiry_futures_market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiry_futures_market_info(&mut self) -> &mut ExpiryFuturesMarketInfo {
        if self.expiry_futures_market_info.is_none() {
            self.expiry_futures_market_info.set_default();
        }
        self.expiry_futures_market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiry_futures_market_info(&mut self) -> ExpiryFuturesMarketInfo {
        self.expiry_futures_market_info.take().unwrap_or_else(|| ExpiryFuturesMarketInfo::new())
    }
}

impl ::protobuf::Message for DerivativeMarketInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.quote_token_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_funding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiry_futures_market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_type)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote_token_meta)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_provider_fee)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_perpetual = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perpetual_market_info)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perpetual_market_funding)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiry_futures_market_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_status);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_quote);
        }
        if !self.oracle_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.maintenance_margin_ratio);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.quote_denom);
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.taker_fee_rate);
        }
        if !self.service_provider_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.service_provider_fee);
        }
        if self.is_perpetual != false {
            my_size += 2;
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.min_quantity_tick_size);
        }
        if let Some(ref v) = self.perpetual_market_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.perpetual_market_funding.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expiry_futures_market_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.market_status.is_empty() {
            os.write_string(2, &self.market_status)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(4, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(5, &self.oracle_quote)?;
        }
        if !self.oracle_type.is_empty() {
            os.write_string(6, &self.oracle_type)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(8, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(9, &self.maintenance_margin_ratio)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(10, &self.quote_denom)?;
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(12, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(13, &self.taker_fee_rate)?;
        }
        if !self.service_provider_fee.is_empty() {
            os.write_string(14, &self.service_provider_fee)?;
        }
        if self.is_perpetual != false {
            os.write_bool(15, self.is_perpetual)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(16, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(17, &self.min_quantity_tick_size)?;
        }
        if let Some(ref v) = self.perpetual_market_info.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.perpetual_market_funding.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expiry_futures_market_info.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketInfo {
        DerivativeMarketInfo::new()
    }

    fn default_instance() -> &'static DerivativeMarketInfo {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketInfo::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.market_status.clear();
        self.ticker.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_type.clear();
        self.oracle_scale_factor = 0;
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.quote_denom.clear();
        self.quote_token_meta.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.service_provider_fee.clear();
        self.is_perpetual = false;
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.perpetual_market_info.clear();
        self.perpetual_market_funding.clear();
        self.expiry_futures_market_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenMeta {
    // message fields
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub symbol: ::std::string::String,
    pub logo: ::std::string::String,
    pub decimals: i32,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenMeta {
    fn default() -> &'a TokenMeta {
        <TokenMeta as ::protobuf::Message>::default_instance()
    }
}

impl TokenMeta {
    pub fn new() -> TokenMeta {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string symbol = 3;


    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::std::string::String) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol, ::std::string::String::new())
    }

    // string logo = 4;


    pub fn get_logo(&self) -> &str {
        &self.logo
    }
    pub fn clear_logo(&mut self) {
        self.logo.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: ::std::string::String) {
        self.logo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo(&mut self) -> &mut ::std::string::String {
        &mut self.logo
    }

    // Take field
    pub fn take_logo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo, ::std::string::String::new())
    }

    // sint32 decimals = 5;


    pub fn get_decimals(&self) -> i32 {
        self.decimals
    }
    pub fn clear_decimals(&mut self) {
        self.decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_decimals(&mut self, v: i32) {
        self.decimals = v;
    }

    // sint64 updated_at = 6;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for TokenMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.decimals = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.symbol);
        }
        if !self.logo.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.logo);
        }
        if self.decimals != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.decimals);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if !self.symbol.is_empty() {
            os.write_string(3, &self.symbol)?;
        }
        if !self.logo.is_empty() {
            os.write_string(4, &self.logo)?;
        }
        if self.decimals != 0 {
            os.write_sint32(5, self.decimals)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(6, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenMeta {
        TokenMeta::new()
    }

    fn default_instance() -> &'static TokenMeta {
        static instance: ::protobuf::rt::LazyV2<TokenMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TokenMeta::new)
    }
}

impl ::protobuf::Clear for TokenMeta {
    fn clear(&mut self) {
        self.name.clear();
        self.address.clear();
        self.symbol.clear();
        self.logo.clear();
        self.decimals = 0;
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketInfo {
    // message fields
    pub hourly_funding_rate_cap: ::std::string::String,
    pub hourly_interest_rate: ::std::string::String,
    pub next_funding_timestamp: i64,
    pub funding_interval: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketInfo {
    fn default() -> &'a PerpetualMarketInfo {
        <PerpetualMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketInfo {
    pub fn new() -> PerpetualMarketInfo {
        ::std::default::Default::default()
    }

    // string hourly_funding_rate_cap = 1;


    pub fn get_hourly_funding_rate_cap(&self) -> &str {
        &self.hourly_funding_rate_cap
    }
    pub fn clear_hourly_funding_rate_cap(&mut self) {
        self.hourly_funding_rate_cap.clear();
    }

    // Param is passed by value, moved
    pub fn set_hourly_funding_rate_cap(&mut self, v: ::std::string::String) {
        self.hourly_funding_rate_cap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hourly_funding_rate_cap(&mut self) -> &mut ::std::string::String {
        &mut self.hourly_funding_rate_cap
    }

    // Take field
    pub fn take_hourly_funding_rate_cap(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hourly_funding_rate_cap, ::std::string::String::new())
    }

    // string hourly_interest_rate = 2;


    pub fn get_hourly_interest_rate(&self) -> &str {
        &self.hourly_interest_rate
    }
    pub fn clear_hourly_interest_rate(&mut self) {
        self.hourly_interest_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_hourly_interest_rate(&mut self, v: ::std::string::String) {
        self.hourly_interest_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hourly_interest_rate(&mut self) -> &mut ::std::string::String {
        &mut self.hourly_interest_rate
    }

    // Take field
    pub fn take_hourly_interest_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hourly_interest_rate, ::std::string::String::new())
    }

    // sint64 next_funding_timestamp = 3;


    pub fn get_next_funding_timestamp(&self) -> i64 {
        self.next_funding_timestamp
    }
    pub fn clear_next_funding_timestamp(&mut self) {
        self.next_funding_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_funding_timestamp(&mut self, v: i64) {
        self.next_funding_timestamp = v;
    }

    // sint64 funding_interval = 4;


    pub fn get_funding_interval(&self) -> i64 {
        self.funding_interval
    }
    pub fn clear_funding_interval(&mut self) {
        self.funding_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_funding_interval(&mut self, v: i64) {
        self.funding_interval = v;
    }
}

impl ::protobuf::Message for PerpetualMarketInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hourly_funding_rate_cap)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hourly_interest_rate)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.next_funding_timestamp = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.funding_interval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hourly_funding_rate_cap.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hourly_funding_rate_cap);
        }
        if !self.hourly_interest_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hourly_interest_rate);
        }
        if self.next_funding_timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.next_funding_timestamp);
        }
        if self.funding_interval != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.funding_interval);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hourly_funding_rate_cap.is_empty() {
            os.write_string(1, &self.hourly_funding_rate_cap)?;
        }
        if !self.hourly_interest_rate.is_empty() {
            os.write_string(2, &self.hourly_interest_rate)?;
        }
        if self.next_funding_timestamp != 0 {
            os.write_sint64(3, self.next_funding_timestamp)?;
        }
        if self.funding_interval != 0 {
            os.write_sint64(4, self.funding_interval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketInfo {
        PerpetualMarketInfo::new()
    }

    fn default_instance() -> &'static PerpetualMarketInfo {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketInfo::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketInfo {
    fn clear(&mut self) {
        self.hourly_funding_rate_cap.clear();
        self.hourly_interest_rate.clear();
        self.next_funding_timestamp = 0;
        self.funding_interval = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketFunding {
    // message fields
    pub cumulative_funding: ::std::string::String,
    pub cumulative_price: ::std::string::String,
    pub last_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketFunding {
    fn default() -> &'a PerpetualMarketFunding {
        <PerpetualMarketFunding as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketFunding {
    pub fn new() -> PerpetualMarketFunding {
        ::std::default::Default::default()
    }

    // string cumulative_funding = 1;


    pub fn get_cumulative_funding(&self) -> &str {
        &self.cumulative_funding
    }
    pub fn clear_cumulative_funding(&mut self) {
        self.cumulative_funding.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_funding(&mut self, v: ::std::string::String) {
        self.cumulative_funding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_funding(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_funding
    }

    // Take field
    pub fn take_cumulative_funding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_funding, ::std::string::String::new())
    }

    // string cumulative_price = 2;


    pub fn get_cumulative_price(&self) -> &str {
        &self.cumulative_price
    }
    pub fn clear_cumulative_price(&mut self) {
        self.cumulative_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_price(&mut self, v: ::std::string::String) {
        self.cumulative_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_price(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_price
    }

    // Take field
    pub fn take_cumulative_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_price, ::std::string::String::new())
    }

    // sint64 last_timestamp = 3;


    pub fn get_last_timestamp(&self) -> i64 {
        self.last_timestamp
    }
    pub fn clear_last_timestamp(&mut self) {
        self.last_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_timestamp(&mut self, v: i64) {
        self.last_timestamp = v;
    }
}

impl ::protobuf::Message for PerpetualMarketFunding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_funding)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_price)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.last_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cumulative_funding.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cumulative_funding);
        }
        if !self.cumulative_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cumulative_price);
        }
        if self.last_timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.last_timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cumulative_funding.is_empty() {
            os.write_string(1, &self.cumulative_funding)?;
        }
        if !self.cumulative_price.is_empty() {
            os.write_string(2, &self.cumulative_price)?;
        }
        if self.last_timestamp != 0 {
            os.write_sint64(3, self.last_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketFunding {
        PerpetualMarketFunding::new()
    }

    fn default_instance() -> &'static PerpetualMarketFunding {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketFunding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketFunding::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketFunding {
    fn clear(&mut self) {
        self.cumulative_funding.clear();
        self.cumulative_price.clear();
        self.last_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketFunding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpiryFuturesMarketInfo {
    // message fields
    pub expiration_timestamp: i64,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpiryFuturesMarketInfo {
    fn default() -> &'a ExpiryFuturesMarketInfo {
        <ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExpiryFuturesMarketInfo {
    pub fn new() -> ExpiryFuturesMarketInfo {
        ::std::default::Default::default()
    }

    // sint64 expiration_timestamp = 1;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // string settlement_price = 2;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExpiryFuturesMarketInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.expiration_timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.expiration_timestamp);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.expiration_timestamp != 0 {
            os.write_sint64(1, self.expiration_timestamp)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(2, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpiryFuturesMarketInfo {
        ExpiryFuturesMarketInfo::new()
    }

    fn default_instance() -> &'static ExpiryFuturesMarketInfo {
        static instance: ::protobuf::rt::LazyV2<ExpiryFuturesMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpiryFuturesMarketInfo::new)
    }
}

impl ::protobuf::Clear for ExpiryFuturesMarketInfo {
    fn clear(&mut self) {
        self.expiration_timestamp = 0;
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpiryFuturesMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketRequest {
    fn default() -> &'a MarketRequest {
        <MarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarketRequest {
    pub fn new() -> MarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketRequest {
        MarketRequest::new()
    }

    fn default_instance() -> &'static MarketRequest {
        static instance: ::protobuf::rt::LazyV2<MarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketRequest::new)
    }
}

impl ::protobuf::Clear for MarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<DerivativeMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketResponse {
    fn default() -> &'a MarketResponse {
        <MarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarketResponse {
    pub fn new() -> MarketResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1;


    pub fn get_market(&self) -> &DerivativeMarketInfo {
        self.market.as_ref().unwrap_or_else(|| <DerivativeMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: DerivativeMarketInfo) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut DerivativeMarketInfo {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> DerivativeMarketInfo {
        self.market.take().unwrap_or_else(|| DerivativeMarketInfo::new())
    }
}

impl ::protobuf::Message for MarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketResponse {
        MarketResponse::new()
    }

    fn default_instance() -> &'static MarketResponse {
        static instance: ::protobuf::rt::LazyV2<MarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketResponse::new)
    }
}

impl ::protobuf::Clear for MarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamMarketRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMarketRequest {
    fn default() -> &'a StreamMarketRequest {
        <StreamMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamMarketRequest {
    pub fn new() -> StreamMarketRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMarketRequest {
        StreamMarketRequest::new()
    }

    fn default_instance() -> &'static StreamMarketRequest {
        static instance: ::protobuf::rt::LazyV2<StreamMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMarketRequest::new)
    }
}

impl ::protobuf::Clear for StreamMarketRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamMarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<DerivativeMarketInfo>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMarketResponse {
    fn default() -> &'a StreamMarketResponse {
        <StreamMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamMarketResponse {
    pub fn new() -> StreamMarketResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1;


    pub fn get_market(&self) -> &DerivativeMarketInfo {
        self.market.as_ref().unwrap_or_else(|| <DerivativeMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: DerivativeMarketInfo) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut DerivativeMarketInfo {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> DerivativeMarketInfo {
        self.market.take().unwrap_or_else(|| DerivativeMarketInfo::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMarketResponse {
        StreamMarketResponse::new()
    }

    fn default_instance() -> &'static StreamMarketResponse {
        static instance: ::protobuf::rt::LazyV2<StreamMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMarketResponse::new)
    }
}

impl ::protobuf::Clear for StreamMarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketsRequest {
    // message fields
    pub market_status: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketsRequest {
    fn default() -> &'a BinaryOptionsMarketsRequest {
        <BinaryOptionsMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketsRequest {
    pub fn new() -> BinaryOptionsMarketsRequest {
        ::std::default::Default::default()
    }

    // string market_status = 1;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string quote_denom = 2;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for BinaryOptionsMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_status);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quote_denom);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_status.is_empty() {
            os.write_string(1, &self.market_status)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(2, &self.quote_denom)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketsRequest {
        BinaryOptionsMarketsRequest::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketsRequest::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketsRequest {
    fn clear(&mut self) {
        self.market_status.clear();
        self.quote_denom.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<BinaryOptionsMarketInfo>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketsResponse {
    fn default() -> &'a BinaryOptionsMarketsResponse {
        <BinaryOptionsMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketsResponse {
    pub fn new() -> BinaryOptionsMarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1;


    pub fn get_markets(&self) -> &[BinaryOptionsMarketInfo] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<BinaryOptionsMarketInfo>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<BinaryOptionsMarketInfo> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<BinaryOptionsMarketInfo> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketsResponse {
        BinaryOptionsMarketsResponse::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketsResponse::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub market_status: ::std::string::String,
    pub ticker: ::std::string::String,
    pub oracle_symbol: ::std::string::String,
    pub oracle_provider: ::std::string::String,
    pub oracle_type: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub quote_denom: ::std::string::String,
    pub quote_token_meta: ::protobuf::SingularPtrField<TokenMeta>,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub service_provider_fee: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketInfo {
    fn default() -> &'a BinaryOptionsMarketInfo {
        <BinaryOptionsMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketInfo {
    pub fn new() -> BinaryOptionsMarketInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string market_status = 2;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_symbol = 4;


    pub fn get_oracle_symbol(&self) -> &str {
        &self.oracle_symbol
    }
    pub fn clear_oracle_symbol(&mut self) {
        self.oracle_symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_symbol(&mut self, v: ::std::string::String) {
        self.oracle_symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_symbol
    }

    // Take field
    pub fn take_oracle_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_symbol, ::std::string::String::new())
    }

    // string oracle_provider = 5;


    pub fn get_oracle_provider(&self) -> &str {
        &self.oracle_provider
    }
    pub fn clear_oracle_provider(&mut self) {
        self.oracle_provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_provider(&mut self, v: ::std::string::String) {
        self.oracle_provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_provider(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_provider
    }

    // Take field
    pub fn take_oracle_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_provider, ::std::string::String::new())
    }

    // string oracle_type = 6;


    pub fn get_oracle_type(&self) -> &str {
        &self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: ::std::string::String) {
        self.oracle_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_type(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_type
    }

    // Take field
    pub fn take_oracle_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_type, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // sint64 expiration_timestamp = 8;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // sint64 settlement_timestamp = 9;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // string quote_denom = 10;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11;


    pub fn get_quote_token_meta(&self) -> &TokenMeta {
        self.quote_token_meta.as_ref().unwrap_or_else(|| <TokenMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote_token_meta(&mut self) {
        self.quote_token_meta.clear();
    }

    pub fn has_quote_token_meta(&self) -> bool {
        self.quote_token_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_token_meta(&mut self, v: TokenMeta) {
        self.quote_token_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_token_meta(&mut self) -> &mut TokenMeta {
        if self.quote_token_meta.is_none() {
            self.quote_token_meta.set_default();
        }
        self.quote_token_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote_token_meta(&mut self) -> TokenMeta {
        self.quote_token_meta.take().unwrap_or_else(|| TokenMeta::new())
    }

    // string maker_fee_rate = 12;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 13;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string service_provider_fee = 14;


    pub fn get_service_provider_fee(&self) -> &str {
        &self.service_provider_fee
    }
    pub fn clear_service_provider_fee(&mut self) {
        self.service_provider_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_provider_fee(&mut self, v: ::std::string::String) {
        self.service_provider_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_provider_fee(&mut self) -> &mut ::std::string::String {
        &mut self.service_provider_fee
    }

    // Take field
    pub fn take_service_provider_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_provider_fee, ::std::string::String::new())
    }

    // string min_price_tick_size = 15;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 16;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // string settlement_price = 17;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.quote_token_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_symbol)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_provider)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_type)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.expiration_timestamp = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.settlement_timestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote_token_meta)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_provider_fee)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_status);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.oracle_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_symbol);
        }
        if !self.oracle_provider.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_provider);
        }
        if !self.oracle_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.expiration_timestamp);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.settlement_timestamp);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.quote_denom);
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.taker_fee_rate);
        }
        if !self.service_provider_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.service_provider_fee);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.min_quantity_tick_size);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.market_status.is_empty() {
            os.write_string(2, &self.market_status)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            os.write_string(4, &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            os.write_string(5, &self.oracle_provider)?;
        }
        if !self.oracle_type.is_empty() {
            os.write_string(6, &self.oracle_type)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_sint64(8, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_sint64(9, self.settlement_timestamp)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(10, &self.quote_denom)?;
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(12, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(13, &self.taker_fee_rate)?;
        }
        if !self.service_provider_fee.is_empty() {
            os.write_string(14, &self.service_provider_fee)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(15, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(16, &self.min_quantity_tick_size)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(17, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketInfo {
        BinaryOptionsMarketInfo::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketInfo {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketInfo::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.market_status.clear();
        self.ticker.clear();
        self.oracle_symbol.clear();
        self.oracle_provider.clear();
        self.oracle_type.clear();
        self.oracle_scale_factor = 0;
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.quote_denom.clear();
        self.quote_token_meta.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.service_provider_fee.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Paging {
    // message fields
    pub total: i64,
    pub from: i32,
    pub to: i32,
    pub count_by_subaccount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Paging {
    fn default() -> &'a Paging {
        <Paging as ::protobuf::Message>::default_instance()
    }
}

impl Paging {
    pub fn new() -> Paging {
        ::std::default::Default::default()
    }

    // sint64 total = 1;


    pub fn get_total(&self) -> i64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i64) {
        self.total = v;
    }

    // sint32 from = 2;


    pub fn get_from(&self) -> i32 {
        self.from
    }
    pub fn clear_from(&mut self) {
        self.from = 0;
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = v;
    }

    // sint32 to = 3;


    pub fn get_to(&self) -> i32 {
        self.to
    }
    pub fn clear_to(&mut self) {
        self.to = 0;
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = v;
    }

    // sint64 count_by_subaccount = 4;


    pub fn get_count_by_subaccount(&self) -> i64 {
        self.count_by_subaccount
    }
    pub fn clear_count_by_subaccount(&mut self) {
        self.count_by_subaccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_by_subaccount(&mut self, v: i64) {
        self.count_by_subaccount = v;
    }
}

impl ::protobuf::Message for Paging {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.from = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.to = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.count_by_subaccount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.total);
        }
        if self.from != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.from);
        }
        if self.to != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.to);
        }
        if self.count_by_subaccount != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.count_by_subaccount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_sint64(1, self.total)?;
        }
        if self.from != 0 {
            os.write_sint32(2, self.from)?;
        }
        if self.to != 0 {
            os.write_sint32(3, self.to)?;
        }
        if self.count_by_subaccount != 0 {
            os.write_sint64(4, self.count_by_subaccount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Paging {
        Paging::new()
    }

    fn default_instance() -> &'static Paging {
        static instance: ::protobuf::rt::LazyV2<Paging> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Paging::new)
    }
}

impl ::protobuf::Clear for Paging {
    fn clear(&mut self) {
        self.total = 0;
        self.from = 0;
        self.to = 0;
        self.count_by_subaccount = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Paging {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketRequest {
    fn default() -> &'a BinaryOptionsMarketRequest {
        <BinaryOptionsMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketRequest {
    pub fn new() -> BinaryOptionsMarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketRequest {
        BinaryOptionsMarketRequest::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketRequest {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketRequest::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<BinaryOptionsMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketResponse {
    fn default() -> &'a BinaryOptionsMarketResponse {
        <BinaryOptionsMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketResponse {
    pub fn new() -> BinaryOptionsMarketResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1;


    pub fn get_market(&self) -> &BinaryOptionsMarketInfo {
        self.market.as_ref().unwrap_or_else(|| <BinaryOptionsMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: BinaryOptionsMarketInfo) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut BinaryOptionsMarketInfo {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> BinaryOptionsMarketInfo {
        self.market.take().unwrap_or_else(|| BinaryOptionsMarketInfo::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketResponse {
        BinaryOptionsMarketResponse::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketResponse {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketResponse::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookRequest {
    fn default() -> &'a OrderbookRequest {
        <OrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookRequest {
    pub fn new() -> OrderbookRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookRequest {
        OrderbookRequest::new()
    }

    fn default_instance() -> &'static OrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<OrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookRequest::new)
    }
}

impl ::protobuf::Clear for OrderbookRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookResponse {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookResponse {
    fn default() -> &'a OrderbookResponse {
        <OrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookResponse {
    pub fn new() -> OrderbookResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbook::new())
    }
}

impl ::protobuf::Message for OrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookResponse {
        OrderbookResponse::new()
    }

    fn default_instance() -> &'static OrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<OrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookResponse::new)
    }
}

impl ::protobuf::Clear for OrderbookResponse {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeLimitOrderbook {
    // message fields
    pub buys: ::protobuf::RepeatedField<PriceLevel>,
    pub sells: ::protobuf::RepeatedField<PriceLevel>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeLimitOrderbook {
    fn default() -> &'a DerivativeLimitOrderbook {
        <DerivativeLimitOrderbook as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeLimitOrderbook {
    pub fn new() -> DerivativeLimitOrderbook {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1;


    pub fn get_buys(&self) -> &[PriceLevel] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2;


    pub fn get_sells(&self) -> &[PriceLevel] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for DerivativeLimitOrderbook {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeLimitOrderbook {
        DerivativeLimitOrderbook::new()
    }

    fn default_instance() -> &'static DerivativeLimitOrderbook {
        static instance: ::protobuf::rt::LazyV2<DerivativeLimitOrderbook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeLimitOrderbook::new)
    }
}

impl ::protobuf::Clear for DerivativeLimitOrderbook {
    fn clear(&mut self) {
        self.buys.clear();
        self.sells.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeLimitOrderbook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceLevel {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceLevel {
    fn default() -> &'a PriceLevel {
        <PriceLevel as ::protobuf::Message>::default_instance()
    }
}

impl PriceLevel {
    pub fn new() -> PriceLevel {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PriceLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceLevel {
        PriceLevel::new()
    }

    fn default_instance() -> &'static PriceLevel {
        static instance: ::protobuf::rt::LazyV2<PriceLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PriceLevel::new)
    }
}

impl ::protobuf::Clear for PriceLevel {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookV2Request {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookV2Request {
    fn default() -> &'a OrderbookV2Request {
        <OrderbookV2Request as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookV2Request {
    pub fn new() -> OrderbookV2Request {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderbookV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookV2Request {
        OrderbookV2Request::new()
    }

    fn default_instance() -> &'static OrderbookV2Request {
        static instance: ::protobuf::rt::LazyV2<OrderbookV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookV2Request::new)
    }
}

impl ::protobuf::Clear for OrderbookV2Request {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookV2Response {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookV2Response {
    fn default() -> &'a OrderbookV2Response {
        <OrderbookV2Response as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookV2Response {
    pub fn new() -> OrderbookV2Response {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbookV2::new())
    }
}

impl ::protobuf::Message for OrderbookV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookV2Response {
        OrderbookV2Response::new()
    }

    fn default_instance() -> &'static OrderbookV2Response {
        static instance: ::protobuf::rt::LazyV2<OrderbookV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookV2Response::new)
    }
}

impl ::protobuf::Clear for OrderbookV2Response {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeLimitOrderbookV2 {
    // message fields
    pub buys: ::protobuf::RepeatedField<PriceLevel>,
    pub sells: ::protobuf::RepeatedField<PriceLevel>,
    pub sequence: u64,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeLimitOrderbookV2 {
    fn default() -> &'a DerivativeLimitOrderbookV2 {
        <DerivativeLimitOrderbookV2 as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeLimitOrderbookV2 {
    pub fn new() -> DerivativeLimitOrderbookV2 {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1;


    pub fn get_buys(&self) -> &[PriceLevel] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2;


    pub fn get_sells(&self) -> &[PriceLevel] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for DerivativeLimitOrderbookV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeLimitOrderbookV2 {
        DerivativeLimitOrderbookV2::new()
    }

    fn default_instance() -> &'static DerivativeLimitOrderbookV2 {
        static instance: ::protobuf::rt::LazyV2<DerivativeLimitOrderbookV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeLimitOrderbookV2::new)
    }
}

impl ::protobuf::Clear for DerivativeLimitOrderbookV2 {
    fn clear(&mut self) {
        self.buys.clear();
        self.sells.clear();
        self.sequence = 0;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeLimitOrderbookV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksRequest {
    fn default() -> &'a OrderbooksRequest {
        <OrderbooksRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksRequest {
    pub fn new() -> OrderbooksRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksRequest {
        OrderbooksRequest::new()
    }

    fn default_instance() -> &'static OrderbooksRequest {
        static instance: ::protobuf::rt::LazyV2<OrderbooksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksRequest::new)
    }
}

impl ::protobuf::Clear for OrderbooksRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksResponse {
    // message fields
    pub orderbooks: ::protobuf::RepeatedField<SingleDerivativeLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksResponse {
    fn default() -> &'a OrderbooksResponse {
        <OrderbooksResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksResponse {
    pub fn new() -> OrderbooksResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook orderbooks = 1;


    pub fn get_orderbooks(&self) -> &[SingleDerivativeLimitOrderbook] {
        &self.orderbooks
    }
    pub fn clear_orderbooks(&mut self) {
        self.orderbooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderbooks(&mut self, v: ::protobuf::RepeatedField<SingleDerivativeLimitOrderbook>) {
        self.orderbooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderbooks(&mut self) -> &mut ::protobuf::RepeatedField<SingleDerivativeLimitOrderbook> {
        &mut self.orderbooks
    }

    // Take field
    pub fn take_orderbooks(&mut self) -> ::protobuf::RepeatedField<SingleDerivativeLimitOrderbook> {
        ::std::mem::replace(&mut self.orderbooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbooks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orderbooks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orderbooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orderbooks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksResponse {
        OrderbooksResponse::new()
    }

    fn default_instance() -> &'static OrderbooksResponse {
        static instance: ::protobuf::rt::LazyV2<OrderbooksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksResponse::new)
    }
}

impl ::protobuf::Clear for OrderbooksResponse {
    fn clear(&mut self) {
        self.orderbooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDerivativeLimitOrderbook {
    // message fields
    pub market_id: ::std::string::String,
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleDerivativeLimitOrderbook {
    fn default() -> &'a SingleDerivativeLimitOrderbook {
        <SingleDerivativeLimitOrderbook as ::protobuf::Message>::default_instance()
    }
}

impl SingleDerivativeLimitOrderbook {
    pub fn new() -> SingleDerivativeLimitOrderbook {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 2;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbook::new())
    }
}

impl ::protobuf::Message for SingleDerivativeLimitOrderbook {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleDerivativeLimitOrderbook {
        SingleDerivativeLimitOrderbook::new()
    }

    fn default_instance() -> &'static SingleDerivativeLimitOrderbook {
        static instance: ::protobuf::rt::LazyV2<SingleDerivativeLimitOrderbook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleDerivativeLimitOrderbook::new)
    }
}

impl ::protobuf::Clear for SingleDerivativeLimitOrderbook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDerivativeLimitOrderbook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksV2Request {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksV2Request {
    fn default() -> &'a OrderbooksV2Request {
        <OrderbooksV2Request as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksV2Request {
    pub fn new() -> OrderbooksV2Request {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksV2Request {
        OrderbooksV2Request::new()
    }

    fn default_instance() -> &'static OrderbooksV2Request {
        static instance: ::protobuf::rt::LazyV2<OrderbooksV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksV2Request::new)
    }
}

impl ::protobuf::Clear for OrderbooksV2Request {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksV2Response {
    // message fields
    pub orderbooks: ::protobuf::RepeatedField<SingleDerivativeLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksV2Response {
    fn default() -> &'a OrderbooksV2Response {
        <OrderbooksV2Response as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksV2Response {
    pub fn new() -> OrderbooksV2Response {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1;


    pub fn get_orderbooks(&self) -> &[SingleDerivativeLimitOrderbookV2] {
        &self.orderbooks
    }
    pub fn clear_orderbooks(&mut self) {
        self.orderbooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderbooks(&mut self, v: ::protobuf::RepeatedField<SingleDerivativeLimitOrderbookV2>) {
        self.orderbooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderbooks(&mut self) -> &mut ::protobuf::RepeatedField<SingleDerivativeLimitOrderbookV2> {
        &mut self.orderbooks
    }

    // Take field
    pub fn take_orderbooks(&mut self) -> ::protobuf::RepeatedField<SingleDerivativeLimitOrderbookV2> {
        ::std::mem::replace(&mut self.orderbooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbooks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orderbooks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orderbooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orderbooks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksV2Response {
        OrderbooksV2Response::new()
    }

    fn default_instance() -> &'static OrderbooksV2Response {
        static instance: ::protobuf::rt::LazyV2<OrderbooksV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksV2Response::new)
    }
}

impl ::protobuf::Clear for OrderbooksV2Response {
    fn clear(&mut self) {
        self.orderbooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleDerivativeLimitOrderbookV2 {
    // message fields
    pub market_id: ::std::string::String,
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleDerivativeLimitOrderbookV2 {
    fn default() -> &'a SingleDerivativeLimitOrderbookV2 {
        <SingleDerivativeLimitOrderbookV2 as ::protobuf::Message>::default_instance()
    }
}

impl SingleDerivativeLimitOrderbookV2 {
    pub fn new() -> SingleDerivativeLimitOrderbookV2 {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbookV2::new())
    }
}

impl ::protobuf::Message for SingleDerivativeLimitOrderbookV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleDerivativeLimitOrderbookV2 {
        SingleDerivativeLimitOrderbookV2::new()
    }

    fn default_instance() -> &'static SingleDerivativeLimitOrderbookV2 {
        static instance: ::protobuf::rt::LazyV2<SingleDerivativeLimitOrderbookV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleDerivativeLimitOrderbookV2::new)
    }
}

impl ::protobuf::Clear for SingleDerivativeLimitOrderbookV2 {
    fn clear(&mut self) {
        self.market_id.clear();
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleDerivativeLimitOrderbookV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookRequest {
    fn default() -> &'a StreamOrderbookRequest {
        <StreamOrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookRequest {
    pub fn new() -> StreamOrderbookRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookRequest {
        StreamOrderbookRequest::new()
    }

    fn default_instance() -> &'static StreamOrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookResponse {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbook>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookResponse {
    fn default() -> &'a StreamOrderbookResponse {
        <StreamOrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookResponse {
    pub fn new() -> StreamOrderbookResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbook::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookResponse {
        StreamOrderbookResponse::new()
    }

    fn default_instance() -> &'static StreamOrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookResponse {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookV2Request {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookV2Request {
    fn default() -> &'a StreamOrderbookV2Request {
        <StreamOrderbookV2Request as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookV2Request {
    pub fn new() -> StreamOrderbookV2Request {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookV2Request {
        StreamOrderbookV2Request::new()
    }

    fn default_instance() -> &'static StreamOrderbookV2Request {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookV2Request::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookV2Request {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookV2Response {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<DerivativeLimitOrderbookV2>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookV2Response {
    fn default() -> &'a StreamOrderbookV2Response {
        <StreamOrderbookV2Response as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookV2Response {
    pub fn new() -> StreamOrderbookV2Response {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1;


    pub fn get_orderbook(&self) -> &DerivativeLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <DerivativeLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: DerivativeLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut DerivativeLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> DerivativeLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| DerivativeLimitOrderbookV2::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookV2Response {
        StreamOrderbookV2Response::new()
    }

    fn default_instance() -> &'static StreamOrderbookV2Response {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookV2Response::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookV2Response {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookUpdateRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookUpdateRequest {
    fn default() -> &'a StreamOrderbookUpdateRequest {
        <StreamOrderbookUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookUpdateRequest {
    pub fn new() -> StreamOrderbookUpdateRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookUpdateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookUpdateRequest {
        StreamOrderbookUpdateRequest::new()
    }

    fn default_instance() -> &'static StreamOrderbookUpdateRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookUpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookUpdateRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookUpdateRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookUpdateResponse {
    // message fields
    pub orderbook_level_updates: ::protobuf::SingularPtrField<OrderbookLevelUpdates>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookUpdateResponse {
    fn default() -> &'a StreamOrderbookUpdateResponse {
        <StreamOrderbookUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookUpdateResponse {
    pub fn new() -> StreamOrderbookUpdateResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1;


    pub fn get_orderbook_level_updates(&self) -> &OrderbookLevelUpdates {
        self.orderbook_level_updates.as_ref().unwrap_or_else(|| <OrderbookLevelUpdates as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook_level_updates(&mut self) {
        self.orderbook_level_updates.clear();
    }

    pub fn has_orderbook_level_updates(&self) -> bool {
        self.orderbook_level_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook_level_updates(&mut self, v: OrderbookLevelUpdates) {
        self.orderbook_level_updates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook_level_updates(&mut self) -> &mut OrderbookLevelUpdates {
        if self.orderbook_level_updates.is_none() {
            self.orderbook_level_updates.set_default();
        }
        self.orderbook_level_updates.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook_level_updates(&mut self) -> OrderbookLevelUpdates {
        self.orderbook_level_updates.take().unwrap_or_else(|| OrderbookLevelUpdates::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookUpdateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook_level_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook_level_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook_level_updates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook_level_updates.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookUpdateResponse {
        StreamOrderbookUpdateResponse::new()
    }

    fn default_instance() -> &'static StreamOrderbookUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookUpdateResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookUpdateResponse {
    fn clear(&mut self) {
        self.orderbook_level_updates.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookLevelUpdates {
    // message fields
    pub market_id: ::std::string::String,
    pub sequence: u64,
    pub buys: ::protobuf::RepeatedField<PriceLevelUpdate>,
    pub sells: ::protobuf::RepeatedField<PriceLevelUpdate>,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookLevelUpdates {
    fn default() -> &'a OrderbookLevelUpdates {
        <OrderbookLevelUpdates as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookLevelUpdates {
    pub fn new() -> OrderbookLevelUpdates {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 sequence = 2;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3;


    pub fn get_buys(&self) -> &[PriceLevelUpdate] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevelUpdate>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevelUpdate> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevelUpdate> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4;


    pub fn get_sells(&self) -> &[PriceLevelUpdate] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevelUpdate>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevelUpdate> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevelUpdate> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // sint64 updated_at = 5;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for OrderbookLevelUpdates {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.sequence != 0 {
            os.write_uint64(2, self.sequence)?;
        }
        for v in &self.buys {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.updated_at != 0 {
            os.write_sint64(5, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookLevelUpdates {
        OrderbookLevelUpdates::new()
    }

    fn default_instance() -> &'static OrderbookLevelUpdates {
        static instance: ::protobuf::rt::LazyV2<OrderbookLevelUpdates> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookLevelUpdates::new)
    }
}

impl ::protobuf::Clear for OrderbookLevelUpdates {
    fn clear(&mut self) {
        self.market_id.clear();
        self.sequence = 0;
        self.buys.clear();
        self.sells.clear();
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookLevelUpdates {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceLevelUpdate {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub is_active: bool,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceLevelUpdate {
    fn default() -> &'a PriceLevelUpdate {
        <PriceLevelUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PriceLevelUpdate {
    pub fn new() -> PriceLevelUpdate {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // bool is_active = 3;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PriceLevelUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if self.is_active != false {
            os.write_bool(3, self.is_active)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceLevelUpdate {
        PriceLevelUpdate::new()
    }

    fn default_instance() -> &'static PriceLevelUpdate {
        static instance: ::protobuf::rt::LazyV2<PriceLevelUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PriceLevelUpdate::new)
    }
}

impl ::protobuf::Clear for PriceLevelUpdate {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.is_active = false;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceLevelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub order_side: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub is_conditional: ::std::string::String,
    pub order_type: ::std::string::String,
    pub include_inactive: bool,
    pub subaccount_total_orders: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersRequest {
    fn default() -> &'a OrdersRequest {
        <OrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrdersRequest {
    pub fn new() -> OrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 5;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 6;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 7;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 8;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // string is_conditional = 9;


    pub fn get_is_conditional(&self) -> &str {
        &self.is_conditional
    }
    pub fn clear_is_conditional(&mut self) {
        self.is_conditional.clear();
    }

    // Param is passed by value, moved
    pub fn set_is_conditional(&mut self, v: ::std::string::String) {
        self.is_conditional = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_conditional(&mut self) -> &mut ::std::string::String {
        &mut self.is_conditional
    }

    // Take field
    pub fn take_is_conditional(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.is_conditional, ::std::string::String::new())
    }

    // string order_type = 10;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // bool include_inactive = 11;


    pub fn get_include_inactive(&self) -> bool {
        self.include_inactive
    }
    pub fn clear_include_inactive(&mut self) {
        self.include_inactive = false;
    }

    // Param is passed by value, moved
    pub fn set_include_inactive(&mut self, v: bool) {
        self.include_inactive = v;
    }

    // bool subaccount_total_orders = 12;


    pub fn get_subaccount_total_orders(&self) -> bool {
        self.subaccount_total_orders
    }
    pub fn clear_subaccount_total_orders(&mut self) {
        self.subaccount_total_orders = false;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_total_orders(&mut self, v: bool) {
        self.subaccount_total_orders = v;
    }
}

impl ::protobuf::Message for OrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.is_conditional)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_inactive = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subaccount_total_orders = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.is_conditional.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.is_conditional);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.order_type);
        }
        if self.include_inactive != false {
            my_size += 2;
        }
        if self.subaccount_total_orders != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(5, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(6, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(7, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(8, &v)?;
        };
        if !self.is_conditional.is_empty() {
            os.write_string(9, &self.is_conditional)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(10, &self.order_type)?;
        }
        if self.include_inactive != false {
            os.write_bool(11, self.include_inactive)?;
        }
        if self.subaccount_total_orders != false {
            os.write_bool(12, self.subaccount_total_orders)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersRequest {
        OrdersRequest::new()
    }

    fn default_instance() -> &'static OrdersRequest {
        static instance: ::protobuf::rt::LazyV2<OrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersRequest::new)
    }
}

impl ::protobuf::Clear for OrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_side.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.is_conditional.clear();
        self.order_type.clear();
        self.include_inactive = false;
        self.subaccount_total_orders = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<DerivativeLimitOrder>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersResponse {
    fn default() -> &'a OrdersResponse {
        <OrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrdersResponse {
    pub fn new() -> OrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[DerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<DerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for OrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersResponse {
        OrdersResponse::new()
    }

    fn default_instance() -> &'static OrdersResponse {
        static instance: ::protobuf::rt::LazyV2<OrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersResponse::new)
    }
}

impl ::protobuf::Clear for OrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeLimitOrder {
    // message fields
    pub order_hash: ::std::string::String,
    pub order_side: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub is_reduce_only: bool,
    pub margin: ::std::string::String,
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub unfilled_quantity: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub fee_recipient: ::std::string::String,
    pub state: ::std::string::String,
    pub created_at: i64,
    pub updated_at: i64,
    pub order_number: i64,
    pub order_type: ::std::string::String,
    pub is_conditional: bool,
    pub trigger_at: u64,
    pub placed_order_hash: ::std::string::String,
    pub execution_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeLimitOrder {
    fn default() -> &'a DerivativeLimitOrder {
        <DerivativeLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeLimitOrder {
    pub fn new() -> DerivativeLimitOrder {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // bool is_reduce_only = 5;


    pub fn get_is_reduce_only(&self) -> bool {
        self.is_reduce_only
    }
    pub fn clear_is_reduce_only(&mut self) {
        self.is_reduce_only = false;
    }

    // Param is passed by value, moved
    pub fn set_is_reduce_only(&mut self, v: bool) {
        self.is_reduce_only = v;
    }

    // string margin = 6;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string price = 7;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 8;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string unfilled_quantity = 9;


    pub fn get_unfilled_quantity(&self) -> &str {
        &self.unfilled_quantity
    }
    pub fn clear_unfilled_quantity(&mut self) {
        self.unfilled_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_unfilled_quantity(&mut self, v: ::std::string::String) {
        self.unfilled_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unfilled_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.unfilled_quantity
    }

    // Take field
    pub fn take_unfilled_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unfilled_quantity, ::std::string::String::new())
    }

    // string trigger_price = 10;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // string fee_recipient = 11;


    pub fn get_fee_recipient(&self) -> &str {
        &self.fee_recipient
    }
    pub fn clear_fee_recipient(&mut self) {
        self.fee_recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient(&mut self, v: ::std::string::String) {
        self.fee_recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.fee_recipient
    }

    // Take field
    pub fn take_fee_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_recipient, ::std::string::String::new())
    }

    // string state = 12;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint64 created_at = 13;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // sint64 updated_at = 14;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }

    // sint64 order_number = 15;


    pub fn get_order_number(&self) -> i64 {
        self.order_number
    }
    pub fn clear_order_number(&mut self) {
        self.order_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_order_number(&mut self, v: i64) {
        self.order_number = v;
    }

    // string order_type = 16;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // bool is_conditional = 17;


    pub fn get_is_conditional(&self) -> bool {
        self.is_conditional
    }
    pub fn clear_is_conditional(&mut self) {
        self.is_conditional = false;
    }

    // Param is passed by value, moved
    pub fn set_is_conditional(&mut self, v: bool) {
        self.is_conditional = v;
    }

    // uint64 trigger_at = 18;


    pub fn get_trigger_at(&self) -> u64 {
        self.trigger_at
    }
    pub fn clear_trigger_at(&mut self) {
        self.trigger_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_trigger_at(&mut self, v: u64) {
        self.trigger_at = v;
    }

    // string placed_order_hash = 19;


    pub fn get_placed_order_hash(&self) -> &str {
        &self.placed_order_hash
    }
    pub fn clear_placed_order_hash(&mut self) {
        self.placed_order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_placed_order_hash(&mut self, v: ::std::string::String) {
        self.placed_order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placed_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.placed_order_hash
    }

    // Take field
    pub fn take_placed_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.placed_order_hash, ::std::string::String::new())
    }

    // string execution_type = 20;


    pub fn get_execution_type(&self) -> &str {
        &self.execution_type
    }
    pub fn clear_execution_type(&mut self) {
        self.execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_type(&mut self, v: ::std::string::String) {
        self.execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.execution_type
    }

    // Take field
    pub fn take_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeLimitOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_reduce_only = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unfilled_quantity)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_recipient)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.order_number = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_conditional = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trigger_at = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.placed_order_hash)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if self.is_reduce_only != false {
            my_size += 2;
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.margin);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.quantity);
        }
        if !self.unfilled_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.unfilled_quantity);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.trigger_price);
        }
        if !self.fee_recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.fee_recipient);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(14, self.updated_at);
        }
        if self.order_number != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(15, self.order_number);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.order_type);
        }
        if self.is_conditional != false {
            my_size += 3;
        }
        if self.trigger_at != 0 {
            my_size += ::protobuf::rt::value_size(18, self.trigger_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.placed_order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.placed_order_hash);
        }
        if !self.execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.execution_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if self.is_reduce_only != false {
            os.write_bool(5, self.is_reduce_only)?;
        }
        if !self.margin.is_empty() {
            os.write_string(6, &self.margin)?;
        }
        if !self.price.is_empty() {
            os.write_string(7, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(8, &self.quantity)?;
        }
        if !self.unfilled_quantity.is_empty() {
            os.write_string(9, &self.unfilled_quantity)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(10, &self.trigger_price)?;
        }
        if !self.fee_recipient.is_empty() {
            os.write_string(11, &self.fee_recipient)?;
        }
        if !self.state.is_empty() {
            os.write_string(12, &self.state)?;
        }
        if self.created_at != 0 {
            os.write_sint64(13, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(14, self.updated_at)?;
        }
        if self.order_number != 0 {
            os.write_sint64(15, self.order_number)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(16, &self.order_type)?;
        }
        if self.is_conditional != false {
            os.write_bool(17, self.is_conditional)?;
        }
        if self.trigger_at != 0 {
            os.write_uint64(18, self.trigger_at)?;
        }
        if !self.placed_order_hash.is_empty() {
            os.write_string(19, &self.placed_order_hash)?;
        }
        if !self.execution_type.is_empty() {
            os.write_string(20, &self.execution_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeLimitOrder {
        DerivativeLimitOrder::new()
    }

    fn default_instance() -> &'static DerivativeLimitOrder {
        static instance: ::protobuf::rt::LazyV2<DerivativeLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeLimitOrder::new)
    }
}

impl ::protobuf::Clear for DerivativeLimitOrder {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.order_side.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.is_reduce_only = false;
        self.margin.clear();
        self.price.clear();
        self.quantity.clear();
        self.unfilled_quantity.clear();
        self.trigger_price.clear();
        self.fee_recipient.clear();
        self.state.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.order_number = 0;
        self.order_type.clear();
        self.is_conditional = false;
        self.trigger_at = 0;
        self.placed_order_hash.clear();
        self.execution_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub direction: ::std::string::String,
    pub subaccount_total_positions: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionsRequest {
    fn default() -> &'a PositionsRequest {
        <PositionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PositionsRequest {
    pub fn new() -> PositionsRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 5;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 6;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 7;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // string direction = 8;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // bool subaccount_total_positions = 9;


    pub fn get_subaccount_total_positions(&self) -> bool {
        self.subaccount_total_positions
    }
    pub fn clear_subaccount_total_positions(&mut self) {
        self.subaccount_total_positions = false;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_total_positions(&mut self, v: bool) {
        self.subaccount_total_positions = v;
    }
}

impl ::protobuf::Message for PositionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subaccount_total_positions = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.direction);
        }
        if self.subaccount_total_positions != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(5, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(6, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(7, &v)?;
        };
        if !self.direction.is_empty() {
            os.write_string(8, &self.direction)?;
        }
        if self.subaccount_total_positions != false {
            os.write_bool(9, self.subaccount_total_positions)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionsRequest {
        PositionsRequest::new()
    }

    fn default_instance() -> &'static PositionsRequest {
        static instance: ::protobuf::rt::LazyV2<PositionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PositionsRequest::new)
    }
}

impl ::protobuf::Clear for PositionsRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.direction.clear();
        self.subaccount_total_positions = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsResponse {
    // message fields
    pub positions: ::protobuf::RepeatedField<DerivativePosition>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionsResponse {
    fn default() -> &'a PositionsResponse {
        <PositionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PositionsResponse {
    pub fn new() -> PositionsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1;


    pub fn get_positions(&self) -> &[DerivativePosition] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::protobuf::RepeatedField<DerivativePosition>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::protobuf::RepeatedField<DerivativePosition> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::protobuf::RepeatedField<DerivativePosition> {
        ::std::mem::replace(&mut self.positions, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for PositionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.positions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.positions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.positions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionsResponse {
        PositionsResponse::new()
    }

    fn default_instance() -> &'static PositionsResponse {
        static instance: ::protobuf::rt::LazyV2<PositionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PositionsResponse::new)
    }
}

impl ::protobuf::Clear for PositionsResponse {
    fn clear(&mut self) {
        self.positions.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativePosition {
    // message fields
    pub ticker: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub direction: ::std::string::String,
    pub quantity: ::std::string::String,
    pub entry_price: ::std::string::String,
    pub margin: ::std::string::String,
    pub liquidation_price: ::std::string::String,
    pub mark_price: ::std::string::String,
    pub aggregate_reduce_only_quantity: ::std::string::String,
    pub updated_at: i64,
    pub created_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativePosition {
    fn default() -> &'a DerivativePosition {
        <DerivativePosition as ::protobuf::Message>::default_instance()
    }
}

impl DerivativePosition {
    pub fn new() -> DerivativePosition {
        ::std::default::Default::default()
    }

    // string ticker = 1;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string direction = 4;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string quantity = 5;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string entry_price = 6;


    pub fn get_entry_price(&self) -> &str {
        &self.entry_price
    }
    pub fn clear_entry_price(&mut self) {
        self.entry_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_price(&mut self, v: ::std::string::String) {
        self.entry_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_price(&mut self) -> &mut ::std::string::String {
        &mut self.entry_price
    }

    // Take field
    pub fn take_entry_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_price, ::std::string::String::new())
    }

    // string margin = 7;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string liquidation_price = 8;


    pub fn get_liquidation_price(&self) -> &str {
        &self.liquidation_price
    }
    pub fn clear_liquidation_price(&mut self) {
        self.liquidation_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_liquidation_price(&mut self, v: ::std::string::String) {
        self.liquidation_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_liquidation_price(&mut self) -> &mut ::std::string::String {
        &mut self.liquidation_price
    }

    // Take field
    pub fn take_liquidation_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.liquidation_price, ::std::string::String::new())
    }

    // string mark_price = 9;


    pub fn get_mark_price(&self) -> &str {
        &self.mark_price
    }
    pub fn clear_mark_price(&mut self) {
        self.mark_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mark_price(&mut self, v: ::std::string::String) {
        self.mark_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mark_price(&mut self) -> &mut ::std::string::String {
        &mut self.mark_price
    }

    // Take field
    pub fn take_mark_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mark_price, ::std::string::String::new())
    }

    // string aggregate_reduce_only_quantity = 11;


    pub fn get_aggregate_reduce_only_quantity(&self) -> &str {
        &self.aggregate_reduce_only_quantity
    }
    pub fn clear_aggregate_reduce_only_quantity(&mut self) {
        self.aggregate_reduce_only_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_reduce_only_quantity(&mut self, v: ::std::string::String) {
        self.aggregate_reduce_only_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_reduce_only_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.aggregate_reduce_only_quantity
    }

    // Take field
    pub fn take_aggregate_reduce_only_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aggregate_reduce_only_quantity, ::std::string::String::new())
    }

    // sint64 updated_at = 12;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }

    // sint64 created_at = 13;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }
}

impl ::protobuf::Message for DerivativePosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_price)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.liquidation_price)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mark_price)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aggregate_reduce_only_quantity)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticker);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.quantity);
        }
        if !self.entry_price.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.entry_price);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.margin);
        }
        if !self.liquidation_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.liquidation_price);
        }
        if !self.mark_price.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.mark_price);
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.aggregate_reduce_only_quantity);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.updated_at);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.created_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ticker.is_empty() {
            os.write_string(1, &self.ticker)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(5, &self.quantity)?;
        }
        if !self.entry_price.is_empty() {
            os.write_string(6, &self.entry_price)?;
        }
        if !self.margin.is_empty() {
            os.write_string(7, &self.margin)?;
        }
        if !self.liquidation_price.is_empty() {
            os.write_string(8, &self.liquidation_price)?;
        }
        if !self.mark_price.is_empty() {
            os.write_string(9, &self.mark_price)?;
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            os.write_string(11, &self.aggregate_reduce_only_quantity)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(12, self.updated_at)?;
        }
        if self.created_at != 0 {
            os.write_sint64(13, self.created_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativePosition {
        DerivativePosition::new()
    }

    fn default_instance() -> &'static DerivativePosition {
        static instance: ::protobuf::rt::LazyV2<DerivativePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativePosition::new)
    }
}

impl ::protobuf::Clear for DerivativePosition {
    fn clear(&mut self) {
        self.ticker.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.direction.clear();
        self.quantity.clear();
        self.entry_price.clear();
        self.margin.clear();
        self.liquidation_price.clear();
        self.mark_price.clear();
        self.aggregate_reduce_only_quantity.clear();
        self.updated_at = 0;
        self.created_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LiquidablePositionsRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LiquidablePositionsRequest {
    fn default() -> &'a LiquidablePositionsRequest {
        <LiquidablePositionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl LiquidablePositionsRequest {
    pub fn new() -> LiquidablePositionsRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 2;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for LiquidablePositionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(2, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(2, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LiquidablePositionsRequest {
        LiquidablePositionsRequest::new()
    }

    fn default_instance() -> &'static LiquidablePositionsRequest {
        static instance: ::protobuf::rt::LazyV2<LiquidablePositionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LiquidablePositionsRequest::new)
    }
}

impl ::protobuf::Clear for LiquidablePositionsRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidablePositionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LiquidablePositionsResponse {
    // message fields
    pub positions: ::protobuf::RepeatedField<DerivativePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LiquidablePositionsResponse {
    fn default() -> &'a LiquidablePositionsResponse {
        <LiquidablePositionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl LiquidablePositionsResponse {
    pub fn new() -> LiquidablePositionsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1;


    pub fn get_positions(&self) -> &[DerivativePosition] {
        &self.positions
    }
    pub fn clear_positions(&mut self) {
        self.positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_positions(&mut self, v: ::protobuf::RepeatedField<DerivativePosition>) {
        self.positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_positions(&mut self) -> &mut ::protobuf::RepeatedField<DerivativePosition> {
        &mut self.positions
    }

    // Take field
    pub fn take_positions(&mut self) -> ::protobuf::RepeatedField<DerivativePosition> {
        ::std::mem::replace(&mut self.positions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LiquidablePositionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.positions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.positions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.positions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LiquidablePositionsResponse {
        LiquidablePositionsResponse::new()
    }

    fn default_instance() -> &'static LiquidablePositionsResponse {
        static instance: ::protobuf::rt::LazyV2<LiquidablePositionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LiquidablePositionsResponse::new)
    }
}

impl ::protobuf::Clear for LiquidablePositionsResponse {
    fn clear(&mut self) {
        self.positions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LiquidablePositionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingPaymentsRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingPaymentsRequest {
    fn default() -> &'a FundingPaymentsRequest {
        <FundingPaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FundingPaymentsRequest {
    pub fn new() -> FundingPaymentsRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 end_time = 5;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 6;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FundingPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        if self.end_time != 0 {
            os.write_sint64(5, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingPaymentsRequest {
        FundingPaymentsRequest::new()
    }

    fn default_instance() -> &'static FundingPaymentsRequest {
        static instance: ::protobuf::rt::LazyV2<FundingPaymentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingPaymentsRequest::new)
    }
}

impl ::protobuf::Clear for FundingPaymentsRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingPaymentsResponse {
    // message fields
    pub payments: ::protobuf::RepeatedField<FundingPayment>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingPaymentsResponse {
    fn default() -> &'a FundingPaymentsResponse {
        <FundingPaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FundingPaymentsResponse {
    pub fn new() -> FundingPaymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.FundingPayment payments = 1;


    pub fn get_payments(&self) -> &[FundingPayment] {
        &self.payments
    }
    pub fn clear_payments(&mut self) {
        self.payments.clear();
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: ::protobuf::RepeatedField<FundingPayment>) {
        self.payments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payments(&mut self) -> &mut ::protobuf::RepeatedField<FundingPayment> {
        &mut self.payments
    }

    // Take field
    pub fn take_payments(&mut self) -> ::protobuf::RepeatedField<FundingPayment> {
        ::std::mem::replace(&mut self.payments, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for FundingPaymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payments)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingPaymentsResponse {
        FundingPaymentsResponse::new()
    }

    fn default_instance() -> &'static FundingPaymentsResponse {
        static instance: ::protobuf::rt::LazyV2<FundingPaymentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingPaymentsResponse::new)
    }
}

impl ::protobuf::Clear for FundingPaymentsResponse {
    fn clear(&mut self) {
        self.payments.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingPayment {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub amount: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingPayment {
    fn default() -> &'a FundingPayment {
        <FundingPayment as ::protobuf::Message>::default_instance()
    }
}

impl FundingPayment {
    pub fn new() -> FundingPayment {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string amount = 3;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for FundingPayment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.amount);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.amount.is_empty() {
            os.write_string(3, &self.amount)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingPayment {
        FundingPayment::new()
    }

    fn default_instance() -> &'static FundingPayment {
        static instance: ::protobuf::rt::LazyV2<FundingPayment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingPayment::new)
    }
}

impl ::protobuf::Clear for FundingPayment {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.amount.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingPayment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingRatesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub end_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingRatesRequest {
    fn default() -> &'a FundingRatesRequest {
        <FundingRatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl FundingRatesRequest {
    pub fn new() -> FundingRatesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 2;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 end_time = 4;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }
}

impl ::protobuf::Message for FundingRatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(2, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.limit);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.end_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(2, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(3, self.limit)?;
        }
        if self.end_time != 0 {
            os.write_sint64(4, self.end_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingRatesRequest {
        FundingRatesRequest::new()
    }

    fn default_instance() -> &'static FundingRatesRequest {
        static instance: ::protobuf::rt::LazyV2<FundingRatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingRatesRequest::new)
    }
}

impl ::protobuf::Clear for FundingRatesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.end_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingRatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingRatesResponse {
    // message fields
    pub funding_rates: ::protobuf::RepeatedField<FundingRate>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingRatesResponse {
    fn default() -> &'a FundingRatesResponse {
        <FundingRatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl FundingRatesResponse {
    pub fn new() -> FundingRatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.FundingRate funding_rates = 1;


    pub fn get_funding_rates(&self) -> &[FundingRate] {
        &self.funding_rates
    }
    pub fn clear_funding_rates(&mut self) {
        self.funding_rates.clear();
    }

    // Param is passed by value, moved
    pub fn set_funding_rates(&mut self, v: ::protobuf::RepeatedField<FundingRate>) {
        self.funding_rates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_funding_rates(&mut self) -> &mut ::protobuf::RepeatedField<FundingRate> {
        &mut self.funding_rates
    }

    // Take field
    pub fn take_funding_rates(&mut self) -> ::protobuf::RepeatedField<FundingRate> {
        ::std::mem::replace(&mut self.funding_rates, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for FundingRatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.funding_rates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.funding_rates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.funding_rates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.funding_rates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingRatesResponse {
        FundingRatesResponse::new()
    }

    fn default_instance() -> &'static FundingRatesResponse {
        static instance: ::protobuf::rt::LazyV2<FundingRatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingRatesResponse::new)
    }
}

impl ::protobuf::Clear for FundingRatesResponse {
    fn clear(&mut self) {
        self.funding_rates.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingRatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FundingRate {
    // message fields
    pub market_id: ::std::string::String,
    pub rate: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FundingRate {
    fn default() -> &'a FundingRate {
        <FundingRate as ::protobuf::Message>::default_instance()
    }
}

impl FundingRate {
    pub fn new() -> FundingRate {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string rate = 2;


    pub fn get_rate(&self) -> &str {
        &self.rate
    }
    pub fn clear_rate(&mut self) {
        self.rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate(&mut self, v: ::std::string::String) {
        self.rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rate(&mut self) -> &mut ::std::string::String {
        &mut self.rate
    }

    // Take field
    pub fn take_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rate, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for FundingRate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rate)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.rate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rate);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.rate.is_empty() {
            os.write_string(2, &self.rate)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FundingRate {
        FundingRate::new()
    }

    fn default_instance() -> &'static FundingRate {
        static instance: ::protobuf::rt::LazyV2<FundingRate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FundingRate::new)
    }
}

impl ::protobuf::Clear for FundingRate {
    fn clear(&mut self) {
        self.market_id.clear();
        self.rate.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FundingRate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamPositionsRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub subaccount_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamPositionsRequest {
    fn default() -> &'a StreamPositionsRequest {
        <StreamPositionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamPositionsRequest {
    pub fn new() -> StreamPositionsRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated string market_ids = 3;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string subaccount_ids = 4;


    pub fn get_subaccount_ids(&self) -> &[::std::string::String] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamPositionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        for v in &self.market_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.subaccount_ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamPositionsRequest {
        StreamPositionsRequest::new()
    }

    fn default_instance() -> &'static StreamPositionsRequest {
        static instance: ::protobuf::rt::LazyV2<StreamPositionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamPositionsRequest::new)
    }
}

impl ::protobuf::Clear for StreamPositionsRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.market_ids.clear();
        self.subaccount_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamPositionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamPositionsResponse {
    // message fields
    pub position: ::protobuf::SingularPtrField<DerivativePosition>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamPositionsResponse {
    fn default() -> &'a StreamPositionsResponse {
        <StreamPositionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamPositionsResponse {
    pub fn new() -> StreamPositionsResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativePosition position = 1;


    pub fn get_position(&self) -> &DerivativePosition {
        self.position.as_ref().unwrap_or_else(|| <DerivativePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: DerivativePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut DerivativePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> DerivativePosition {
        self.position.take().unwrap_or_else(|| DerivativePosition::new())
    }

    // sint64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamPositionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamPositionsResponse {
        StreamPositionsResponse::new()
    }

    fn default_instance() -> &'static StreamPositionsResponse {
        static instance: ::protobuf::rt::LazyV2<StreamPositionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamPositionsResponse::new)
    }
}

impl ::protobuf::Clear for StreamPositionsResponse {
    fn clear(&mut self) {
        self.position.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamPositionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub order_side: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub is_conditional: ::std::string::String,
    pub order_type: ::std::string::String,
    pub include_inactive: bool,
    pub subaccount_total_orders: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersRequest {
    fn default() -> &'a StreamOrdersRequest {
        <StreamOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersRequest {
    pub fn new() -> StreamOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 5;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 6;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 7;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 8;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // string is_conditional = 9;


    pub fn get_is_conditional(&self) -> &str {
        &self.is_conditional
    }
    pub fn clear_is_conditional(&mut self) {
        self.is_conditional.clear();
    }

    // Param is passed by value, moved
    pub fn set_is_conditional(&mut self, v: ::std::string::String) {
        self.is_conditional = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_conditional(&mut self) -> &mut ::std::string::String {
        &mut self.is_conditional
    }

    // Take field
    pub fn take_is_conditional(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.is_conditional, ::std::string::String::new())
    }

    // string order_type = 10;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // bool include_inactive = 11;


    pub fn get_include_inactive(&self) -> bool {
        self.include_inactive
    }
    pub fn clear_include_inactive(&mut self) {
        self.include_inactive = false;
    }

    // Param is passed by value, moved
    pub fn set_include_inactive(&mut self, v: bool) {
        self.include_inactive = v;
    }

    // bool subaccount_total_orders = 12;


    pub fn get_subaccount_total_orders(&self) -> bool {
        self.subaccount_total_orders
    }
    pub fn clear_subaccount_total_orders(&mut self) {
        self.subaccount_total_orders = false;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_total_orders(&mut self, v: bool) {
        self.subaccount_total_orders = v;
    }
}

impl ::protobuf::Message for StreamOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.is_conditional)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_inactive = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subaccount_total_orders = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.is_conditional.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.is_conditional);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.order_type);
        }
        if self.include_inactive != false {
            my_size += 2;
        }
        if self.subaccount_total_orders != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(5, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(6, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(7, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(8, &v)?;
        };
        if !self.is_conditional.is_empty() {
            os.write_string(9, &self.is_conditional)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(10, &self.order_type)?;
        }
        if self.include_inactive != false {
            os.write_bool(11, self.include_inactive)?;
        }
        if self.subaccount_total_orders != false {
            os.write_bool(12, self.subaccount_total_orders)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersRequest {
        StreamOrdersRequest::new()
    }

    fn default_instance() -> &'static StreamOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_side.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.is_conditional.clear();
        self.order_type.clear();
        self.include_inactive = false;
        self.subaccount_total_orders = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersResponse {
    // message fields
    pub order: ::protobuf::SingularPtrField<DerivativeLimitOrder>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersResponse {
    fn default() -> &'a StreamOrdersResponse {
        <StreamOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersResponse {
    pub fn new() -> StreamOrdersResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1;


    pub fn get_order(&self) -> &DerivativeLimitOrder {
        self.order.as_ref().unwrap_or_else(|| <DerivativeLimitOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: DerivativeLimitOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut DerivativeLimitOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> DerivativeLimitOrder {
        self.order.take().unwrap_or_else(|| DerivativeLimitOrder::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersResponse {
        StreamOrdersResponse::new()
    }

    fn default_instance() -> &'static StreamOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrdersResponse {
    fn clear(&mut self) {
        self.order.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    pub direction: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub subaccount_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradesRequest {
    fn default() -> &'a TradesRequest {
        <TradesRequest as ::protobuf::Message>::default_instance()
    }
}

impl TradesRequest {
    pub fn new() -> TradesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_side = 2;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }

    // string direction = 3;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 9;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string subaccount_ids = 10;


    pub fn get_subaccount_ids(&self) -> &[::std::string::String] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string execution_types = 11;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_side);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.direction);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(2, &self.execution_side)?;
        }
        if !self.direction.is_empty() {
            os.write_string(3, &self.direction)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.subaccount_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.execution_types {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradesRequest {
        TradesRequest::new()
    }

    fn default_instance() -> &'static TradesRequest {
        static instance: ::protobuf::rt::LazyV2<TradesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradesRequest::new)
    }
}

impl ::protobuf::Clear for TradesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.execution_side.clear();
        self.direction.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.subaccount_ids.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradesResponse {
    // message fields
    pub trades: ::protobuf::RepeatedField<DerivativeTrade>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradesResponse {
    fn default() -> &'a TradesResponse {
        <TradesResponse as ::protobuf::Message>::default_instance()
    }
}

impl TradesResponse {
    pub fn new() -> TradesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1;


    pub fn get_trades(&self) -> &[DerivativeTrade] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<DerivativeTrade>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeTrade> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<DerivativeTrade> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for TradesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trades {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradesResponse {
        TradesResponse::new()
    }

    fn default_instance() -> &'static TradesResponse {
        static instance: ::protobuf::rt::LazyV2<TradesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradesResponse::new)
    }
}

impl ::protobuf::Clear for TradesResponse {
    fn clear(&mut self) {
        self.trades.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeTrade {
    // message fields
    pub order_hash: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub trade_execution_type: ::std::string::String,
    pub is_liquidation: bool,
    pub position_delta: ::protobuf::SingularPtrField<PositionDelta>,
    pub payout: ::std::string::String,
    pub fee: ::std::string::String,
    pub executed_at: i64,
    pub fee_recipient: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeTrade {
    fn default() -> &'a DerivativeTrade {
        <DerivativeTrade as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeTrade {
    pub fn new() -> DerivativeTrade {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string trade_execution_type = 4;


    pub fn get_trade_execution_type(&self) -> &str {
        &self.trade_execution_type
    }
    pub fn clear_trade_execution_type(&mut self) {
        self.trade_execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_execution_type(&mut self, v: ::std::string::String) {
        self.trade_execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.trade_execution_type
    }

    // Take field
    pub fn take_trade_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_execution_type, ::std::string::String::new())
    }

    // bool is_liquidation = 5;


    pub fn get_is_liquidation(&self) -> bool {
        self.is_liquidation
    }
    pub fn clear_is_liquidation(&mut self) {
        self.is_liquidation = false;
    }

    // Param is passed by value, moved
    pub fn set_is_liquidation(&mut self, v: bool) {
        self.is_liquidation = v;
    }

    // .injective_derivative_exchange_rpc.PositionDelta position_delta = 6;


    pub fn get_position_delta(&self) -> &PositionDelta {
        self.position_delta.as_ref().unwrap_or_else(|| <PositionDelta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position_delta(&mut self) {
        self.position_delta.clear();
    }

    pub fn has_position_delta(&self) -> bool {
        self.position_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_delta(&mut self, v: PositionDelta) {
        self.position_delta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_delta(&mut self) -> &mut PositionDelta {
        if self.position_delta.is_none() {
            self.position_delta.set_default();
        }
        self.position_delta.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_delta(&mut self) -> PositionDelta {
        self.position_delta.take().unwrap_or_else(|| PositionDelta::new())
    }

    // string payout = 7;


    pub fn get_payout(&self) -> &str {
        &self.payout
    }
    pub fn clear_payout(&mut self) {
        self.payout.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout(&mut self, v: ::std::string::String) {
        self.payout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout(&mut self) -> &mut ::std::string::String {
        &mut self.payout
    }

    // Take field
    pub fn take_payout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payout, ::std::string::String::new())
    }

    // string fee = 8;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }

    // sint64 executed_at = 9;


    pub fn get_executed_at(&self) -> i64 {
        self.executed_at
    }
    pub fn clear_executed_at(&mut self) {
        self.executed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_executed_at(&mut self, v: i64) {
        self.executed_at = v;
    }

    // string fee_recipient = 10;


    pub fn get_fee_recipient(&self) -> &str {
        &self.fee_recipient
    }
    pub fn clear_fee_recipient(&mut self) {
        self.fee_recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient(&mut self, v: ::std::string::String) {
        self.fee_recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.fee_recipient
    }

    // Take field
    pub fn take_fee_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_recipient, ::std::string::String::new())
    }

    // string trade_id = 11;


    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // string execution_side = 12;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.position_delta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_execution_type)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_liquidation = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_delta)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payout)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.executed_at = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_recipient)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_id)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.trade_execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trade_execution_type);
        }
        if self.is_liquidation != false {
            my_size += 2;
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payout.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.payout);
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fee);
        }
        if self.executed_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.executed_at);
        }
        if !self.fee_recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.fee_recipient);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.trade_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.execution_side);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.trade_execution_type.is_empty() {
            os.write_string(4, &self.trade_execution_type)?;
        }
        if self.is_liquidation != false {
            os.write_bool(5, self.is_liquidation)?;
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payout.is_empty() {
            os.write_string(7, &self.payout)?;
        }
        if !self.fee.is_empty() {
            os.write_string(8, &self.fee)?;
        }
        if self.executed_at != 0 {
            os.write_sint64(9, self.executed_at)?;
        }
        if !self.fee_recipient.is_empty() {
            os.write_string(10, &self.fee_recipient)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(11, &self.trade_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(12, &self.execution_side)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeTrade {
        DerivativeTrade::new()
    }

    fn default_instance() -> &'static DerivativeTrade {
        static instance: ::protobuf::rt::LazyV2<DerivativeTrade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeTrade::new)
    }
}

impl ::protobuf::Clear for DerivativeTrade {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.subaccount_id.clear();
        self.market_id.clear();
        self.trade_execution_type.clear();
        self.is_liquidation = false;
        self.position_delta.clear();
        self.payout.clear();
        self.fee.clear();
        self.executed_at = 0;
        self.fee_recipient.clear();
        self.trade_id.clear();
        self.execution_side.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionDelta {
    // message fields
    pub trade_direction: ::std::string::String,
    pub execution_price: ::std::string::String,
    pub execution_quantity: ::std::string::String,
    pub execution_margin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionDelta {
    fn default() -> &'a PositionDelta {
        <PositionDelta as ::protobuf::Message>::default_instance()
    }
}

impl PositionDelta {
    pub fn new() -> PositionDelta {
        ::std::default::Default::default()
    }

    // string trade_direction = 1;


    pub fn get_trade_direction(&self) -> &str {
        &self.trade_direction
    }
    pub fn clear_trade_direction(&mut self) {
        self.trade_direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_direction(&mut self, v: ::std::string::String) {
        self.trade_direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_direction(&mut self) -> &mut ::std::string::String {
        &mut self.trade_direction
    }

    // Take field
    pub fn take_trade_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_direction, ::std::string::String::new())
    }

    // string execution_price = 2;


    pub fn get_execution_price(&self) -> &str {
        &self.execution_price
    }
    pub fn clear_execution_price(&mut self) {
        self.execution_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_price(&mut self, v: ::std::string::String) {
        self.execution_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_price(&mut self) -> &mut ::std::string::String {
        &mut self.execution_price
    }

    // Take field
    pub fn take_execution_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_price, ::std::string::String::new())
    }

    // string execution_quantity = 3;


    pub fn get_execution_quantity(&self) -> &str {
        &self.execution_quantity
    }
    pub fn clear_execution_quantity(&mut self) {
        self.execution_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_quantity(&mut self, v: ::std::string::String) {
        self.execution_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.execution_quantity
    }

    // Take field
    pub fn take_execution_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_quantity, ::std::string::String::new())
    }

    // string execution_margin = 4;


    pub fn get_execution_margin(&self) -> &str {
        &self.execution_margin
    }
    pub fn clear_execution_margin(&mut self) {
        self.execution_margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_margin(&mut self, v: ::std::string::String) {
        self.execution_margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_margin(&mut self) -> &mut ::std::string::String {
        &mut self.execution_margin
    }

    // Take field
    pub fn take_execution_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_margin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PositionDelta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_direction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_quantity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_margin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trade_direction.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trade_direction);
        }
        if !self.execution_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_price);
        }
        if !self.execution_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.execution_quantity);
        }
        if !self.execution_margin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.execution_margin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trade_direction.is_empty() {
            os.write_string(1, &self.trade_direction)?;
        }
        if !self.execution_price.is_empty() {
            os.write_string(2, &self.execution_price)?;
        }
        if !self.execution_quantity.is_empty() {
            os.write_string(3, &self.execution_quantity)?;
        }
        if !self.execution_margin.is_empty() {
            os.write_string(4, &self.execution_margin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionDelta {
        PositionDelta::new()
    }

    fn default_instance() -> &'static PositionDelta {
        static instance: ::protobuf::rt::LazyV2<PositionDelta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PositionDelta::new)
    }
}

impl ::protobuf::Clear for PositionDelta {
    fn clear(&mut self) {
        self.trade_direction.clear();
        self.execution_price.clear();
        self.execution_quantity.clear();
        self.execution_margin.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionDelta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTradesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    pub direction: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub subaccount_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTradesRequest {
    fn default() -> &'a StreamTradesRequest {
        <StreamTradesRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamTradesRequest {
    pub fn new() -> StreamTradesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_side = 2;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }

    // string direction = 3;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 9;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string subaccount_ids = 10;


    pub fn get_subaccount_ids(&self) -> &[::std::string::String] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string execution_types = 11;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamTradesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_side);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.direction);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(2, &self.execution_side)?;
        }
        if !self.direction.is_empty() {
            os.write_string(3, &self.direction)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.subaccount_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.execution_types {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTradesRequest {
        StreamTradesRequest::new()
    }

    fn default_instance() -> &'static StreamTradesRequest {
        static instance: ::protobuf::rt::LazyV2<StreamTradesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTradesRequest::new)
    }
}

impl ::protobuf::Clear for StreamTradesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.execution_side.clear();
        self.direction.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.subaccount_ids.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTradesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTradesResponse {
    // message fields
    pub trade: ::protobuf::SingularPtrField<DerivativeTrade>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTradesResponse {
    fn default() -> &'a StreamTradesResponse {
        <StreamTradesResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamTradesResponse {
    pub fn new() -> StreamTradesResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeTrade trade = 1;


    pub fn get_trade(&self) -> &DerivativeTrade {
        self.trade.as_ref().unwrap_or_else(|| <DerivativeTrade as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: DerivativeTrade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut DerivativeTrade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> DerivativeTrade {
        self.trade.take().unwrap_or_else(|| DerivativeTrade::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamTradesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTradesResponse {
        StreamTradesResponse::new()
    }

    fn default_instance() -> &'static StreamTradesResponse {
        static instance: ::protobuf::rt::LazyV2<StreamTradesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTradesResponse::new)
    }
}

impl ::protobuf::Clear for StreamTradesResponse {
    fn clear(&mut self) {
        self.trade.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTradesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrdersListRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrdersListRequest {
    fn default() -> &'a SubaccountOrdersListRequest {
        <SubaccountOrdersListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrdersListRequest {
    pub fn new() -> SubaccountOrdersListRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for SubaccountOrdersListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrdersListRequest {
        SubaccountOrdersListRequest::new()
    }

    fn default_instance() -> &'static SubaccountOrdersListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrdersListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrdersListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountOrdersListRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrdersListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrdersListResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<DerivativeLimitOrder>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrdersListResponse {
    fn default() -> &'a SubaccountOrdersListResponse {
        <SubaccountOrdersListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrdersListResponse {
    pub fn new() -> SubaccountOrdersListResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[DerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<DerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<DerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for SubaccountOrdersListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrdersListResponse {
        SubaccountOrdersListResponse::new()
    }

    fn default_instance() -> &'static SubaccountOrdersListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrdersListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrdersListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountOrdersListResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrdersListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountTradesListRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub execution_type: ::std::string::String,
    pub direction: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountTradesListRequest {
    fn default() -> &'a SubaccountTradesListRequest {
        <SubaccountTradesListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountTradesListRequest {
    pub fn new() -> SubaccountTradesListRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_type = 3;


    pub fn get_execution_type(&self) -> &str {
        &self.execution_type
    }
    pub fn clear_execution_type(&mut self) {
        self.execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_type(&mut self, v: ::std::string::String) {
        self.execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.execution_type
    }

    // Take field
    pub fn take_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_type, ::std::string::String::new())
    }

    // string direction = 4;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for SubaccountTradesListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.execution_type);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.execution_type.is_empty() {
            os.write_string(3, &self.execution_type)?;
        }
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountTradesListRequest {
        SubaccountTradesListRequest::new()
    }

    fn default_instance() -> &'static SubaccountTradesListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountTradesListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountTradesListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountTradesListRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.execution_type.clear();
        self.direction.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountTradesListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountTradesListResponse {
    // message fields
    pub trades: ::protobuf::RepeatedField<DerivativeTrade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountTradesListResponse {
    fn default() -> &'a SubaccountTradesListResponse {
        <SubaccountTradesListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountTradesListResponse {
    pub fn new() -> SubaccountTradesListResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1;


    pub fn get_trades(&self) -> &[DerivativeTrade] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<DerivativeTrade>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeTrade> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<DerivativeTrade> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountTradesListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trades {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountTradesListResponse {
        SubaccountTradesListResponse::new()
    }

    fn default_instance() -> &'static SubaccountTradesListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountTradesListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountTradesListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountTradesListResponse {
    fn clear(&mut self) {
        self.trades.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountTradesListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersHistoryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub order_types: ::protobuf::RepeatedField<::std::string::String>,
    pub direction: ::std::string::String,
    pub start_time: i64,
    pub end_time: i64,
    pub is_conditional: ::std::string::String,
    pub order_type: ::std::string::String,
    pub state: ::std::string::String,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersHistoryRequest {
    fn default() -> &'a OrdersHistoryRequest {
        <OrdersHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrdersHistoryRequest {
    pub fn new() -> OrdersHistoryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // repeated string order_types = 5;


    pub fn get_order_types(&self) -> &[::std::string::String] {
        &self.order_types
    }
    pub fn clear_order_types(&mut self) {
        self.order_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_types
    }

    // Take field
    pub fn take_order_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_types, ::protobuf::RepeatedField::new())
    }

    // string direction = 6;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // string is_conditional = 9;


    pub fn get_is_conditional(&self) -> &str {
        &self.is_conditional
    }
    pub fn clear_is_conditional(&mut self) {
        self.is_conditional.clear();
    }

    // Param is passed by value, moved
    pub fn set_is_conditional(&mut self, v: ::std::string::String) {
        self.is_conditional = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_conditional(&mut self) -> &mut ::std::string::String {
        &mut self.is_conditional
    }

    // Take field
    pub fn take_is_conditional(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.is_conditional, ::std::string::String::new())
    }

    // string order_type = 10;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // string state = 11;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // repeated string execution_types = 12;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }

    // repeated string market_ids = 13;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrdersHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_types)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.is_conditional)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        for value in &self.order_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.direction);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        if !self.is_conditional.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.is_conditional);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.order_type);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.state);
        }
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        for v in &self.order_types {
            os.write_string(5, &v)?;
        };
        if !self.direction.is_empty() {
            os.write_string(6, &self.direction)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        if !self.is_conditional.is_empty() {
            os.write_string(9, &self.is_conditional)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(10, &self.order_type)?;
        }
        if !self.state.is_empty() {
            os.write_string(11, &self.state)?;
        }
        for v in &self.execution_types {
            os.write_string(12, &v)?;
        };
        for v in &self.market_ids {
            os.write_string(13, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersHistoryRequest {
        OrdersHistoryRequest::new()
    }

    fn default_instance() -> &'static OrdersHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<OrdersHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersHistoryRequest::new)
    }
}

impl ::protobuf::Clear for OrdersHistoryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.order_types.clear();
        self.direction.clear();
        self.start_time = 0;
        self.end_time = 0;
        self.is_conditional.clear();
        self.order_type.clear();
        self.state.clear();
        self.execution_types.clear();
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersHistoryResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<DerivativeOrderHistory>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersHistoryResponse {
    fn default() -> &'a OrdersHistoryResponse {
        <OrdersHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrdersHistoryResponse {
    pub fn new() -> OrdersHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1;


    pub fn get_orders(&self) -> &[DerivativeOrderHistory] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<DerivativeOrderHistory>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeOrderHistory> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<DerivativeOrderHistory> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_derivative_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for OrdersHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersHistoryResponse {
        OrdersHistoryResponse::new()
    }

    fn default_instance() -> &'static OrdersHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<OrdersHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersHistoryResponse::new)
    }
}

impl ::protobuf::Clear for OrdersHistoryResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeOrderHistory {
    // message fields
    pub order_hash: ::std::string::String,
    pub market_id: ::std::string::String,
    pub is_active: bool,
    pub subaccount_id: ::std::string::String,
    pub execution_type: ::std::string::String,
    pub order_type: ::std::string::String,
    pub price: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub filled_quantity: ::std::string::String,
    pub state: ::std::string::String,
    pub created_at: i64,
    pub updated_at: i64,
    pub is_reduce_only: bool,
    pub direction: ::std::string::String,
    pub is_conditional: bool,
    pub trigger_at: u64,
    pub placed_order_hash: ::std::string::String,
    pub margin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeOrderHistory {
    fn default() -> &'a DerivativeOrderHistory {
        <DerivativeOrderHistory as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeOrderHistory {
    pub fn new() -> DerivativeOrderHistory {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool is_active = 3;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string execution_type = 5;


    pub fn get_execution_type(&self) -> &str {
        &self.execution_type
    }
    pub fn clear_execution_type(&mut self) {
        self.execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_type(&mut self, v: ::std::string::String) {
        self.execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.execution_type
    }

    // Take field
    pub fn take_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_type, ::std::string::String::new())
    }

    // string order_type = 6;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // string price = 7;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string trigger_price = 8;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // string quantity = 9;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string filled_quantity = 10;


    pub fn get_filled_quantity(&self) -> &str {
        &self.filled_quantity
    }
    pub fn clear_filled_quantity(&mut self) {
        self.filled_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_filled_quantity(&mut self, v: ::std::string::String) {
        self.filled_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filled_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.filled_quantity
    }

    // Take field
    pub fn take_filled_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filled_quantity, ::std::string::String::new())
    }

    // string state = 11;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint64 created_at = 12;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // sint64 updated_at = 13;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }

    // bool is_reduce_only = 14;


    pub fn get_is_reduce_only(&self) -> bool {
        self.is_reduce_only
    }
    pub fn clear_is_reduce_only(&mut self) {
        self.is_reduce_only = false;
    }

    // Param is passed by value, moved
    pub fn set_is_reduce_only(&mut self, v: bool) {
        self.is_reduce_only = v;
    }

    // string direction = 15;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // bool is_conditional = 16;


    pub fn get_is_conditional(&self) -> bool {
        self.is_conditional
    }
    pub fn clear_is_conditional(&mut self) {
        self.is_conditional = false;
    }

    // Param is passed by value, moved
    pub fn set_is_conditional(&mut self, v: bool) {
        self.is_conditional = v;
    }

    // uint64 trigger_at = 17;


    pub fn get_trigger_at(&self) -> u64 {
        self.trigger_at
    }
    pub fn clear_trigger_at(&mut self) {
        self.trigger_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_trigger_at(&mut self, v: u64) {
        self.trigger_at = v;
    }

    // string placed_order_hash = 18;


    pub fn get_placed_order_hash(&self) -> &str {
        &self.placed_order_hash
    }
    pub fn clear_placed_order_hash(&mut self) {
        self.placed_order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_placed_order_hash(&mut self, v: ::std::string::String) {
        self.placed_order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_placed_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.placed_order_hash
    }

    // Take field
    pub fn take_placed_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.placed_order_hash, ::std::string::String::new())
    }

    // string margin = 19;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeOrderHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filled_quantity)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_reduce_only = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_conditional = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trigger_at = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.placed_order_hash)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if !self.execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.execution_type);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_type);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.price);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.trigger_price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.quantity);
        }
        if !self.filled_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.filled_quantity);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.updated_at);
        }
        if self.is_reduce_only != false {
            my_size += 2;
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.direction);
        }
        if self.is_conditional != false {
            my_size += 3;
        }
        if self.trigger_at != 0 {
            my_size += ::protobuf::rt::value_size(17, self.trigger_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.placed_order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.placed_order_hash);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.margin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.is_active != false {
            os.write_bool(3, self.is_active)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if !self.execution_type.is_empty() {
            os.write_string(5, &self.execution_type)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(6, &self.order_type)?;
        }
        if !self.price.is_empty() {
            os.write_string(7, &self.price)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(8, &self.trigger_price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(9, &self.quantity)?;
        }
        if !self.filled_quantity.is_empty() {
            os.write_string(10, &self.filled_quantity)?;
        }
        if !self.state.is_empty() {
            os.write_string(11, &self.state)?;
        }
        if self.created_at != 0 {
            os.write_sint64(12, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(13, self.updated_at)?;
        }
        if self.is_reduce_only != false {
            os.write_bool(14, self.is_reduce_only)?;
        }
        if !self.direction.is_empty() {
            os.write_string(15, &self.direction)?;
        }
        if self.is_conditional != false {
            os.write_bool(16, self.is_conditional)?;
        }
        if self.trigger_at != 0 {
            os.write_uint64(17, self.trigger_at)?;
        }
        if !self.placed_order_hash.is_empty() {
            os.write_string(18, &self.placed_order_hash)?;
        }
        if !self.margin.is_empty() {
            os.write_string(19, &self.margin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeOrderHistory {
        DerivativeOrderHistory::new()
    }

    fn default_instance() -> &'static DerivativeOrderHistory {
        static instance: ::protobuf::rt::LazyV2<DerivativeOrderHistory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeOrderHistory::new)
    }
}

impl ::protobuf::Clear for DerivativeOrderHistory {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.market_id.clear();
        self.is_active = false;
        self.subaccount_id.clear();
        self.execution_type.clear();
        self.order_type.clear();
        self.price.clear();
        self.trigger_price.clear();
        self.quantity.clear();
        self.filled_quantity.clear();
        self.state.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.is_reduce_only = false;
        self.direction.clear();
        self.is_conditional = false;
        self.trigger_at = 0;
        self.placed_order_hash.clear();
        self.margin.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeOrderHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersHistoryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub order_types: ::protobuf::RepeatedField<::std::string::String>,
    pub direction: ::std::string::String,
    pub state: ::std::string::String,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersHistoryRequest {
    fn default() -> &'a StreamOrdersHistoryRequest {
        <StreamOrdersHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersHistoryRequest {
    pub fn new() -> StreamOrdersHistoryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated string order_types = 3;


    pub fn get_order_types(&self) -> &[::std::string::String] {
        &self.order_types
    }
    pub fn clear_order_types(&mut self) {
        self.order_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_types
    }

    // Take field
    pub fn take_order_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_types, ::protobuf::RepeatedField::new())
    }

    // string direction = 4;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string state = 5;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // repeated string execution_types = 6;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrdersHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_types)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        for value in &self.order_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.state);
        }
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        for v in &self.order_types {
            os.write_string(3, &v)?;
        };
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if !self.state.is_empty() {
            os.write_string(5, &self.state)?;
        }
        for v in &self.execution_types {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersHistoryRequest {
        StreamOrdersHistoryRequest::new()
    }

    fn default_instance() -> &'static StreamOrdersHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersHistoryRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrdersHistoryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.order_types.clear();
        self.direction.clear();
        self.state.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersHistoryResponse {
    // message fields
    pub order: ::protobuf::SingularPtrField<DerivativeOrderHistory>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersHistoryResponse {
    fn default() -> &'a StreamOrdersHistoryResponse {
        <StreamOrdersHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersHistoryResponse {
    pub fn new() -> StreamOrdersHistoryResponse {
        ::std::default::Default::default()
    }

    // .injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1;


    pub fn get_order(&self) -> &DerivativeOrderHistory {
        self.order.as_ref().unwrap_or_else(|| <DerivativeOrderHistory as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: DerivativeOrderHistory) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut DerivativeOrderHistory {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> DerivativeOrderHistory {
        self.order.take().unwrap_or_else(|| DerivativeOrderHistory::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamOrdersHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersHistoryResponse {
        StreamOrdersHistoryResponse::new()
    }

    fn default_instance() -> &'static StreamOrdersHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersHistoryResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrdersHistoryResponse {
    fn clear(&mut self) {
        self.order.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
