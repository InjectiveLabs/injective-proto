// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/exchange/v1beta1/tx.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgUpdateParams {
    // message fields
    pub authority: ::std::string::String,
    pub params: ::protobuf::SingularPtrField<super::exchange::Params>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgUpdateParams {
    fn default() -> &'a MsgUpdateParams {
        <MsgUpdateParams as ::protobuf::Message>::default_instance()
    }
}

impl MsgUpdateParams {
    pub fn new() -> MsgUpdateParams {
        ::std::default::Default::default()
    }

    // string authority = 1;


    pub fn get_authority(&self) -> &str {
        &self.authority
    }
    pub fn clear_authority(&mut self) {
        self.authority.clear();
    }

    // Param is passed by value, moved
    pub fn set_authority(&mut self, v: ::std::string::String) {
        self.authority = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authority(&mut self) -> &mut ::std::string::String {
        &mut self.authority
    }

    // Take field
    pub fn take_authority(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authority, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.Params params = 2;


    pub fn get_params(&self) -> &super::exchange::Params {
        self.params.as_ref().unwrap_or_else(|| <super::exchange::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::exchange::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::exchange::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::exchange::Params {
        self.params.take().unwrap_or_else(|| super::exchange::Params::new())
    }
}

impl ::protobuf::Message for MsgUpdateParams {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authority)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authority.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authority);
        }
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.authority.is_empty() {
            os.write_string(1, &self.authority)?;
        }
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgUpdateParams {
        MsgUpdateParams::new()
    }

    fn default_instance() -> &'static MsgUpdateParams {
        static instance: ::protobuf::rt::LazyV2<MsgUpdateParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgUpdateParams::new)
    }
}

impl ::protobuf::Clear for MsgUpdateParams {
    fn clear(&mut self) {
        self.authority.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgUpdateParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgUpdateParamsResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgUpdateParamsResponse {
    fn default() -> &'a MsgUpdateParamsResponse {
        <MsgUpdateParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgUpdateParamsResponse {
    pub fn new() -> MsgUpdateParamsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgUpdateParamsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgUpdateParamsResponse {
        MsgUpdateParamsResponse::new()
    }

    fn default_instance() -> &'static MsgUpdateParamsResponse {
        static instance: ::protobuf::rt::LazyV2<MsgUpdateParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgUpdateParamsResponse::new)
    }
}

impl ::protobuf::Clear for MsgUpdateParamsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgUpdateParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgDeposit {
    // message fields
    pub sender: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgDeposit {
    fn default() -> &'a MsgDeposit {
        <MsgDeposit as ::protobuf::Message>::default_instance()
    }
}

impl MsgDeposit {
    pub fn new() -> MsgDeposit {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for MsgDeposit {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgDeposit {
        MsgDeposit::new()
    }

    fn default_instance() -> &'static MsgDeposit {
        static instance: ::protobuf::rt::LazyV2<MsgDeposit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgDeposit::new)
    }
}

impl ::protobuf::Clear for MsgDeposit {
    fn clear(&mut self) {
        self.sender.clear();
        self.subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDeposit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgDepositResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgDepositResponse {
    fn default() -> &'a MsgDepositResponse {
        <MsgDepositResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgDepositResponse {
    pub fn new() -> MsgDepositResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgDepositResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgDepositResponse {
        MsgDepositResponse::new()
    }

    fn default_instance() -> &'static MsgDepositResponse {
        static instance: ::protobuf::rt::LazyV2<MsgDepositResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgDepositResponse::new)
    }
}

impl ::protobuf::Clear for MsgDepositResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgDepositResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgWithdraw {
    // message fields
    pub sender: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgWithdraw {
    fn default() -> &'a MsgWithdraw {
        <MsgWithdraw as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdraw {
    pub fn new() -> MsgWithdraw {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for MsgWithdraw {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgWithdraw {
        MsgWithdraw::new()
    }

    fn default_instance() -> &'static MsgWithdraw {
        static instance: ::protobuf::rt::LazyV2<MsgWithdraw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgWithdraw::new)
    }
}

impl ::protobuf::Clear for MsgWithdraw {
    fn clear(&mut self) {
        self.sender.clear();
        self.subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdraw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgWithdrawResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgWithdrawResponse {
    fn default() -> &'a MsgWithdrawResponse {
        <MsgWithdrawResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgWithdrawResponse {
    pub fn new() -> MsgWithdrawResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgWithdrawResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgWithdrawResponse {
        MsgWithdrawResponse::new()
    }

    fn default_instance() -> &'static MsgWithdrawResponse {
        static instance: ::protobuf::rt::LazyV2<MsgWithdrawResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgWithdrawResponse::new)
    }
}

impl ::protobuf::Clear for MsgWithdrawResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgWithdrawResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateSpotLimitOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::SpotOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateSpotLimitOrder {
    fn default() -> &'a MsgCreateSpotLimitOrder {
        <MsgCreateSpotLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateSpotLimitOrder {
    pub fn new() -> MsgCreateSpotLimitOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.SpotOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::SpotOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::SpotOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::SpotOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::SpotOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::SpotOrder {
        self.order.take().unwrap_or_else(|| super::exchange::SpotOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateSpotLimitOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateSpotLimitOrder {
        MsgCreateSpotLimitOrder::new()
    }

    fn default_instance() -> &'static MsgCreateSpotLimitOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateSpotLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateSpotLimitOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateSpotLimitOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateSpotLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateSpotLimitOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateSpotLimitOrderResponse {
    fn default() -> &'a MsgCreateSpotLimitOrderResponse {
        <MsgCreateSpotLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateSpotLimitOrderResponse {
    pub fn new() -> MsgCreateSpotLimitOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgCreateSpotLimitOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateSpotLimitOrderResponse {
        MsgCreateSpotLimitOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateSpotLimitOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateSpotLimitOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateSpotLimitOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateSpotLimitOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateSpotLimitOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCreateSpotLimitOrders {
    // message fields
    pub sender: ::std::string::String,
    pub orders: ::protobuf::RepeatedField<super::exchange::SpotOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCreateSpotLimitOrders {
    fn default() -> &'a MsgBatchCreateSpotLimitOrders {
        <MsgBatchCreateSpotLimitOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCreateSpotLimitOrders {
    pub fn new() -> MsgBatchCreateSpotLimitOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.SpotOrder orders = 2;


    pub fn get_orders(&self) -> &[super::exchange::SpotOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCreateSpotLimitOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        for v in &self.orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCreateSpotLimitOrders {
        MsgBatchCreateSpotLimitOrders::new()
    }

    fn default_instance() -> &'static MsgBatchCreateSpotLimitOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCreateSpotLimitOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCreateSpotLimitOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchCreateSpotLimitOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCreateSpotLimitOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCreateSpotLimitOrdersResponse {
    // message fields
    pub order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCreateSpotLimitOrdersResponse {
    fn default() -> &'a MsgBatchCreateSpotLimitOrdersResponse {
        <MsgBatchCreateSpotLimitOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCreateSpotLimitOrdersResponse {
    pub fn new() -> MsgBatchCreateSpotLimitOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated string order_hashes = 1;


    pub fn get_order_hashes(&self) -> &[::std::string::String] {
        &self.order_hashes
    }
    pub fn clear_order_hashes(&mut self) {
        self.order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_hashes
    }

    // Take field
    pub fn take_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCreateSpotLimitOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.order_hashes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.order_hashes {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCreateSpotLimitOrdersResponse {
        MsgBatchCreateSpotLimitOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchCreateSpotLimitOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCreateSpotLimitOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCreateSpotLimitOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchCreateSpotLimitOrdersResponse {
    fn clear(&mut self) {
        self.order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCreateSpotLimitOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantSpotMarketLaunch {
    // message fields
    pub sender: ::std::string::String,
    pub ticker: ::std::string::String,
    pub base_denom: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantSpotMarketLaunch {
    fn default() -> &'a MsgInstantSpotMarketLaunch {
        <MsgInstantSpotMarketLaunch as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantSpotMarketLaunch {
    pub fn new() -> MsgInstantSpotMarketLaunch {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string ticker = 2;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string base_denom = 3;


    pub fn get_base_denom(&self) -> &str {
        &self.base_denom
    }
    pub fn clear_base_denom(&mut self) {
        self.base_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_denom(&mut self, v: ::std::string::String) {
        self.base_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_denom(&mut self) -> &mut ::std::string::String {
        &mut self.base_denom
    }

    // Take field
    pub fn take_base_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_denom, ::std::string::String::new())
    }

    // string quote_denom = 4;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string min_price_tick_size = 5;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 6;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgInstantSpotMarketLaunch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_denom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ticker);
        }
        if !self.base_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.base_denom);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.quote_denom);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(2, &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            os.write_string(3, &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(4, &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(5, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(6, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantSpotMarketLaunch {
        MsgInstantSpotMarketLaunch::new()
    }

    fn default_instance() -> &'static MsgInstantSpotMarketLaunch {
        static instance: ::protobuf::rt::LazyV2<MsgInstantSpotMarketLaunch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantSpotMarketLaunch::new)
    }
}

impl ::protobuf::Clear for MsgInstantSpotMarketLaunch {
    fn clear(&mut self) {
        self.sender.clear();
        self.ticker.clear();
        self.base_denom.clear();
        self.quote_denom.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantSpotMarketLaunch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantSpotMarketLaunchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantSpotMarketLaunchResponse {
    fn default() -> &'a MsgInstantSpotMarketLaunchResponse {
        <MsgInstantSpotMarketLaunchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantSpotMarketLaunchResponse {
    pub fn new() -> MsgInstantSpotMarketLaunchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgInstantSpotMarketLaunchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantSpotMarketLaunchResponse {
        MsgInstantSpotMarketLaunchResponse::new()
    }

    fn default_instance() -> &'static MsgInstantSpotMarketLaunchResponse {
        static instance: ::protobuf::rt::LazyV2<MsgInstantSpotMarketLaunchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantSpotMarketLaunchResponse::new)
    }
}

impl ::protobuf::Clear for MsgInstantSpotMarketLaunchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantSpotMarketLaunchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantPerpetualMarketLaunch {
    // message fields
    pub sender: ::std::string::String,
    pub ticker: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub oracle_type: super::oracle::OracleType,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantPerpetualMarketLaunch {
    fn default() -> &'a MsgInstantPerpetualMarketLaunch {
        <MsgInstantPerpetualMarketLaunch as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantPerpetualMarketLaunch {
    pub fn new() -> MsgInstantPerpetualMarketLaunch {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string ticker = 2;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string quote_denom = 3;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string oracle_base = 4;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 5;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 6;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 7;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // string maker_fee_rate = 8;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 9;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string initial_margin_ratio = 10;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 11;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string min_price_tick_size = 12;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 13;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgInstantPerpetualMarketLaunch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ticker);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_denom);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_quote);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(6, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(7, self.oracle_type);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.taker_fee_rate);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.maintenance_margin_ratio);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(2, &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(3, &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(4, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(5, &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(6, self.oracle_scale_factor)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(8, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(9, &self.taker_fee_rate)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(10, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(11, &self.maintenance_margin_ratio)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(12, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(13, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantPerpetualMarketLaunch {
        MsgInstantPerpetualMarketLaunch::new()
    }

    fn default_instance() -> &'static MsgInstantPerpetualMarketLaunch {
        static instance: ::protobuf::rt::LazyV2<MsgInstantPerpetualMarketLaunch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantPerpetualMarketLaunch::new)
    }
}

impl ::protobuf::Clear for MsgInstantPerpetualMarketLaunch {
    fn clear(&mut self) {
        self.sender.clear();
        self.ticker.clear();
        self.quote_denom.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_scale_factor = 0;
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantPerpetualMarketLaunch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantPerpetualMarketLaunchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantPerpetualMarketLaunchResponse {
    fn default() -> &'a MsgInstantPerpetualMarketLaunchResponse {
        <MsgInstantPerpetualMarketLaunchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantPerpetualMarketLaunchResponse {
    pub fn new() -> MsgInstantPerpetualMarketLaunchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgInstantPerpetualMarketLaunchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantPerpetualMarketLaunchResponse {
        MsgInstantPerpetualMarketLaunchResponse::new()
    }

    fn default_instance() -> &'static MsgInstantPerpetualMarketLaunchResponse {
        static instance: ::protobuf::rt::LazyV2<MsgInstantPerpetualMarketLaunchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantPerpetualMarketLaunchResponse::new)
    }
}

impl ::protobuf::Clear for MsgInstantPerpetualMarketLaunchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantPerpetualMarketLaunchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantBinaryOptionsMarketLaunch {
    // message fields
    pub sender: ::std::string::String,
    pub ticker: ::std::string::String,
    pub oracle_symbol: ::std::string::String,
    pub oracle_provider: ::std::string::String,
    pub oracle_type: super::oracle::OracleType,
    pub oracle_scale_factor: u32,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub admin: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantBinaryOptionsMarketLaunch {
    fn default() -> &'a MsgInstantBinaryOptionsMarketLaunch {
        <MsgInstantBinaryOptionsMarketLaunch as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantBinaryOptionsMarketLaunch {
    pub fn new() -> MsgInstantBinaryOptionsMarketLaunch {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string ticker = 2;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_symbol = 3;


    pub fn get_oracle_symbol(&self) -> &str {
        &self.oracle_symbol
    }
    pub fn clear_oracle_symbol(&mut self) {
        self.oracle_symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_symbol(&mut self, v: ::std::string::String) {
        self.oracle_symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_symbol
    }

    // Take field
    pub fn take_oracle_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_symbol, ::std::string::String::new())
    }

    // string oracle_provider = 4;


    pub fn get_oracle_provider(&self) -> &str {
        &self.oracle_provider
    }
    pub fn clear_oracle_provider(&mut self) {
        self.oracle_provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_provider(&mut self, v: ::std::string::String) {
        self.oracle_provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_provider(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_provider
    }

    // Take field
    pub fn take_oracle_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_provider, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 5;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // uint32 oracle_scale_factor = 6;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // string maker_fee_rate = 7;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 8;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // int64 expiration_timestamp = 9;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 settlement_timestamp = 10;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // string admin = 11;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // string quote_denom = 12;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string min_price_tick_size = 13;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 14;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgInstantBinaryOptionsMarketLaunch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_symbol)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_provider)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settlement_timestamp = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ticker);
        }
        if !self.oracle_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.oracle_symbol);
        }
        if !self.oracle_provider.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_provider);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(5, self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(6, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.taker_fee_rate);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.settlement_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.admin);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.quote_denom);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(2, &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            os.write_string(3, &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            os.write_string(4, &self.oracle_provider)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(6, self.oracle_scale_factor)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(7, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(8, &self.taker_fee_rate)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(9, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_int64(10, self.settlement_timestamp)?;
        }
        if !self.admin.is_empty() {
            os.write_string(11, &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(12, &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(13, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(14, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantBinaryOptionsMarketLaunch {
        MsgInstantBinaryOptionsMarketLaunch::new()
    }

    fn default_instance() -> &'static MsgInstantBinaryOptionsMarketLaunch {
        static instance: ::protobuf::rt::LazyV2<MsgInstantBinaryOptionsMarketLaunch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantBinaryOptionsMarketLaunch::new)
    }
}

impl ::protobuf::Clear for MsgInstantBinaryOptionsMarketLaunch {
    fn clear(&mut self) {
        self.sender.clear();
        self.ticker.clear();
        self.oracle_symbol.clear();
        self.oracle_provider.clear();
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.oracle_scale_factor = 0;
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.admin.clear();
        self.quote_denom.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantBinaryOptionsMarketLaunch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantBinaryOptionsMarketLaunchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantBinaryOptionsMarketLaunchResponse {
    fn default() -> &'a MsgInstantBinaryOptionsMarketLaunchResponse {
        <MsgInstantBinaryOptionsMarketLaunchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantBinaryOptionsMarketLaunchResponse {
    pub fn new() -> MsgInstantBinaryOptionsMarketLaunchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgInstantBinaryOptionsMarketLaunchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantBinaryOptionsMarketLaunchResponse {
        MsgInstantBinaryOptionsMarketLaunchResponse::new()
    }

    fn default_instance() -> &'static MsgInstantBinaryOptionsMarketLaunchResponse {
        static instance: ::protobuf::rt::LazyV2<MsgInstantBinaryOptionsMarketLaunchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantBinaryOptionsMarketLaunchResponse::new)
    }
}

impl ::protobuf::Clear for MsgInstantBinaryOptionsMarketLaunchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantBinaryOptionsMarketLaunchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantExpiryFuturesMarketLaunch {
    // message fields
    pub sender: ::std::string::String,
    pub ticker: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_type: super::oracle::OracleType,
    pub oracle_scale_factor: u32,
    pub expiry: i64,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantExpiryFuturesMarketLaunch {
    fn default() -> &'a MsgInstantExpiryFuturesMarketLaunch {
        <MsgInstantExpiryFuturesMarketLaunch as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantExpiryFuturesMarketLaunch {
    pub fn new() -> MsgInstantExpiryFuturesMarketLaunch {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string ticker = 2;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string quote_denom = 3;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string oracle_base = 4;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 5;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 6;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // int64 expiry = 8;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string maker_fee_rate = 9;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 10;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string initial_margin_ratio = 11;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 12;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string min_price_tick_size = 13;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 14;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgInstantExpiryFuturesMarketLaunch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ticker);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_denom);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_quote);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(6, self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.taker_fee_rate);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.maintenance_margin_ratio);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(2, &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(3, &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(4, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(5, &self.oracle_quote)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if self.expiry != 0 {
            os.write_int64(8, self.expiry)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(9, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(10, &self.taker_fee_rate)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(11, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(12, &self.maintenance_margin_ratio)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(13, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(14, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantExpiryFuturesMarketLaunch {
        MsgInstantExpiryFuturesMarketLaunch::new()
    }

    fn default_instance() -> &'static MsgInstantExpiryFuturesMarketLaunch {
        static instance: ::protobuf::rt::LazyV2<MsgInstantExpiryFuturesMarketLaunch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantExpiryFuturesMarketLaunch::new)
    }
}

impl ::protobuf::Clear for MsgInstantExpiryFuturesMarketLaunch {
    fn clear(&mut self) {
        self.sender.clear();
        self.ticker.clear();
        self.quote_denom.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.oracle_scale_factor = 0;
        self.expiry = 0;
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantExpiryFuturesMarketLaunch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgInstantExpiryFuturesMarketLaunchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgInstantExpiryFuturesMarketLaunchResponse {
    fn default() -> &'a MsgInstantExpiryFuturesMarketLaunchResponse {
        <MsgInstantExpiryFuturesMarketLaunchResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgInstantExpiryFuturesMarketLaunchResponse {
    pub fn new() -> MsgInstantExpiryFuturesMarketLaunchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgInstantExpiryFuturesMarketLaunchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgInstantExpiryFuturesMarketLaunchResponse {
        MsgInstantExpiryFuturesMarketLaunchResponse::new()
    }

    fn default_instance() -> &'static MsgInstantExpiryFuturesMarketLaunchResponse {
        static instance: ::protobuf::rt::LazyV2<MsgInstantExpiryFuturesMarketLaunchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgInstantExpiryFuturesMarketLaunchResponse::new)
    }
}

impl ::protobuf::Clear for MsgInstantExpiryFuturesMarketLaunchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgInstantExpiryFuturesMarketLaunchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateSpotMarketOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::SpotOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateSpotMarketOrder {
    fn default() -> &'a MsgCreateSpotMarketOrder {
        <MsgCreateSpotMarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateSpotMarketOrder {
    pub fn new() -> MsgCreateSpotMarketOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.SpotOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::SpotOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::SpotOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::SpotOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::SpotOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::SpotOrder {
        self.order.take().unwrap_or_else(|| super::exchange::SpotOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateSpotMarketOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateSpotMarketOrder {
        MsgCreateSpotMarketOrder::new()
    }

    fn default_instance() -> &'static MsgCreateSpotMarketOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateSpotMarketOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateSpotMarketOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateSpotMarketOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateSpotMarketOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateSpotMarketOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    pub results: ::protobuf::SingularPtrField<SpotMarketOrderResults>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateSpotMarketOrderResponse {
    fn default() -> &'a MsgCreateSpotMarketOrderResponse {
        <MsgCreateSpotMarketOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateSpotMarketOrderResponse {
    pub fn new() -> MsgCreateSpotMarketOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.SpotMarketOrderResults results = 2;


    pub fn get_results(&self) -> &SpotMarketOrderResults {
        self.results.as_ref().unwrap_or_else(|| <SpotMarketOrderResults as ::protobuf::Message>::default_instance())
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: SpotMarketOrderResults) {
        self.results = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_results(&mut self) -> &mut SpotMarketOrderResults {
        if self.results.is_none() {
            self.results.set_default();
        }
        self.results.as_mut().unwrap()
    }

    // Take field
    pub fn take_results(&mut self) -> SpotMarketOrderResults {
        self.results.take().unwrap_or_else(|| SpotMarketOrderResults::new())
    }
}

impl ::protobuf::Message for MsgCreateSpotMarketOrderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if let Some(ref v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if let Some(ref v) = self.results.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateSpotMarketOrderResponse {
        MsgCreateSpotMarketOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateSpotMarketOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateSpotMarketOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateSpotMarketOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateSpotMarketOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateSpotMarketOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarketOrderResults {
    // message fields
    pub quantity: ::std::string::String,
    pub price: ::std::string::String,
    pub fee: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarketOrderResults {
    fn default() -> &'a SpotMarketOrderResults {
        <SpotMarketOrderResults as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarketOrderResults {
    pub fn new() -> SpotMarketOrderResults {
        ::std::default::Default::default()
    }

    // string quantity = 1;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string price = 2;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string fee = 3;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotMarketOrderResults {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.quantity);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.price);
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fee);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.quantity.is_empty() {
            os.write_string(1, &self.quantity)?;
        }
        if !self.price.is_empty() {
            os.write_string(2, &self.price)?;
        }
        if !self.fee.is_empty() {
            os.write_string(3, &self.fee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarketOrderResults {
        SpotMarketOrderResults::new()
    }

    fn default_instance() -> &'static SpotMarketOrderResults {
        static instance: ::protobuf::rt::LazyV2<SpotMarketOrderResults> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarketOrderResults::new)
    }
}

impl ::protobuf::Clear for SpotMarketOrderResults {
    fn clear(&mut self) {
        self.quantity.clear();
        self.price.clear();
        self.fee.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarketOrderResults {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateDerivativeLimitOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateDerivativeLimitOrder {
    fn default() -> &'a MsgCreateDerivativeLimitOrder {
        <MsgCreateDerivativeLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateDerivativeLimitOrder {
    pub fn new() -> MsgCreateDerivativeLimitOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateDerivativeLimitOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateDerivativeLimitOrder {
        MsgCreateDerivativeLimitOrder::new()
    }

    fn default_instance() -> &'static MsgCreateDerivativeLimitOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateDerivativeLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateDerivativeLimitOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateDerivativeLimitOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateDerivativeLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateDerivativeLimitOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateDerivativeLimitOrderResponse {
    fn default() -> &'a MsgCreateDerivativeLimitOrderResponse {
        <MsgCreateDerivativeLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateDerivativeLimitOrderResponse {
    pub fn new() -> MsgCreateDerivativeLimitOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgCreateDerivativeLimitOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateDerivativeLimitOrderResponse {
        MsgCreateDerivativeLimitOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateDerivativeLimitOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateDerivativeLimitOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateDerivativeLimitOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateDerivativeLimitOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateDerivativeLimitOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateBinaryOptionsLimitOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateBinaryOptionsLimitOrder {
    fn default() -> &'a MsgCreateBinaryOptionsLimitOrder {
        <MsgCreateBinaryOptionsLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateBinaryOptionsLimitOrder {
    pub fn new() -> MsgCreateBinaryOptionsLimitOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateBinaryOptionsLimitOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateBinaryOptionsLimitOrder {
        MsgCreateBinaryOptionsLimitOrder::new()
    }

    fn default_instance() -> &'static MsgCreateBinaryOptionsLimitOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateBinaryOptionsLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateBinaryOptionsLimitOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateBinaryOptionsLimitOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateBinaryOptionsLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateBinaryOptionsLimitOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateBinaryOptionsLimitOrderResponse {
    fn default() -> &'a MsgCreateBinaryOptionsLimitOrderResponse {
        <MsgCreateBinaryOptionsLimitOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateBinaryOptionsLimitOrderResponse {
    pub fn new() -> MsgCreateBinaryOptionsLimitOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgCreateBinaryOptionsLimitOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateBinaryOptionsLimitOrderResponse {
        MsgCreateBinaryOptionsLimitOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateBinaryOptionsLimitOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateBinaryOptionsLimitOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateBinaryOptionsLimitOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateBinaryOptionsLimitOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateBinaryOptionsLimitOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCreateDerivativeLimitOrders {
    // message fields
    pub sender: ::std::string::String,
    pub orders: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCreateDerivativeLimitOrders {
    fn default() -> &'a MsgBatchCreateDerivativeLimitOrders {
        <MsgBatchCreateDerivativeLimitOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCreateDerivativeLimitOrders {
    pub fn new() -> MsgBatchCreateDerivativeLimitOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeOrder orders = 2;


    pub fn get_orders(&self) -> &[super::exchange::DerivativeOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCreateDerivativeLimitOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        for v in &self.orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCreateDerivativeLimitOrders {
        MsgBatchCreateDerivativeLimitOrders::new()
    }

    fn default_instance() -> &'static MsgBatchCreateDerivativeLimitOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCreateDerivativeLimitOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCreateDerivativeLimitOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchCreateDerivativeLimitOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCreateDerivativeLimitOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCreateDerivativeLimitOrdersResponse {
    // message fields
    pub order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCreateDerivativeLimitOrdersResponse {
    fn default() -> &'a MsgBatchCreateDerivativeLimitOrdersResponse {
        <MsgBatchCreateDerivativeLimitOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCreateDerivativeLimitOrdersResponse {
    pub fn new() -> MsgBatchCreateDerivativeLimitOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated string order_hashes = 1;


    pub fn get_order_hashes(&self) -> &[::std::string::String] {
        &self.order_hashes
    }
    pub fn clear_order_hashes(&mut self) {
        self.order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_hashes
    }

    // Take field
    pub fn take_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCreateDerivativeLimitOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.order_hashes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.order_hashes {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCreateDerivativeLimitOrdersResponse {
        MsgBatchCreateDerivativeLimitOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchCreateDerivativeLimitOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCreateDerivativeLimitOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCreateDerivativeLimitOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchCreateDerivativeLimitOrdersResponse {
    fn clear(&mut self) {
        self.order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCreateDerivativeLimitOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelSpotOrder {
    // message fields
    pub sender: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelSpotOrder {
    fn default() -> &'a MsgCancelSpotOrder {
        <MsgCancelSpotOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelSpotOrder {
    pub fn new() -> MsgCancelSpotOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string order_hash = 4;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgCancelSpotOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(4, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelSpotOrder {
        MsgCancelSpotOrder::new()
    }

    fn default_instance() -> &'static MsgCancelSpotOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCancelSpotOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelSpotOrder::new)
    }
}

impl ::protobuf::Clear for MsgCancelSpotOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelSpotOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelSpotOrderResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelSpotOrderResponse {
    fn default() -> &'a MsgCancelSpotOrderResponse {
        <MsgCancelSpotOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelSpotOrderResponse {
    pub fn new() -> MsgCancelSpotOrderResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgCancelSpotOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelSpotOrderResponse {
        MsgCancelSpotOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCancelSpotOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCancelSpotOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelSpotOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCancelSpotOrderResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelSpotOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelSpotOrders {
    // message fields
    pub sender: ::std::string::String,
    pub data: ::protobuf::RepeatedField<OrderData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelSpotOrders {
    fn default() -> &'a MsgBatchCancelSpotOrders {
        <MsgBatchCancelSpotOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelSpotOrders {
    pub fn new() -> MsgBatchCancelSpotOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData data = 2;


    pub fn get_data(&self) -> &[OrderData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelSpotOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelSpotOrders {
        MsgBatchCancelSpotOrders::new()
    }

    fn default_instance() -> &'static MsgBatchCancelSpotOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelSpotOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelSpotOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelSpotOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelSpotOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelSpotOrdersResponse {
    // message fields
    pub success: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelSpotOrdersResponse {
    fn default() -> &'a MsgBatchCancelSpotOrdersResponse {
        <MsgBatchCancelSpotOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelSpotOrdersResponse {
    pub fn new() -> MsgBatchCancelSpotOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated bool success = 1;


    pub fn get_success(&self) -> &[bool] {
        &self.success
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.success
    }

    // Take field
    pub fn take_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.success, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelSpotOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.success)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.success.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.success {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelSpotOrdersResponse {
        MsgBatchCancelSpotOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchCancelSpotOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelSpotOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelSpotOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelSpotOrdersResponse {
    fn clear(&mut self) {
        self.success.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelSpotOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelBinaryOptionsOrders {
    // message fields
    pub sender: ::std::string::String,
    pub data: ::protobuf::RepeatedField<OrderData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelBinaryOptionsOrders {
    fn default() -> &'a MsgBatchCancelBinaryOptionsOrders {
        <MsgBatchCancelBinaryOptionsOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelBinaryOptionsOrders {
    pub fn new() -> MsgBatchCancelBinaryOptionsOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData data = 2;


    pub fn get_data(&self) -> &[OrderData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelBinaryOptionsOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelBinaryOptionsOrders {
        MsgBatchCancelBinaryOptionsOrders::new()
    }

    fn default_instance() -> &'static MsgBatchCancelBinaryOptionsOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelBinaryOptionsOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelBinaryOptionsOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelBinaryOptionsOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelBinaryOptionsOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelBinaryOptionsOrdersResponse {
    // message fields
    pub success: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelBinaryOptionsOrdersResponse {
    fn default() -> &'a MsgBatchCancelBinaryOptionsOrdersResponse {
        <MsgBatchCancelBinaryOptionsOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelBinaryOptionsOrdersResponse {
    pub fn new() -> MsgBatchCancelBinaryOptionsOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated bool success = 1;


    pub fn get_success(&self) -> &[bool] {
        &self.success
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.success
    }

    // Take field
    pub fn take_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.success, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelBinaryOptionsOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.success)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.success.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.success {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelBinaryOptionsOrdersResponse {
        MsgBatchCancelBinaryOptionsOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchCancelBinaryOptionsOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelBinaryOptionsOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelBinaryOptionsOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelBinaryOptionsOrdersResponse {
    fn clear(&mut self) {
        self.success.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelBinaryOptionsOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchUpdateOrders {
    // message fields
    pub sender: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub spot_market_ids_to_cancel_all: ::protobuf::RepeatedField<::std::string::String>,
    pub derivative_market_ids_to_cancel_all: ::protobuf::RepeatedField<::std::string::String>,
    pub spot_orders_to_cancel: ::protobuf::RepeatedField<OrderData>,
    pub derivative_orders_to_cancel: ::protobuf::RepeatedField<OrderData>,
    pub spot_orders_to_create: ::protobuf::RepeatedField<super::exchange::SpotOrder>,
    pub derivative_orders_to_create: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>,
    pub binary_options_orders_to_cancel: ::protobuf::RepeatedField<OrderData>,
    pub binary_options_market_ids_to_cancel_all: ::protobuf::RepeatedField<::std::string::String>,
    pub binary_options_orders_to_create: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchUpdateOrders {
    fn default() -> &'a MsgBatchUpdateOrders {
        <MsgBatchUpdateOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchUpdateOrders {
    pub fn new() -> MsgBatchUpdateOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated string spot_market_ids_to_cancel_all = 3;


    pub fn get_spot_market_ids_to_cancel_all(&self) -> &[::std::string::String] {
        &self.spot_market_ids_to_cancel_all
    }
    pub fn clear_spot_market_ids_to_cancel_all(&mut self) {
        self.spot_market_ids_to_cancel_all.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_market_ids_to_cancel_all(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.spot_market_ids_to_cancel_all = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_market_ids_to_cancel_all(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.spot_market_ids_to_cancel_all
    }

    // Take field
    pub fn take_spot_market_ids_to_cancel_all(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.spot_market_ids_to_cancel_all, ::protobuf::RepeatedField::new())
    }

    // repeated string derivative_market_ids_to_cancel_all = 4;


    pub fn get_derivative_market_ids_to_cancel_all(&self) -> &[::std::string::String] {
        &self.derivative_market_ids_to_cancel_all
    }
    pub fn clear_derivative_market_ids_to_cancel_all(&mut self) {
        self.derivative_market_ids_to_cancel_all.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_market_ids_to_cancel_all(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.derivative_market_ids_to_cancel_all = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_market_ids_to_cancel_all(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.derivative_market_ids_to_cancel_all
    }

    // Take field
    pub fn take_derivative_market_ids_to_cancel_all(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.derivative_market_ids_to_cancel_all, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData spot_orders_to_cancel = 5;


    pub fn get_spot_orders_to_cancel(&self) -> &[OrderData] {
        &self.spot_orders_to_cancel
    }
    pub fn clear_spot_orders_to_cancel(&mut self) {
        self.spot_orders_to_cancel.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_orders_to_cancel(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.spot_orders_to_cancel = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_orders_to_cancel(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.spot_orders_to_cancel
    }

    // Take field
    pub fn take_spot_orders_to_cancel(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.spot_orders_to_cancel, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData derivative_orders_to_cancel = 6;


    pub fn get_derivative_orders_to_cancel(&self) -> &[OrderData] {
        &self.derivative_orders_to_cancel
    }
    pub fn clear_derivative_orders_to_cancel(&mut self) {
        self.derivative_orders_to_cancel.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_orders_to_cancel(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.derivative_orders_to_cancel = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_orders_to_cancel(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.derivative_orders_to_cancel
    }

    // Take field
    pub fn take_derivative_orders_to_cancel(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.derivative_orders_to_cancel, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SpotOrder spot_orders_to_create = 7;


    pub fn get_spot_orders_to_create(&self) -> &[super::exchange::SpotOrder] {
        &self.spot_orders_to_create
    }
    pub fn clear_spot_orders_to_create(&mut self) {
        self.spot_orders_to_create.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_orders_to_create(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotOrder>) {
        self.spot_orders_to_create = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_orders_to_create(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotOrder> {
        &mut self.spot_orders_to_create
    }

    // Take field
    pub fn take_spot_orders_to_create(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotOrder> {
        ::std::mem::replace(&mut self.spot_orders_to_create, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeOrder derivative_orders_to_create = 8;


    pub fn get_derivative_orders_to_create(&self) -> &[super::exchange::DerivativeOrder] {
        &self.derivative_orders_to_create
    }
    pub fn clear_derivative_orders_to_create(&mut self) {
        self.derivative_orders_to_create.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_orders_to_create(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>) {
        self.derivative_orders_to_create = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_orders_to_create(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        &mut self.derivative_orders_to_create
    }

    // Take field
    pub fn take_derivative_orders_to_create(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        ::std::mem::replace(&mut self.derivative_orders_to_create, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData binary_options_orders_to_cancel = 9;


    pub fn get_binary_options_orders_to_cancel(&self) -> &[OrderData] {
        &self.binary_options_orders_to_cancel
    }
    pub fn clear_binary_options_orders_to_cancel(&mut self) {
        self.binary_options_orders_to_cancel.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_orders_to_cancel(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.binary_options_orders_to_cancel = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_orders_to_cancel(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.binary_options_orders_to_cancel
    }

    // Take field
    pub fn take_binary_options_orders_to_cancel(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.binary_options_orders_to_cancel, ::protobuf::RepeatedField::new())
    }

    // repeated string binary_options_market_ids_to_cancel_all = 10;


    pub fn get_binary_options_market_ids_to_cancel_all(&self) -> &[::std::string::String] {
        &self.binary_options_market_ids_to_cancel_all
    }
    pub fn clear_binary_options_market_ids_to_cancel_all(&mut self) {
        self.binary_options_market_ids_to_cancel_all.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_market_ids_to_cancel_all(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.binary_options_market_ids_to_cancel_all = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_market_ids_to_cancel_all(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.binary_options_market_ids_to_cancel_all
    }

    // Take field
    pub fn take_binary_options_market_ids_to_cancel_all(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.binary_options_market_ids_to_cancel_all, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeOrder binary_options_orders_to_create = 11;


    pub fn get_binary_options_orders_to_create(&self) -> &[super::exchange::DerivativeOrder] {
        &self.binary_options_orders_to_create
    }
    pub fn clear_binary_options_orders_to_create(&mut self) {
        self.binary_options_orders_to_create.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_orders_to_create(&mut self, v: ::protobuf::RepeatedField<super::exchange::DerivativeOrder>) {
        self.binary_options_orders_to_create = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_orders_to_create(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        &mut self.binary_options_orders_to_create
    }

    // Take field
    pub fn take_binary_options_orders_to_create(&mut self) -> ::protobuf::RepeatedField<super::exchange::DerivativeOrder> {
        ::std::mem::replace(&mut self.binary_options_orders_to_create, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchUpdateOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_orders_to_cancel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_orders_to_cancel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spot_orders_to_create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_orders_to_create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_orders_to_cancel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_orders_to_create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.spot_market_ids_to_cancel_all)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.derivative_market_ids_to_cancel_all)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_orders_to_cancel)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_orders_to_cancel)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_orders_to_create)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_orders_to_create)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_options_orders_to_cancel)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.binary_options_market_ids_to_cancel_all)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_options_orders_to_create)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        for value in &self.spot_market_ids_to_cancel_all {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.derivative_market_ids_to_cancel_all {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.spot_orders_to_cancel {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_orders_to_cancel {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.spot_orders_to_create {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_orders_to_create {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_options_orders_to_cancel {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_options_market_ids_to_cancel_all {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.binary_options_orders_to_create {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        for v in &self.spot_market_ids_to_cancel_all {
            os.write_string(3, &v)?;
        };
        for v in &self.derivative_market_ids_to_cancel_all {
            os.write_string(4, &v)?;
        };
        for v in &self.spot_orders_to_cancel {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_orders_to_cancel {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.spot_orders_to_create {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_orders_to_create {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_options_orders_to_cancel {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_options_market_ids_to_cancel_all {
            os.write_string(10, &v)?;
        };
        for v in &self.binary_options_orders_to_create {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchUpdateOrders {
        MsgBatchUpdateOrders::new()
    }

    fn default_instance() -> &'static MsgBatchUpdateOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchUpdateOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchUpdateOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchUpdateOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.subaccount_id.clear();
        self.spot_market_ids_to_cancel_all.clear();
        self.derivative_market_ids_to_cancel_all.clear();
        self.spot_orders_to_cancel.clear();
        self.derivative_orders_to_cancel.clear();
        self.spot_orders_to_create.clear();
        self.derivative_orders_to_create.clear();
        self.binary_options_orders_to_cancel.clear();
        self.binary_options_market_ids_to_cancel_all.clear();
        self.binary_options_orders_to_create.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchUpdateOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchUpdateOrdersResponse {
    // message fields
    pub spot_cancel_success: ::std::vec::Vec<bool>,
    pub derivative_cancel_success: ::std::vec::Vec<bool>,
    pub spot_order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub derivative_order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub binary_options_cancel_success: ::std::vec::Vec<bool>,
    pub binary_options_order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchUpdateOrdersResponse {
    fn default() -> &'a MsgBatchUpdateOrdersResponse {
        <MsgBatchUpdateOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchUpdateOrdersResponse {
    pub fn new() -> MsgBatchUpdateOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated bool spot_cancel_success = 1;


    pub fn get_spot_cancel_success(&self) -> &[bool] {
        &self.spot_cancel_success
    }
    pub fn clear_spot_cancel_success(&mut self) {
        self.spot_cancel_success.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_cancel_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.spot_cancel_success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_cancel_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.spot_cancel_success
    }

    // Take field
    pub fn take_spot_cancel_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.spot_cancel_success, ::std::vec::Vec::new())
    }

    // repeated bool derivative_cancel_success = 2;


    pub fn get_derivative_cancel_success(&self) -> &[bool] {
        &self.derivative_cancel_success
    }
    pub fn clear_derivative_cancel_success(&mut self) {
        self.derivative_cancel_success.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_cancel_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.derivative_cancel_success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_cancel_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.derivative_cancel_success
    }

    // Take field
    pub fn take_derivative_cancel_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.derivative_cancel_success, ::std::vec::Vec::new())
    }

    // repeated string spot_order_hashes = 3;


    pub fn get_spot_order_hashes(&self) -> &[::std::string::String] {
        &self.spot_order_hashes
    }
    pub fn clear_spot_order_hashes(&mut self) {
        self.spot_order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.spot_order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.spot_order_hashes
    }

    // Take field
    pub fn take_spot_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.spot_order_hashes, ::protobuf::RepeatedField::new())
    }

    // repeated string derivative_order_hashes = 4;


    pub fn get_derivative_order_hashes(&self) -> &[::std::string::String] {
        &self.derivative_order_hashes
    }
    pub fn clear_derivative_order_hashes(&mut self) {
        self.derivative_order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.derivative_order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.derivative_order_hashes
    }

    // Take field
    pub fn take_derivative_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.derivative_order_hashes, ::protobuf::RepeatedField::new())
    }

    // repeated bool binary_options_cancel_success = 5;


    pub fn get_binary_options_cancel_success(&self) -> &[bool] {
        &self.binary_options_cancel_success
    }
    pub fn clear_binary_options_cancel_success(&mut self) {
        self.binary_options_cancel_success.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_cancel_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.binary_options_cancel_success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_cancel_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.binary_options_cancel_success
    }

    // Take field
    pub fn take_binary_options_cancel_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.binary_options_cancel_success, ::std::vec::Vec::new())
    }

    // repeated string binary_options_order_hashes = 6;


    pub fn get_binary_options_order_hashes(&self) -> &[::std::string::String] {
        &self.binary_options_order_hashes
    }
    pub fn clear_binary_options_order_hashes(&mut self) {
        self.binary_options_order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.binary_options_order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.binary_options_order_hashes
    }

    // Take field
    pub fn take_binary_options_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.binary_options_order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchUpdateOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.spot_cancel_success)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.derivative_cancel_success)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.spot_order_hashes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.derivative_order_hashes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.binary_options_cancel_success)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.binary_options_order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.spot_cancel_success.len() as u32;
        my_size += 2 * self.derivative_cancel_success.len() as u32;
        for value in &self.spot_order_hashes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.derivative_order_hashes {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += 2 * self.binary_options_cancel_success.len() as u32;
        for value in &self.binary_options_order_hashes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spot_cancel_success {
            os.write_bool(1, *v)?;
        };
        for v in &self.derivative_cancel_success {
            os.write_bool(2, *v)?;
        };
        for v in &self.spot_order_hashes {
            os.write_string(3, &v)?;
        };
        for v in &self.derivative_order_hashes {
            os.write_string(4, &v)?;
        };
        for v in &self.binary_options_cancel_success {
            os.write_bool(5, *v)?;
        };
        for v in &self.binary_options_order_hashes {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchUpdateOrdersResponse {
        MsgBatchUpdateOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchUpdateOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchUpdateOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchUpdateOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchUpdateOrdersResponse {
    fn clear(&mut self) {
        self.spot_cancel_success.clear();
        self.derivative_cancel_success.clear();
        self.spot_order_hashes.clear();
        self.derivative_order_hashes.clear();
        self.binary_options_cancel_success.clear();
        self.binary_options_order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchUpdateOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateDerivativeMarketOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateDerivativeMarketOrder {
    fn default() -> &'a MsgCreateDerivativeMarketOrder {
        <MsgCreateDerivativeMarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateDerivativeMarketOrder {
    pub fn new() -> MsgCreateDerivativeMarketOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateDerivativeMarketOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateDerivativeMarketOrder {
        MsgCreateDerivativeMarketOrder::new()
    }

    fn default_instance() -> &'static MsgCreateDerivativeMarketOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateDerivativeMarketOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateDerivativeMarketOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateDerivativeMarketOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateDerivativeMarketOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateDerivativeMarketOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    pub results: ::protobuf::SingularPtrField<DerivativeMarketOrderResults>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateDerivativeMarketOrderResponse {
    fn default() -> &'a MsgCreateDerivativeMarketOrderResponse {
        <MsgCreateDerivativeMarketOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateDerivativeMarketOrderResponse {
    pub fn new() -> MsgCreateDerivativeMarketOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2;


    pub fn get_results(&self) -> &DerivativeMarketOrderResults {
        self.results.as_ref().unwrap_or_else(|| <DerivativeMarketOrderResults as ::protobuf::Message>::default_instance())
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: DerivativeMarketOrderResults) {
        self.results = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_results(&mut self) -> &mut DerivativeMarketOrderResults {
        if self.results.is_none() {
            self.results.set_default();
        }
        self.results.as_mut().unwrap()
    }

    // Take field
    pub fn take_results(&mut self) -> DerivativeMarketOrderResults {
        self.results.take().unwrap_or_else(|| DerivativeMarketOrderResults::new())
    }
}

impl ::protobuf::Message for MsgCreateDerivativeMarketOrderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if let Some(ref v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if let Some(ref v) = self.results.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateDerivativeMarketOrderResponse {
        MsgCreateDerivativeMarketOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateDerivativeMarketOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateDerivativeMarketOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateDerivativeMarketOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateDerivativeMarketOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateDerivativeMarketOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketOrderResults {
    // message fields
    pub quantity: ::std::string::String,
    pub price: ::std::string::String,
    pub fee: ::std::string::String,
    pub position_delta: ::protobuf::SingularPtrField<super::exchange::PositionDelta>,
    pub payout: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketOrderResults {
    fn default() -> &'a DerivativeMarketOrderResults {
        <DerivativeMarketOrderResults as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketOrderResults {
    pub fn new() -> DerivativeMarketOrderResults {
        ::std::default::Default::default()
    }

    // string quantity = 1;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string price = 2;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string fee = 3;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.PositionDelta position_delta = 4;


    pub fn get_position_delta(&self) -> &super::exchange::PositionDelta {
        self.position_delta.as_ref().unwrap_or_else(|| <super::exchange::PositionDelta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position_delta(&mut self) {
        self.position_delta.clear();
    }

    pub fn has_position_delta(&self) -> bool {
        self.position_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_delta(&mut self, v: super::exchange::PositionDelta) {
        self.position_delta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_delta(&mut self) -> &mut super::exchange::PositionDelta {
        if self.position_delta.is_none() {
            self.position_delta.set_default();
        }
        self.position_delta.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_delta(&mut self) -> super::exchange::PositionDelta {
        self.position_delta.take().unwrap_or_else(|| super::exchange::PositionDelta::new())
    }

    // string payout = 5;


    pub fn get_payout(&self) -> &str {
        &self.payout
    }
    pub fn clear_payout(&mut self) {
        self.payout.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout(&mut self, v: ::std::string::String) {
        self.payout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout(&mut self) -> &mut ::std::string::String {
        &mut self.payout
    }

    // Take field
    pub fn take_payout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payout, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeMarketOrderResults {
    fn is_initialized(&self) -> bool {
        for v in &self.position_delta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_delta)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.quantity);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.price);
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fee);
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payout.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.quantity.is_empty() {
            os.write_string(1, &self.quantity)?;
        }
        if !self.price.is_empty() {
            os.write_string(2, &self.price)?;
        }
        if !self.fee.is_empty() {
            os.write_string(3, &self.fee)?;
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payout.is_empty() {
            os.write_string(5, &self.payout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketOrderResults {
        DerivativeMarketOrderResults::new()
    }

    fn default_instance() -> &'static DerivativeMarketOrderResults {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketOrderResults> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketOrderResults::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketOrderResults {
    fn clear(&mut self) {
        self.quantity.clear();
        self.price.clear();
        self.fee.clear();
        self.position_delta.clear();
        self.payout.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketOrderResults {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateBinaryOptionsMarketOrder {
    // message fields
    pub sender: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateBinaryOptionsMarketOrder {
    fn default() -> &'a MsgCreateBinaryOptionsMarketOrder {
        <MsgCreateBinaryOptionsMarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateBinaryOptionsMarketOrder {
    pub fn new() -> MsgCreateBinaryOptionsMarketOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 2;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }
}

impl ::protobuf::Message for MsgCreateBinaryOptionsMarketOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateBinaryOptionsMarketOrder {
        MsgCreateBinaryOptionsMarketOrder::new()
    }

    fn default_instance() -> &'static MsgCreateBinaryOptionsMarketOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCreateBinaryOptionsMarketOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateBinaryOptionsMarketOrder::new)
    }
}

impl ::protobuf::Clear for MsgCreateBinaryOptionsMarketOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateBinaryOptionsMarketOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCreateBinaryOptionsMarketOrderResponse {
    // message fields
    pub order_hash: ::std::string::String,
    pub results: ::protobuf::SingularPtrField<DerivativeMarketOrderResults>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCreateBinaryOptionsMarketOrderResponse {
    fn default() -> &'a MsgCreateBinaryOptionsMarketOrderResponse {
        <MsgCreateBinaryOptionsMarketOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCreateBinaryOptionsMarketOrderResponse {
    pub fn new() -> MsgCreateBinaryOptionsMarketOrderResponse {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeMarketOrderResults results = 2;


    pub fn get_results(&self) -> &DerivativeMarketOrderResults {
        self.results.as_ref().unwrap_or_else(|| <DerivativeMarketOrderResults as ::protobuf::Message>::default_instance())
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: DerivativeMarketOrderResults) {
        self.results = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_results(&mut self) -> &mut DerivativeMarketOrderResults {
        if self.results.is_none() {
            self.results.set_default();
        }
        self.results.as_mut().unwrap()
    }

    // Take field
    pub fn take_results(&mut self) -> DerivativeMarketOrderResults {
        self.results.take().unwrap_or_else(|| DerivativeMarketOrderResults::new())
    }
}

impl ::protobuf::Message for MsgCreateBinaryOptionsMarketOrderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if let Some(ref v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if let Some(ref v) = self.results.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCreateBinaryOptionsMarketOrderResponse {
        MsgCreateBinaryOptionsMarketOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCreateBinaryOptionsMarketOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCreateBinaryOptionsMarketOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCreateBinaryOptionsMarketOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCreateBinaryOptionsMarketOrderResponse {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCreateBinaryOptionsMarketOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelDerivativeOrder {
    // message fields
    pub sender: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hash: ::std::string::String,
    pub order_mask: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelDerivativeOrder {
    fn default() -> &'a MsgCancelDerivativeOrder {
        <MsgCancelDerivativeOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelDerivativeOrder {
    pub fn new() -> MsgCancelDerivativeOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string order_hash = 4;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // int32 order_mask = 5;


    pub fn get_order_mask(&self) -> i32 {
        self.order_mask
    }
    pub fn clear_order_mask(&mut self) {
        self.order_mask = 0;
    }

    // Param is passed by value, moved
    pub fn set_order_mask(&mut self, v: i32) {
        self.order_mask = v;
    }
}

impl ::protobuf::Message for MsgCancelDerivativeOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_mask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.order_hash);
        }
        if self.order_mask != 0 {
            my_size += ::protobuf::rt::value_size(5, self.order_mask, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(4, &self.order_hash)?;
        }
        if self.order_mask != 0 {
            os.write_int32(5, self.order_mask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelDerivativeOrder {
        MsgCancelDerivativeOrder::new()
    }

    fn default_instance() -> &'static MsgCancelDerivativeOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCancelDerivativeOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelDerivativeOrder::new)
    }
}

impl ::protobuf::Clear for MsgCancelDerivativeOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hash.clear();
        self.order_mask = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelDerivativeOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelDerivativeOrderResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelDerivativeOrderResponse {
    fn default() -> &'a MsgCancelDerivativeOrderResponse {
        <MsgCancelDerivativeOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelDerivativeOrderResponse {
    pub fn new() -> MsgCancelDerivativeOrderResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgCancelDerivativeOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelDerivativeOrderResponse {
        MsgCancelDerivativeOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCancelDerivativeOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCancelDerivativeOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelDerivativeOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCancelDerivativeOrderResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelDerivativeOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelBinaryOptionsOrder {
    // message fields
    pub sender: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hash: ::std::string::String,
    pub order_mask: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelBinaryOptionsOrder {
    fn default() -> &'a MsgCancelBinaryOptionsOrder {
        <MsgCancelBinaryOptionsOrder as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelBinaryOptionsOrder {
    pub fn new() -> MsgCancelBinaryOptionsOrder {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string order_hash = 4;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // int32 order_mask = 5;


    pub fn get_order_mask(&self) -> i32 {
        self.order_mask
    }
    pub fn clear_order_mask(&mut self) {
        self.order_mask = 0;
    }

    // Param is passed by value, moved
    pub fn set_order_mask(&mut self, v: i32) {
        self.order_mask = v;
    }
}

impl ::protobuf::Message for MsgCancelBinaryOptionsOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_mask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.order_hash);
        }
        if self.order_mask != 0 {
            my_size += ::protobuf::rt::value_size(5, self.order_mask, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(4, &self.order_hash)?;
        }
        if self.order_mask != 0 {
            os.write_int32(5, self.order_mask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelBinaryOptionsOrder {
        MsgCancelBinaryOptionsOrder::new()
    }

    fn default_instance() -> &'static MsgCancelBinaryOptionsOrder {
        static instance: ::protobuf::rt::LazyV2<MsgCancelBinaryOptionsOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelBinaryOptionsOrder::new)
    }
}

impl ::protobuf::Clear for MsgCancelBinaryOptionsOrder {
    fn clear(&mut self) {
        self.sender.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hash.clear();
        self.order_mask = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelBinaryOptionsOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgCancelBinaryOptionsOrderResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgCancelBinaryOptionsOrderResponse {
    fn default() -> &'a MsgCancelBinaryOptionsOrderResponse {
        <MsgCancelBinaryOptionsOrderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgCancelBinaryOptionsOrderResponse {
    pub fn new() -> MsgCancelBinaryOptionsOrderResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgCancelBinaryOptionsOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgCancelBinaryOptionsOrderResponse {
        MsgCancelBinaryOptionsOrderResponse::new()
    }

    fn default_instance() -> &'static MsgCancelBinaryOptionsOrderResponse {
        static instance: ::protobuf::rt::LazyV2<MsgCancelBinaryOptionsOrderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgCancelBinaryOptionsOrderResponse::new)
    }
}

impl ::protobuf::Clear for MsgCancelBinaryOptionsOrderResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgCancelBinaryOptionsOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderData {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hash: ::std::string::String,
    pub order_mask: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderData {
    fn default() -> &'a OrderData {
        <OrderData as ::protobuf::Message>::default_instance()
    }
}

impl OrderData {
    pub fn new() -> OrderData {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string order_hash = 3;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // int32 order_mask = 4;


    pub fn get_order_mask(&self) -> i32 {
        self.order_mask
    }
    pub fn clear_order_mask(&mut self) {
        self.order_mask = 0;
    }

    // Param is passed by value, moved
    pub fn set_order_mask(&mut self, v: i32) {
        self.order_mask = v;
    }
}

impl ::protobuf::Message for OrderData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_mask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.order_hash);
        }
        if self.order_mask != 0 {
            my_size += ::protobuf::rt::value_size(4, self.order_mask, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(3, &self.order_hash)?;
        }
        if self.order_mask != 0 {
            os.write_int32(4, self.order_mask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderData {
        OrderData::new()
    }

    fn default_instance() -> &'static OrderData {
        static instance: ::protobuf::rt::LazyV2<OrderData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderData::new)
    }
}

impl ::protobuf::Clear for OrderData {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hash.clear();
        self.order_mask = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelDerivativeOrders {
    // message fields
    pub sender: ::std::string::String,
    pub data: ::protobuf::RepeatedField<OrderData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelDerivativeOrders {
    fn default() -> &'a MsgBatchCancelDerivativeOrders {
        <MsgBatchCancelDerivativeOrders as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelDerivativeOrders {
    pub fn new() -> MsgBatchCancelDerivativeOrders {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.OrderData data = 2;


    pub fn get_data(&self) -> &[OrderData] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<OrderData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<OrderData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<OrderData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelDerivativeOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelDerivativeOrders {
        MsgBatchCancelDerivativeOrders::new()
    }

    fn default_instance() -> &'static MsgBatchCancelDerivativeOrders {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelDerivativeOrders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelDerivativeOrders::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelDerivativeOrders {
    fn clear(&mut self) {
        self.sender.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelDerivativeOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgBatchCancelDerivativeOrdersResponse {
    // message fields
    pub success: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgBatchCancelDerivativeOrdersResponse {
    fn default() -> &'a MsgBatchCancelDerivativeOrdersResponse {
        <MsgBatchCancelDerivativeOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgBatchCancelDerivativeOrdersResponse {
    pub fn new() -> MsgBatchCancelDerivativeOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated bool success = 1;


    pub fn get_success(&self) -> &[bool] {
        &self.success
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: ::std::vec::Vec<bool>) {
        self.success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.success
    }

    // Take field
    pub fn take_success(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.success, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgBatchCancelDerivativeOrdersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.success)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.success.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.success {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgBatchCancelDerivativeOrdersResponse {
        MsgBatchCancelDerivativeOrdersResponse::new()
    }

    fn default_instance() -> &'static MsgBatchCancelDerivativeOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<MsgBatchCancelDerivativeOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgBatchCancelDerivativeOrdersResponse::new)
    }
}

impl ::protobuf::Clear for MsgBatchCancelDerivativeOrdersResponse {
    fn clear(&mut self) {
        self.success.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgBatchCancelDerivativeOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgSubaccountTransfer {
    // message fields
    pub sender: ::std::string::String,
    pub source_subaccount_id: ::std::string::String,
    pub destination_subaccount_id: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgSubaccountTransfer {
    fn default() -> &'a MsgSubaccountTransfer {
        <MsgSubaccountTransfer as ::protobuf::Message>::default_instance()
    }
}

impl MsgSubaccountTransfer {
    pub fn new() -> MsgSubaccountTransfer {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string source_subaccount_id = 2;


    pub fn get_source_subaccount_id(&self) -> &str {
        &self.source_subaccount_id
    }
    pub fn clear_source_subaccount_id(&mut self) {
        self.source_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_subaccount_id(&mut self, v: ::std::string::String) {
        self.source_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.source_subaccount_id
    }

    // Take field
    pub fn take_source_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_subaccount_id, ::std::string::String::new())
    }

    // string destination_subaccount_id = 3;


    pub fn get_destination_subaccount_id(&self) -> &str {
        &self.destination_subaccount_id
    }
    pub fn clear_destination_subaccount_id(&mut self) {
        self.destination_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_subaccount_id(&mut self, v: ::std::string::String) {
        self.destination_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.destination_subaccount_id
    }

    // Take field
    pub fn take_destination_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_subaccount_id, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 4;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for MsgSubaccountTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.source_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_subaccount_id);
        }
        if !self.destination_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination_subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            os.write_string(2, &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            os.write_string(3, &self.destination_subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgSubaccountTransfer {
        MsgSubaccountTransfer::new()
    }

    fn default_instance() -> &'static MsgSubaccountTransfer {
        static instance: ::protobuf::rt::LazyV2<MsgSubaccountTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgSubaccountTransfer::new)
    }
}

impl ::protobuf::Clear for MsgSubaccountTransfer {
    fn clear(&mut self) {
        self.sender.clear();
        self.source_subaccount_id.clear();
        self.destination_subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgSubaccountTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgSubaccountTransferResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgSubaccountTransferResponse {
    fn default() -> &'a MsgSubaccountTransferResponse {
        <MsgSubaccountTransferResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgSubaccountTransferResponse {
    pub fn new() -> MsgSubaccountTransferResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgSubaccountTransferResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgSubaccountTransferResponse {
        MsgSubaccountTransferResponse::new()
    }

    fn default_instance() -> &'static MsgSubaccountTransferResponse {
        static instance: ::protobuf::rt::LazyV2<MsgSubaccountTransferResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgSubaccountTransferResponse::new)
    }
}

impl ::protobuf::Clear for MsgSubaccountTransferResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgSubaccountTransferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgExternalTransfer {
    // message fields
    pub sender: ::std::string::String,
    pub source_subaccount_id: ::std::string::String,
    pub destination_subaccount_id: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgExternalTransfer {
    fn default() -> &'a MsgExternalTransfer {
        <MsgExternalTransfer as ::protobuf::Message>::default_instance()
    }
}

impl MsgExternalTransfer {
    pub fn new() -> MsgExternalTransfer {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string source_subaccount_id = 2;


    pub fn get_source_subaccount_id(&self) -> &str {
        &self.source_subaccount_id
    }
    pub fn clear_source_subaccount_id(&mut self) {
        self.source_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_subaccount_id(&mut self, v: ::std::string::String) {
        self.source_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.source_subaccount_id
    }

    // Take field
    pub fn take_source_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_subaccount_id, ::std::string::String::new())
    }

    // string destination_subaccount_id = 3;


    pub fn get_destination_subaccount_id(&self) -> &str {
        &self.destination_subaccount_id
    }
    pub fn clear_destination_subaccount_id(&mut self) {
        self.destination_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_subaccount_id(&mut self, v: ::std::string::String) {
        self.destination_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.destination_subaccount_id
    }

    // Take field
    pub fn take_destination_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_subaccount_id, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 4;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for MsgExternalTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.source_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_subaccount_id);
        }
        if !self.destination_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination_subaccount_id);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            os.write_string(2, &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            os.write_string(3, &self.destination_subaccount_id)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgExternalTransfer {
        MsgExternalTransfer::new()
    }

    fn default_instance() -> &'static MsgExternalTransfer {
        static instance: ::protobuf::rt::LazyV2<MsgExternalTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgExternalTransfer::new)
    }
}

impl ::protobuf::Clear for MsgExternalTransfer {
    fn clear(&mut self) {
        self.sender.clear();
        self.source_subaccount_id.clear();
        self.destination_subaccount_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgExternalTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgExternalTransferResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgExternalTransferResponse {
    fn default() -> &'a MsgExternalTransferResponse {
        <MsgExternalTransferResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgExternalTransferResponse {
    pub fn new() -> MsgExternalTransferResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgExternalTransferResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgExternalTransferResponse {
        MsgExternalTransferResponse::new()
    }

    fn default_instance() -> &'static MsgExternalTransferResponse {
        static instance: ::protobuf::rt::LazyV2<MsgExternalTransferResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgExternalTransferResponse::new)
    }
}

impl ::protobuf::Clear for MsgExternalTransferResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgExternalTransferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgLiquidatePosition {
    // message fields
    pub sender: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub order: ::protobuf::SingularPtrField<super::exchange::DerivativeOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgLiquidatePosition {
    fn default() -> &'a MsgLiquidatePosition {
        <MsgLiquidatePosition as ::protobuf::Message>::default_instance()
    }
}

impl MsgLiquidatePosition {
    pub fn new() -> MsgLiquidatePosition {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.DerivativeOrder order = 4;


    pub fn get_order(&self) -> &super::exchange::DerivativeOrder {
        self.order.as_ref().unwrap_or_else(|| <super::exchange::DerivativeOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: super::exchange::DerivativeOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut super::exchange::DerivativeOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> super::exchange::DerivativeOrder {
        self.order.take().unwrap_or_else(|| super::exchange::DerivativeOrder::new())
    }
}

impl ::protobuf::Message for MsgLiquidatePosition {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgLiquidatePosition {
        MsgLiquidatePosition::new()
    }

    fn default_instance() -> &'static MsgLiquidatePosition {
        static instance: ::protobuf::rt::LazyV2<MsgLiquidatePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgLiquidatePosition::new)
    }
}

impl ::protobuf::Clear for MsgLiquidatePosition {
    fn clear(&mut self) {
        self.sender.clear();
        self.subaccount_id.clear();
        self.market_id.clear();
        self.order.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgLiquidatePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgLiquidatePositionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgLiquidatePositionResponse {
    fn default() -> &'a MsgLiquidatePositionResponse {
        <MsgLiquidatePositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgLiquidatePositionResponse {
    pub fn new() -> MsgLiquidatePositionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgLiquidatePositionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgLiquidatePositionResponse {
        MsgLiquidatePositionResponse::new()
    }

    fn default_instance() -> &'static MsgLiquidatePositionResponse {
        static instance: ::protobuf::rt::LazyV2<MsgLiquidatePositionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgLiquidatePositionResponse::new)
    }
}

impl ::protobuf::Clear for MsgLiquidatePositionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgLiquidatePositionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgIncreasePositionMargin {
    // message fields
    pub sender: ::std::string::String,
    pub source_subaccount_id: ::std::string::String,
    pub destination_subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgIncreasePositionMargin {
    fn default() -> &'a MsgIncreasePositionMargin {
        <MsgIncreasePositionMargin as ::protobuf::Message>::default_instance()
    }
}

impl MsgIncreasePositionMargin {
    pub fn new() -> MsgIncreasePositionMargin {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string source_subaccount_id = 2;


    pub fn get_source_subaccount_id(&self) -> &str {
        &self.source_subaccount_id
    }
    pub fn clear_source_subaccount_id(&mut self) {
        self.source_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_subaccount_id(&mut self, v: ::std::string::String) {
        self.source_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.source_subaccount_id
    }

    // Take field
    pub fn take_source_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_subaccount_id, ::std::string::String::new())
    }

    // string destination_subaccount_id = 3;


    pub fn get_destination_subaccount_id(&self) -> &str {
        &self.destination_subaccount_id
    }
    pub fn clear_destination_subaccount_id(&mut self) {
        self.destination_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_subaccount_id(&mut self, v: ::std::string::String) {
        self.destination_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.destination_subaccount_id
    }

    // Take field
    pub fn take_destination_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_subaccount_id, ::std::string::String::new())
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string amount = 5;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgIncreasePositionMargin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.source_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_subaccount_id);
        }
        if !self.destination_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination_subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.source_subaccount_id.is_empty() {
            os.write_string(2, &self.source_subaccount_id)?;
        }
        if !self.destination_subaccount_id.is_empty() {
            os.write_string(3, &self.destination_subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        if !self.amount.is_empty() {
            os.write_string(5, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgIncreasePositionMargin {
        MsgIncreasePositionMargin::new()
    }

    fn default_instance() -> &'static MsgIncreasePositionMargin {
        static instance: ::protobuf::rt::LazyV2<MsgIncreasePositionMargin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgIncreasePositionMargin::new)
    }
}

impl ::protobuf::Clear for MsgIncreasePositionMargin {
    fn clear(&mut self) {
        self.sender.clear();
        self.source_subaccount_id.clear();
        self.destination_subaccount_id.clear();
        self.market_id.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgIncreasePositionMargin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgIncreasePositionMarginResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgIncreasePositionMarginResponse {
    fn default() -> &'a MsgIncreasePositionMarginResponse {
        <MsgIncreasePositionMarginResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgIncreasePositionMarginResponse {
    pub fn new() -> MsgIncreasePositionMarginResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgIncreasePositionMarginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgIncreasePositionMarginResponse {
        MsgIncreasePositionMarginResponse::new()
    }

    fn default_instance() -> &'static MsgIncreasePositionMarginResponse {
        static instance: ::protobuf::rt::LazyV2<MsgIncreasePositionMarginResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgIncreasePositionMarginResponse::new)
    }
}

impl ::protobuf::Clear for MsgIncreasePositionMarginResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgIncreasePositionMarginResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgPrivilegedExecuteContract {
    // message fields
    pub sender: ::std::string::String,
    pub funds: ::std::string::String,
    pub contract_address: ::std::string::String,
    pub data: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgPrivilegedExecuteContract {
    fn default() -> &'a MsgPrivilegedExecuteContract {
        <MsgPrivilegedExecuteContract as ::protobuf::Message>::default_instance()
    }
}

impl MsgPrivilegedExecuteContract {
    pub fn new() -> MsgPrivilegedExecuteContract {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string funds = 2;


    pub fn get_funds(&self) -> &str {
        &self.funds
    }
    pub fn clear_funds(&mut self) {
        self.funds.clear();
    }

    // Param is passed by value, moved
    pub fn set_funds(&mut self, v: ::std::string::String) {
        self.funds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funds(&mut self) -> &mut ::std::string::String {
        &mut self.funds
    }

    // Take field
    pub fn take_funds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.funds, ::std::string::String::new())
    }

    // string contract_address = 3;


    pub fn get_contract_address(&self) -> &str {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::string::String) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::string::String {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_address, ::std::string::String::new())
    }

    // string data = 4;


    pub fn get_data(&self) -> &str {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgPrivilegedExecuteContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.funds)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.funds.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.funds);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.contract_address);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.funds.is_empty() {
            os.write_string(2, &self.funds)?;
        }
        if !self.contract_address.is_empty() {
            os.write_string(3, &self.contract_address)?;
        }
        if !self.data.is_empty() {
            os.write_string(4, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgPrivilegedExecuteContract {
        MsgPrivilegedExecuteContract::new()
    }

    fn default_instance() -> &'static MsgPrivilegedExecuteContract {
        static instance: ::protobuf::rt::LazyV2<MsgPrivilegedExecuteContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgPrivilegedExecuteContract::new)
    }
}

impl ::protobuf::Clear for MsgPrivilegedExecuteContract {
    fn clear(&mut self) {
        self.sender.clear();
        self.funds.clear();
        self.contract_address.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgPrivilegedExecuteContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgPrivilegedExecuteContractResponse {
    // message fields
    pub funds_diff: ::protobuf::RepeatedField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgPrivilegedExecuteContractResponse {
    fn default() -> &'a MsgPrivilegedExecuteContractResponse {
        <MsgPrivilegedExecuteContractResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgPrivilegedExecuteContractResponse {
    pub fn new() -> MsgPrivilegedExecuteContractResponse {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.v1beta1.Coin funds_diff = 1;


    pub fn get_funds_diff(&self) -> &[super::coin::Coin] {
        &self.funds_diff
    }
    pub fn clear_funds_diff(&mut self) {
        self.funds_diff.clear();
    }

    // Param is passed by value, moved
    pub fn set_funds_diff(&mut self, v: ::protobuf::RepeatedField<super::coin::Coin>) {
        self.funds_diff = v;
    }

    // Mutable pointer to the field.
    pub fn mut_funds_diff(&mut self) -> &mut ::protobuf::RepeatedField<super::coin::Coin> {
        &mut self.funds_diff
    }

    // Take field
    pub fn take_funds_diff(&mut self) -> ::protobuf::RepeatedField<super::coin::Coin> {
        ::std::mem::replace(&mut self.funds_diff, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MsgPrivilegedExecuteContractResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.funds_diff {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.funds_diff)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.funds_diff {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.funds_diff {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgPrivilegedExecuteContractResponse {
        MsgPrivilegedExecuteContractResponse::new()
    }

    fn default_instance() -> &'static MsgPrivilegedExecuteContractResponse {
        static instance: ::protobuf::rt::LazyV2<MsgPrivilegedExecuteContractResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgPrivilegedExecuteContractResponse::new)
    }
}

impl ::protobuf::Clear for MsgPrivilegedExecuteContractResponse {
    fn clear(&mut self) {
        self.funds_diff.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgPrivilegedExecuteContractResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarketParamUpdateProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub market_id: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub status: super::exchange::MarketStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarketParamUpdateProposal {
    fn default() -> &'a SpotMarketParamUpdateProposal {
        <SpotMarketParamUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarketParamUpdateProposal {
    pub fn new() -> SpotMarketParamUpdateProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string maker_fee_rate = 4;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 5;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 6;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 7;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 8;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MarketStatus status = 9;


    pub fn get_status(&self) -> super::exchange::MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = super::exchange::MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::exchange::MarketStatus) {
        self.status = v;
    }
}

impl ::protobuf::Message for SpotMarketParamUpdateProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.relayer_fee_share_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.min_quantity_tick_size);
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(9, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(4, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(5, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(6, &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(7, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(8, &self.min_quantity_tick_size)?;
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarketParamUpdateProposal {
        SpotMarketParamUpdateProposal::new()
    }

    fn default_instance() -> &'static SpotMarketParamUpdateProposal {
        static instance: ::protobuf::rt::LazyV2<SpotMarketParamUpdateProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarketParamUpdateProposal::new)
    }
}

impl ::protobuf::Clear for SpotMarketParamUpdateProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.market_id.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.status = super::exchange::MarketStatus::Unspecified;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarketParamUpdateProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExchangeEnableProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub exchangeType: ExchangeType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeEnableProposal {
    fn default() -> &'a ExchangeEnableProposal {
        <ExchangeEnableProposal as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeEnableProposal {
    pub fn new() -> ExchangeEnableProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.ExchangeType exchangeType = 3;


    pub fn get_exchangeType(&self) -> ExchangeType {
        self.exchangeType
    }
    pub fn clear_exchangeType(&mut self) {
        self.exchangeType = ExchangeType::EXCHANGE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_exchangeType(&mut self, v: ExchangeType) {
        self.exchangeType = v;
    }
}

impl ::protobuf::Message for ExchangeEnableProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.exchangeType, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.exchangeType != ExchangeType::EXCHANGE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.exchangeType);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.exchangeType != ExchangeType::EXCHANGE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.exchangeType))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeEnableProposal {
        ExchangeEnableProposal::new()
    }

    fn default_instance() -> &'static ExchangeEnableProposal {
        static instance: ::protobuf::rt::LazyV2<ExchangeEnableProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeEnableProposal::new)
    }
}

impl ::protobuf::Clear for ExchangeEnableProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.exchangeType = ExchangeType::EXCHANGE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeEnableProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatchExchangeModificationProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub spot_market_param_update_proposals: ::protobuf::RepeatedField<SpotMarketParamUpdateProposal>,
    pub derivative_market_param_update_proposals: ::protobuf::RepeatedField<DerivativeMarketParamUpdateProposal>,
    pub spot_market_launch_proposals: ::protobuf::RepeatedField<SpotMarketLaunchProposal>,
    pub perpetual_market_launch_proposals: ::protobuf::RepeatedField<PerpetualMarketLaunchProposal>,
    pub expiry_futures_market_launch_proposals: ::protobuf::RepeatedField<ExpiryFuturesMarketLaunchProposal>,
    pub trading_reward_campaign_update_proposal: ::protobuf::SingularPtrField<TradingRewardCampaignUpdateProposal>,
    pub binary_options_market_launch_proposals: ::protobuf::RepeatedField<BinaryOptionsMarketLaunchProposal>,
    pub binary_options_param_update_proposals: ::protobuf::RepeatedField<BinaryOptionsMarketParamUpdateProposal>,
    pub denom_decimals_update_proposal: ::protobuf::SingularPtrField<UpdateDenomDecimalsProposal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchExchangeModificationProposal {
    fn default() -> &'a BatchExchangeModificationProposal {
        <BatchExchangeModificationProposal as ::protobuf::Message>::default_instance()
    }
}

impl BatchExchangeModificationProposal {
    pub fn new() -> BatchExchangeModificationProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.SpotMarketParamUpdateProposal spot_market_param_update_proposals = 3;


    pub fn get_spot_market_param_update_proposals(&self) -> &[SpotMarketParamUpdateProposal] {
        &self.spot_market_param_update_proposals
    }
    pub fn clear_spot_market_param_update_proposals(&mut self) {
        self.spot_market_param_update_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_market_param_update_proposals(&mut self, v: ::protobuf::RepeatedField<SpotMarketParamUpdateProposal>) {
        self.spot_market_param_update_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_market_param_update_proposals(&mut self) -> &mut ::protobuf::RepeatedField<SpotMarketParamUpdateProposal> {
        &mut self.spot_market_param_update_proposals
    }

    // Take field
    pub fn take_spot_market_param_update_proposals(&mut self) -> ::protobuf::RepeatedField<SpotMarketParamUpdateProposal> {
        ::std::mem::replace(&mut self.spot_market_param_update_proposals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.DerivativeMarketParamUpdateProposal derivative_market_param_update_proposals = 4;


    pub fn get_derivative_market_param_update_proposals(&self) -> &[DerivativeMarketParamUpdateProposal] {
        &self.derivative_market_param_update_proposals
    }
    pub fn clear_derivative_market_param_update_proposals(&mut self) {
        self.derivative_market_param_update_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_market_param_update_proposals(&mut self, v: ::protobuf::RepeatedField<DerivativeMarketParamUpdateProposal>) {
        self.derivative_market_param_update_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_market_param_update_proposals(&mut self) -> &mut ::protobuf::RepeatedField<DerivativeMarketParamUpdateProposal> {
        &mut self.derivative_market_param_update_proposals
    }

    // Take field
    pub fn take_derivative_market_param_update_proposals(&mut self) -> ::protobuf::RepeatedField<DerivativeMarketParamUpdateProposal> {
        ::std::mem::replace(&mut self.derivative_market_param_update_proposals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SpotMarketLaunchProposal spot_market_launch_proposals = 5;


    pub fn get_spot_market_launch_proposals(&self) -> &[SpotMarketLaunchProposal] {
        &self.spot_market_launch_proposals
    }
    pub fn clear_spot_market_launch_proposals(&mut self) {
        self.spot_market_launch_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_market_launch_proposals(&mut self, v: ::protobuf::RepeatedField<SpotMarketLaunchProposal>) {
        self.spot_market_launch_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_market_launch_proposals(&mut self) -> &mut ::protobuf::RepeatedField<SpotMarketLaunchProposal> {
        &mut self.spot_market_launch_proposals
    }

    // Take field
    pub fn take_spot_market_launch_proposals(&mut self) -> ::protobuf::RepeatedField<SpotMarketLaunchProposal> {
        ::std::mem::replace(&mut self.spot_market_launch_proposals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.PerpetualMarketLaunchProposal perpetual_market_launch_proposals = 6;


    pub fn get_perpetual_market_launch_proposals(&self) -> &[PerpetualMarketLaunchProposal] {
        &self.perpetual_market_launch_proposals
    }
    pub fn clear_perpetual_market_launch_proposals(&mut self) {
        self.perpetual_market_launch_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_perpetual_market_launch_proposals(&mut self, v: ::protobuf::RepeatedField<PerpetualMarketLaunchProposal>) {
        self.perpetual_market_launch_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perpetual_market_launch_proposals(&mut self) -> &mut ::protobuf::RepeatedField<PerpetualMarketLaunchProposal> {
        &mut self.perpetual_market_launch_proposals
    }

    // Take field
    pub fn take_perpetual_market_launch_proposals(&mut self) -> ::protobuf::RepeatedField<PerpetualMarketLaunchProposal> {
        ::std::mem::replace(&mut self.perpetual_market_launch_proposals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.ExpiryFuturesMarketLaunchProposal expiry_futures_market_launch_proposals = 7;


    pub fn get_expiry_futures_market_launch_proposals(&self) -> &[ExpiryFuturesMarketLaunchProposal] {
        &self.expiry_futures_market_launch_proposals
    }
    pub fn clear_expiry_futures_market_launch_proposals(&mut self) {
        self.expiry_futures_market_launch_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_expiry_futures_market_launch_proposals(&mut self, v: ::protobuf::RepeatedField<ExpiryFuturesMarketLaunchProposal>) {
        self.expiry_futures_market_launch_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expiry_futures_market_launch_proposals(&mut self) -> &mut ::protobuf::RepeatedField<ExpiryFuturesMarketLaunchProposal> {
        &mut self.expiry_futures_market_launch_proposals
    }

    // Take field
    pub fn take_expiry_futures_market_launch_proposals(&mut self) -> ::protobuf::RepeatedField<ExpiryFuturesMarketLaunchProposal> {
        ::std::mem::replace(&mut self.expiry_futures_market_launch_proposals, ::protobuf::RepeatedField::new())
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignUpdateProposal trading_reward_campaign_update_proposal = 8;


    pub fn get_trading_reward_campaign_update_proposal(&self) -> &TradingRewardCampaignUpdateProposal {
        self.trading_reward_campaign_update_proposal.as_ref().unwrap_or_else(|| <TradingRewardCampaignUpdateProposal as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trading_reward_campaign_update_proposal(&mut self) {
        self.trading_reward_campaign_update_proposal.clear();
    }

    pub fn has_trading_reward_campaign_update_proposal(&self) -> bool {
        self.trading_reward_campaign_update_proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_campaign_update_proposal(&mut self, v: TradingRewardCampaignUpdateProposal) {
        self.trading_reward_campaign_update_proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_reward_campaign_update_proposal(&mut self) -> &mut TradingRewardCampaignUpdateProposal {
        if self.trading_reward_campaign_update_proposal.is_none() {
            self.trading_reward_campaign_update_proposal.set_default();
        }
        self.trading_reward_campaign_update_proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_reward_campaign_update_proposal(&mut self) -> TradingRewardCampaignUpdateProposal {
        self.trading_reward_campaign_update_proposal.take().unwrap_or_else(|| TradingRewardCampaignUpdateProposal::new())
    }

    // repeated .injective.exchange.v1beta1.BinaryOptionsMarketLaunchProposal binary_options_market_launch_proposals = 9;


    pub fn get_binary_options_market_launch_proposals(&self) -> &[BinaryOptionsMarketLaunchProposal] {
        &self.binary_options_market_launch_proposals
    }
    pub fn clear_binary_options_market_launch_proposals(&mut self) {
        self.binary_options_market_launch_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_market_launch_proposals(&mut self, v: ::protobuf::RepeatedField<BinaryOptionsMarketLaunchProposal>) {
        self.binary_options_market_launch_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_market_launch_proposals(&mut self) -> &mut ::protobuf::RepeatedField<BinaryOptionsMarketLaunchProposal> {
        &mut self.binary_options_market_launch_proposals
    }

    // Take field
    pub fn take_binary_options_market_launch_proposals(&mut self) -> ::protobuf::RepeatedField<BinaryOptionsMarketLaunchProposal> {
        ::std::mem::replace(&mut self.binary_options_market_launch_proposals, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.BinaryOptionsMarketParamUpdateProposal binary_options_param_update_proposals = 10;


    pub fn get_binary_options_param_update_proposals(&self) -> &[BinaryOptionsMarketParamUpdateProposal] {
        &self.binary_options_param_update_proposals
    }
    pub fn clear_binary_options_param_update_proposals(&mut self) {
        self.binary_options_param_update_proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_param_update_proposals(&mut self, v: ::protobuf::RepeatedField<BinaryOptionsMarketParamUpdateProposal>) {
        self.binary_options_param_update_proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_options_param_update_proposals(&mut self) -> &mut ::protobuf::RepeatedField<BinaryOptionsMarketParamUpdateProposal> {
        &mut self.binary_options_param_update_proposals
    }

    // Take field
    pub fn take_binary_options_param_update_proposals(&mut self) -> ::protobuf::RepeatedField<BinaryOptionsMarketParamUpdateProposal> {
        ::std::mem::replace(&mut self.binary_options_param_update_proposals, ::protobuf::RepeatedField::new())
    }

    // .injective.exchange.v1beta1.UpdateDenomDecimalsProposal denom_decimals_update_proposal = 11;


    pub fn get_denom_decimals_update_proposal(&self) -> &UpdateDenomDecimalsProposal {
        self.denom_decimals_update_proposal.as_ref().unwrap_or_else(|| <UpdateDenomDecimalsProposal as ::protobuf::Message>::default_instance())
    }
    pub fn clear_denom_decimals_update_proposal(&mut self) {
        self.denom_decimals_update_proposal.clear();
    }

    pub fn has_denom_decimals_update_proposal(&self) -> bool {
        self.denom_decimals_update_proposal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denom_decimals_update_proposal(&mut self, v: UpdateDenomDecimalsProposal) {
        self.denom_decimals_update_proposal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom_decimals_update_proposal(&mut self) -> &mut UpdateDenomDecimalsProposal {
        if self.denom_decimals_update_proposal.is_none() {
            self.denom_decimals_update_proposal.set_default();
        }
        self.denom_decimals_update_proposal.as_mut().unwrap()
    }

    // Take field
    pub fn take_denom_decimals_update_proposal(&mut self) -> UpdateDenomDecimalsProposal {
        self.denom_decimals_update_proposal.take().unwrap_or_else(|| UpdateDenomDecimalsProposal::new())
    }
}

impl ::protobuf::Message for BatchExchangeModificationProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_market_param_update_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_market_param_update_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spot_market_launch_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perpetual_market_launch_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiry_futures_market_launch_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trading_reward_campaign_update_proposal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_market_launch_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_param_update_proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denom_decimals_update_proposal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_market_param_update_proposals)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_market_param_update_proposals)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_market_launch_proposals)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.perpetual_market_launch_proposals)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.expiry_futures_market_launch_proposals)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trading_reward_campaign_update_proposal)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_options_market_launch_proposals)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_options_param_update_proposals)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.denom_decimals_update_proposal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.spot_market_param_update_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_market_param_update_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.spot_market_launch_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.perpetual_market_launch_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.expiry_futures_market_launch_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.trading_reward_campaign_update_proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.binary_options_market_launch_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_options_param_update_proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.denom_decimals_update_proposal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.spot_market_param_update_proposals {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_market_param_update_proposals {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.spot_market_launch_proposals {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.perpetual_market_launch_proposals {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.expiry_futures_market_launch_proposals {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.trading_reward_campaign_update_proposal.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.binary_options_market_launch_proposals {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_options_param_update_proposals {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.denom_decimals_update_proposal.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchExchangeModificationProposal {
        BatchExchangeModificationProposal::new()
    }

    fn default_instance() -> &'static BatchExchangeModificationProposal {
        static instance: ::protobuf::rt::LazyV2<BatchExchangeModificationProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchExchangeModificationProposal::new)
    }
}

impl ::protobuf::Clear for BatchExchangeModificationProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.spot_market_param_update_proposals.clear();
        self.derivative_market_param_update_proposals.clear();
        self.spot_market_launch_proposals.clear();
        self.perpetual_market_launch_proposals.clear();
        self.expiry_futures_market_launch_proposals.clear();
        self.trading_reward_campaign_update_proposal.clear();
        self.binary_options_market_launch_proposals.clear();
        self.binary_options_param_update_proposals.clear();
        self.denom_decimals_update_proposal.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchExchangeModificationProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarketLaunchProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub ticker: ::std::string::String,
    pub base_denom: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarketLaunchProposal {
    fn default() -> &'a SpotMarketLaunchProposal {
        <SpotMarketLaunchProposal as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarketLaunchProposal {
    pub fn new() -> SpotMarketLaunchProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string base_denom = 4;


    pub fn get_base_denom(&self) -> &str {
        &self.base_denom
    }
    pub fn clear_base_denom(&mut self) {
        self.base_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_denom(&mut self, v: ::std::string::String) {
        self.base_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_denom(&mut self) -> &mut ::std::string::String {
        &mut self.base_denom
    }

    // Take field
    pub fn take_base_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_denom, ::std::string::String::new())
    }

    // string quote_denom = 5;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string min_price_tick_size = 6;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 7;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // string maker_fee_rate = 8;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 9;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotMarketLaunchProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.base_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.base_denom);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.quote_denom);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.min_quantity_tick_size);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.taker_fee_rate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            os.write_string(4, &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(5, &self.quote_denom)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(6, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(7, &self.min_quantity_tick_size)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(8, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(9, &self.taker_fee_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarketLaunchProposal {
        SpotMarketLaunchProposal::new()
    }

    fn default_instance() -> &'static SpotMarketLaunchProposal {
        static instance: ::protobuf::rt::LazyV2<SpotMarketLaunchProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarketLaunchProposal::new)
    }
}

impl ::protobuf::Clear for SpotMarketLaunchProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.ticker.clear();
        self.base_denom.clear();
        self.quote_denom.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarketLaunchProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketLaunchProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub ticker: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub oracle_type: super::oracle::OracleType,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketLaunchProposal {
    fn default() -> &'a PerpetualMarketLaunchProposal {
        <PerpetualMarketLaunchProposal as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketLaunchProposal {
    pub fn new() -> PerpetualMarketLaunchProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string quote_denom = 4;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string oracle_base = 5;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 6;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 8;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // string initial_margin_ratio = 9;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 10;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string maker_fee_rate = 11;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 12;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 13;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 14;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PerpetualMarketLaunchProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.quote_denom);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.oracle_quote);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(8, self.oracle_type);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.maintenance_margin_ratio);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.taker_fee_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(4, &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(5, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(6, &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(9, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(10, &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(11, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(12, &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(13, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(14, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketLaunchProposal {
        PerpetualMarketLaunchProposal::new()
    }

    fn default_instance() -> &'static PerpetualMarketLaunchProposal {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketLaunchProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketLaunchProposal::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketLaunchProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.ticker.clear();
        self.quote_denom.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_scale_factor = 0;
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketLaunchProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketLaunchProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub ticker: ::std::string::String,
    pub oracle_symbol: ::std::string::String,
    pub oracle_provider: ::std::string::String,
    pub oracle_type: super::oracle::OracleType,
    pub oracle_scale_factor: u32,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub admin: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketLaunchProposal {
    fn default() -> &'a BinaryOptionsMarketLaunchProposal {
        <BinaryOptionsMarketLaunchProposal as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketLaunchProposal {
    pub fn new() -> BinaryOptionsMarketLaunchProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_symbol = 4;


    pub fn get_oracle_symbol(&self) -> &str {
        &self.oracle_symbol
    }
    pub fn clear_oracle_symbol(&mut self) {
        self.oracle_symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_symbol(&mut self, v: ::std::string::String) {
        self.oracle_symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_symbol
    }

    // Take field
    pub fn take_oracle_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_symbol, ::std::string::String::new())
    }

    // string oracle_provider = 5;


    pub fn get_oracle_provider(&self) -> &str {
        &self.oracle_provider
    }
    pub fn clear_oracle_provider(&mut self) {
        self.oracle_provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_provider(&mut self, v: ::std::string::String) {
        self.oracle_provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_provider(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_provider
    }

    // Take field
    pub fn take_oracle_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_provider, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 6;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // int64 expiration_timestamp = 8;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 settlement_timestamp = 9;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // string admin = 10;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // string quote_denom = 11;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string maker_fee_rate = 12;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 13;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 14;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 15;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketLaunchProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_symbol)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_provider)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settlement_timestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.oracle_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.oracle_symbol);
        }
        if !self.oracle_provider.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_provider);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(6, self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.settlement_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.admin);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.quote_denom);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.taker_fee_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            os.write_string(4, &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            os.write_string(5, &self.oracle_provider)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(8, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_int64(9, self.settlement_timestamp)?;
        }
        if !self.admin.is_empty() {
            os.write_string(10, &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(11, &self.quote_denom)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(12, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(13, &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(14, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(15, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketLaunchProposal {
        BinaryOptionsMarketLaunchProposal::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketLaunchProposal {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketLaunchProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketLaunchProposal::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketLaunchProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.ticker.clear();
        self.oracle_symbol.clear();
        self.oracle_provider.clear();
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.oracle_scale_factor = 0;
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.admin.clear();
        self.quote_denom.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketLaunchProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpiryFuturesMarketLaunchProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub ticker: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub oracle_type: super::oracle::OracleType,
    pub expiry: i64,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpiryFuturesMarketLaunchProposal {
    fn default() -> &'a ExpiryFuturesMarketLaunchProposal {
        <ExpiryFuturesMarketLaunchProposal as ::protobuf::Message>::default_instance()
    }
}

impl ExpiryFuturesMarketLaunchProposal {
    pub fn new() -> ExpiryFuturesMarketLaunchProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string quote_denom = 4;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string oracle_base = 5;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 6;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 7;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 8;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // int64 expiry = 9;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string initial_margin_ratio = 10;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 11;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string maker_fee_rate = 12;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 13;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 14;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 15;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExpiryFuturesMarketLaunchProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.quote_denom);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.oracle_quote);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(7, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(8, self.oracle_type);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(9, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.maintenance_margin_ratio);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.taker_fee_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(4, &self.quote_denom)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(5, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(6, &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(7, self.oracle_scale_factor)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.expiry != 0 {
            os.write_int64(9, self.expiry)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(10, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(11, &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(12, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(13, &self.taker_fee_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(14, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(15, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpiryFuturesMarketLaunchProposal {
        ExpiryFuturesMarketLaunchProposal::new()
    }

    fn default_instance() -> &'static ExpiryFuturesMarketLaunchProposal {
        static instance: ::protobuf::rt::LazyV2<ExpiryFuturesMarketLaunchProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpiryFuturesMarketLaunchProposal::new)
    }
}

impl ::protobuf::Clear for ExpiryFuturesMarketLaunchProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.ticker.clear();
        self.quote_denom.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_scale_factor = 0;
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.expiry = 0;
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpiryFuturesMarketLaunchProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketParamUpdateProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub market_id: ::std::string::String,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub HourlyInterestRate: ::std::string::String,
    pub HourlyFundingRateCap: ::std::string::String,
    pub status: super::exchange::MarketStatus,
    pub oracle_params: ::protobuf::SingularPtrField<OracleParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketParamUpdateProposal {
    fn default() -> &'a DerivativeMarketParamUpdateProposal {
        <DerivativeMarketParamUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketParamUpdateProposal {
    pub fn new() -> DerivativeMarketParamUpdateProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string initial_margin_ratio = 4;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 5;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string maker_fee_rate = 6;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 7;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 8;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 9;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 10;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // string HourlyInterestRate = 11;


    pub fn get_HourlyInterestRate(&self) -> &str {
        &self.HourlyInterestRate
    }
    pub fn clear_HourlyInterestRate(&mut self) {
        self.HourlyInterestRate.clear();
    }

    // Param is passed by value, moved
    pub fn set_HourlyInterestRate(&mut self, v: ::std::string::String) {
        self.HourlyInterestRate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HourlyInterestRate(&mut self) -> &mut ::std::string::String {
        &mut self.HourlyInterestRate
    }

    // Take field
    pub fn take_HourlyInterestRate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.HourlyInterestRate, ::std::string::String::new())
    }

    // string HourlyFundingRateCap = 12;


    pub fn get_HourlyFundingRateCap(&self) -> &str {
        &self.HourlyFundingRateCap
    }
    pub fn clear_HourlyFundingRateCap(&mut self) {
        self.HourlyFundingRateCap.clear();
    }

    // Param is passed by value, moved
    pub fn set_HourlyFundingRateCap(&mut self, v: ::std::string::String) {
        self.HourlyFundingRateCap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HourlyFundingRateCap(&mut self) -> &mut ::std::string::String {
        &mut self.HourlyFundingRateCap
    }

    // Take field
    pub fn take_HourlyFundingRateCap(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.HourlyFundingRateCap, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MarketStatus status = 13;


    pub fn get_status(&self) -> super::exchange::MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = super::exchange::MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::exchange::MarketStatus) {
        self.status = v;
    }

    // .injective.exchange.v1beta1.OracleParams oracle_params = 14;


    pub fn get_oracle_params(&self) -> &OracleParams {
        self.oracle_params.as_ref().unwrap_or_else(|| <OracleParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_oracle_params(&mut self) {
        self.oracle_params.clear();
    }

    pub fn has_oracle_params(&self) -> bool {
        self.oracle_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oracle_params(&mut self, v: OracleParams) {
        self.oracle_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_params(&mut self) -> &mut OracleParams {
        if self.oracle_params.is_none() {
            self.oracle_params.set_default();
        }
        self.oracle_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_oracle_params(&mut self) -> OracleParams {
        self.oracle_params.take().unwrap_or_else(|| OracleParams::new())
    }
}

impl ::protobuf::Message for DerivativeMarketParamUpdateProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.oracle_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.HourlyInterestRate)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.HourlyFundingRateCap)?;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oracle_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.maintenance_margin_ratio);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.relayer_fee_share_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.min_quantity_tick_size);
        }
        if !self.HourlyInterestRate.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.HourlyInterestRate);
        }
        if !self.HourlyFundingRateCap.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.HourlyFundingRateCap);
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(13, self.status);
        }
        if let Some(ref v) = self.oracle_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(4, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(5, &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(6, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(7, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(8, &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(9, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(10, &self.min_quantity_tick_size)?;
        }
        if !self.HourlyInterestRate.is_empty() {
            os.write_string(11, &self.HourlyInterestRate)?;
        }
        if !self.HourlyFundingRateCap.is_empty() {
            os.write_string(12, &self.HourlyFundingRateCap)?;
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if let Some(ref v) = self.oracle_params.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketParamUpdateProposal {
        DerivativeMarketParamUpdateProposal::new()
    }

    fn default_instance() -> &'static DerivativeMarketParamUpdateProposal {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketParamUpdateProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketParamUpdateProposal::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketParamUpdateProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.market_id.clear();
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.HourlyInterestRate.clear();
        self.HourlyFundingRateCap.clear();
        self.status = super::exchange::MarketStatus::Unspecified;
        self.oracle_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketParamUpdateProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketForcedSettlementProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub market_id: ::std::string::String,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketForcedSettlementProposal {
    fn default() -> &'a MarketForcedSettlementProposal {
        <MarketForcedSettlementProposal as ::protobuf::Message>::default_instance()
    }
}

impl MarketForcedSettlementProposal {
    pub fn new() -> MarketForcedSettlementProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settlement_price = 4;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketForcedSettlementProposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(4, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketForcedSettlementProposal {
        MarketForcedSettlementProposal::new()
    }

    fn default_instance() -> &'static MarketForcedSettlementProposal {
        static instance: ::protobuf::rt::LazyV2<MarketForcedSettlementProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketForcedSettlementProposal::new)
    }
}

impl ::protobuf::Clear for MarketForcedSettlementProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.market_id.clear();
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketForcedSettlementProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateDenomDecimalsProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub denom_decimals: ::protobuf::RepeatedField<super::exchange::DenomDecimals>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDenomDecimalsProposal {
    fn default() -> &'a UpdateDenomDecimalsProposal {
        <UpdateDenomDecimalsProposal as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDenomDecimalsProposal {
    pub fn new() -> UpdateDenomDecimalsProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 3;


    pub fn get_denom_decimals(&self) -> &[super::exchange::DenomDecimals] {
        &self.denom_decimals
    }
    pub fn clear_denom_decimals(&mut self) {
        self.denom_decimals.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom_decimals(&mut self, v: ::protobuf::RepeatedField<super::exchange::DenomDecimals>) {
        self.denom_decimals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denom_decimals(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        &mut self.denom_decimals
    }

    // Take field
    pub fn take_denom_decimals(&mut self) -> ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        ::std::mem::replace(&mut self.denom_decimals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateDenomDecimalsProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.denom_decimals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.denom_decimals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.denom_decimals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.denom_decimals {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDenomDecimalsProposal {
        UpdateDenomDecimalsProposal::new()
    }

    fn default_instance() -> &'static UpdateDenomDecimalsProposal {
        static instance: ::protobuf::rt::LazyV2<UpdateDenomDecimalsProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDenomDecimalsProposal::new)
    }
}

impl ::protobuf::Clear for UpdateDenomDecimalsProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.denom_decimals.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDenomDecimalsProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarketParamUpdateProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub market_id: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub settlement_price: ::std::string::String,
    pub admin: ::std::string::String,
    pub status: super::exchange::MarketStatus,
    pub oracle_params: ::protobuf::SingularPtrField<ProviderOracleParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarketParamUpdateProposal {
    fn default() -> &'a BinaryOptionsMarketParamUpdateProposal {
        <BinaryOptionsMarketParamUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarketParamUpdateProposal {
    pub fn new() -> BinaryOptionsMarketParamUpdateProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string maker_fee_rate = 4;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 5;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 6;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // string min_price_tick_size = 7;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 8;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // int64 expiration_timestamp = 9;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 settlement_timestamp = 10;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // string settlement_price = 11;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }

    // string admin = 12;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MarketStatus status = 13;


    pub fn get_status(&self) -> super::exchange::MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = super::exchange::MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::exchange::MarketStatus) {
        self.status = v;
    }

    // .injective.exchange.v1beta1.ProviderOracleParams oracle_params = 14;


    pub fn get_oracle_params(&self) -> &ProviderOracleParams {
        self.oracle_params.as_ref().unwrap_or_else(|| <ProviderOracleParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_oracle_params(&mut self) {
        self.oracle_params.clear();
    }

    pub fn has_oracle_params(&self) -> bool {
        self.oracle_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oracle_params(&mut self, v: ProviderOracleParams) {
        self.oracle_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_params(&mut self) -> &mut ProviderOracleParams {
        if self.oracle_params.is_none() {
            self.oracle_params.set_default();
        }
        self.oracle_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_oracle_params(&mut self) -> ProviderOracleParams {
        self.oracle_params.take().unwrap_or_else(|| ProviderOracleParams::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarketParamUpdateProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.oracle_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settlement_timestamp = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oracle_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.relayer_fee_share_rate);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.min_quantity_tick_size);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.settlement_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.settlement_price);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.admin);
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(13, self.status);
        }
        if let Some(ref v) = self.oracle_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(4, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(5, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(6, &self.relayer_fee_share_rate)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(7, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(8, &self.min_quantity_tick_size)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(9, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_int64(10, self.settlement_timestamp)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(11, &self.settlement_price)?;
        }
        if !self.admin.is_empty() {
            os.write_string(12, &self.admin)?;
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if let Some(ref v) = self.oracle_params.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarketParamUpdateProposal {
        BinaryOptionsMarketParamUpdateProposal::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarketParamUpdateProposal {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarketParamUpdateProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarketParamUpdateProposal::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarketParamUpdateProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.market_id.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.settlement_price.clear();
        self.admin.clear();
        self.status = super::exchange::MarketStatus::Unspecified;
        self.oracle_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarketParamUpdateProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProviderOracleParams {
    // message fields
    pub symbol: ::std::string::String,
    pub provider: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub oracle_type: super::oracle::OracleType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProviderOracleParams {
    fn default() -> &'a ProviderOracleParams {
        <ProviderOracleParams as ::protobuf::Message>::default_instance()
    }
}

impl ProviderOracleParams {
    pub fn new() -> ProviderOracleParams {
        ::std::default::Default::default()
    }

    // string symbol = 1;


    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::std::string::String) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol, ::std::string::String::new())
    }

    // string provider = 2;


    pub fn get_provider(&self) -> &str {
        &self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::string::String) {
        self.provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::string::String {
        &mut self.provider
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.provider, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 3;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 4;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }
}

impl ::protobuf::Message for ProviderOracleParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.provider)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symbol);
        }
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.provider);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(3, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(4, self.oracle_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.symbol.is_empty() {
            os.write_string(1, &self.symbol)?;
        }
        if !self.provider.is_empty() {
            os.write_string(2, &self.provider)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(3, self.oracle_scale_factor)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProviderOracleParams {
        ProviderOracleParams::new()
    }

    fn default_instance() -> &'static ProviderOracleParams {
        static instance: ::protobuf::rt::LazyV2<ProviderOracleParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProviderOracleParams::new)
    }
}

impl ::protobuf::Clear for ProviderOracleParams {
    fn clear(&mut self) {
        self.symbol.clear();
        self.provider.clear();
        self.oracle_scale_factor = 0;
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ProviderOracleParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OracleParams {
    // message fields
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_scale_factor: u32,
    pub oracle_type: super::oracle::OracleType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OracleParams {
    fn default() -> &'a OracleParams {
        <OracleParams as ::protobuf::Message>::default_instance()
    }
}

impl OracleParams {
    pub fn new() -> OracleParams {
        ::std::default::Default::default()
    }

    // string oracle_base = 1;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 2;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // uint32 oracle_scale_factor = 3;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 4;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }
}

impl ::protobuf::Message for OracleParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.oracle_quote);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(3, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(4, self.oracle_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.oracle_base.is_empty() {
            os.write_string(1, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(2, &self.oracle_quote)?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(3, self.oracle_scale_factor)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OracleParams {
        OracleParams::new()
    }

    fn default_instance() -> &'static OracleParams {
        static instance: ::protobuf::rt::LazyV2<OracleParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OracleParams::new)
    }
}

impl ::protobuf::Clear for OracleParams {
    fn clear(&mut self) {
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_scale_factor = 0;
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OracleParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignLaunchProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub campaign_info: ::protobuf::SingularPtrField<super::exchange::TradingRewardCampaignInfo>,
    pub campaign_reward_pools: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignLaunchProposal {
    fn default() -> &'a TradingRewardCampaignLaunchProposal {
        <TradingRewardCampaignLaunchProposal as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignLaunchProposal {
    pub fn new() -> TradingRewardCampaignLaunchProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3;


    pub fn get_campaign_info(&self) -> &super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.as_ref().unwrap_or_else(|| <super::exchange::TradingRewardCampaignInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_campaign_info(&mut self) {
        self.campaign_info.clear();
    }

    pub fn has_campaign_info(&self) -> bool {
        self.campaign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_info(&mut self, v: super::exchange::TradingRewardCampaignInfo) {
        self.campaign_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_campaign_info(&mut self) -> &mut super::exchange::TradingRewardCampaignInfo {
        if self.campaign_info.is_none() {
            self.campaign_info.set_default();
        }
        self.campaign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_campaign_info(&mut self) -> super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.take().unwrap_or_else(|| super::exchange::TradingRewardCampaignInfo::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools = 4;


    pub fn get_campaign_reward_pools(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.campaign_reward_pools
    }
    pub fn clear_campaign_reward_pools(&mut self) {
        self.campaign_reward_pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_campaign_reward_pools(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.campaign_reward_pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_campaign_reward_pools(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.campaign_reward_pools
    }

    // Take field
    pub fn take_campaign_reward_pools(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.campaign_reward_pools, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignLaunchProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.campaign_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.campaign_reward_pools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.campaign_info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.campaign_reward_pools)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.campaign_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.campaign_reward_pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.campaign_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.campaign_reward_pools {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignLaunchProposal {
        TradingRewardCampaignLaunchProposal::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignLaunchProposal {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignLaunchProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignLaunchProposal::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignLaunchProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.campaign_info.clear();
        self.campaign_reward_pools.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignLaunchProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignUpdateProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub campaign_info: ::protobuf::SingularPtrField<super::exchange::TradingRewardCampaignInfo>,
    pub campaign_reward_pools_additions: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    pub campaign_reward_pools_updates: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignUpdateProposal {
    fn default() -> &'a TradingRewardCampaignUpdateProposal {
        <TradingRewardCampaignUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignUpdateProposal {
    pub fn new() -> TradingRewardCampaignUpdateProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo campaign_info = 3;


    pub fn get_campaign_info(&self) -> &super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.as_ref().unwrap_or_else(|| <super::exchange::TradingRewardCampaignInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_campaign_info(&mut self) {
        self.campaign_info.clear();
    }

    pub fn has_campaign_info(&self) -> bool {
        self.campaign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_info(&mut self, v: super::exchange::TradingRewardCampaignInfo) {
        self.campaign_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_campaign_info(&mut self) -> &mut super::exchange::TradingRewardCampaignInfo {
        if self.campaign_info.is_none() {
            self.campaign_info.set_default();
        }
        self.campaign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_campaign_info(&mut self) -> super::exchange::TradingRewardCampaignInfo {
        self.campaign_info.take().unwrap_or_else(|| super::exchange::TradingRewardCampaignInfo::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_additions = 4;


    pub fn get_campaign_reward_pools_additions(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.campaign_reward_pools_additions
    }
    pub fn clear_campaign_reward_pools_additions(&mut self) {
        self.campaign_reward_pools_additions.clear();
    }

    // Param is passed by value, moved
    pub fn set_campaign_reward_pools_additions(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.campaign_reward_pools_additions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_campaign_reward_pools_additions(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.campaign_reward_pools_additions
    }

    // Take field
    pub fn take_campaign_reward_pools_additions(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.campaign_reward_pools_additions, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool campaign_reward_pools_updates = 5;


    pub fn get_campaign_reward_pools_updates(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.campaign_reward_pools_updates
    }
    pub fn clear_campaign_reward_pools_updates(&mut self) {
        self.campaign_reward_pools_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_campaign_reward_pools_updates(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.campaign_reward_pools_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_campaign_reward_pools_updates(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.campaign_reward_pools_updates
    }

    // Take field
    pub fn take_campaign_reward_pools_updates(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.campaign_reward_pools_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignUpdateProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.campaign_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.campaign_reward_pools_additions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.campaign_reward_pools_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.campaign_info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.campaign_reward_pools_additions)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.campaign_reward_pools_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.campaign_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.campaign_reward_pools_additions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.campaign_reward_pools_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.campaign_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.campaign_reward_pools_additions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.campaign_reward_pools_updates {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignUpdateProposal {
        TradingRewardCampaignUpdateProposal::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignUpdateProposal {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignUpdateProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignUpdateProposal::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignUpdateProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.campaign_info.clear();
        self.campaign_reward_pools_additions.clear();
        self.campaign_reward_pools_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignUpdateProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RewardPointUpdate {
    // message fields
    pub account_address: ::std::string::String,
    pub new_points: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewardPointUpdate {
    fn default() -> &'a RewardPointUpdate {
        <RewardPointUpdate as ::protobuf::Message>::default_instance()
    }
}

impl RewardPointUpdate {
    pub fn new() -> RewardPointUpdate {
        ::std::default::Default::default()
    }

    // string account_address = 1;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }

    // string new_points = 12;


    pub fn get_new_points(&self) -> &str {
        &self.new_points
    }
    pub fn clear_new_points(&mut self) {
        self.new_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_points(&mut self, v: ::std::string::String) {
        self.new_points = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_points(&mut self) -> &mut ::std::string::String {
        &mut self.new_points
    }

    // Take field
    pub fn take_new_points(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new_points, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RewardPointUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new_points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_address);
        }
        if !self.new_points.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.new_points);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_address.is_empty() {
            os.write_string(1, &self.account_address)?;
        }
        if !self.new_points.is_empty() {
            os.write_string(12, &self.new_points)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewardPointUpdate {
        RewardPointUpdate::new()
    }

    fn default_instance() -> &'static RewardPointUpdate {
        static instance: ::protobuf::rt::LazyV2<RewardPointUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewardPointUpdate::new)
    }
}

impl ::protobuf::Clear for RewardPointUpdate {
    fn clear(&mut self) {
        self.account_address.clear();
        self.new_points.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RewardPointUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardPendingPointsUpdateProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub pending_pool_timestamp: i64,
    pub reward_point_updates: ::protobuf::RepeatedField<RewardPointUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardPendingPointsUpdateProposal {
    fn default() -> &'a TradingRewardPendingPointsUpdateProposal {
        <TradingRewardPendingPointsUpdateProposal as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardPendingPointsUpdateProposal {
    pub fn new() -> TradingRewardPendingPointsUpdateProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int64 pending_pool_timestamp = 3;


    pub fn get_pending_pool_timestamp(&self) -> i64 {
        self.pending_pool_timestamp
    }
    pub fn clear_pending_pool_timestamp(&mut self) {
        self.pending_pool_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_pool_timestamp(&mut self, v: i64) {
        self.pending_pool_timestamp = v;
    }

    // repeated .injective.exchange.v1beta1.RewardPointUpdate reward_point_updates = 4;


    pub fn get_reward_point_updates(&self) -> &[RewardPointUpdate] {
        &self.reward_point_updates
    }
    pub fn clear_reward_point_updates(&mut self) {
        self.reward_point_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_reward_point_updates(&mut self, v: ::protobuf::RepeatedField<RewardPointUpdate>) {
        self.reward_point_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reward_point_updates(&mut self) -> &mut ::protobuf::RepeatedField<RewardPointUpdate> {
        &mut self.reward_point_updates
    }

    // Take field
    pub fn take_reward_point_updates(&mut self) -> ::protobuf::RepeatedField<RewardPointUpdate> {
        ::std::mem::replace(&mut self.reward_point_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardPendingPointsUpdateProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.reward_point_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_pool_timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reward_point_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.pending_pool_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.pending_pool_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.reward_point_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.pending_pool_timestamp != 0 {
            os.write_int64(3, self.pending_pool_timestamp)?;
        }
        for v in &self.reward_point_updates {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardPendingPointsUpdateProposal {
        TradingRewardPendingPointsUpdateProposal::new()
    }

    fn default_instance() -> &'static TradingRewardPendingPointsUpdateProposal {
        static instance: ::protobuf::rt::LazyV2<TradingRewardPendingPointsUpdateProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardPendingPointsUpdateProposal::new)
    }
}

impl ::protobuf::Clear for TradingRewardPendingPointsUpdateProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.pending_pool_timestamp = 0;
        self.reward_point_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardPendingPointsUpdateProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub schedule: ::protobuf::SingularPtrField<super::exchange::FeeDiscountSchedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountProposal {
    fn default() -> &'a FeeDiscountProposal {
        <FeeDiscountProposal as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountProposal {
    pub fn new() -> FeeDiscountProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.FeeDiscountSchedule schedule = 3;


    pub fn get_schedule(&self) -> &super::exchange::FeeDiscountSchedule {
        self.schedule.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schedule(&mut self) {
        self.schedule.clear();
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: super::exchange::FeeDiscountSchedule) {
        self.schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut super::exchange::FeeDiscountSchedule {
        if self.schedule.is_none() {
            self.schedule.set_default();
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> super::exchange::FeeDiscountSchedule {
        self.schedule.take().unwrap_or_else(|| super::exchange::FeeDiscountSchedule::new())
    }
}

impl ::protobuf::Message for FeeDiscountProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.schedule.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountProposal {
        FeeDiscountProposal::new()
    }

    fn default_instance() -> &'static FeeDiscountProposal {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountProposal::new)
    }
}

impl ::protobuf::Clear for FeeDiscountProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.schedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BatchCommunityPoolSpendProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub proposals: ::protobuf::RepeatedField<super::distribution::CommunityPoolSpendProposal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchCommunityPoolSpendProposal {
    fn default() -> &'a BatchCommunityPoolSpendProposal {
        <BatchCommunityPoolSpendProposal as ::protobuf::Message>::default_instance()
    }
}

impl BatchCommunityPoolSpendProposal {
    pub fn new() -> BatchCommunityPoolSpendProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .cosmos.distribution.v1beta1.CommunityPoolSpendProposal proposals = 3;


    pub fn get_proposals(&self) -> &[super::distribution::CommunityPoolSpendProposal] {
        &self.proposals
    }
    pub fn clear_proposals(&mut self) {
        self.proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposals(&mut self, v: ::protobuf::RepeatedField<super::distribution::CommunityPoolSpendProposal>) {
        self.proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proposals(&mut self) -> &mut ::protobuf::RepeatedField<super::distribution::CommunityPoolSpendProposal> {
        &mut self.proposals
    }

    // Take field
    pub fn take_proposals(&mut self) -> ::protobuf::RepeatedField<super::distribution::CommunityPoolSpendProposal> {
        ::std::mem::replace(&mut self.proposals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchCommunityPoolSpendProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proposals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.proposals {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchCommunityPoolSpendProposal {
        BatchCommunityPoolSpendProposal::new()
    }

    fn default_instance() -> &'static BatchCommunityPoolSpendProposal {
        static instance: ::protobuf::rt::LazyV2<BatchCommunityPoolSpendProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchCommunityPoolSpendProposal::new)
    }
}

impl ::protobuf::Clear for BatchCommunityPoolSpendProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.proposals.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchCommunityPoolSpendProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgRewardsOptOut {
    // message fields
    pub sender: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgRewardsOptOut {
    fn default() -> &'a MsgRewardsOptOut {
        <MsgRewardsOptOut as ::protobuf::Message>::default_instance()
    }
}

impl MsgRewardsOptOut {
    pub fn new() -> MsgRewardsOptOut {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgRewardsOptOut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgRewardsOptOut {
        MsgRewardsOptOut::new()
    }

    fn default_instance() -> &'static MsgRewardsOptOut {
        static instance: ::protobuf::rt::LazyV2<MsgRewardsOptOut> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgRewardsOptOut::new)
    }
}

impl ::protobuf::Clear for MsgRewardsOptOut {
    fn clear(&mut self) {
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRewardsOptOut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgRewardsOptOutResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgRewardsOptOutResponse {
    fn default() -> &'a MsgRewardsOptOutResponse {
        <MsgRewardsOptOutResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgRewardsOptOutResponse {
    pub fn new() -> MsgRewardsOptOutResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgRewardsOptOutResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgRewardsOptOutResponse {
        MsgRewardsOptOutResponse::new()
    }

    fn default_instance() -> &'static MsgRewardsOptOutResponse {
        static instance: ::protobuf::rt::LazyV2<MsgRewardsOptOutResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgRewardsOptOutResponse::new)
    }
}

impl ::protobuf::Clear for MsgRewardsOptOutResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRewardsOptOutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgReclaimLockedFunds {
    // message fields
    pub sender: ::std::string::String,
    pub lockedAccountPubKey: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgReclaimLockedFunds {
    fn default() -> &'a MsgReclaimLockedFunds {
        <MsgReclaimLockedFunds as ::protobuf::Message>::default_instance()
    }
}

impl MsgReclaimLockedFunds {
    pub fn new() -> MsgReclaimLockedFunds {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // bytes lockedAccountPubKey = 2;


    pub fn get_lockedAccountPubKey(&self) -> &[u8] {
        &self.lockedAccountPubKey
    }
    pub fn clear_lockedAccountPubKey(&mut self) {
        self.lockedAccountPubKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockedAccountPubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.lockedAccountPubKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockedAccountPubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.lockedAccountPubKey
    }

    // Take field
    pub fn take_lockedAccountPubKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.lockedAccountPubKey, ::std::vec::Vec::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgReclaimLockedFunds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.lockedAccountPubKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.lockedAccountPubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.lockedAccountPubKey);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.lockedAccountPubKey.is_empty() {
            os.write_bytes(2, &self.lockedAccountPubKey)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgReclaimLockedFunds {
        MsgReclaimLockedFunds::new()
    }

    fn default_instance() -> &'static MsgReclaimLockedFunds {
        static instance: ::protobuf::rt::LazyV2<MsgReclaimLockedFunds> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgReclaimLockedFunds::new)
    }
}

impl ::protobuf::Clear for MsgReclaimLockedFunds {
    fn clear(&mut self) {
        self.sender.clear();
        self.lockedAccountPubKey.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgReclaimLockedFunds {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgReclaimLockedFundsResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgReclaimLockedFundsResponse {
    fn default() -> &'a MsgReclaimLockedFundsResponse {
        <MsgReclaimLockedFundsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgReclaimLockedFundsResponse {
    pub fn new() -> MsgReclaimLockedFundsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgReclaimLockedFundsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgReclaimLockedFundsResponse {
        MsgReclaimLockedFundsResponse::new()
    }

    fn default_instance() -> &'static MsgReclaimLockedFundsResponse {
        static instance: ::protobuf::rt::LazyV2<MsgReclaimLockedFundsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgReclaimLockedFundsResponse::new)
    }
}

impl ::protobuf::Clear for MsgReclaimLockedFundsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgReclaimLockedFundsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgSignData {
    // message fields
    pub Signer: ::std::vec::Vec<u8>,
    pub Data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgSignData {
    fn default() -> &'a MsgSignData {
        <MsgSignData as ::protobuf::Message>::default_instance()
    }
}

impl MsgSignData {
    pub fn new() -> MsgSignData {
        ::std::default::Default::default()
    }

    // bytes Signer = 1;


    pub fn get_Signer(&self) -> &[u8] {
        &self.Signer
    }
    pub fn clear_Signer(&mut self) {
        self.Signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_Signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.Signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Signer
    }

    // Take field
    pub fn take_Signer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Signer, ::std::vec::Vec::new())
    }

    // bytes Data = 2;


    pub fn get_Data(&self) -> &[u8] {
        &self.Data
    }
    pub fn clear_Data(&mut self) {
        self.Data.clear();
    }

    // Param is passed by value, moved
    pub fn set_Data(&mut self, v: ::std::vec::Vec<u8>) {
        self.Data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Data
    }

    // Take field
    pub fn take_Data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MsgSignData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.Signer);
        }
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.Data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Signer.is_empty() {
            os.write_bytes(1, &self.Signer)?;
        }
        if !self.Data.is_empty() {
            os.write_bytes(2, &self.Data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgSignData {
        MsgSignData::new()
    }

    fn default_instance() -> &'static MsgSignData {
        static instance: ::protobuf::rt::LazyV2<MsgSignData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgSignData::new)
    }
}

impl ::protobuf::Clear for MsgSignData {
    fn clear(&mut self) {
        self.Signer.clear();
        self.Data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgSignData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgSignDoc {
    // message fields
    pub sign_type: ::std::string::String,
    pub value: ::protobuf::SingularPtrField<MsgSignData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgSignDoc {
    fn default() -> &'a MsgSignDoc {
        <MsgSignDoc as ::protobuf::Message>::default_instance()
    }
}

impl MsgSignDoc {
    pub fn new() -> MsgSignDoc {
        ::std::default::Default::default()
    }

    // string sign_type = 1;


    pub fn get_sign_type(&self) -> &str {
        &self.sign_type
    }
    pub fn clear_sign_type(&mut self) {
        self.sign_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign_type(&mut self, v: ::std::string::String) {
        self.sign_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign_type(&mut self) -> &mut ::std::string::String {
        &mut self.sign_type
    }

    // Take field
    pub fn take_sign_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sign_type, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MsgSignData value = 2;


    pub fn get_value(&self) -> &MsgSignData {
        self.value.as_ref().unwrap_or_else(|| <MsgSignData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MsgSignData) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut MsgSignData {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> MsgSignData {
        self.value.take().unwrap_or_else(|| MsgSignData::new())
    }
}

impl ::protobuf::Message for MsgSignDoc {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sign_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sign_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sign_type);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sign_type.is_empty() {
            os.write_string(1, &self.sign_type)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgSignDoc {
        MsgSignDoc::new()
    }

    fn default_instance() -> &'static MsgSignDoc {
        static instance: ::protobuf::rt::LazyV2<MsgSignDoc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgSignDoc::new)
    }
}

impl ::protobuf::Clear for MsgSignDoc {
    fn clear(&mut self) {
        self.sign_type.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgSignDoc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgAdminUpdateBinaryOptionsMarket {
    // message fields
    pub sender: ::std::string::String,
    pub market_id: ::std::string::String,
    pub settlement_price: ::std::string::String,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub status: super::exchange::MarketStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgAdminUpdateBinaryOptionsMarket {
    fn default() -> &'a MsgAdminUpdateBinaryOptionsMarket {
        <MsgAdminUpdateBinaryOptionsMarket as ::protobuf::Message>::default_instance()
    }
}

impl MsgAdminUpdateBinaryOptionsMarket {
    pub fn new() -> MsgAdminUpdateBinaryOptionsMarket {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settlement_price = 3;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }

    // int64 expiration_timestamp = 4;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 settlement_timestamp = 5;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // .injective.exchange.v1beta1.MarketStatus status = 6;


    pub fn get_status(&self) -> super::exchange::MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = super::exchange::MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::exchange::MarketStatus) {
        self.status = v;
    }
}

impl ::protobuf::Message for MsgAdminUpdateBinaryOptionsMarket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settlement_timestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.settlement_price);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.settlement_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(6, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(3, &self.settlement_price)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(4, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_int64(5, self.settlement_timestamp)?;
        }
        if self.status != super::exchange::MarketStatus::Unspecified {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgAdminUpdateBinaryOptionsMarket {
        MsgAdminUpdateBinaryOptionsMarket::new()
    }

    fn default_instance() -> &'static MsgAdminUpdateBinaryOptionsMarket {
        static instance: ::protobuf::rt::LazyV2<MsgAdminUpdateBinaryOptionsMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgAdminUpdateBinaryOptionsMarket::new)
    }
}

impl ::protobuf::Clear for MsgAdminUpdateBinaryOptionsMarket {
    fn clear(&mut self) {
        self.sender.clear();
        self.market_id.clear();
        self.settlement_price.clear();
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.status = super::exchange::MarketStatus::Unspecified;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAdminUpdateBinaryOptionsMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MsgAdminUpdateBinaryOptionsMarketResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgAdminUpdateBinaryOptionsMarketResponse {
    fn default() -> &'a MsgAdminUpdateBinaryOptionsMarketResponse {
        <MsgAdminUpdateBinaryOptionsMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgAdminUpdateBinaryOptionsMarketResponse {
    pub fn new() -> MsgAdminUpdateBinaryOptionsMarketResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgAdminUpdateBinaryOptionsMarketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgAdminUpdateBinaryOptionsMarketResponse {
        MsgAdminUpdateBinaryOptionsMarketResponse::new()
    }

    fn default_instance() -> &'static MsgAdminUpdateBinaryOptionsMarketResponse {
        static instance: ::protobuf::rt::LazyV2<MsgAdminUpdateBinaryOptionsMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgAdminUpdateBinaryOptionsMarketResponse::new)
    }
}

impl ::protobuf::Clear for MsgAdminUpdateBinaryOptionsMarketResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAdminUpdateBinaryOptionsMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AtomicMarketOrderFeeMultiplierScheduleProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub market_fee_multipliers: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AtomicMarketOrderFeeMultiplierScheduleProposal {
    fn default() -> &'a AtomicMarketOrderFeeMultiplierScheduleProposal {
        <AtomicMarketOrderFeeMultiplierScheduleProposal as ::protobuf::Message>::default_instance()
    }
}

impl AtomicMarketOrderFeeMultiplierScheduleProposal {
    pub fn new() -> AtomicMarketOrderFeeMultiplierScheduleProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.MarketFeeMultiplier market_fee_multipliers = 3;


    pub fn get_market_fee_multipliers(&self) -> &[super::exchange::MarketFeeMultiplier] {
        &self.market_fee_multipliers
    }
    pub fn clear_market_fee_multipliers(&mut self) {
        self.market_fee_multipliers.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_fee_multipliers(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier>) {
        self.market_fee_multipliers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_fee_multipliers(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        &mut self.market_fee_multipliers
    }

    // Take field
    pub fn take_market_fee_multipliers(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketFeeMultiplier> {
        ::std::mem::replace(&mut self.market_fee_multipliers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AtomicMarketOrderFeeMultiplierScheduleProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.market_fee_multipliers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_fee_multipliers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.market_fee_multipliers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.market_fee_multipliers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AtomicMarketOrderFeeMultiplierScheduleProposal {
        AtomicMarketOrderFeeMultiplierScheduleProposal::new()
    }

    fn default_instance() -> &'static AtomicMarketOrderFeeMultiplierScheduleProposal {
        static instance: ::protobuf::rt::LazyV2<AtomicMarketOrderFeeMultiplierScheduleProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AtomicMarketOrderFeeMultiplierScheduleProposal::new)
    }
}

impl ::protobuf::Clear for AtomicMarketOrderFeeMultiplierScheduleProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.market_fee_multipliers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AtomicMarketOrderFeeMultiplierScheduleProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExchangeType {
    EXCHANGE_UNSPECIFIED = 0,
    SPOT = 1,
    DERIVATIVES = 2,
}

impl ::protobuf::ProtobufEnum for ExchangeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExchangeType> {
        match value {
            0 => ::std::option::Option::Some(ExchangeType::EXCHANGE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ExchangeType::SPOT),
            2 => ::std::option::Option::Some(ExchangeType::DERIVATIVES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExchangeType] = &[
            ExchangeType::EXCHANGE_UNSPECIFIED,
            ExchangeType::SPOT,
            ExchangeType::DERIVATIVES,
        ];
        values
    }
}

impl ::std::marker::Copy for ExchangeType {
}

impl ::std::default::Default for ExchangeType {
    fn default() -> Self {
        ExchangeType::EXCHANGE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
