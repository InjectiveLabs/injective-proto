// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/exchange/v1beta1/exchange.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Params {
    // message fields
    pub spot_market_instant_listing_fee: ::protobuf::SingularPtrField<super::coin::Coin>,
    pub derivative_market_instant_listing_fee: ::protobuf::SingularPtrField<super::coin::Coin>,
    pub default_spot_maker_fee_rate: ::std::string::String,
    pub default_spot_taker_fee_rate: ::std::string::String,
    pub default_derivative_maker_fee_rate: ::std::string::String,
    pub default_derivative_taker_fee_rate: ::std::string::String,
    pub default_initial_margin_ratio: ::std::string::String,
    pub default_maintenance_margin_ratio: ::std::string::String,
    pub default_funding_interval: i64,
    pub funding_multiple: i64,
    pub relayer_fee_share_rate: ::std::string::String,
    pub default_hourly_funding_rate_cap: ::std::string::String,
    pub default_hourly_interest_rate: ::std::string::String,
    pub max_derivative_order_side_count: u32,
    pub inj_reward_staked_requirement_threshold: ::std::string::String,
    pub trading_rewards_vesting_duration: i64,
    pub liquidator_reward_share_rate: ::std::string::String,
    pub binary_options_market_instant_listing_fee: ::protobuf::SingularPtrField<super::coin::Coin>,
    pub atomic_market_order_access_level: AtomicMarketOrderAccessLevel,
    pub spot_atomic_market_order_fee_multiplier: ::std::string::String,
    pub derivative_atomic_market_order_fee_multiplier: ::std::string::String,
    pub binary_options_atomic_market_order_fee_multiplier: ::std::string::String,
    pub minimal_protocol_fee_rate: ::std::string::String,
    pub is_instant_derivative_market_launch_enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    // .cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1;


    pub fn get_spot_market_instant_listing_fee(&self) -> &super::coin::Coin {
        self.spot_market_instant_listing_fee.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spot_market_instant_listing_fee(&mut self) {
        self.spot_market_instant_listing_fee.clear();
    }

    pub fn has_spot_market_instant_listing_fee(&self) -> bool {
        self.spot_market_instant_listing_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spot_market_instant_listing_fee(&mut self, v: super::coin::Coin) {
        self.spot_market_instant_listing_fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spot_market_instant_listing_fee(&mut self) -> &mut super::coin::Coin {
        if self.spot_market_instant_listing_fee.is_none() {
            self.spot_market_instant_listing_fee.set_default();
        }
        self.spot_market_instant_listing_fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_spot_market_instant_listing_fee(&mut self) -> super::coin::Coin {
        self.spot_market_instant_listing_fee.take().unwrap_or_else(|| super::coin::Coin::new())
    }

    // .cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2;


    pub fn get_derivative_market_instant_listing_fee(&self) -> &super::coin::Coin {
        self.derivative_market_instant_listing_fee.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_derivative_market_instant_listing_fee(&mut self) {
        self.derivative_market_instant_listing_fee.clear();
    }

    pub fn has_derivative_market_instant_listing_fee(&self) -> bool {
        self.derivative_market_instant_listing_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_derivative_market_instant_listing_fee(&mut self, v: super::coin::Coin) {
        self.derivative_market_instant_listing_fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_derivative_market_instant_listing_fee(&mut self) -> &mut super::coin::Coin {
        if self.derivative_market_instant_listing_fee.is_none() {
            self.derivative_market_instant_listing_fee.set_default();
        }
        self.derivative_market_instant_listing_fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_derivative_market_instant_listing_fee(&mut self) -> super::coin::Coin {
        self.derivative_market_instant_listing_fee.take().unwrap_or_else(|| super::coin::Coin::new())
    }

    // string default_spot_maker_fee_rate = 3;


    pub fn get_default_spot_maker_fee_rate(&self) -> &str {
        &self.default_spot_maker_fee_rate
    }
    pub fn clear_default_spot_maker_fee_rate(&mut self) {
        self.default_spot_maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_spot_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.default_spot_maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_spot_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.default_spot_maker_fee_rate
    }

    // Take field
    pub fn take_default_spot_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_spot_maker_fee_rate, ::std::string::String::new())
    }

    // string default_spot_taker_fee_rate = 4;


    pub fn get_default_spot_taker_fee_rate(&self) -> &str {
        &self.default_spot_taker_fee_rate
    }
    pub fn clear_default_spot_taker_fee_rate(&mut self) {
        self.default_spot_taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_spot_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.default_spot_taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_spot_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.default_spot_taker_fee_rate
    }

    // Take field
    pub fn take_default_spot_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_spot_taker_fee_rate, ::std::string::String::new())
    }

    // string default_derivative_maker_fee_rate = 5;


    pub fn get_default_derivative_maker_fee_rate(&self) -> &str {
        &self.default_derivative_maker_fee_rate
    }
    pub fn clear_default_derivative_maker_fee_rate(&mut self) {
        self.default_derivative_maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_derivative_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.default_derivative_maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_derivative_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.default_derivative_maker_fee_rate
    }

    // Take field
    pub fn take_default_derivative_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_derivative_maker_fee_rate, ::std::string::String::new())
    }

    // string default_derivative_taker_fee_rate = 6;


    pub fn get_default_derivative_taker_fee_rate(&self) -> &str {
        &self.default_derivative_taker_fee_rate
    }
    pub fn clear_default_derivative_taker_fee_rate(&mut self) {
        self.default_derivative_taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_derivative_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.default_derivative_taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_derivative_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.default_derivative_taker_fee_rate
    }

    // Take field
    pub fn take_default_derivative_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_derivative_taker_fee_rate, ::std::string::String::new())
    }

    // string default_initial_margin_ratio = 7;


    pub fn get_default_initial_margin_ratio(&self) -> &str {
        &self.default_initial_margin_ratio
    }
    pub fn clear_default_initial_margin_ratio(&mut self) {
        self.default_initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.default_initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.default_initial_margin_ratio
    }

    // Take field
    pub fn take_default_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_initial_margin_ratio, ::std::string::String::new())
    }

    // string default_maintenance_margin_ratio = 8;


    pub fn get_default_maintenance_margin_ratio(&self) -> &str {
        &self.default_maintenance_margin_ratio
    }
    pub fn clear_default_maintenance_margin_ratio(&mut self) {
        self.default_maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.default_maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.default_maintenance_margin_ratio
    }

    // Take field
    pub fn take_default_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_maintenance_margin_ratio, ::std::string::String::new())
    }

    // int64 default_funding_interval = 9;


    pub fn get_default_funding_interval(&self) -> i64 {
        self.default_funding_interval
    }
    pub fn clear_default_funding_interval(&mut self) {
        self.default_funding_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_funding_interval(&mut self, v: i64) {
        self.default_funding_interval = v;
    }

    // int64 funding_multiple = 10;


    pub fn get_funding_multiple(&self) -> i64 {
        self.funding_multiple
    }
    pub fn clear_funding_multiple(&mut self) {
        self.funding_multiple = 0;
    }

    // Param is passed by value, moved
    pub fn set_funding_multiple(&mut self, v: i64) {
        self.funding_multiple = v;
    }

    // string relayer_fee_share_rate = 11;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // string default_hourly_funding_rate_cap = 12;


    pub fn get_default_hourly_funding_rate_cap(&self) -> &str {
        &self.default_hourly_funding_rate_cap
    }
    pub fn clear_default_hourly_funding_rate_cap(&mut self) {
        self.default_hourly_funding_rate_cap.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_hourly_funding_rate_cap(&mut self, v: ::std::string::String) {
        self.default_hourly_funding_rate_cap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_hourly_funding_rate_cap(&mut self) -> &mut ::std::string::String {
        &mut self.default_hourly_funding_rate_cap
    }

    // Take field
    pub fn take_default_hourly_funding_rate_cap(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_hourly_funding_rate_cap, ::std::string::String::new())
    }

    // string default_hourly_interest_rate = 13;


    pub fn get_default_hourly_interest_rate(&self) -> &str {
        &self.default_hourly_interest_rate
    }
    pub fn clear_default_hourly_interest_rate(&mut self) {
        self.default_hourly_interest_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_hourly_interest_rate(&mut self, v: ::std::string::String) {
        self.default_hourly_interest_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_hourly_interest_rate(&mut self) -> &mut ::std::string::String {
        &mut self.default_hourly_interest_rate
    }

    // Take field
    pub fn take_default_hourly_interest_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_hourly_interest_rate, ::std::string::String::new())
    }

    // uint32 max_derivative_order_side_count = 14;


    pub fn get_max_derivative_order_side_count(&self) -> u32 {
        self.max_derivative_order_side_count
    }
    pub fn clear_max_derivative_order_side_count(&mut self) {
        self.max_derivative_order_side_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_derivative_order_side_count(&mut self, v: u32) {
        self.max_derivative_order_side_count = v;
    }

    // string inj_reward_staked_requirement_threshold = 15;


    pub fn get_inj_reward_staked_requirement_threshold(&self) -> &str {
        &self.inj_reward_staked_requirement_threshold
    }
    pub fn clear_inj_reward_staked_requirement_threshold(&mut self) {
        self.inj_reward_staked_requirement_threshold.clear();
    }

    // Param is passed by value, moved
    pub fn set_inj_reward_staked_requirement_threshold(&mut self, v: ::std::string::String) {
        self.inj_reward_staked_requirement_threshold = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inj_reward_staked_requirement_threshold(&mut self) -> &mut ::std::string::String {
        &mut self.inj_reward_staked_requirement_threshold
    }

    // Take field
    pub fn take_inj_reward_staked_requirement_threshold(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inj_reward_staked_requirement_threshold, ::std::string::String::new())
    }

    // int64 trading_rewards_vesting_duration = 16;


    pub fn get_trading_rewards_vesting_duration(&self) -> i64 {
        self.trading_rewards_vesting_duration
    }
    pub fn clear_trading_rewards_vesting_duration(&mut self) {
        self.trading_rewards_vesting_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_trading_rewards_vesting_duration(&mut self, v: i64) {
        self.trading_rewards_vesting_duration = v;
    }

    // string liquidator_reward_share_rate = 17;


    pub fn get_liquidator_reward_share_rate(&self) -> &str {
        &self.liquidator_reward_share_rate
    }
    pub fn clear_liquidator_reward_share_rate(&mut self) {
        self.liquidator_reward_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_liquidator_reward_share_rate(&mut self, v: ::std::string::String) {
        self.liquidator_reward_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_liquidator_reward_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.liquidator_reward_share_rate
    }

    // Take field
    pub fn take_liquidator_reward_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.liquidator_reward_share_rate, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18;


    pub fn get_binary_options_market_instant_listing_fee(&self) -> &super::coin::Coin {
        self.binary_options_market_instant_listing_fee.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_binary_options_market_instant_listing_fee(&mut self) {
        self.binary_options_market_instant_listing_fee.clear();
    }

    pub fn has_binary_options_market_instant_listing_fee(&self) -> bool {
        self.binary_options_market_instant_listing_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_options_market_instant_listing_fee(&mut self, v: super::coin::Coin) {
        self.binary_options_market_instant_listing_fee = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_options_market_instant_listing_fee(&mut self) -> &mut super::coin::Coin {
        if self.binary_options_market_instant_listing_fee.is_none() {
            self.binary_options_market_instant_listing_fee.set_default();
        }
        self.binary_options_market_instant_listing_fee.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_options_market_instant_listing_fee(&mut self) -> super::coin::Coin {
        self.binary_options_market_instant_listing_fee.take().unwrap_or_else(|| super::coin::Coin::new())
    }

    // .injective.exchange.v1beta1.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19;


    pub fn get_atomic_market_order_access_level(&self) -> AtomicMarketOrderAccessLevel {
        self.atomic_market_order_access_level
    }
    pub fn clear_atomic_market_order_access_level(&mut self) {
        self.atomic_market_order_access_level = AtomicMarketOrderAccessLevel::Nobody;
    }

    // Param is passed by value, moved
    pub fn set_atomic_market_order_access_level(&mut self, v: AtomicMarketOrderAccessLevel) {
        self.atomic_market_order_access_level = v;
    }

    // string spot_atomic_market_order_fee_multiplier = 20;


    pub fn get_spot_atomic_market_order_fee_multiplier(&self) -> &str {
        &self.spot_atomic_market_order_fee_multiplier
    }
    pub fn clear_spot_atomic_market_order_fee_multiplier(&mut self) {
        self.spot_atomic_market_order_fee_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_atomic_market_order_fee_multiplier(&mut self, v: ::std::string::String) {
        self.spot_atomic_market_order_fee_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spot_atomic_market_order_fee_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.spot_atomic_market_order_fee_multiplier
    }

    // Take field
    pub fn take_spot_atomic_market_order_fee_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.spot_atomic_market_order_fee_multiplier, ::std::string::String::new())
    }

    // string derivative_atomic_market_order_fee_multiplier = 21;


    pub fn get_derivative_atomic_market_order_fee_multiplier(&self) -> &str {
        &self.derivative_atomic_market_order_fee_multiplier
    }
    pub fn clear_derivative_atomic_market_order_fee_multiplier(&mut self) {
        self.derivative_atomic_market_order_fee_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_atomic_market_order_fee_multiplier(&mut self, v: ::std::string::String) {
        self.derivative_atomic_market_order_fee_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_derivative_atomic_market_order_fee_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.derivative_atomic_market_order_fee_multiplier
    }

    // Take field
    pub fn take_derivative_atomic_market_order_fee_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.derivative_atomic_market_order_fee_multiplier, ::std::string::String::new())
    }

    // string binary_options_atomic_market_order_fee_multiplier = 22;


    pub fn get_binary_options_atomic_market_order_fee_multiplier(&self) -> &str {
        &self.binary_options_atomic_market_order_fee_multiplier
    }
    pub fn clear_binary_options_atomic_market_order_fee_multiplier(&mut self) {
        self.binary_options_atomic_market_order_fee_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_options_atomic_market_order_fee_multiplier(&mut self, v: ::std::string::String) {
        self.binary_options_atomic_market_order_fee_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_options_atomic_market_order_fee_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.binary_options_atomic_market_order_fee_multiplier
    }

    // Take field
    pub fn take_binary_options_atomic_market_order_fee_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.binary_options_atomic_market_order_fee_multiplier, ::std::string::String::new())
    }

    // string minimal_protocol_fee_rate = 23;


    pub fn get_minimal_protocol_fee_rate(&self) -> &str {
        &self.minimal_protocol_fee_rate
    }
    pub fn clear_minimal_protocol_fee_rate(&mut self) {
        self.minimal_protocol_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_minimal_protocol_fee_rate(&mut self, v: ::std::string::String) {
        self.minimal_protocol_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minimal_protocol_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.minimal_protocol_fee_rate
    }

    // Take field
    pub fn take_minimal_protocol_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.minimal_protocol_fee_rate, ::std::string::String::new())
    }

    // bool is_instant_derivative_market_launch_enabled = 24;


    pub fn get_is_instant_derivative_market_launch_enabled(&self) -> bool {
        self.is_instant_derivative_market_launch_enabled
    }
    pub fn clear_is_instant_derivative_market_launch_enabled(&mut self) {
        self.is_instant_derivative_market_launch_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_instant_derivative_market_launch_enabled(&mut self, v: bool) {
        self.is_instant_derivative_market_launch_enabled = v;
    }
}

impl ::protobuf::Message for Params {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_market_instant_listing_fee {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_market_instant_listing_fee {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_options_market_instant_listing_fee {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spot_market_instant_listing_fee)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.derivative_market_instant_listing_fee)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_spot_maker_fee_rate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_spot_taker_fee_rate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_derivative_maker_fee_rate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_derivative_taker_fee_rate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_initial_margin_ratio)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_maintenance_margin_ratio)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.default_funding_interval = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.funding_multiple = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_hourly_funding_rate_cap)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_hourly_interest_rate)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_derivative_order_side_count = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inj_reward_staked_requirement_threshold)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.trading_rewards_vesting_duration = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.liquidator_reward_share_rate)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.binary_options_market_instant_listing_fee)?;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.atomic_market_order_access_level, 19, &mut self.unknown_fields)?
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.spot_atomic_market_order_fee_multiplier)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.derivative_atomic_market_order_fee_multiplier)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.binary_options_atomic_market_order_fee_multiplier)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.minimal_protocol_fee_rate)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_instant_derivative_market_launch_enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.spot_market_instant_listing_fee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.derivative_market_instant_listing_fee.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_spot_maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_spot_maker_fee_rate);
        }
        if !self.default_spot_taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.default_spot_taker_fee_rate);
        }
        if !self.default_derivative_maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.default_derivative_maker_fee_rate);
        }
        if !self.default_derivative_taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.default_derivative_taker_fee_rate);
        }
        if !self.default_initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.default_initial_margin_ratio);
        }
        if !self.default_maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.default_maintenance_margin_ratio);
        }
        if self.default_funding_interval != 0 {
            my_size += ::protobuf::rt::value_size(9, self.default_funding_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.funding_multiple != 0 {
            my_size += ::protobuf::rt::value_size(10, self.funding_multiple, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.relayer_fee_share_rate);
        }
        if !self.default_hourly_funding_rate_cap.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.default_hourly_funding_rate_cap);
        }
        if !self.default_hourly_interest_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.default_hourly_interest_rate);
        }
        if self.max_derivative_order_side_count != 0 {
            my_size += ::protobuf::rt::value_size(14, self.max_derivative_order_side_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.inj_reward_staked_requirement_threshold.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.inj_reward_staked_requirement_threshold);
        }
        if self.trading_rewards_vesting_duration != 0 {
            my_size += ::protobuf::rt::value_size(16, self.trading_rewards_vesting_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.liquidator_reward_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.liquidator_reward_share_rate);
        }
        if let Some(ref v) = self.binary_options_market_instant_listing_fee.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.atomic_market_order_access_level != AtomicMarketOrderAccessLevel::Nobody {
            my_size += ::protobuf::rt::enum_size(19, self.atomic_market_order_access_level);
        }
        if !self.spot_atomic_market_order_fee_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.spot_atomic_market_order_fee_multiplier);
        }
        if !self.derivative_atomic_market_order_fee_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.derivative_atomic_market_order_fee_multiplier);
        }
        if !self.binary_options_atomic_market_order_fee_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.binary_options_atomic_market_order_fee_multiplier);
        }
        if !self.minimal_protocol_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.minimal_protocol_fee_rate);
        }
        if self.is_instant_derivative_market_launch_enabled != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.spot_market_instant_listing_fee.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.derivative_market_instant_listing_fee.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_spot_maker_fee_rate.is_empty() {
            os.write_string(3, &self.default_spot_maker_fee_rate)?;
        }
        if !self.default_spot_taker_fee_rate.is_empty() {
            os.write_string(4, &self.default_spot_taker_fee_rate)?;
        }
        if !self.default_derivative_maker_fee_rate.is_empty() {
            os.write_string(5, &self.default_derivative_maker_fee_rate)?;
        }
        if !self.default_derivative_taker_fee_rate.is_empty() {
            os.write_string(6, &self.default_derivative_taker_fee_rate)?;
        }
        if !self.default_initial_margin_ratio.is_empty() {
            os.write_string(7, &self.default_initial_margin_ratio)?;
        }
        if !self.default_maintenance_margin_ratio.is_empty() {
            os.write_string(8, &self.default_maintenance_margin_ratio)?;
        }
        if self.default_funding_interval != 0 {
            os.write_int64(9, self.default_funding_interval)?;
        }
        if self.funding_multiple != 0 {
            os.write_int64(10, self.funding_multiple)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(11, &self.relayer_fee_share_rate)?;
        }
        if !self.default_hourly_funding_rate_cap.is_empty() {
            os.write_string(12, &self.default_hourly_funding_rate_cap)?;
        }
        if !self.default_hourly_interest_rate.is_empty() {
            os.write_string(13, &self.default_hourly_interest_rate)?;
        }
        if self.max_derivative_order_side_count != 0 {
            os.write_uint32(14, self.max_derivative_order_side_count)?;
        }
        if !self.inj_reward_staked_requirement_threshold.is_empty() {
            os.write_string(15, &self.inj_reward_staked_requirement_threshold)?;
        }
        if self.trading_rewards_vesting_duration != 0 {
            os.write_int64(16, self.trading_rewards_vesting_duration)?;
        }
        if !self.liquidator_reward_share_rate.is_empty() {
            os.write_string(17, &self.liquidator_reward_share_rate)?;
        }
        if let Some(ref v) = self.binary_options_market_instant_listing_fee.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.atomic_market_order_access_level != AtomicMarketOrderAccessLevel::Nobody {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.atomic_market_order_access_level))?;
        }
        if !self.spot_atomic_market_order_fee_multiplier.is_empty() {
            os.write_string(20, &self.spot_atomic_market_order_fee_multiplier)?;
        }
        if !self.derivative_atomic_market_order_fee_multiplier.is_empty() {
            os.write_string(21, &self.derivative_atomic_market_order_fee_multiplier)?;
        }
        if !self.binary_options_atomic_market_order_fee_multiplier.is_empty() {
            os.write_string(22, &self.binary_options_atomic_market_order_fee_multiplier)?;
        }
        if !self.minimal_protocol_fee_rate.is_empty() {
            os.write_string(23, &self.minimal_protocol_fee_rate)?;
        }
        if self.is_instant_derivative_market_launch_enabled != false {
            os.write_bool(24, self.is_instant_derivative_market_launch_enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Params {
        Params::new()
    }

    fn default_instance() -> &'static Params {
        static instance: ::protobuf::rt::LazyV2<Params> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Params::new)
    }
}

impl ::protobuf::Clear for Params {
    fn clear(&mut self) {
        self.spot_market_instant_listing_fee.clear();
        self.derivative_market_instant_listing_fee.clear();
        self.default_spot_maker_fee_rate.clear();
        self.default_spot_taker_fee_rate.clear();
        self.default_derivative_maker_fee_rate.clear();
        self.default_derivative_taker_fee_rate.clear();
        self.default_initial_margin_ratio.clear();
        self.default_maintenance_margin_ratio.clear();
        self.default_funding_interval = 0;
        self.funding_multiple = 0;
        self.relayer_fee_share_rate.clear();
        self.default_hourly_funding_rate_cap.clear();
        self.default_hourly_interest_rate.clear();
        self.max_derivative_order_side_count = 0;
        self.inj_reward_staked_requirement_threshold.clear();
        self.trading_rewards_vesting_duration = 0;
        self.liquidator_reward_share_rate.clear();
        self.binary_options_market_instant_listing_fee.clear();
        self.atomic_market_order_access_level = AtomicMarketOrderAccessLevel::Nobody;
        self.spot_atomic_market_order_fee_multiplier.clear();
        self.derivative_atomic_market_order_fee_multiplier.clear();
        self.binary_options_atomic_market_order_fee_multiplier.clear();
        self.minimal_protocol_fee_rate.clear();
        self.is_instant_derivative_market_launch_enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketFeeMultiplier {
    // message fields
    pub market_id: ::std::string::String,
    pub fee_multiplier: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketFeeMultiplier {
    fn default() -> &'a MarketFeeMultiplier {
        <MarketFeeMultiplier as ::protobuf::Message>::default_instance()
    }
}

impl MarketFeeMultiplier {
    pub fn new() -> MarketFeeMultiplier {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string fee_multiplier = 2;


    pub fn get_fee_multiplier(&self) -> &str {
        &self.fee_multiplier
    }
    pub fn clear_fee_multiplier(&mut self) {
        self.fee_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_multiplier(&mut self, v: ::std::string::String) {
        self.fee_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.fee_multiplier
    }

    // Take field
    pub fn take_fee_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_multiplier, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketFeeMultiplier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_multiplier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.fee_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.fee_multiplier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.fee_multiplier.is_empty() {
            os.write_string(2, &self.fee_multiplier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketFeeMultiplier {
        MarketFeeMultiplier::new()
    }

    fn default_instance() -> &'static MarketFeeMultiplier {
        static instance: ::protobuf::rt::LazyV2<MarketFeeMultiplier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketFeeMultiplier::new)
    }
}

impl ::protobuf::Clear for MarketFeeMultiplier {
    fn clear(&mut self) {
        self.market_id.clear();
        self.fee_multiplier.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketFeeMultiplier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarket {
    // message fields
    pub ticker: ::std::string::String,
    pub oracle_base: ::std::string::String,
    pub oracle_quote: ::std::string::String,
    pub oracle_type: super::oracle::OracleType,
    pub oracle_scale_factor: u32,
    pub quote_denom: ::std::string::String,
    pub market_id: ::std::string::String,
    pub initial_margin_ratio: ::std::string::String,
    pub maintenance_margin_ratio: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub isPerpetual: bool,
    pub status: MarketStatus,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarket {
    fn default() -> &'a DerivativeMarket {
        <DerivativeMarket as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarket {
    pub fn new() -> DerivativeMarket {
        ::std::default::Default::default()
    }

    // string ticker = 1;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_base = 2;


    pub fn get_oracle_base(&self) -> &str {
        &self.oracle_base
    }
    pub fn clear_oracle_base(&mut self) {
        self.oracle_base.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_base(&mut self, v: ::std::string::String) {
        self.oracle_base = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_base(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_base
    }

    // Take field
    pub fn take_oracle_base(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_base, ::std::string::String::new())
    }

    // string oracle_quote = 3;


    pub fn get_oracle_quote(&self) -> &str {
        &self.oracle_quote
    }
    pub fn clear_oracle_quote(&mut self) {
        self.oracle_quote.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_quote(&mut self, v: ::std::string::String) {
        self.oracle_quote = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_quote(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_quote
    }

    // Take field
    pub fn take_oracle_quote(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_quote, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 4;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // uint32 oracle_scale_factor = 5;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // string quote_denom = 6;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string market_id = 7;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string initial_margin_ratio = 8;


    pub fn get_initial_margin_ratio(&self) -> &str {
        &self.initial_margin_ratio
    }
    pub fn clear_initial_margin_ratio(&mut self) {
        self.initial_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_margin_ratio(&mut self, v: ::std::string::String) {
        self.initial_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.initial_margin_ratio
    }

    // Take field
    pub fn take_initial_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_margin_ratio, ::std::string::String::new())
    }

    // string maintenance_margin_ratio = 9;


    pub fn get_maintenance_margin_ratio(&self) -> &str {
        &self.maintenance_margin_ratio
    }
    pub fn clear_maintenance_margin_ratio(&mut self) {
        self.maintenance_margin_ratio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_margin_ratio(&mut self, v: ::std::string::String) {
        self.maintenance_margin_ratio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_margin_ratio(&mut self) -> &mut ::std::string::String {
        &mut self.maintenance_margin_ratio
    }

    // Take field
    pub fn take_maintenance_margin_ratio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maintenance_margin_ratio, ::std::string::String::new())
    }

    // string maker_fee_rate = 10;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 11;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 12;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // bool isPerpetual = 13;


    pub fn get_isPerpetual(&self) -> bool {
        self.isPerpetual
    }
    pub fn clear_isPerpetual(&mut self) {
        self.isPerpetual = false;
    }

    // Param is passed by value, moved
    pub fn set_isPerpetual(&mut self, v: bool) {
        self.isPerpetual = v;
    }

    // .injective.exchange.v1beta1.MarketStatus status = 14;


    pub fn get_status(&self) -> MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MarketStatus) {
        self.status = v;
    }

    // string min_price_tick_size = 15;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 16;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeMarket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_base)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_quote)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_margin_ratio)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maintenance_margin_ratio)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPerpetual = tmp;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticker);
        }
        if !self.oracle_base.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.oracle_base);
        }
        if !self.oracle_quote.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.oracle_quote);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(4, self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(5, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.quote_denom);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.market_id);
        }
        if !self.initial_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.initial_margin_ratio);
        }
        if !self.maintenance_margin_ratio.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.maintenance_margin_ratio);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.relayer_fee_share_rate);
        }
        if self.isPerpetual != false {
            my_size += 2;
        }
        if self.status != MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(14, self.status);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ticker.is_empty() {
            os.write_string(1, &self.ticker)?;
        }
        if !self.oracle_base.is_empty() {
            os.write_string(2, &self.oracle_base)?;
        }
        if !self.oracle_quote.is_empty() {
            os.write_string(3, &self.oracle_quote)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(5, self.oracle_scale_factor)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(6, &self.quote_denom)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(7, &self.market_id)?;
        }
        if !self.initial_margin_ratio.is_empty() {
            os.write_string(8, &self.initial_margin_ratio)?;
        }
        if !self.maintenance_margin_ratio.is_empty() {
            os.write_string(9, &self.maintenance_margin_ratio)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(10, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(11, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(12, &self.relayer_fee_share_rate)?;
        }
        if self.isPerpetual != false {
            os.write_bool(13, self.isPerpetual)?;
        }
        if self.status != MarketStatus::Unspecified {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(15, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(16, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarket {
        DerivativeMarket::new()
    }

    fn default_instance() -> &'static DerivativeMarket {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarket::new)
    }
}

impl ::protobuf::Clear for DerivativeMarket {
    fn clear(&mut self) {
        self.ticker.clear();
        self.oracle_base.clear();
        self.oracle_quote.clear();
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.oracle_scale_factor = 0;
        self.quote_denom.clear();
        self.market_id.clear();
        self.initial_margin_ratio.clear();
        self.maintenance_margin_ratio.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.isPerpetual = false;
        self.status = MarketStatus::Unspecified;
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinaryOptionsMarket {
    // message fields
    pub ticker: ::std::string::String,
    pub oracle_symbol: ::std::string::String,
    pub oracle_provider: ::std::string::String,
    pub oracle_type: super::oracle::OracleType,
    pub oracle_scale_factor: u32,
    pub expiration_timestamp: i64,
    pub settlement_timestamp: i64,
    pub admin: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub market_id: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub status: MarketStatus,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryOptionsMarket {
    fn default() -> &'a BinaryOptionsMarket {
        <BinaryOptionsMarket as ::protobuf::Message>::default_instance()
    }
}

impl BinaryOptionsMarket {
    pub fn new() -> BinaryOptionsMarket {
        ::std::default::Default::default()
    }

    // string ticker = 1;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string oracle_symbol = 2;


    pub fn get_oracle_symbol(&self) -> &str {
        &self.oracle_symbol
    }
    pub fn clear_oracle_symbol(&mut self) {
        self.oracle_symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_symbol(&mut self, v: ::std::string::String) {
        self.oracle_symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_symbol
    }

    // Take field
    pub fn take_oracle_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_symbol, ::std::string::String::new())
    }

    // string oracle_provider = 3;


    pub fn get_oracle_provider(&self) -> &str {
        &self.oracle_provider
    }
    pub fn clear_oracle_provider(&mut self) {
        self.oracle_provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_oracle_provider(&mut self, v: ::std::string::String) {
        self.oracle_provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oracle_provider(&mut self) -> &mut ::std::string::String {
        &mut self.oracle_provider
    }

    // Take field
    pub fn take_oracle_provider(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oracle_provider, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.OracleType oracle_type = 4;


    pub fn get_oracle_type(&self) -> super::oracle::OracleType {
        self.oracle_type
    }
    pub fn clear_oracle_type(&mut self) {
        self.oracle_type = super::oracle::OracleType::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_oracle_type(&mut self, v: super::oracle::OracleType) {
        self.oracle_type = v;
    }

    // uint32 oracle_scale_factor = 5;


    pub fn get_oracle_scale_factor(&self) -> u32 {
        self.oracle_scale_factor
    }
    pub fn clear_oracle_scale_factor(&mut self) {
        self.oracle_scale_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_oracle_scale_factor(&mut self, v: u32) {
        self.oracle_scale_factor = v;
    }

    // int64 expiration_timestamp = 6;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 settlement_timestamp = 7;


    pub fn get_settlement_timestamp(&self) -> i64 {
        self.settlement_timestamp
    }
    pub fn clear_settlement_timestamp(&mut self) {
        self.settlement_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement_timestamp(&mut self, v: i64) {
        self.settlement_timestamp = v;
    }

    // string admin = 8;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // string quote_denom = 9;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string market_id = 10;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string maker_fee_rate = 11;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 12;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 13;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MarketStatus status = 14;


    pub fn get_status(&self) -> MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MarketStatus) {
        self.status = v;
    }

    // string min_price_tick_size = 15;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 16;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }

    // string settlement_price = 17;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BinaryOptionsMarket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_symbol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oracle_provider)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.oracle_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.oracle_scale_factor = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settlement_timestamp = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticker);
        }
        if !self.oracle_symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.oracle_symbol);
        }
        if !self.oracle_provider.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.oracle_provider);
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            my_size += ::protobuf::rt::enum_size(4, self.oracle_type);
        }
        if self.oracle_scale_factor != 0 {
            my_size += ::protobuf::rt::value_size(5, self.oracle_scale_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.settlement_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.admin);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.quote_denom);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.market_id);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.relayer_fee_share_rate);
        }
        if self.status != MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(14, self.status);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.min_quantity_tick_size);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ticker.is_empty() {
            os.write_string(1, &self.ticker)?;
        }
        if !self.oracle_symbol.is_empty() {
            os.write_string(2, &self.oracle_symbol)?;
        }
        if !self.oracle_provider.is_empty() {
            os.write_string(3, &self.oracle_provider)?;
        }
        if self.oracle_type != super::oracle::OracleType::Unspecified {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.oracle_type))?;
        }
        if self.oracle_scale_factor != 0 {
            os.write_uint32(5, self.oracle_scale_factor)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(6, self.expiration_timestamp)?;
        }
        if self.settlement_timestamp != 0 {
            os.write_int64(7, self.settlement_timestamp)?;
        }
        if !self.admin.is_empty() {
            os.write_string(8, &self.admin)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(9, &self.quote_denom)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(10, &self.market_id)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(11, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(12, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(13, &self.relayer_fee_share_rate)?;
        }
        if self.status != MarketStatus::Unspecified {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(15, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(16, &self.min_quantity_tick_size)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(17, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOptionsMarket {
        BinaryOptionsMarket::new()
    }

    fn default_instance() -> &'static BinaryOptionsMarket {
        static instance: ::protobuf::rt::LazyV2<BinaryOptionsMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryOptionsMarket::new)
    }
}

impl ::protobuf::Clear for BinaryOptionsMarket {
    fn clear(&mut self) {
        self.ticker.clear();
        self.oracle_symbol.clear();
        self.oracle_provider.clear();
        self.oracle_type = super::oracle::OracleType::Unspecified;
        self.oracle_scale_factor = 0;
        self.expiration_timestamp = 0;
        self.settlement_timestamp = 0;
        self.admin.clear();
        self.quote_denom.clear();
        self.market_id.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.status = MarketStatus::Unspecified;
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOptionsMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExpiryFuturesMarketInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub expiration_timestamp: i64,
    pub twap_start_timestamp: i64,
    pub expiration_twap_start_price_cumulative: ::std::string::String,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpiryFuturesMarketInfo {
    fn default() -> &'a ExpiryFuturesMarketInfo {
        <ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExpiryFuturesMarketInfo {
    pub fn new() -> ExpiryFuturesMarketInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // int64 expiration_timestamp = 2;


    pub fn get_expiration_timestamp(&self) -> i64 {
        self.expiration_timestamp
    }
    pub fn clear_expiration_timestamp(&mut self) {
        self.expiration_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_timestamp(&mut self, v: i64) {
        self.expiration_timestamp = v;
    }

    // int64 twap_start_timestamp = 3;


    pub fn get_twap_start_timestamp(&self) -> i64 {
        self.twap_start_timestamp
    }
    pub fn clear_twap_start_timestamp(&mut self) {
        self.twap_start_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_twap_start_timestamp(&mut self, v: i64) {
        self.twap_start_timestamp = v;
    }

    // string expiration_twap_start_price_cumulative = 4;


    pub fn get_expiration_twap_start_price_cumulative(&self) -> &str {
        &self.expiration_twap_start_price_cumulative
    }
    pub fn clear_expiration_twap_start_price_cumulative(&mut self) {
        self.expiration_twap_start_price_cumulative.clear();
    }

    // Param is passed by value, moved
    pub fn set_expiration_twap_start_price_cumulative(&mut self, v: ::std::string::String) {
        self.expiration_twap_start_price_cumulative = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration_twap_start_price_cumulative(&mut self) -> &mut ::std::string::String {
        &mut self.expiration_twap_start_price_cumulative
    }

    // Take field
    pub fn take_expiration_twap_start_price_cumulative(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expiration_twap_start_price_cumulative, ::std::string::String::new())
    }

    // string settlement_price = 5;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExpiryFuturesMarketInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.twap_start_timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expiration_twap_start_price_cumulative)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.expiration_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expiration_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.twap_start_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.twap_start_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.expiration_twap_start_price_cumulative.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.expiration_twap_start_price_cumulative);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.expiration_timestamp != 0 {
            os.write_int64(2, self.expiration_timestamp)?;
        }
        if self.twap_start_timestamp != 0 {
            os.write_int64(3, self.twap_start_timestamp)?;
        }
        if !self.expiration_twap_start_price_cumulative.is_empty() {
            os.write_string(4, &self.expiration_twap_start_price_cumulative)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(5, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpiryFuturesMarketInfo {
        ExpiryFuturesMarketInfo::new()
    }

    fn default_instance() -> &'static ExpiryFuturesMarketInfo {
        static instance: ::protobuf::rt::LazyV2<ExpiryFuturesMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpiryFuturesMarketInfo::new)
    }
}

impl ::protobuf::Clear for ExpiryFuturesMarketInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.expiration_timestamp = 0;
        self.twap_start_timestamp = 0;
        self.expiration_twap_start_price_cumulative.clear();
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpiryFuturesMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub hourly_funding_rate_cap: ::std::string::String,
    pub hourly_interest_rate: ::std::string::String,
    pub next_funding_timestamp: i64,
    pub funding_interval: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketInfo {
    fn default() -> &'a PerpetualMarketInfo {
        <PerpetualMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketInfo {
    pub fn new() -> PerpetualMarketInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string hourly_funding_rate_cap = 2;


    pub fn get_hourly_funding_rate_cap(&self) -> &str {
        &self.hourly_funding_rate_cap
    }
    pub fn clear_hourly_funding_rate_cap(&mut self) {
        self.hourly_funding_rate_cap.clear();
    }

    // Param is passed by value, moved
    pub fn set_hourly_funding_rate_cap(&mut self, v: ::std::string::String) {
        self.hourly_funding_rate_cap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hourly_funding_rate_cap(&mut self) -> &mut ::std::string::String {
        &mut self.hourly_funding_rate_cap
    }

    // Take field
    pub fn take_hourly_funding_rate_cap(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hourly_funding_rate_cap, ::std::string::String::new())
    }

    // string hourly_interest_rate = 3;


    pub fn get_hourly_interest_rate(&self) -> &str {
        &self.hourly_interest_rate
    }
    pub fn clear_hourly_interest_rate(&mut self) {
        self.hourly_interest_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_hourly_interest_rate(&mut self, v: ::std::string::String) {
        self.hourly_interest_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hourly_interest_rate(&mut self) -> &mut ::std::string::String {
        &mut self.hourly_interest_rate
    }

    // Take field
    pub fn take_hourly_interest_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hourly_interest_rate, ::std::string::String::new())
    }

    // int64 next_funding_timestamp = 4;


    pub fn get_next_funding_timestamp(&self) -> i64 {
        self.next_funding_timestamp
    }
    pub fn clear_next_funding_timestamp(&mut self) {
        self.next_funding_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_funding_timestamp(&mut self, v: i64) {
        self.next_funding_timestamp = v;
    }

    // int64 funding_interval = 5;


    pub fn get_funding_interval(&self) -> i64 {
        self.funding_interval
    }
    pub fn clear_funding_interval(&mut self) {
        self.funding_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_funding_interval(&mut self, v: i64) {
        self.funding_interval = v;
    }
}

impl ::protobuf::Message for PerpetualMarketInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hourly_funding_rate_cap)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hourly_interest_rate)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_funding_timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.funding_interval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hourly_funding_rate_cap);
        }
        if !self.hourly_interest_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hourly_interest_rate);
        }
        if self.next_funding_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.next_funding_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.funding_interval != 0 {
            my_size += ::protobuf::rt::value_size(5, self.funding_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.hourly_funding_rate_cap.is_empty() {
            os.write_string(2, &self.hourly_funding_rate_cap)?;
        }
        if !self.hourly_interest_rate.is_empty() {
            os.write_string(3, &self.hourly_interest_rate)?;
        }
        if self.next_funding_timestamp != 0 {
            os.write_int64(4, self.next_funding_timestamp)?;
        }
        if self.funding_interval != 0 {
            os.write_int64(5, self.funding_interval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketInfo {
        PerpetualMarketInfo::new()
    }

    fn default_instance() -> &'static PerpetualMarketInfo {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketInfo::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.hourly_funding_rate_cap.clear();
        self.hourly_interest_rate.clear();
        self.next_funding_timestamp = 0;
        self.funding_interval = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketFunding {
    // message fields
    pub cumulative_funding: ::std::string::String,
    pub cumulative_price: ::std::string::String,
    pub last_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketFunding {
    fn default() -> &'a PerpetualMarketFunding {
        <PerpetualMarketFunding as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketFunding {
    pub fn new() -> PerpetualMarketFunding {
        ::std::default::Default::default()
    }

    // string cumulative_funding = 1;


    pub fn get_cumulative_funding(&self) -> &str {
        &self.cumulative_funding
    }
    pub fn clear_cumulative_funding(&mut self) {
        self.cumulative_funding.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_funding(&mut self, v: ::std::string::String) {
        self.cumulative_funding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_funding(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_funding
    }

    // Take field
    pub fn take_cumulative_funding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_funding, ::std::string::String::new())
    }

    // string cumulative_price = 2;


    pub fn get_cumulative_price(&self) -> &str {
        &self.cumulative_price
    }
    pub fn clear_cumulative_price(&mut self) {
        self.cumulative_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_price(&mut self, v: ::std::string::String) {
        self.cumulative_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_price(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_price
    }

    // Take field
    pub fn take_cumulative_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_price, ::std::string::String::new())
    }

    // int64 last_timestamp = 3;


    pub fn get_last_timestamp(&self) -> i64 {
        self.last_timestamp
    }
    pub fn clear_last_timestamp(&mut self) {
        self.last_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_timestamp(&mut self, v: i64) {
        self.last_timestamp = v;
    }
}

impl ::protobuf::Message for PerpetualMarketFunding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_funding)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_price)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cumulative_funding.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cumulative_funding);
        }
        if !self.cumulative_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cumulative_price);
        }
        if self.last_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cumulative_funding.is_empty() {
            os.write_string(1, &self.cumulative_funding)?;
        }
        if !self.cumulative_price.is_empty() {
            os.write_string(2, &self.cumulative_price)?;
        }
        if self.last_timestamp != 0 {
            os.write_int64(3, self.last_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketFunding {
        PerpetualMarketFunding::new()
    }

    fn default_instance() -> &'static PerpetualMarketFunding {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketFunding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketFunding::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketFunding {
    fn clear(&mut self) {
        self.cumulative_funding.clear();
        self.cumulative_price.clear();
        self.last_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketFunding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketSettlementInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub settlement_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketSettlementInfo {
    fn default() -> &'a DerivativeMarketSettlementInfo {
        <DerivativeMarketSettlementInfo as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketSettlementInfo {
    pub fn new() -> DerivativeMarketSettlementInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string settlement_price = 2;


    pub fn get_settlement_price(&self) -> &str {
        &self.settlement_price
    }
    pub fn clear_settlement_price(&mut self) {
        self.settlement_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_settlement_price(&mut self, v: ::std::string::String) {
        self.settlement_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settlement_price(&mut self) -> &mut ::std::string::String {
        &mut self.settlement_price
    }

    // Take field
    pub fn take_settlement_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.settlement_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeMarketSettlementInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.settlement_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.settlement_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.settlement_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.settlement_price.is_empty() {
            os.write_string(2, &self.settlement_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketSettlementInfo {
        DerivativeMarketSettlementInfo::new()
    }

    fn default_instance() -> &'static DerivativeMarketSettlementInfo {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketSettlementInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketSettlementInfo::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketSettlementInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.settlement_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketSettlementInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct NextFundingTimestamp {
    // message fields
    pub next_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextFundingTimestamp {
    fn default() -> &'a NextFundingTimestamp {
        <NextFundingTimestamp as ::protobuf::Message>::default_instance()
    }
}

impl NextFundingTimestamp {
    pub fn new() -> NextFundingTimestamp {
        ::std::default::Default::default()
    }

    // int64 next_timestamp = 1;


    pub fn get_next_timestamp(&self) -> i64 {
        self.next_timestamp
    }
    pub fn clear_next_timestamp(&mut self) {
        self.next_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_timestamp(&mut self, v: i64) {
        self.next_timestamp = v;
    }
}

impl ::protobuf::Message for NextFundingTimestamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.next_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.next_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.next_timestamp != 0 {
            os.write_int64(1, self.next_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextFundingTimestamp {
        NextFundingTimestamp::new()
    }

    fn default_instance() -> &'static NextFundingTimestamp {
        static instance: ::protobuf::rt::LazyV2<NextFundingTimestamp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NextFundingTimestamp::new)
    }
}

impl ::protobuf::Clear for NextFundingTimestamp {
    fn clear(&mut self) {
        self.next_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for NextFundingTimestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MidPriceAndTOB {
    // message fields
    pub mid_price: ::std::string::String,
    pub best_buy_price: ::std::string::String,
    pub best_sell_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MidPriceAndTOB {
    fn default() -> &'a MidPriceAndTOB {
        <MidPriceAndTOB as ::protobuf::Message>::default_instance()
    }
}

impl MidPriceAndTOB {
    pub fn new() -> MidPriceAndTOB {
        ::std::default::Default::default()
    }

    // string mid_price = 1;


    pub fn get_mid_price(&self) -> &str {
        &self.mid_price
    }
    pub fn clear_mid_price(&mut self) {
        self.mid_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mid_price(&mut self, v: ::std::string::String) {
        self.mid_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid_price(&mut self) -> &mut ::std::string::String {
        &mut self.mid_price
    }

    // Take field
    pub fn take_mid_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mid_price, ::std::string::String::new())
    }

    // string best_buy_price = 2;


    pub fn get_best_buy_price(&self) -> &str {
        &self.best_buy_price
    }
    pub fn clear_best_buy_price(&mut self) {
        self.best_buy_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_buy_price(&mut self, v: ::std::string::String) {
        self.best_buy_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_buy_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_buy_price
    }

    // Take field
    pub fn take_best_buy_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_buy_price, ::std::string::String::new())
    }

    // string best_sell_price = 3;


    pub fn get_best_sell_price(&self) -> &str {
        &self.best_sell_price
    }
    pub fn clear_best_sell_price(&mut self) {
        self.best_sell_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_sell_price(&mut self, v: ::std::string::String) {
        self.best_sell_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_sell_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_sell_price
    }

    // Take field
    pub fn take_best_sell_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_sell_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MidPriceAndTOB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mid_price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_buy_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_sell_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mid_price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mid_price);
        }
        if !self.best_buy_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.best_buy_price);
        }
        if !self.best_sell_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.best_sell_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mid_price.is_empty() {
            os.write_string(1, &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            os.write_string(2, &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            os.write_string(3, &self.best_sell_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MidPriceAndTOB {
        MidPriceAndTOB::new()
    }

    fn default_instance() -> &'static MidPriceAndTOB {
        static instance: ::protobuf::rt::LazyV2<MidPriceAndTOB> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MidPriceAndTOB::new)
    }
}

impl ::protobuf::Clear for MidPriceAndTOB {
    fn clear(&mut self) {
        self.mid_price.clear();
        self.best_buy_price.clear();
        self.best_sell_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MidPriceAndTOB {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarket {
    // message fields
    pub ticker: ::std::string::String,
    pub base_denom: ::std::string::String,
    pub quote_denom: ::std::string::String,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub relayer_fee_share_rate: ::std::string::String,
    pub market_id: ::std::string::String,
    pub status: MarketStatus,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarket {
    fn default() -> &'a SpotMarket {
        <SpotMarket as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarket {
    pub fn new() -> SpotMarket {
        ::std::default::Default::default()
    }

    // string ticker = 1;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string base_denom = 2;


    pub fn get_base_denom(&self) -> &str {
        &self.base_denom
    }
    pub fn clear_base_denom(&mut self) {
        self.base_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_denom(&mut self, v: ::std::string::String) {
        self.base_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_denom(&mut self) -> &mut ::std::string::String {
        &mut self.base_denom
    }

    // Take field
    pub fn take_base_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_denom, ::std::string::String::new())
    }

    // string quote_denom = 3;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // string maker_fee_rate = 4;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 5;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string relayer_fee_share_rate = 6;


    pub fn get_relayer_fee_share_rate(&self) -> &str {
        &self.relayer_fee_share_rate
    }
    pub fn clear_relayer_fee_share_rate(&mut self) {
        self.relayer_fee_share_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_relayer_fee_share_rate(&mut self, v: ::std::string::String) {
        self.relayer_fee_share_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relayer_fee_share_rate(&mut self) -> &mut ::std::string::String {
        &mut self.relayer_fee_share_rate
    }

    // Take field
    pub fn take_relayer_fee_share_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relayer_fee_share_rate, ::std::string::String::new())
    }

    // string market_id = 7;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MarketStatus status = 8;


    pub fn get_status(&self) -> MarketStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = MarketStatus::Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MarketStatus) {
        self.status = v;
    }

    // string min_price_tick_size = 9;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 10;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotMarket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_denom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relayer_fee_share_rate)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ticker);
        }
        if !self.base_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_denom);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_denom);
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.taker_fee_rate);
        }
        if !self.relayer_fee_share_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.relayer_fee_share_rate);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.market_id);
        }
        if self.status != MarketStatus::Unspecified {
            my_size += ::protobuf::rt::enum_size(8, self.status);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ticker.is_empty() {
            os.write_string(1, &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            os.write_string(2, &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(3, &self.quote_denom)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(4, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(5, &self.taker_fee_rate)?;
        }
        if !self.relayer_fee_share_rate.is_empty() {
            os.write_string(6, &self.relayer_fee_share_rate)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(7, &self.market_id)?;
        }
        if self.status != MarketStatus::Unspecified {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(9, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(10, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarket {
        SpotMarket::new()
    }

    fn default_instance() -> &'static SpotMarket {
        static instance: ::protobuf::rt::LazyV2<SpotMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarket::new)
    }
}

impl ::protobuf::Clear for SpotMarket {
    fn clear(&mut self) {
        self.ticker.clear();
        self.base_denom.clear();
        self.quote_denom.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.relayer_fee_share_rate.clear();
        self.market_id.clear();
        self.status = MarketStatus::Unspecified;
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Deposit {
    // message fields
    pub available_balance: ::std::string::String,
    pub total_balance: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Deposit {
    fn default() -> &'a Deposit {
        <Deposit as ::protobuf::Message>::default_instance()
    }
}

impl Deposit {
    pub fn new() -> Deposit {
        ::std::default::Default::default()
    }

    // string available_balance = 1;


    pub fn get_available_balance(&self) -> &str {
        &self.available_balance
    }
    pub fn clear_available_balance(&mut self) {
        self.available_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_balance(&mut self, v: ::std::string::String) {
        self.available_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available_balance(&mut self) -> &mut ::std::string::String {
        &mut self.available_balance
    }

    // Take field
    pub fn take_available_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available_balance, ::std::string::String::new())
    }

    // string total_balance = 2;


    pub fn get_total_balance(&self) -> &str {
        &self.total_balance
    }
    pub fn clear_total_balance(&mut self) {
        self.total_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: ::std::string::String) {
        self.total_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_balance(&mut self) -> &mut ::std::string::String {
        &mut self.total_balance
    }

    // Take field
    pub fn take_total_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_balance, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Deposit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available_balance)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.available_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.available_balance);
        }
        if !self.total_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.total_balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.available_balance.is_empty() {
            os.write_string(1, &self.available_balance)?;
        }
        if !self.total_balance.is_empty() {
            os.write_string(2, &self.total_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Deposit {
        Deposit::new()
    }

    fn default_instance() -> &'static Deposit {
        static instance: ::protobuf::rt::LazyV2<Deposit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Deposit::new)
    }
}

impl ::protobuf::Clear for Deposit {
    fn clear(&mut self) {
        self.available_balance.clear();
        self.total_balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Deposit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountTradeNonce {
    // message fields
    pub nonce: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountTradeNonce {
    fn default() -> &'a SubaccountTradeNonce {
        <SubaccountTradeNonce as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountTradeNonce {
    pub fn new() -> SubaccountTradeNonce {
        ::std::default::Default::default()
    }

    // uint32 nonce = 1;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for SubaccountTradeNonce {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_uint32(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountTradeNonce {
        SubaccountTradeNonce::new()
    }

    fn default_instance() -> &'static SubaccountTradeNonce {
        static instance: ::protobuf::rt::LazyV2<SubaccountTradeNonce> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountTradeNonce::new)
    }
}

impl ::protobuf::Clear for SubaccountTradeNonce {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountTradeNonce {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderInfo {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub fee_recipient: ::std::string::String,
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderInfo {
    fn default() -> &'a OrderInfo {
        <OrderInfo as ::protobuf::Message>::default_instance()
    }
}

impl OrderInfo {
    pub fn new() -> OrderInfo {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string fee_recipient = 2;


    pub fn get_fee_recipient(&self) -> &str {
        &self.fee_recipient
    }
    pub fn clear_fee_recipient(&mut self) {
        self.fee_recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient(&mut self, v: ::std::string::String) {
        self.fee_recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.fee_recipient
    }

    // Take field
    pub fn take_fee_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_recipient, ::std::string::String::new())
    }

    // string price = 3;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 4;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_recipient)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.fee_recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.fee_recipient);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.fee_recipient.is_empty() {
            os.write_string(2, &self.fee_recipient)?;
        }
        if !self.price.is_empty() {
            os.write_string(3, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(4, &self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderInfo {
        OrderInfo::new()
    }

    fn default_instance() -> &'static OrderInfo {
        static instance: ::protobuf::rt::LazyV2<OrderInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderInfo::new)
    }
}

impl ::protobuf::Clear for OrderInfo {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.fee_recipient.clear();
        self.price.clear();
        self.quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub order_type: OrderType,
    pub trigger_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotOrder {
    fn default() -> &'a SpotOrder {
        <SpotOrder as ::protobuf::Message>::default_instance()
    }
}

impl SpotOrder {
    pub fn new() -> SpotOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 2;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 3;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string trigger_price = 4;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.order_type);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trigger_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(4, &self.trigger_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotOrder {
        SpotOrder::new()
    }

    fn default_instance() -> &'static SpotOrder {
        static instance: ::protobuf::rt::LazyV2<SpotOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotOrder::new)
    }
}

impl ::protobuf::Clear for SpotOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_info.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.trigger_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotLimitOrder {
    // message fields
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub order_type: OrderType,
    pub fillable: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotLimitOrder {
    fn default() -> &'a SpotLimitOrder {
        <SpotLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl SpotLimitOrder {
    pub fn new() -> SpotLimitOrder {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 1;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 2;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string fillable = 3;


    pub fn get_fillable(&self) -> &str {
        &self.fillable
    }
    pub fn clear_fillable(&mut self) {
        self.fillable.clear();
    }

    // Param is passed by value, moved
    pub fn set_fillable(&mut self, v: ::std::string::String) {
        self.fillable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fillable(&mut self) -> &mut ::std::string::String {
        &mut self.fillable
    }

    // Take field
    pub fn take_fillable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fillable, ::std::string::String::new())
    }

    // string trigger_price = 4;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // bytes order_hash = 5;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SpotLimitOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fillable)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.order_type);
        }
        if !self.fillable.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fillable);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trigger_price);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.fillable.is_empty() {
            os.write_string(3, &self.fillable)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(4, &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(5, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotLimitOrder {
        SpotLimitOrder::new()
    }

    fn default_instance() -> &'static SpotLimitOrder {
        static instance: ::protobuf::rt::LazyV2<SpotLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotLimitOrder::new)
    }
}

impl ::protobuf::Clear for SpotLimitOrder {
    fn clear(&mut self) {
        self.order_info.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.fillable.clear();
        self.trigger_price.clear();
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarketOrder {
    // message fields
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub balance_hold: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    pub order_type: OrderType,
    pub trigger_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarketOrder {
    fn default() -> &'a SpotMarketOrder {
        <SpotMarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarketOrder {
    pub fn new() -> SpotMarketOrder {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 1;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // string balance_hold = 2;


    pub fn get_balance_hold(&self) -> &str {
        &self.balance_hold
    }
    pub fn clear_balance_hold(&mut self) {
        self.balance_hold.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance_hold(&mut self, v: ::std::string::String) {
        self.balance_hold = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_hold(&mut self) -> &mut ::std::string::String {
        &mut self.balance_hold
    }

    // Take field
    pub fn take_balance_hold(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance_hold, ::std::string::String::new())
    }

    // bytes order_hash = 3;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 4;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string trigger_price = 5;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotMarketOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance_hold)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.balance_hold.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.balance_hold);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.order_hash);
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.order_type);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trigger_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.balance_hold.is_empty() {
            os.write_string(2, &self.balance_hold)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(3, &self.order_hash)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(5, &self.trigger_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarketOrder {
        SpotMarketOrder::new()
    }

    fn default_instance() -> &'static SpotMarketOrder {
        static instance: ::protobuf::rt::LazyV2<SpotMarketOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarketOrder::new)
    }
}

impl ::protobuf::Clear for SpotMarketOrder {
    fn clear(&mut self) {
        self.order_info.clear();
        self.balance_hold.clear();
        self.order_hash.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.trigger_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarketOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeOrder {
    // message fields
    pub market_id: ::std::string::String,
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub order_type: OrderType,
    pub margin: ::std::string::String,
    pub trigger_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeOrder {
    fn default() -> &'a DerivativeOrder {
        <DerivativeOrder as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeOrder {
    pub fn new() -> DerivativeOrder {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 2;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 3;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string margin = 4;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string trigger_price = 5;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DerivativeOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.order_type);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.margin);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trigger_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.margin.is_empty() {
            os.write_string(4, &self.margin)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(5, &self.trigger_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeOrder {
        DerivativeOrder::new()
    }

    fn default_instance() -> &'static DerivativeOrder {
        static instance: ::protobuf::rt::LazyV2<DerivativeOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeOrder::new)
    }
}

impl ::protobuf::Clear for DerivativeOrder {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_info.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.margin.clear();
        self.trigger_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrderbookMetadata {
    // message fields
    pub vanilla_limit_order_count: u32,
    pub reduce_only_limit_order_count: u32,
    pub aggregate_reduce_only_quantity: ::std::string::String,
    pub aggregate_vanilla_quantity: ::std::string::String,
    pub vanilla_conditional_order_count: u32,
    pub reduce_only_conditional_order_count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrderbookMetadata {
    fn default() -> &'a SubaccountOrderbookMetadata {
        <SubaccountOrderbookMetadata as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrderbookMetadata {
    pub fn new() -> SubaccountOrderbookMetadata {
        ::std::default::Default::default()
    }

    // uint32 vanilla_limit_order_count = 1;


    pub fn get_vanilla_limit_order_count(&self) -> u32 {
        self.vanilla_limit_order_count
    }
    pub fn clear_vanilla_limit_order_count(&mut self) {
        self.vanilla_limit_order_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vanilla_limit_order_count(&mut self, v: u32) {
        self.vanilla_limit_order_count = v;
    }

    // uint32 reduce_only_limit_order_count = 2;


    pub fn get_reduce_only_limit_order_count(&self) -> u32 {
        self.reduce_only_limit_order_count
    }
    pub fn clear_reduce_only_limit_order_count(&mut self) {
        self.reduce_only_limit_order_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_reduce_only_limit_order_count(&mut self, v: u32) {
        self.reduce_only_limit_order_count = v;
    }

    // string aggregate_reduce_only_quantity = 3;


    pub fn get_aggregate_reduce_only_quantity(&self) -> &str {
        &self.aggregate_reduce_only_quantity
    }
    pub fn clear_aggregate_reduce_only_quantity(&mut self) {
        self.aggregate_reduce_only_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_reduce_only_quantity(&mut self, v: ::std::string::String) {
        self.aggregate_reduce_only_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_reduce_only_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.aggregate_reduce_only_quantity
    }

    // Take field
    pub fn take_aggregate_reduce_only_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aggregate_reduce_only_quantity, ::std::string::String::new())
    }

    // string aggregate_vanilla_quantity = 4;


    pub fn get_aggregate_vanilla_quantity(&self) -> &str {
        &self.aggregate_vanilla_quantity
    }
    pub fn clear_aggregate_vanilla_quantity(&mut self) {
        self.aggregate_vanilla_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_vanilla_quantity(&mut self, v: ::std::string::String) {
        self.aggregate_vanilla_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_vanilla_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.aggregate_vanilla_quantity
    }

    // Take field
    pub fn take_aggregate_vanilla_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aggregate_vanilla_quantity, ::std::string::String::new())
    }

    // uint32 vanilla_conditional_order_count = 5;


    pub fn get_vanilla_conditional_order_count(&self) -> u32 {
        self.vanilla_conditional_order_count
    }
    pub fn clear_vanilla_conditional_order_count(&mut self) {
        self.vanilla_conditional_order_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vanilla_conditional_order_count(&mut self, v: u32) {
        self.vanilla_conditional_order_count = v;
    }

    // uint32 reduce_only_conditional_order_count = 6;


    pub fn get_reduce_only_conditional_order_count(&self) -> u32 {
        self.reduce_only_conditional_order_count
    }
    pub fn clear_reduce_only_conditional_order_count(&mut self) {
        self.reduce_only_conditional_order_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_reduce_only_conditional_order_count(&mut self, v: u32) {
        self.reduce_only_conditional_order_count = v;
    }
}

impl ::protobuf::Message for SubaccountOrderbookMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vanilla_limit_order_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reduce_only_limit_order_count = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aggregate_reduce_only_quantity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aggregate_vanilla_quantity)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vanilla_conditional_order_count = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reduce_only_conditional_order_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vanilla_limit_order_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vanilla_limit_order_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reduce_only_limit_order_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.reduce_only_limit_order_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.aggregate_reduce_only_quantity);
        }
        if !self.aggregate_vanilla_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.aggregate_vanilla_quantity);
        }
        if self.vanilla_conditional_order_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.vanilla_conditional_order_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reduce_only_conditional_order_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.reduce_only_conditional_order_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.vanilla_limit_order_count != 0 {
            os.write_uint32(1, self.vanilla_limit_order_count)?;
        }
        if self.reduce_only_limit_order_count != 0 {
            os.write_uint32(2, self.reduce_only_limit_order_count)?;
        }
        if !self.aggregate_reduce_only_quantity.is_empty() {
            os.write_string(3, &self.aggregate_reduce_only_quantity)?;
        }
        if !self.aggregate_vanilla_quantity.is_empty() {
            os.write_string(4, &self.aggregate_vanilla_quantity)?;
        }
        if self.vanilla_conditional_order_count != 0 {
            os.write_uint32(5, self.vanilla_conditional_order_count)?;
        }
        if self.reduce_only_conditional_order_count != 0 {
            os.write_uint32(6, self.reduce_only_conditional_order_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrderbookMetadata {
        SubaccountOrderbookMetadata::new()
    }

    fn default_instance() -> &'static SubaccountOrderbookMetadata {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrderbookMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrderbookMetadata::new)
    }
}

impl ::protobuf::Clear for SubaccountOrderbookMetadata {
    fn clear(&mut self) {
        self.vanilla_limit_order_count = 0;
        self.reduce_only_limit_order_count = 0;
        self.aggregate_reduce_only_quantity.clear();
        self.aggregate_vanilla_quantity.clear();
        self.vanilla_conditional_order_count = 0;
        self.reduce_only_conditional_order_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrderbookMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrder {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub isReduceOnly: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrder {
    fn default() -> &'a SubaccountOrder {
        <SubaccountOrder as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrder {
    pub fn new() -> SubaccountOrder {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // bool isReduceOnly = 3;


    pub fn get_isReduceOnly(&self) -> bool {
        self.isReduceOnly
    }
    pub fn clear_isReduceOnly(&mut self) {
        self.isReduceOnly = false;
    }

    // Param is passed by value, moved
    pub fn set_isReduceOnly(&mut self, v: bool) {
        self.isReduceOnly = v;
    }
}

impl ::protobuf::Message for SubaccountOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isReduceOnly = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if self.isReduceOnly != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if self.isReduceOnly != false {
            os.write_bool(3, self.isReduceOnly)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrder {
        SubaccountOrder::new()
    }

    fn default_instance() -> &'static SubaccountOrder {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrder::new)
    }
}

impl ::protobuf::Clear for SubaccountOrder {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.isReduceOnly = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrderData {
    // message fields
    pub order: ::protobuf::SingularPtrField<SubaccountOrder>,
    pub order_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrderData {
    fn default() -> &'a SubaccountOrderData {
        <SubaccountOrderData as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrderData {
    pub fn new() -> SubaccountOrderData {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.SubaccountOrder order = 1;


    pub fn get_order(&self) -> &SubaccountOrder {
        self.order.as_ref().unwrap_or_else(|| <SubaccountOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: SubaccountOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut SubaccountOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> SubaccountOrder {
        self.order.take().unwrap_or_else(|| SubaccountOrder::new())
    }

    // bytes order_hash = 2;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SubaccountOrderData {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(2, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrderData {
        SubaccountOrderData::new()
    }

    fn default_instance() -> &'static SubaccountOrderData {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrderData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrderData::new)
    }
}

impl ::protobuf::Clear for SubaccountOrderData {
    fn clear(&mut self) {
        self.order.clear();
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrderData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeLimitOrder {
    // message fields
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub order_type: OrderType,
    pub margin: ::std::string::String,
    pub fillable: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeLimitOrder {
    fn default() -> &'a DerivativeLimitOrder {
        <DerivativeLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeLimitOrder {
    pub fn new() -> DerivativeLimitOrder {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 1;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 2;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string margin = 3;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string fillable = 4;


    pub fn get_fillable(&self) -> &str {
        &self.fillable
    }
    pub fn clear_fillable(&mut self) {
        self.fillable.clear();
    }

    // Param is passed by value, moved
    pub fn set_fillable(&mut self, v: ::std::string::String) {
        self.fillable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fillable(&mut self) -> &mut ::std::string::String {
        &mut self.fillable
    }

    // Take field
    pub fn take_fillable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fillable, ::std::string::String::new())
    }

    // string trigger_price = 5;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // bytes order_hash = 6;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DerivativeLimitOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fillable)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.order_type);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.margin);
        }
        if !self.fillable.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fillable);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trigger_price);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.margin.is_empty() {
            os.write_string(3, &self.margin)?;
        }
        if !self.fillable.is_empty() {
            os.write_string(4, &self.fillable)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(5, &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(6, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeLimitOrder {
        DerivativeLimitOrder::new()
    }

    fn default_instance() -> &'static DerivativeLimitOrder {
        static instance: ::protobuf::rt::LazyV2<DerivativeLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeLimitOrder::new)
    }
}

impl ::protobuf::Clear for DerivativeLimitOrder {
    fn clear(&mut self) {
        self.order_info.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.margin.clear();
        self.fillable.clear();
        self.trigger_price.clear();
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeMarketOrder {
    // message fields
    pub order_info: ::protobuf::SingularPtrField<OrderInfo>,
    pub order_type: OrderType,
    pub margin: ::std::string::String,
    pub margin_hold: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeMarketOrder {
    fn default() -> &'a DerivativeMarketOrder {
        <DerivativeMarketOrder as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeMarketOrder {
    pub fn new() -> DerivativeMarketOrder {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.OrderInfo order_info = 1;


    pub fn get_order_info(&self) -> &OrderInfo {
        self.order_info.as_ref().unwrap_or_else(|| <OrderInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order_info(&mut self) {
        self.order_info.clear();
    }

    pub fn has_order_info(&self) -> bool {
        self.order_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_info(&mut self, v: OrderInfo) {
        self.order_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_info(&mut self) -> &mut OrderInfo {
        if self.order_info.is_none() {
            self.order_info.set_default();
        }
        self.order_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_order_info(&mut self) -> OrderInfo {
        self.order_info.take().unwrap_or_else(|| OrderInfo::new())
    }

    // .injective.exchange.v1beta1.OrderType order_type = 2;


    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    // string margin = 3;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string margin_hold = 4;


    pub fn get_margin_hold(&self) -> &str {
        &self.margin_hold
    }
    pub fn clear_margin_hold(&mut self) {
        self.margin_hold.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin_hold(&mut self, v: ::std::string::String) {
        self.margin_hold = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin_hold(&mut self) -> &mut ::std::string::String {
        &mut self.margin_hold
    }

    // Take field
    pub fn take_margin_hold(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin_hold, ::std::string::String::new())
    }

    // string trigger_price = 5;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // bytes order_hash = 6;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DerivativeMarketOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.order_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order_info)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin_hold)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.order_type);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.margin);
        }
        if !self.margin_hold.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.margin_hold);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trigger_price);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.order_type != OrderType::UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.order_type))?;
        }
        if !self.margin.is_empty() {
            os.write_string(3, &self.margin)?;
        }
        if !self.margin_hold.is_empty() {
            os.write_string(4, &self.margin_hold)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(5, &self.trigger_price)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(6, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeMarketOrder {
        DerivativeMarketOrder::new()
    }

    fn default_instance() -> &'static DerivativeMarketOrder {
        static instance: ::protobuf::rt::LazyV2<DerivativeMarketOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeMarketOrder::new)
    }
}

impl ::protobuf::Clear for DerivativeMarketOrder {
    fn clear(&mut self) {
        self.order_info.clear();
        self.order_type = OrderType::UNSPECIFIED;
        self.margin.clear();
        self.margin_hold.clear();
        self.trigger_price.clear();
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeMarketOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    pub isLong: bool,
    pub quantity: ::std::string::String,
    pub entry_price: ::std::string::String,
    pub margin: ::std::string::String,
    pub cumulative_funding_entry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // bool isLong = 1;


    pub fn get_isLong(&self) -> bool {
        self.isLong
    }
    pub fn clear_isLong(&mut self) {
        self.isLong = false;
    }

    // Param is passed by value, moved
    pub fn set_isLong(&mut self, v: bool) {
        self.isLong = v;
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string entry_price = 3;


    pub fn get_entry_price(&self) -> &str {
        &self.entry_price
    }
    pub fn clear_entry_price(&mut self) {
        self.entry_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_price(&mut self, v: ::std::string::String) {
        self.entry_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_price(&mut self) -> &mut ::std::string::String {
        &mut self.entry_price
    }

    // Take field
    pub fn take_entry_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_price, ::std::string::String::new())
    }

    // string margin = 4;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string cumulative_funding_entry = 5;


    pub fn get_cumulative_funding_entry(&self) -> &str {
        &self.cumulative_funding_entry
    }
    pub fn clear_cumulative_funding_entry(&mut self) {
        self.cumulative_funding_entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_cumulative_funding_entry(&mut self, v: ::std::string::String) {
        self.cumulative_funding_entry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cumulative_funding_entry(&mut self) -> &mut ::std::string::String {
        &mut self.cumulative_funding_entry
    }

    // Take field
    pub fn take_cumulative_funding_entry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cumulative_funding_entry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLong = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_price)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cumulative_funding_entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.isLong != false {
            my_size += 2;
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if !self.entry_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.entry_price);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.margin);
        }
        if !self.cumulative_funding_entry.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cumulative_funding_entry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.isLong != false {
            os.write_bool(1, self.isLong)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if !self.entry_price.is_empty() {
            os.write_string(3, &self.entry_price)?;
        }
        if !self.margin.is_empty() {
            os.write_string(4, &self.margin)?;
        }
        if !self.cumulative_funding_entry.is_empty() {
            os.write_string(5, &self.cumulative_funding_entry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Position {
        Position::new()
    }

    fn default_instance() -> &'static Position {
        static instance: ::protobuf::rt::LazyV2<Position> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Position::new)
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.isLong = false;
        self.quantity.clear();
        self.entry_price.clear();
        self.margin.clear();
        self.cumulative_funding_entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketOrderIndicator {
    // message fields
    pub market_id: ::std::string::String,
    pub isBuy: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketOrderIndicator {
    fn default() -> &'a MarketOrderIndicator {
        <MarketOrderIndicator as ::protobuf::Message>::default_instance()
    }
}

impl MarketOrderIndicator {
    pub fn new() -> MarketOrderIndicator {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isBuy = 2;


    pub fn get_isBuy(&self) -> bool {
        self.isBuy
    }
    pub fn clear_isBuy(&mut self) {
        self.isBuy = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuy(&mut self, v: bool) {
        self.isBuy = v;
    }
}

impl ::protobuf::Message for MarketOrderIndicator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.isBuy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.isBuy != false {
            os.write_bool(2, self.isBuy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketOrderIndicator {
        MarketOrderIndicator::new()
    }

    fn default_instance() -> &'static MarketOrderIndicator {
        static instance: ::protobuf::rt::LazyV2<MarketOrderIndicator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketOrderIndicator::new)
    }
}

impl ::protobuf::Clear for MarketOrderIndicator {
    fn clear(&mut self) {
        self.market_id.clear();
        self.isBuy = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketOrderIndicator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradeLog {
    // message fields
    pub quantity: ::std::string::String,
    pub price: ::std::string::String,
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub fee: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    pub fee_recipient_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeLog {
    fn default() -> &'a TradeLog {
        <TradeLog as ::protobuf::Message>::default_instance()
    }
}

impl TradeLog {
    pub fn new() -> TradeLog {
        ::std::default::Default::default()
    }

    // string quantity = 1;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string price = 2;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // bytes subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // string fee = 4;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }

    // bytes order_hash = 5;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }

    // bytes fee_recipient_address = 6;


    pub fn get_fee_recipient_address(&self) -> &[u8] {
        &self.fee_recipient_address
    }
    pub fn clear_fee_recipient_address(&mut self) {
        self.fee_recipient_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.fee_recipient_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fee_recipient_address
    }

    // Take field
    pub fn take_fee_recipient_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fee_recipient_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TradeLog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fee_recipient_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.quantity);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.price);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.subaccount_id);
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fee);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.order_hash);
        }
        if !self.fee_recipient_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.fee_recipient_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.quantity.is_empty() {
            os.write_string(1, &self.quantity)?;
        }
        if !self.price.is_empty() {
            os.write_string(2, &self.price)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_bytes(3, &self.subaccount_id)?;
        }
        if !self.fee.is_empty() {
            os.write_string(4, &self.fee)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(5, &self.order_hash)?;
        }
        if !self.fee_recipient_address.is_empty() {
            os.write_bytes(6, &self.fee_recipient_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeLog {
        TradeLog::new()
    }

    fn default_instance() -> &'static TradeLog {
        static instance: ::protobuf::rt::LazyV2<TradeLog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradeLog::new)
    }
}

impl ::protobuf::Clear for TradeLog {
    fn clear(&mut self) {
        self.quantity.clear();
        self.price.clear();
        self.subaccount_id.clear();
        self.fee.clear();
        self.order_hash.clear();
        self.fee_recipient_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeLog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionDelta {
    // message fields
    pub is_long: bool,
    pub execution_quantity: ::std::string::String,
    pub execution_margin: ::std::string::String,
    pub execution_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionDelta {
    fn default() -> &'a PositionDelta {
        <PositionDelta as ::protobuf::Message>::default_instance()
    }
}

impl PositionDelta {
    pub fn new() -> PositionDelta {
        ::std::default::Default::default()
    }

    // bool is_long = 1;


    pub fn get_is_long(&self) -> bool {
        self.is_long
    }
    pub fn clear_is_long(&mut self) {
        self.is_long = false;
    }

    // Param is passed by value, moved
    pub fn set_is_long(&mut self, v: bool) {
        self.is_long = v;
    }

    // string execution_quantity = 2;


    pub fn get_execution_quantity(&self) -> &str {
        &self.execution_quantity
    }
    pub fn clear_execution_quantity(&mut self) {
        self.execution_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_quantity(&mut self, v: ::std::string::String) {
        self.execution_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.execution_quantity
    }

    // Take field
    pub fn take_execution_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_quantity, ::std::string::String::new())
    }

    // string execution_margin = 3;


    pub fn get_execution_margin(&self) -> &str {
        &self.execution_margin
    }
    pub fn clear_execution_margin(&mut self) {
        self.execution_margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_margin(&mut self, v: ::std::string::String) {
        self.execution_margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_margin(&mut self) -> &mut ::std::string::String {
        &mut self.execution_margin
    }

    // Take field
    pub fn take_execution_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_margin, ::std::string::String::new())
    }

    // string execution_price = 4;


    pub fn get_execution_price(&self) -> &str {
        &self.execution_price
    }
    pub fn clear_execution_price(&mut self) {
        self.execution_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_price(&mut self, v: ::std::string::String) {
        self.execution_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_price(&mut self) -> &mut ::std::string::String {
        &mut self.execution_price
    }

    // Take field
    pub fn take_execution_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PositionDelta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_long = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_margin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_long != false {
            my_size += 2;
        }
        if !self.execution_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_quantity);
        }
        if !self.execution_margin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.execution_margin);
        }
        if !self.execution_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.execution_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_long != false {
            os.write_bool(1, self.is_long)?;
        }
        if !self.execution_quantity.is_empty() {
            os.write_string(2, &self.execution_quantity)?;
        }
        if !self.execution_margin.is_empty() {
            os.write_string(3, &self.execution_margin)?;
        }
        if !self.execution_price.is_empty() {
            os.write_string(4, &self.execution_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionDelta {
        PositionDelta::new()
    }

    fn default_instance() -> &'static PositionDelta {
        static instance: ::protobuf::rt::LazyV2<PositionDelta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PositionDelta::new)
    }
}

impl ::protobuf::Clear for PositionDelta {
    fn clear(&mut self) {
        self.is_long = false;
        self.execution_quantity.clear();
        self.execution_margin.clear();
        self.execution_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionDelta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DerivativeTradeLog {
    // message fields
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub position_delta: ::protobuf::SingularPtrField<PositionDelta>,
    pub payout: ::std::string::String,
    pub fee: ::std::string::String,
    pub order_hash: ::std::vec::Vec<u8>,
    pub fee_recipient_address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DerivativeTradeLog {
    fn default() -> &'a DerivativeTradeLog {
        <DerivativeTradeLog as ::protobuf::Message>::default_instance()
    }
}

impl DerivativeTradeLog {
    pub fn new() -> DerivativeTradeLog {
        ::std::default::Default::default()
    }

    // bytes subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // .injective.exchange.v1beta1.PositionDelta position_delta = 2;


    pub fn get_position_delta(&self) -> &PositionDelta {
        self.position_delta.as_ref().unwrap_or_else(|| <PositionDelta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position_delta(&mut self) {
        self.position_delta.clear();
    }

    pub fn has_position_delta(&self) -> bool {
        self.position_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_delta(&mut self, v: PositionDelta) {
        self.position_delta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_delta(&mut self) -> &mut PositionDelta {
        if self.position_delta.is_none() {
            self.position_delta.set_default();
        }
        self.position_delta.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_delta(&mut self) -> PositionDelta {
        self.position_delta.take().unwrap_or_else(|| PositionDelta::new())
    }

    // string payout = 3;


    pub fn get_payout(&self) -> &str {
        &self.payout
    }
    pub fn clear_payout(&mut self) {
        self.payout.clear();
    }

    // Param is passed by value, moved
    pub fn set_payout(&mut self, v: ::std::string::String) {
        self.payout = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payout(&mut self) -> &mut ::std::string::String {
        &mut self.payout
    }

    // Take field
    pub fn take_payout(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payout, ::std::string::String::new())
    }

    // string fee = 4;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }

    // bytes order_hash = 5;


    pub fn get_order_hash(&self) -> &[u8] {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.order_hash, ::std::vec::Vec::new())
    }

    // bytes fee_recipient_address = 6;


    pub fn get_fee_recipient_address(&self) -> &[u8] {
        &self.fee_recipient_address
    }
    pub fn clear_fee_recipient_address(&mut self) {
        self.fee_recipient_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.fee_recipient_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fee_recipient_address
    }

    // Take field
    pub fn take_fee_recipient_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fee_recipient_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DerivativeTradeLog {
    fn is_initialized(&self) -> bool {
        for v in &self.position_delta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_delta)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.order_hash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fee_recipient_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.subaccount_id);
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payout.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payout);
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fee);
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.order_hash);
        }
        if !self.fee_recipient_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.fee_recipient_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_bytes(1, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.position_delta.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payout.is_empty() {
            os.write_string(3, &self.payout)?;
        }
        if !self.fee.is_empty() {
            os.write_string(4, &self.fee)?;
        }
        if !self.order_hash.is_empty() {
            os.write_bytes(5, &self.order_hash)?;
        }
        if !self.fee_recipient_address.is_empty() {
            os.write_bytes(6, &self.fee_recipient_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DerivativeTradeLog {
        DerivativeTradeLog::new()
    }

    fn default_instance() -> &'static DerivativeTradeLog {
        static instance: ::protobuf::rt::LazyV2<DerivativeTradeLog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DerivativeTradeLog::new)
    }
}

impl ::protobuf::Clear for DerivativeTradeLog {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.position_delta.clear();
        self.payout.clear();
        self.fee.clear();
        self.order_hash.clear();
        self.fee_recipient_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DerivativeTradeLog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountPosition {
    // message fields
    pub position: ::protobuf::SingularPtrField<Position>,
    pub subaccount_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountPosition {
    fn default() -> &'a SubaccountPosition {
        <SubaccountPosition as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountPosition {
    pub fn new() -> SubaccountPosition {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.Position position = 1;


    pub fn get_position(&self) -> &Position {
        self.position.as_ref().unwrap_or_else(|| <Position as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Position {
        self.position.take().unwrap_or_else(|| Position::new())
    }

    // bytes subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SubaccountPosition {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_bytes(2, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountPosition {
        SubaccountPosition::new()
    }

    fn default_instance() -> &'static SubaccountPosition {
        static instance: ::protobuf::rt::LazyV2<SubaccountPosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountPosition::new)
    }
}

impl ::protobuf::Clear for SubaccountPosition {
    fn clear(&mut self) {
        self.position.clear();
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountDeposit {
    // message fields
    pub subaccount_id: ::std::vec::Vec<u8>,
    pub deposit: ::protobuf::SingularPtrField<Deposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountDeposit {
    fn default() -> &'a SubaccountDeposit {
        <SubaccountDeposit as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountDeposit {
    pub fn new() -> SubaccountDeposit {
        ::std::default::Default::default()
    }

    // bytes subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &[u8] {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.subaccount_id, ::std::vec::Vec::new())
    }

    // .injective.exchange.v1beta1.Deposit deposit = 2;


    pub fn get_deposit(&self) -> &Deposit {
        self.deposit.as_ref().unwrap_or_else(|| <Deposit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deposit(&mut self) {
        self.deposit.clear();
    }

    pub fn has_deposit(&self) -> bool {
        self.deposit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deposit(&mut self, v: Deposit) {
        self.deposit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit(&mut self) -> &mut Deposit {
        if self.deposit.is_none() {
            self.deposit.set_default();
        }
        self.deposit.as_mut().unwrap()
    }

    // Take field
    pub fn take_deposit(&mut self) -> Deposit {
        self.deposit.take().unwrap_or_else(|| Deposit::new())
    }
}

impl ::protobuf::Message for SubaccountDeposit {
    fn is_initialized(&self) -> bool {
        for v in &self.deposit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deposit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.subaccount_id);
        }
        if let Some(ref v) = self.deposit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_bytes(1, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.deposit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountDeposit {
        SubaccountDeposit::new()
    }

    fn default_instance() -> &'static SubaccountDeposit {
        static instance: ::protobuf::rt::LazyV2<SubaccountDeposit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountDeposit::new)
    }
}

impl ::protobuf::Clear for SubaccountDeposit {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.deposit.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountDeposit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DepositUpdate {
    // message fields
    pub denom: ::std::string::String,
    pub deposits: ::protobuf::RepeatedField<SubaccountDeposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DepositUpdate {
    fn default() -> &'a DepositUpdate {
        <DepositUpdate as ::protobuf::Message>::default_instance()
    }
}

impl DepositUpdate {
    pub fn new() -> DepositUpdate {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.SubaccountDeposit deposits = 2;


    pub fn get_deposits(&self) -> &[SubaccountDeposit] {
        &self.deposits
    }
    pub fn clear_deposits(&mut self) {
        self.deposits.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposits(&mut self, v: ::protobuf::RepeatedField<SubaccountDeposit>) {
        self.deposits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deposits(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountDeposit> {
        &mut self.deposits
    }

    // Take field
    pub fn take_deposits(&mut self) -> ::protobuf::RepeatedField<SubaccountDeposit> {
        ::std::mem::replace(&mut self.deposits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DepositUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.deposits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deposits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        for value in &self.deposits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        for v in &self.deposits {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DepositUpdate {
        DepositUpdate::new()
    }

    fn default_instance() -> &'static DepositUpdate {
        static instance: ::protobuf::rt::LazyV2<DepositUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DepositUpdate::new)
    }
}

impl ::protobuf::Clear for DepositUpdate {
    fn clear(&mut self) {
        self.denom.clear();
        self.deposits.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DepositUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PointsMultiplier {
    // message fields
    pub maker_points_multiplier: ::std::string::String,
    pub taker_points_multiplier: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PointsMultiplier {
    fn default() -> &'a PointsMultiplier {
        <PointsMultiplier as ::protobuf::Message>::default_instance()
    }
}

impl PointsMultiplier {
    pub fn new() -> PointsMultiplier {
        ::std::default::Default::default()
    }

    // string maker_points_multiplier = 1;


    pub fn get_maker_points_multiplier(&self) -> &str {
        &self.maker_points_multiplier
    }
    pub fn clear_maker_points_multiplier(&mut self) {
        self.maker_points_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_points_multiplier(&mut self, v: ::std::string::String) {
        self.maker_points_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_points_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.maker_points_multiplier
    }

    // Take field
    pub fn take_maker_points_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_points_multiplier, ::std::string::String::new())
    }

    // string taker_points_multiplier = 2;


    pub fn get_taker_points_multiplier(&self) -> &str {
        &self.taker_points_multiplier
    }
    pub fn clear_taker_points_multiplier(&mut self) {
        self.taker_points_multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_points_multiplier(&mut self, v: ::std::string::String) {
        self.taker_points_multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_points_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.taker_points_multiplier
    }

    // Take field
    pub fn take_taker_points_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_points_multiplier, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PointsMultiplier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_points_multiplier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_points_multiplier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.maker_points_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.maker_points_multiplier);
        }
        if !self.taker_points_multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.taker_points_multiplier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.maker_points_multiplier.is_empty() {
            os.write_string(1, &self.maker_points_multiplier)?;
        }
        if !self.taker_points_multiplier.is_empty() {
            os.write_string(2, &self.taker_points_multiplier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PointsMultiplier {
        PointsMultiplier::new()
    }

    fn default_instance() -> &'static PointsMultiplier {
        static instance: ::protobuf::rt::LazyV2<PointsMultiplier> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PointsMultiplier::new)
    }
}

impl ::protobuf::Clear for PointsMultiplier {
    fn clear(&mut self) {
        self.maker_points_multiplier.clear();
        self.taker_points_multiplier.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PointsMultiplier {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignBoostInfo {
    // message fields
    pub boosted_spot_market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub spot_market_multipliers: ::protobuf::RepeatedField<PointsMultiplier>,
    pub boosted_derivative_market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub derivative_market_multipliers: ::protobuf::RepeatedField<PointsMultiplier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignBoostInfo {
    fn default() -> &'a TradingRewardCampaignBoostInfo {
        <TradingRewardCampaignBoostInfo as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignBoostInfo {
    pub fn new() -> TradingRewardCampaignBoostInfo {
        ::std::default::Default::default()
    }

    // repeated string boosted_spot_market_ids = 1;


    pub fn get_boosted_spot_market_ids(&self) -> &[::std::string::String] {
        &self.boosted_spot_market_ids
    }
    pub fn clear_boosted_spot_market_ids(&mut self) {
        self.boosted_spot_market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_boosted_spot_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.boosted_spot_market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_boosted_spot_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.boosted_spot_market_ids
    }

    // Take field
    pub fn take_boosted_spot_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.boosted_spot_market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.PointsMultiplier spot_market_multipliers = 2;


    pub fn get_spot_market_multipliers(&self) -> &[PointsMultiplier] {
        &self.spot_market_multipliers
    }
    pub fn clear_spot_market_multipliers(&mut self) {
        self.spot_market_multipliers.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_market_multipliers(&mut self, v: ::protobuf::RepeatedField<PointsMultiplier>) {
        self.spot_market_multipliers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_market_multipliers(&mut self) -> &mut ::protobuf::RepeatedField<PointsMultiplier> {
        &mut self.spot_market_multipliers
    }

    // Take field
    pub fn take_spot_market_multipliers(&mut self) -> ::protobuf::RepeatedField<PointsMultiplier> {
        ::std::mem::replace(&mut self.spot_market_multipliers, ::protobuf::RepeatedField::new())
    }

    // repeated string boosted_derivative_market_ids = 3;


    pub fn get_boosted_derivative_market_ids(&self) -> &[::std::string::String] {
        &self.boosted_derivative_market_ids
    }
    pub fn clear_boosted_derivative_market_ids(&mut self) {
        self.boosted_derivative_market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_boosted_derivative_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.boosted_derivative_market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_boosted_derivative_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.boosted_derivative_market_ids
    }

    // Take field
    pub fn take_boosted_derivative_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.boosted_derivative_market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.PointsMultiplier derivative_market_multipliers = 4;


    pub fn get_derivative_market_multipliers(&self) -> &[PointsMultiplier] {
        &self.derivative_market_multipliers
    }
    pub fn clear_derivative_market_multipliers(&mut self) {
        self.derivative_market_multipliers.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_market_multipliers(&mut self, v: ::protobuf::RepeatedField<PointsMultiplier>) {
        self.derivative_market_multipliers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_market_multipliers(&mut self) -> &mut ::protobuf::RepeatedField<PointsMultiplier> {
        &mut self.derivative_market_multipliers
    }

    // Take field
    pub fn take_derivative_market_multipliers(&mut self) -> ::protobuf::RepeatedField<PointsMultiplier> {
        ::std::mem::replace(&mut self.derivative_market_multipliers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignBoostInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_market_multipliers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_market_multipliers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.boosted_spot_market_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_market_multipliers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.boosted_derivative_market_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_market_multipliers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.boosted_spot_market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.spot_market_multipliers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.boosted_derivative_market_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.derivative_market_multipliers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.boosted_spot_market_ids {
            os.write_string(1, &v)?;
        };
        for v in &self.spot_market_multipliers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.boosted_derivative_market_ids {
            os.write_string(3, &v)?;
        };
        for v in &self.derivative_market_multipliers {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignBoostInfo {
        TradingRewardCampaignBoostInfo::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignBoostInfo {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignBoostInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignBoostInfo::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignBoostInfo {
    fn clear(&mut self) {
        self.boosted_spot_market_ids.clear();
        self.spot_market_multipliers.clear();
        self.boosted_derivative_market_ids.clear();
        self.derivative_market_multipliers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignBoostInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CampaignRewardPool {
    // message fields
    pub start_timestamp: i64,
    pub max_campaign_rewards: ::protobuf::RepeatedField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CampaignRewardPool {
    fn default() -> &'a CampaignRewardPool {
        <CampaignRewardPool as ::protobuf::Message>::default_instance()
    }
}

impl CampaignRewardPool {
    pub fn new() -> CampaignRewardPool {
        ::std::default::Default::default()
    }

    // int64 start_timestamp = 1;


    pub fn get_start_timestamp(&self) -> i64 {
        self.start_timestamp
    }
    pub fn clear_start_timestamp(&mut self) {
        self.start_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp(&mut self, v: i64) {
        self.start_timestamp = v;
    }

    // repeated .cosmos.base.v1beta1.Coin max_campaign_rewards = 2;


    pub fn get_max_campaign_rewards(&self) -> &[super::coin::Coin] {
        &self.max_campaign_rewards
    }
    pub fn clear_max_campaign_rewards(&mut self) {
        self.max_campaign_rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_campaign_rewards(&mut self, v: ::protobuf::RepeatedField<super::coin::Coin>) {
        self.max_campaign_rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max_campaign_rewards(&mut self) -> &mut ::protobuf::RepeatedField<super::coin::Coin> {
        &mut self.max_campaign_rewards
    }

    // Take field
    pub fn take_max_campaign_rewards(&mut self) -> ::protobuf::RepeatedField<super::coin::Coin> {
        ::std::mem::replace(&mut self.max_campaign_rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CampaignRewardPool {
    fn is_initialized(&self) -> bool {
        for v in &self.max_campaign_rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.max_campaign_rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.max_campaign_rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_timestamp != 0 {
            os.write_int64(1, self.start_timestamp)?;
        }
        for v in &self.max_campaign_rewards {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CampaignRewardPool {
        CampaignRewardPool::new()
    }

    fn default_instance() -> &'static CampaignRewardPool {
        static instance: ::protobuf::rt::LazyV2<CampaignRewardPool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CampaignRewardPool::new)
    }
}

impl ::protobuf::Clear for CampaignRewardPool {
    fn clear(&mut self) {
        self.start_timestamp = 0;
        self.max_campaign_rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CampaignRewardPool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradingRewardCampaignInfo {
    // message fields
    pub campaign_duration_seconds: i64,
    pub quote_denoms: ::protobuf::RepeatedField<::std::string::String>,
    pub trading_reward_boost_info: ::protobuf::SingularPtrField<TradingRewardCampaignBoostInfo>,
    pub disqualified_market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradingRewardCampaignInfo {
    fn default() -> &'a TradingRewardCampaignInfo {
        <TradingRewardCampaignInfo as ::protobuf::Message>::default_instance()
    }
}

impl TradingRewardCampaignInfo {
    pub fn new() -> TradingRewardCampaignInfo {
        ::std::default::Default::default()
    }

    // int64 campaign_duration_seconds = 1;


    pub fn get_campaign_duration_seconds(&self) -> i64 {
        self.campaign_duration_seconds
    }
    pub fn clear_campaign_duration_seconds(&mut self) {
        self.campaign_duration_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_campaign_duration_seconds(&mut self, v: i64) {
        self.campaign_duration_seconds = v;
    }

    // repeated string quote_denoms = 2;


    pub fn get_quote_denoms(&self) -> &[::std::string::String] {
        &self.quote_denoms
    }
    pub fn clear_quote_denoms(&mut self) {
        self.quote_denoms.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denoms(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quote_denoms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quote_denoms(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quote_denoms
    }

    // Take field
    pub fn take_quote_denoms(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quote_denoms, ::protobuf::RepeatedField::new())
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3;


    pub fn get_trading_reward_boost_info(&self) -> &TradingRewardCampaignBoostInfo {
        self.trading_reward_boost_info.as_ref().unwrap_or_else(|| <TradingRewardCampaignBoostInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trading_reward_boost_info(&mut self) {
        self.trading_reward_boost_info.clear();
    }

    pub fn has_trading_reward_boost_info(&self) -> bool {
        self.trading_reward_boost_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_boost_info(&mut self, v: TradingRewardCampaignBoostInfo) {
        self.trading_reward_boost_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_reward_boost_info(&mut self) -> &mut TradingRewardCampaignBoostInfo {
        if self.trading_reward_boost_info.is_none() {
            self.trading_reward_boost_info.set_default();
        }
        self.trading_reward_boost_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_reward_boost_info(&mut self) -> TradingRewardCampaignBoostInfo {
        self.trading_reward_boost_info.take().unwrap_or_else(|| TradingRewardCampaignBoostInfo::new())
    }

    // repeated string disqualified_market_ids = 4;


    pub fn get_disqualified_market_ids(&self) -> &[::std::string::String] {
        &self.disqualified_market_ids
    }
    pub fn clear_disqualified_market_ids(&mut self) {
        self.disqualified_market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_disqualified_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.disqualified_market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disqualified_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.disqualified_market_ids
    }

    // Take field
    pub fn take_disqualified_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.disqualified_market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradingRewardCampaignInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.trading_reward_boost_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.campaign_duration_seconds = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quote_denoms)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trading_reward_boost_info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.disqualified_market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.campaign_duration_seconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.campaign_duration_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.quote_denoms {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.trading_reward_boost_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.disqualified_market_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.campaign_duration_seconds != 0 {
            os.write_int64(1, self.campaign_duration_seconds)?;
        }
        for v in &self.quote_denoms {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.trading_reward_boost_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.disqualified_market_ids {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradingRewardCampaignInfo {
        TradingRewardCampaignInfo::new()
    }

    fn default_instance() -> &'static TradingRewardCampaignInfo {
        static instance: ::protobuf::rt::LazyV2<TradingRewardCampaignInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradingRewardCampaignInfo::new)
    }
}

impl ::protobuf::Clear for TradingRewardCampaignInfo {
    fn clear(&mut self) {
        self.campaign_duration_seconds = 0;
        self.quote_denoms.clear();
        self.trading_reward_boost_info.clear();
        self.disqualified_market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradingRewardCampaignInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountTierInfo {
    // message fields
    pub maker_discount_rate: ::std::string::String,
    pub taker_discount_rate: ::std::string::String,
    pub staked_amount: ::std::string::String,
    pub volume: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountTierInfo {
    fn default() -> &'a FeeDiscountTierInfo {
        <FeeDiscountTierInfo as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountTierInfo {
    pub fn new() -> FeeDiscountTierInfo {
        ::std::default::Default::default()
    }

    // string maker_discount_rate = 1;


    pub fn get_maker_discount_rate(&self) -> &str {
        &self.maker_discount_rate
    }
    pub fn clear_maker_discount_rate(&mut self) {
        self.maker_discount_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_discount_rate(&mut self, v: ::std::string::String) {
        self.maker_discount_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_discount_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_discount_rate
    }

    // Take field
    pub fn take_maker_discount_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_discount_rate, ::std::string::String::new())
    }

    // string taker_discount_rate = 2;


    pub fn get_taker_discount_rate(&self) -> &str {
        &self.taker_discount_rate
    }
    pub fn clear_taker_discount_rate(&mut self) {
        self.taker_discount_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_discount_rate(&mut self, v: ::std::string::String) {
        self.taker_discount_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_discount_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_discount_rate
    }

    // Take field
    pub fn take_taker_discount_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_discount_rate, ::std::string::String::new())
    }

    // string staked_amount = 3;


    pub fn get_staked_amount(&self) -> &str {
        &self.staked_amount
    }
    pub fn clear_staked_amount(&mut self) {
        self.staked_amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_staked_amount(&mut self, v: ::std::string::String) {
        self.staked_amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_staked_amount(&mut self) -> &mut ::std::string::String {
        &mut self.staked_amount
    }

    // Take field
    pub fn take_staked_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.staked_amount, ::std::string::String::new())
    }

    // string volume = 4;


    pub fn get_volume(&self) -> &str {
        &self.volume
    }
    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        &mut self.volume
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volume, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeeDiscountTierInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_discount_rate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_discount_rate)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.staked_amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.maker_discount_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.maker_discount_rate);
        }
        if !self.taker_discount_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.taker_discount_rate);
        }
        if !self.staked_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.staked_amount);
        }
        if !self.volume.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.volume);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.maker_discount_rate.is_empty() {
            os.write_string(1, &self.maker_discount_rate)?;
        }
        if !self.taker_discount_rate.is_empty() {
            os.write_string(2, &self.taker_discount_rate)?;
        }
        if !self.staked_amount.is_empty() {
            os.write_string(3, &self.staked_amount)?;
        }
        if !self.volume.is_empty() {
            os.write_string(4, &self.volume)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountTierInfo {
        FeeDiscountTierInfo::new()
    }

    fn default_instance() -> &'static FeeDiscountTierInfo {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountTierInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountTierInfo::new)
    }
}

impl ::protobuf::Clear for FeeDiscountTierInfo {
    fn clear(&mut self) {
        self.maker_discount_rate.clear();
        self.taker_discount_rate.clear();
        self.staked_amount.clear();
        self.volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountTierInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountSchedule {
    // message fields
    pub bucket_count: u64,
    pub bucket_duration: i64,
    pub quote_denoms: ::protobuf::RepeatedField<::std::string::String>,
    pub tier_infos: ::protobuf::RepeatedField<FeeDiscountTierInfo>,
    pub disqualified_market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountSchedule {
    fn default() -> &'a FeeDiscountSchedule {
        <FeeDiscountSchedule as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountSchedule {
    pub fn new() -> FeeDiscountSchedule {
        ::std::default::Default::default()
    }

    // uint64 bucket_count = 1;


    pub fn get_bucket_count(&self) -> u64 {
        self.bucket_count
    }
    pub fn clear_bucket_count(&mut self) {
        self.bucket_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_bucket_count(&mut self, v: u64) {
        self.bucket_count = v;
    }

    // int64 bucket_duration = 2;


    pub fn get_bucket_duration(&self) -> i64 {
        self.bucket_duration
    }
    pub fn clear_bucket_duration(&mut self) {
        self.bucket_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_bucket_duration(&mut self, v: i64) {
        self.bucket_duration = v;
    }

    // repeated string quote_denoms = 3;


    pub fn get_quote_denoms(&self) -> &[::std::string::String] {
        &self.quote_denoms
    }
    pub fn clear_quote_denoms(&mut self) {
        self.quote_denoms.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denoms(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.quote_denoms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quote_denoms(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.quote_denoms
    }

    // Take field
    pub fn take_quote_denoms(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.quote_denoms, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.FeeDiscountTierInfo tier_infos = 4;


    pub fn get_tier_infos(&self) -> &[FeeDiscountTierInfo] {
        &self.tier_infos
    }
    pub fn clear_tier_infos(&mut self) {
        self.tier_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_tier_infos(&mut self, v: ::protobuf::RepeatedField<FeeDiscountTierInfo>) {
        self.tier_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tier_infos(&mut self) -> &mut ::protobuf::RepeatedField<FeeDiscountTierInfo> {
        &mut self.tier_infos
    }

    // Take field
    pub fn take_tier_infos(&mut self) -> ::protobuf::RepeatedField<FeeDiscountTierInfo> {
        ::std::mem::replace(&mut self.tier_infos, ::protobuf::RepeatedField::new())
    }

    // repeated string disqualified_market_ids = 5;


    pub fn get_disqualified_market_ids(&self) -> &[::std::string::String] {
        &self.disqualified_market_ids
    }
    pub fn clear_disqualified_market_ids(&mut self) {
        self.disqualified_market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_disqualified_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.disqualified_market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disqualified_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.disqualified_market_ids
    }

    // Take field
    pub fn take_disqualified_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.disqualified_market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FeeDiscountSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.tier_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bucket_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bucket_duration = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.quote_denoms)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tier_infos)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.disqualified_market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bucket_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bucket_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bucket_duration != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bucket_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.quote_denoms {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.tier_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.disqualified_market_ids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bucket_count != 0 {
            os.write_uint64(1, self.bucket_count)?;
        }
        if self.bucket_duration != 0 {
            os.write_int64(2, self.bucket_duration)?;
        }
        for v in &self.quote_denoms {
            os.write_string(3, &v)?;
        };
        for v in &self.tier_infos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.disqualified_market_ids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountSchedule {
        FeeDiscountSchedule::new()
    }

    fn default_instance() -> &'static FeeDiscountSchedule {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountSchedule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountSchedule::new)
    }
}

impl ::protobuf::Clear for FeeDiscountSchedule {
    fn clear(&mut self) {
        self.bucket_count = 0;
        self.bucket_duration = 0;
        self.quote_denoms.clear();
        self.tier_infos.clear();
        self.disqualified_market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeeDiscountTierTTL {
    // message fields
    pub tier: u64,
    pub ttl_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeDiscountTierTTL {
    fn default() -> &'a FeeDiscountTierTTL {
        <FeeDiscountTierTTL as ::protobuf::Message>::default_instance()
    }
}

impl FeeDiscountTierTTL {
    pub fn new() -> FeeDiscountTierTTL {
        ::std::default::Default::default()
    }

    // uint64 tier = 1;


    pub fn get_tier(&self) -> u64 {
        self.tier
    }
    pub fn clear_tier(&mut self) {
        self.tier = 0;
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u64) {
        self.tier = v;
    }

    // int64 ttl_timestamp = 2;


    pub fn get_ttl_timestamp(&self) -> i64 {
        self.ttl_timestamp
    }
    pub fn clear_ttl_timestamp(&mut self) {
        self.ttl_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl_timestamp(&mut self, v: i64) {
        self.ttl_timestamp = v;
    }
}

impl ::protobuf::Message for FeeDiscountTierTTL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tier = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ttl_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tier != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tier, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ttl_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ttl_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tier != 0 {
            os.write_uint64(1, self.tier)?;
        }
        if self.ttl_timestamp != 0 {
            os.write_int64(2, self.ttl_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeDiscountTierTTL {
        FeeDiscountTierTTL::new()
    }

    fn default_instance() -> &'static FeeDiscountTierTTL {
        static instance: ::protobuf::rt::LazyV2<FeeDiscountTierTTL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeDiscountTierTTL::new)
    }
}

impl ::protobuf::Clear for FeeDiscountTierTTL {
    fn clear(&mut self) {
        self.tier = 0;
        self.ttl_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeDiscountTierTTL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeRecord {
    // message fields
    pub maker_volume: ::std::string::String,
    pub taker_volume: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeRecord {
    fn default() -> &'a VolumeRecord {
        <VolumeRecord as ::protobuf::Message>::default_instance()
    }
}

impl VolumeRecord {
    pub fn new() -> VolumeRecord {
        ::std::default::Default::default()
    }

    // string maker_volume = 1;


    pub fn get_maker_volume(&self) -> &str {
        &self.maker_volume
    }
    pub fn clear_maker_volume(&mut self) {
        self.maker_volume.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_volume(&mut self, v: ::std::string::String) {
        self.maker_volume = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_volume(&mut self) -> &mut ::std::string::String {
        &mut self.maker_volume
    }

    // Take field
    pub fn take_maker_volume(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_volume, ::std::string::String::new())
    }

    // string taker_volume = 2;


    pub fn get_taker_volume(&self) -> &str {
        &self.taker_volume
    }
    pub fn clear_taker_volume(&mut self) {
        self.taker_volume.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_volume(&mut self, v: ::std::string::String) {
        self.taker_volume = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_volume(&mut self) -> &mut ::std::string::String {
        &mut self.taker_volume
    }

    // Take field
    pub fn take_taker_volume(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_volume, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VolumeRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_volume)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.maker_volume.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.maker_volume);
        }
        if !self.taker_volume.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.taker_volume);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.maker_volume.is_empty() {
            os.write_string(1, &self.maker_volume)?;
        }
        if !self.taker_volume.is_empty() {
            os.write_string(2, &self.taker_volume)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeRecord {
        VolumeRecord::new()
    }

    fn default_instance() -> &'static VolumeRecord {
        static instance: ::protobuf::rt::LazyV2<VolumeRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeRecord::new)
    }
}

impl ::protobuf::Clear for VolumeRecord {
    fn clear(&mut self) {
        self.maker_volume.clear();
        self.taker_volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountRewards {
    // message fields
    pub account: ::std::string::String,
    pub rewards: ::protobuf::RepeatedField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountRewards {
    fn default() -> &'a AccountRewards {
        <AccountRewards as ::protobuf::Message>::default_instance()
    }
}

impl AccountRewards {
    pub fn new() -> AccountRewards {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // repeated .cosmos.base.v1beta1.Coin rewards = 2;


    pub fn get_rewards(&self) -> &[super::coin::Coin] {
        &self.rewards
    }
    pub fn clear_rewards(&mut self) {
        self.rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewards(&mut self, v: ::protobuf::RepeatedField<super::coin::Coin>) {
        self.rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewards(&mut self) -> &mut ::protobuf::RepeatedField<super::coin::Coin> {
        &mut self.rewards
    }

    // Take field
    pub fn take_rewards(&mut self) -> ::protobuf::RepeatedField<super::coin::Coin> {
        ::std::mem::replace(&mut self.rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccountRewards {
    fn is_initialized(&self) -> bool {
        for v in &self.rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        for v in &self.rewards {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountRewards {
        AccountRewards::new()
    }

    fn default_instance() -> &'static AccountRewards {
        static instance: ::protobuf::rt::LazyV2<AccountRewards> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountRewards::new)
    }
}

impl ::protobuf::Clear for AccountRewards {
    fn clear(&mut self) {
        self.account.clear();
        self.rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountRewards {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradeRecords {
    // message fields
    pub market_id: ::std::string::String,
    pub latest_trade_records: ::protobuf::RepeatedField<TradeRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeRecords {
    fn default() -> &'a TradeRecords {
        <TradeRecords as ::protobuf::Message>::default_instance()
    }
}

impl TradeRecords {
    pub fn new() -> TradeRecords {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.TradeRecord latest_trade_records = 2;


    pub fn get_latest_trade_records(&self) -> &[TradeRecord] {
        &self.latest_trade_records
    }
    pub fn clear_latest_trade_records(&mut self) {
        self.latest_trade_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_trade_records(&mut self, v: ::protobuf::RepeatedField<TradeRecord>) {
        self.latest_trade_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_trade_records(&mut self) -> &mut ::protobuf::RepeatedField<TradeRecord> {
        &mut self.latest_trade_records
    }

    // Take field
    pub fn take_latest_trade_records(&mut self) -> ::protobuf::RepeatedField<TradeRecord> {
        ::std::mem::replace(&mut self.latest_trade_records, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradeRecords {
    fn is_initialized(&self) -> bool {
        for v in &self.latest_trade_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.latest_trade_records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        for value in &self.latest_trade_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        for v in &self.latest_trade_records {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeRecords {
        TradeRecords::new()
    }

    fn default_instance() -> &'static TradeRecords {
        static instance: ::protobuf::rt::LazyV2<TradeRecords> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradeRecords::new)
    }
}

impl ::protobuf::Clear for TradeRecords {
    fn clear(&mut self) {
        self.market_id.clear();
        self.latest_trade_records.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeRecords {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountIDs {
    // message fields
    pub subaccount_ids: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountIDs {
    fn default() -> &'a SubaccountIDs {
        <SubaccountIDs as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountIDs {
    pub fn new() -> SubaccountIDs {
        ::std::default::Default::default()
    }

    // repeated bytes subaccount_ids = 1;


    pub fn get_subaccount_ids(&self) -> &[::std::vec::Vec<u8>] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountIDs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subaccount_ids {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountIDs {
        SubaccountIDs::new()
    }

    fn default_instance() -> &'static SubaccountIDs {
        static instance: ::protobuf::rt::LazyV2<SubaccountIDs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountIDs::new)
    }
}

impl ::protobuf::Clear for SubaccountIDs {
    fn clear(&mut self) {
        self.subaccount_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountIDs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradeRecord {
    // message fields
    pub timestamp: i64,
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeRecord {
    fn default() -> &'a TradeRecord {
        <TradeRecord as ::protobuf::Message>::default_instance()
    }
}

impl TradeRecord {
    pub fn new() -> TradeRecord {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string price = 2;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 3;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TradeRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if !self.price.is_empty() {
            os.write_string(2, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(3, &self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeRecord {
        TradeRecord::new()
    }

    fn default_instance() -> &'static TradeRecord {
        static instance: ::protobuf::rt::LazyV2<TradeRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradeRecord::new)
    }
}

impl ::protobuf::Clear for TradeRecord {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.price.clear();
        self.quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Level {
    // message fields
    pub p: ::std::string::String,
    pub q: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Level {
    fn default() -> &'a Level {
        <Level as ::protobuf::Message>::default_instance()
    }
}

impl Level {
    pub fn new() -> Level {
        ::std::default::Default::default()
    }

    // string p = 1;


    pub fn get_p(&self) -> &str {
        &self.p
    }
    pub fn clear_p(&mut self) {
        self.p.clear();
    }

    // Param is passed by value, moved
    pub fn set_p(&mut self, v: ::std::string::String) {
        self.p = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p(&mut self) -> &mut ::std::string::String {
        &mut self.p
    }

    // Take field
    pub fn take_p(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.p, ::std::string::String::new())
    }

    // string q = 2;


    pub fn get_q(&self) -> &str {
        &self.q
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: ::std::string::String) {
        self.q = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut ::std::string::String {
        &mut self.q
    }

    // Take field
    pub fn take_q(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.q, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Level {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.p)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.q)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.p.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.p);
        }
        if !self.q.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.q);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.p.is_empty() {
            os.write_string(1, &self.p)?;
        }
        if !self.q.is_empty() {
            os.write_string(2, &self.q)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Level {
        Level::new()
    }

    fn default_instance() -> &'static Level {
        static instance: ::protobuf::rt::LazyV2<Level> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Level::new)
    }
}

impl ::protobuf::Clear for Level {
    fn clear(&mut self) {
        self.p.clear();
        self.q.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Level {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AggregateSubaccountVolumeRecord {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_volumes: ::protobuf::RepeatedField<MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AggregateSubaccountVolumeRecord {
    fn default() -> &'a AggregateSubaccountVolumeRecord {
        <AggregateSubaccountVolumeRecord as ::protobuf::Message>::default_instance()
    }
}

impl AggregateSubaccountVolumeRecord {
    pub fn new() -> AggregateSubaccountVolumeRecord {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2;


    pub fn get_market_volumes(&self) -> &[MarketVolume] {
        &self.market_volumes
    }
    pub fn clear_market_volumes(&mut self) {
        self.market_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_volumes(&mut self, v: ::protobuf::RepeatedField<MarketVolume>) {
        self.market_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_volumes(&mut self) -> &mut ::protobuf::RepeatedField<MarketVolume> {
        &mut self.market_volumes
    }

    // Take field
    pub fn take_market_volumes(&mut self) -> ::protobuf::RepeatedField<MarketVolume> {
        ::std::mem::replace(&mut self.market_volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AggregateSubaccountVolumeRecord {
    fn is_initialized(&self) -> bool {
        for v in &self.market_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        for value in &self.market_volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        for v in &self.market_volumes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregateSubaccountVolumeRecord {
        AggregateSubaccountVolumeRecord::new()
    }

    fn default_instance() -> &'static AggregateSubaccountVolumeRecord {
        static instance: ::protobuf::rt::LazyV2<AggregateSubaccountVolumeRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AggregateSubaccountVolumeRecord::new)
    }
}

impl ::protobuf::Clear for AggregateSubaccountVolumeRecord {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregateSubaccountVolumeRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AggregateAccountVolumeRecord {
    // message fields
    pub account: ::std::string::String,
    pub market_volumes: ::protobuf::RepeatedField<MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AggregateAccountVolumeRecord {
    fn default() -> &'a AggregateAccountVolumeRecord {
        <AggregateAccountVolumeRecord as ::protobuf::Message>::default_instance()
    }
}

impl AggregateAccountVolumeRecord {
    pub fn new() -> AggregateAccountVolumeRecord {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.MarketVolume market_volumes = 2;


    pub fn get_market_volumes(&self) -> &[MarketVolume] {
        &self.market_volumes
    }
    pub fn clear_market_volumes(&mut self) {
        self.market_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_volumes(&mut self, v: ::protobuf::RepeatedField<MarketVolume>) {
        self.market_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_volumes(&mut self) -> &mut ::protobuf::RepeatedField<MarketVolume> {
        &mut self.market_volumes
    }

    // Take field
    pub fn take_market_volumes(&mut self) -> ::protobuf::RepeatedField<MarketVolume> {
        ::std::mem::replace(&mut self.market_volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AggregateAccountVolumeRecord {
    fn is_initialized(&self) -> bool {
        for v in &self.market_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.market_volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        for value in &self.market_volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        for v in &self.market_volumes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregateAccountVolumeRecord {
        AggregateAccountVolumeRecord::new()
    }

    fn default_instance() -> &'static AggregateAccountVolumeRecord {
        static instance: ::protobuf::rt::LazyV2<AggregateAccountVolumeRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AggregateAccountVolumeRecord::new)
    }
}

impl ::protobuf::Clear for AggregateAccountVolumeRecord {
    fn clear(&mut self) {
        self.account.clear();
        self.market_volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregateAccountVolumeRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketVolume {
    // message fields
    pub market_id: ::std::string::String,
    pub volume: ::protobuf::SingularPtrField<VolumeRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketVolume {
    fn default() -> &'a MarketVolume {
        <MarketVolume as ::protobuf::Message>::default_instance()
    }
}

impl MarketVolume {
    pub fn new() -> MarketVolume {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.VolumeRecord volume = 2;


    pub fn get_volume(&self) -> &VolumeRecord {
        self.volume.as_ref().unwrap_or_else(|| <VolumeRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: VolumeRecord) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut VolumeRecord {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> VolumeRecord {
        self.volume.take().unwrap_or_else(|| VolumeRecord::new())
    }
}

impl ::protobuf::Message for MarketVolume {
    fn is_initialized(&self) -> bool {
        for v in &self.volume {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketVolume {
        MarketVolume::new()
    }

    fn default_instance() -> &'static MarketVolume {
        static instance: ::protobuf::rt::LazyV2<MarketVolume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketVolume::new)
    }
}

impl ::protobuf::Clear for MarketVolume {
    fn clear(&mut self) {
        self.market_id.clear();
        self.volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DenomDecimals {
    // message fields
    pub denom: ::std::string::String,
    pub decimals: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DenomDecimals {
    fn default() -> &'a DenomDecimals {
        <DenomDecimals as ::protobuf::Message>::default_instance()
    }
}

impl DenomDecimals {
    pub fn new() -> DenomDecimals {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // uint64 decimals = 2;


    pub fn get_decimals(&self) -> u64 {
        self.decimals
    }
    pub fn clear_decimals(&mut self) {
        self.decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_decimals(&mut self, v: u64) {
        self.decimals = v;
    }
}

impl ::protobuf::Message for DenomDecimals {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.decimals = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        if self.decimals != 0 {
            my_size += ::protobuf::rt::value_size(2, self.decimals, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        if self.decimals != 0 {
            os.write_uint64(2, self.decimals)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DenomDecimals {
        DenomDecimals::new()
    }

    fn default_instance() -> &'static DenomDecimals {
        static instance: ::protobuf::rt::LazyV2<DenomDecimals> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DenomDecimals::new)
    }
}

impl ::protobuf::Clear for DenomDecimals {
    fn clear(&mut self) {
        self.denom.clear();
        self.decimals = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DenomDecimals {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AtomicMarketOrderAccessLevel {
    Nobody = 0,
    BeginBlockerSmartContractsOnly = 1,
    SmartContractsOnly = 2,
    Everyone = 3,
}

impl ::protobuf::ProtobufEnum for AtomicMarketOrderAccessLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AtomicMarketOrderAccessLevel> {
        match value {
            0 => ::std::option::Option::Some(AtomicMarketOrderAccessLevel::Nobody),
            1 => ::std::option::Option::Some(AtomicMarketOrderAccessLevel::BeginBlockerSmartContractsOnly),
            2 => ::std::option::Option::Some(AtomicMarketOrderAccessLevel::SmartContractsOnly),
            3 => ::std::option::Option::Some(AtomicMarketOrderAccessLevel::Everyone),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AtomicMarketOrderAccessLevel] = &[
            AtomicMarketOrderAccessLevel::Nobody,
            AtomicMarketOrderAccessLevel::BeginBlockerSmartContractsOnly,
            AtomicMarketOrderAccessLevel::SmartContractsOnly,
            AtomicMarketOrderAccessLevel::Everyone,
        ];
        values
    }
}

impl ::std::marker::Copy for AtomicMarketOrderAccessLevel {
}

impl ::std::default::Default for AtomicMarketOrderAccessLevel {
    fn default() -> Self {
        AtomicMarketOrderAccessLevel::Nobody
    }
}

impl ::protobuf::reflect::ProtobufValue for AtomicMarketOrderAccessLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MarketStatus {
    Unspecified = 0,
    Active = 1,
    Paused = 2,
    Demolished = 3,
    Expired = 4,
}

impl ::protobuf::ProtobufEnum for MarketStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MarketStatus> {
        match value {
            0 => ::std::option::Option::Some(MarketStatus::Unspecified),
            1 => ::std::option::Option::Some(MarketStatus::Active),
            2 => ::std::option::Option::Some(MarketStatus::Paused),
            3 => ::std::option::Option::Some(MarketStatus::Demolished),
            4 => ::std::option::Option::Some(MarketStatus::Expired),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MarketStatus] = &[
            MarketStatus::Unspecified,
            MarketStatus::Active,
            MarketStatus::Paused,
            MarketStatus::Demolished,
            MarketStatus::Expired,
        ];
        values
    }
}

impl ::std::marker::Copy for MarketStatus {
}

impl ::std::default::Default for MarketStatus {
    fn default() -> Self {
        MarketStatus::Unspecified
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderType {
    UNSPECIFIED = 0,
    BUY = 1,
    SELL = 2,
    STOP_BUY = 3,
    STOP_SELL = 4,
    TAKE_BUY = 5,
    TAKE_SELL = 6,
    BUY_PO = 7,
    SELL_PO = 8,
    BUY_ATOMIC = 9,
    SELL_ATOMIC = 10,
}

impl ::protobuf::ProtobufEnum for OrderType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderType> {
        match value {
            0 => ::std::option::Option::Some(OrderType::UNSPECIFIED),
            1 => ::std::option::Option::Some(OrderType::BUY),
            2 => ::std::option::Option::Some(OrderType::SELL),
            3 => ::std::option::Option::Some(OrderType::STOP_BUY),
            4 => ::std::option::Option::Some(OrderType::STOP_SELL),
            5 => ::std::option::Option::Some(OrderType::TAKE_BUY),
            6 => ::std::option::Option::Some(OrderType::TAKE_SELL),
            7 => ::std::option::Option::Some(OrderType::BUY_PO),
            8 => ::std::option::Option::Some(OrderType::SELL_PO),
            9 => ::std::option::Option::Some(OrderType::BUY_ATOMIC),
            10 => ::std::option::Option::Some(OrderType::SELL_ATOMIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderType] = &[
            OrderType::UNSPECIFIED,
            OrderType::BUY,
            OrderType::SELL,
            OrderType::STOP_BUY,
            OrderType::STOP_SELL,
            OrderType::TAKE_BUY,
            OrderType::TAKE_SELL,
            OrderType::BUY_PO,
            OrderType::SELL_PO,
            OrderType::BUY_ATOMIC,
            OrderType::SELL_ATOMIC,
        ];
        values
    }
}

impl ::std::marker::Copy for OrderType {
}

impl ::std::default::Default for OrderType {
    fn default() -> Self {
        OrderType::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExecutionType {
    UnspecifiedExecutionType = 0,
    Market = 1,
    LimitFill = 2,
    LimitMatchRestingOrder = 3,
    LimitMatchNewOrder = 4,
    MarketLiquidation = 5,
    ExpiryMarketSettlement = 6,
}

impl ::protobuf::ProtobufEnum for ExecutionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExecutionType> {
        match value {
            0 => ::std::option::Option::Some(ExecutionType::UnspecifiedExecutionType),
            1 => ::std::option::Option::Some(ExecutionType::Market),
            2 => ::std::option::Option::Some(ExecutionType::LimitFill),
            3 => ::std::option::Option::Some(ExecutionType::LimitMatchRestingOrder),
            4 => ::std::option::Option::Some(ExecutionType::LimitMatchNewOrder),
            5 => ::std::option::Option::Some(ExecutionType::MarketLiquidation),
            6 => ::std::option::Option::Some(ExecutionType::ExpiryMarketSettlement),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExecutionType] = &[
            ExecutionType::UnspecifiedExecutionType,
            ExecutionType::Market,
            ExecutionType::LimitFill,
            ExecutionType::LimitMatchRestingOrder,
            ExecutionType::LimitMatchNewOrder,
            ExecutionType::MarketLiquidation,
            ExecutionType::ExpiryMarketSettlement,
        ];
        values
    }
}

impl ::std::marker::Copy for ExecutionType {
}

impl ::std::default::Default for ExecutionType {
    fn default() -> Self {
        ExecutionType::UnspecifiedExecutionType
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderMask {
    UNUSED = 0,
    ANY = 1,
    REGULAR = 2,
    CONDITIONAL = 4,
    DIRECTION_BUY_OR_HIGHER = 8,
    DIRECTION_SELL_OR_LOWER = 16,
    TYPE_MARKET = 32,
    TYPE_LIMIT = 64,
}

impl ::protobuf::ProtobufEnum for OrderMask {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderMask> {
        match value {
            0 => ::std::option::Option::Some(OrderMask::UNUSED),
            1 => ::std::option::Option::Some(OrderMask::ANY),
            2 => ::std::option::Option::Some(OrderMask::REGULAR),
            4 => ::std::option::Option::Some(OrderMask::CONDITIONAL),
            8 => ::std::option::Option::Some(OrderMask::DIRECTION_BUY_OR_HIGHER),
            16 => ::std::option::Option::Some(OrderMask::DIRECTION_SELL_OR_LOWER),
            32 => ::std::option::Option::Some(OrderMask::TYPE_MARKET),
            64 => ::std::option::Option::Some(OrderMask::TYPE_LIMIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderMask] = &[
            OrderMask::UNUSED,
            OrderMask::ANY,
            OrderMask::REGULAR,
            OrderMask::CONDITIONAL,
            OrderMask::DIRECTION_BUY_OR_HIGHER,
            OrderMask::DIRECTION_SELL_OR_LOWER,
            OrderMask::TYPE_MARKET,
            OrderMask::TYPE_LIMIT,
        ];
        values
    }
}

impl ::std::marker::Copy for OrderMask {
}

impl ::std::default::Default for OrderMask {
    fn default() -> Self {
        OrderMask::UNUSED
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
