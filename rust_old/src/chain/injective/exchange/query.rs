// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/exchange/v1beta1/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Subaccount {
    // message fields
    pub trader: ::std::string::String,
    pub subaccount_nonce: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subaccount {
    fn default() -> &'a Subaccount {
        <Subaccount as ::protobuf::Message>::default_instance()
    }
}

impl Subaccount {
    pub fn new() -> Subaccount {
        ::std::default::Default::default()
    }

    // string trader = 1;


    pub fn get_trader(&self) -> &str {
        &self.trader
    }
    pub fn clear_trader(&mut self) {
        self.trader.clear();
    }

    // Param is passed by value, moved
    pub fn set_trader(&mut self, v: ::std::string::String) {
        self.trader = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trader(&mut self) -> &mut ::std::string::String {
        &mut self.trader
    }

    // Take field
    pub fn take_trader(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trader, ::std::string::String::new())
    }

    // uint32 subaccount_nonce = 2;


    pub fn get_subaccount_nonce(&self) -> u32 {
        self.subaccount_nonce
    }
    pub fn clear_subaccount_nonce(&mut self) {
        self.subaccount_nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_nonce(&mut self, v: u32) {
        self.subaccount_nonce = v;
    }
}

impl ::protobuf::Message for Subaccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trader)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.subaccount_nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trader.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.trader);
        }
        if self.subaccount_nonce != 0 {
            my_size += ::protobuf::rt::value_size(2, self.subaccount_nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trader.is_empty() {
            os.write_string(1, &self.trader)?;
        }
        if self.subaccount_nonce != 0 {
            os.write_uint32(2, self.subaccount_nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subaccount {
        Subaccount::new()
    }

    fn default_instance() -> &'static Subaccount {
        static instance: ::protobuf::rt::LazyV2<Subaccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Subaccount::new)
    }
}

impl ::protobuf::Clear for Subaccount {
    fn clear(&mut self) {
        self.trader.clear();
        self.subaccount_nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Subaccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountOrdersRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountOrdersRequest {
    fn default() -> &'a QuerySubaccountOrdersRequest {
        <QuerySubaccountOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountOrdersRequest {
    pub fn new() -> QuerySubaccountOrdersRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountOrdersRequest {
        QuerySubaccountOrdersRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountOrdersRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountOrdersResponse {
    // message fields
    pub buy_orders: ::protobuf::RepeatedField<super::exchange::SubaccountOrderData>,
    pub sell_orders: ::protobuf::RepeatedField<super::exchange::SubaccountOrderData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountOrdersResponse {
    fn default() -> &'a QuerySubaccountOrdersResponse {
        <QuerySubaccountOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountOrdersResponse {
    pub fn new() -> QuerySubaccountOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.SubaccountOrderData buy_orders = 1;


    pub fn get_buy_orders(&self) -> &[super::exchange::SubaccountOrderData] {
        &self.buy_orders
    }
    pub fn clear_buy_orders(&mut self) {
        self.buy_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SubaccountOrderData>) {
        self.buy_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buy_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SubaccountOrderData> {
        &mut self.buy_orders
    }

    // Take field
    pub fn take_buy_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SubaccountOrderData> {
        ::std::mem::replace(&mut self.buy_orders, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.SubaccountOrderData sell_orders = 2;


    pub fn get_sell_orders(&self) -> &[super::exchange::SubaccountOrderData] {
        &self.sell_orders
    }
    pub fn clear_sell_orders(&mut self) {
        self.sell_orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_orders(&mut self, v: ::protobuf::RepeatedField<super::exchange::SubaccountOrderData>) {
        self.sell_orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sell_orders(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SubaccountOrderData> {
        &mut self.sell_orders
    }

    // Take field
    pub fn take_sell_orders(&mut self) -> ::protobuf::RepeatedField<super::exchange::SubaccountOrderData> {
        ::std::mem::replace(&mut self.sell_orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySubaccountOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.buy_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sell_orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buy_orders)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sell_orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buy_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sell_orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buy_orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sell_orders {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountOrdersResponse {
        QuerySubaccountOrdersResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountOrdersResponse {
    fn clear(&mut self) {
        self.buy_orders.clear();
        self.sell_orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrderbookMetadataWithMarket {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::exchange::SubaccountOrderbookMetadata>,
    pub market_id: ::std::string::String,
    pub isBuy: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrderbookMetadataWithMarket {
    fn default() -> &'a SubaccountOrderbookMetadataWithMarket {
        <SubaccountOrderbookMetadataWithMarket as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrderbookMetadataWithMarket {
    pub fn new() -> SubaccountOrderbookMetadataWithMarket {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.SubaccountOrderbookMetadata metadata = 1;


    pub fn get_metadata(&self) -> &super::exchange::SubaccountOrderbookMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::exchange::SubaccountOrderbookMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::exchange::SubaccountOrderbookMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::exchange::SubaccountOrderbookMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::exchange::SubaccountOrderbookMetadata {
        self.metadata.take().unwrap_or_else(|| super::exchange::SubaccountOrderbookMetadata::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool isBuy = 3;


    pub fn get_isBuy(&self) -> bool {
        self.isBuy
    }
    pub fn clear_isBuy(&mut self) {
        self.isBuy = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuy(&mut self, v: bool) {
        self.isBuy = v;
    }
}

impl ::protobuf::Message for SubaccountOrderbookMetadataWithMarket {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.isBuy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.isBuy != false {
            os.write_bool(3, self.isBuy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrderbookMetadataWithMarket {
        SubaccountOrderbookMetadataWithMarket::new()
    }

    fn default_instance() -> &'static SubaccountOrderbookMetadataWithMarket {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrderbookMetadataWithMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrderbookMetadataWithMarket::new)
    }
}

impl ::protobuf::Clear for SubaccountOrderbookMetadataWithMarket {
    fn clear(&mut self) {
        self.metadata.clear();
        self.market_id.clear();
        self.isBuy = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrderbookMetadataWithMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExchangeParamsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeParamsRequest {
    fn default() -> &'a QueryExchangeParamsRequest {
        <QueryExchangeParamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeParamsRequest {
    pub fn new() -> QueryExchangeParamsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryExchangeParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeParamsRequest {
        QueryExchangeParamsRequest::new()
    }

    fn default_instance() -> &'static QueryExchangeParamsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeParamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeParamsRequest::new)
    }
}

impl ::protobuf::Clear for QueryExchangeParamsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExchangeParamsResponse {
    // message fields
    pub params: ::protobuf::SingularPtrField<super::exchange::Params>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeParamsResponse {
    fn default() -> &'a QueryExchangeParamsResponse {
        <QueryExchangeParamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeParamsResponse {
    pub fn new() -> QueryExchangeParamsResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.Params params = 1;


    pub fn get_params(&self) -> &super::exchange::Params {
        self.params.as_ref().unwrap_or_else(|| <super::exchange::Params as ::protobuf::Message>::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: super::exchange::Params) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut super::exchange::Params {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> super::exchange::Params {
        self.params.take().unwrap_or_else(|| super::exchange::Params::new())
    }
}

impl ::protobuf::Message for QueryExchangeParamsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeParamsResponse {
        QueryExchangeParamsResponse::new()
    }

    fn default_instance() -> &'static QueryExchangeParamsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeParamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeParamsResponse::new)
    }
}

impl ::protobuf::Clear for QueryExchangeParamsResponse {
    fn clear(&mut self) {
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountDepositsRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub subaccount: ::protobuf::SingularPtrField<Subaccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountDepositsRequest {
    fn default() -> &'a QuerySubaccountDepositsRequest {
        <QuerySubaccountDepositsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountDepositsRequest {
    pub fn new() -> QuerySubaccountDepositsRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.Subaccount subaccount = 2;


    pub fn get_subaccount(&self) -> &Subaccount {
        self.subaccount.as_ref().unwrap_or_else(|| <Subaccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subaccount(&mut self) {
        self.subaccount.clear();
    }

    pub fn has_subaccount(&self) -> bool {
        self.subaccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subaccount(&mut self, v: Subaccount) {
        self.subaccount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount(&mut self) -> &mut Subaccount {
        if self.subaccount.is_none() {
            self.subaccount.set_default();
        }
        self.subaccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_subaccount(&mut self) -> Subaccount {
        self.subaccount.take().unwrap_or_else(|| Subaccount::new())
    }
}

impl ::protobuf::Message for QuerySubaccountDepositsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.subaccount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subaccount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if let Some(ref v) = self.subaccount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if let Some(ref v) = self.subaccount.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountDepositsRequest {
        QuerySubaccountDepositsRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountDepositsRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountDepositsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountDepositsRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountDepositsRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.subaccount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountDepositsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountDepositsResponse {
    // message fields
    pub deposits: ::std::collections::HashMap<::std::string::String, super::exchange::Deposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountDepositsResponse {
    fn default() -> &'a QuerySubaccountDepositsResponse {
        <QuerySubaccountDepositsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountDepositsResponse {
    pub fn new() -> QuerySubaccountDepositsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.QuerySubaccountDepositsResponse.deposits_MapEntry deposits = 1;


    pub fn get_deposits(&self) -> &::std::collections::HashMap<::std::string::String, super::exchange::Deposit> {
        &self.deposits
    }
    pub fn clear_deposits(&mut self) {
        self.deposits.clear();
    }

    // Param is passed by value, moved
    pub fn set_deposits(&mut self, v: ::std::collections::HashMap<::std::string::String, super::exchange::Deposit>) {
        self.deposits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deposits(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::exchange::Deposit> {
        &mut self.deposits
    }

    // Take field
    pub fn take_deposits(&mut self) -> ::std::collections::HashMap<::std::string::String, super::exchange::Deposit> {
        ::std::mem::replace(&mut self.deposits, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for QuerySubaccountDepositsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::exchange::Deposit>>(wire_type, is, &mut self.deposits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::exchange::Deposit>>(1, &self.deposits);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::exchange::Deposit>>(1, &self.deposits, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountDepositsResponse {
        QuerySubaccountDepositsResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountDepositsResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountDepositsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountDepositsResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountDepositsResponse {
    fn clear(&mut self) {
        self.deposits.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountDepositsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExchangeBalancesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeBalancesRequest {
    fn default() -> &'a QueryExchangeBalancesRequest {
        <QueryExchangeBalancesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeBalancesRequest {
    pub fn new() -> QueryExchangeBalancesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryExchangeBalancesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeBalancesRequest {
        QueryExchangeBalancesRequest::new()
    }

    fn default_instance() -> &'static QueryExchangeBalancesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeBalancesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeBalancesRequest::new)
    }
}

impl ::protobuf::Clear for QueryExchangeBalancesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeBalancesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExchangeBalancesResponse {
    // message fields
    pub balances: ::protobuf::RepeatedField<super::genesis::Balance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExchangeBalancesResponse {
    fn default() -> &'a QueryExchangeBalancesResponse {
        <QueryExchangeBalancesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryExchangeBalancesResponse {
    pub fn new() -> QueryExchangeBalancesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.Balance balances = 1;


    pub fn get_balances(&self) -> &[super::genesis::Balance] {
        &self.balances
    }
    pub fn clear_balances(&mut self) {
        self.balances.clear();
    }

    // Param is passed by value, moved
    pub fn set_balances(&mut self, v: ::protobuf::RepeatedField<super::genesis::Balance>) {
        self.balances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_balances(&mut self) -> &mut ::protobuf::RepeatedField<super::genesis::Balance> {
        &mut self.balances
    }

    // Take field
    pub fn take_balances(&mut self) -> ::protobuf::RepeatedField<super::genesis::Balance> {
        ::std::mem::replace(&mut self.balances, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryExchangeBalancesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.balances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.balances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.balances {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExchangeBalancesResponse {
        QueryExchangeBalancesResponse::new()
    }

    fn default_instance() -> &'static QueryExchangeBalancesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryExchangeBalancesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExchangeBalancesResponse::new)
    }
}

impl ::protobuf::Clear for QueryExchangeBalancesResponse {
    fn clear(&mut self) {
        self.balances.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExchangeBalancesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateVolumeRequest {
    // message fields
    pub account: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVolumeRequest {
    fn default() -> &'a QueryAggregateVolumeRequest {
        <QueryAggregateVolumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVolumeRequest {
    pub fn new() -> QueryAggregateVolumeRequest {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAggregateVolumeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVolumeRequest {
        QueryAggregateVolumeRequest::new()
    }

    fn default_instance() -> &'static QueryAggregateVolumeRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVolumeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVolumeRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVolumeRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVolumeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateVolumeResponse {
    // message fields
    pub aggregate_volumes: ::protobuf::RepeatedField<super::exchange::MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVolumeResponse {
    fn default() -> &'a QueryAggregateVolumeResponse {
        <QueryAggregateVolumeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVolumeResponse {
    pub fn new() -> QueryAggregateVolumeResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.MarketVolume aggregate_volumes = 1;


    pub fn get_aggregate_volumes(&self) -> &[super::exchange::MarketVolume] {
        &self.aggregate_volumes
    }
    pub fn clear_aggregate_volumes(&mut self) {
        self.aggregate_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketVolume>) {
        self.aggregate_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregate_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        &mut self.aggregate_volumes
    }

    // Take field
    pub fn take_aggregate_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        ::std::mem::replace(&mut self.aggregate_volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateVolumeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregate_volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.aggregate_volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aggregate_volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVolumeResponse {
        QueryAggregateVolumeResponse::new()
    }

    fn default_instance() -> &'static QueryAggregateVolumeResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVolumeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVolumeResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVolumeResponse {
    fn clear(&mut self) {
        self.aggregate_volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVolumeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateVolumesRequest {
    // message fields
    pub accounts: ::protobuf::RepeatedField<::std::string::String>,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVolumesRequest {
    fn default() -> &'a QueryAggregateVolumesRequest {
        <QueryAggregateVolumesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVolumesRequest {
    pub fn new() -> QueryAggregateVolumesRequest {
        ::std::default::Default::default()
    }

    // repeated string accounts = 1;


    pub fn get_accounts(&self) -> &[::std::string::String] {
        &self.accounts
    }
    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }

    // repeated string market_ids = 2;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateVolumesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accounts)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_string(1, &v)?;
        };
        for v in &self.market_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVolumesRequest {
        QueryAggregateVolumesRequest::new()
    }

    fn default_instance() -> &'static QueryAggregateVolumesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVolumesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVolumesRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVolumesRequest {
    fn clear(&mut self) {
        self.accounts.clear();
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVolumesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateVolumesResponse {
    // message fields
    pub aggregate_account_volumes: ::protobuf::RepeatedField<super::exchange::AggregateAccountVolumeRecord>,
    pub aggregate_market_volumes: ::protobuf::RepeatedField<super::exchange::MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateVolumesResponse {
    fn default() -> &'a QueryAggregateVolumesResponse {
        <QueryAggregateVolumesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateVolumesResponse {
    pub fn new() -> QueryAggregateVolumesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.AggregateAccountVolumeRecord aggregate_account_volumes = 1;


    pub fn get_aggregate_account_volumes(&self) -> &[super::exchange::AggregateAccountVolumeRecord] {
        &self.aggregate_account_volumes
    }
    pub fn clear_aggregate_account_volumes(&mut self) {
        self.aggregate_account_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_account_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::AggregateAccountVolumeRecord>) {
        self.aggregate_account_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregate_account_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::AggregateAccountVolumeRecord> {
        &mut self.aggregate_account_volumes
    }

    // Take field
    pub fn take_aggregate_account_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::AggregateAccountVolumeRecord> {
        ::std::mem::replace(&mut self.aggregate_account_volumes, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.MarketVolume aggregate_market_volumes = 2;


    pub fn get_aggregate_market_volumes(&self) -> &[super::exchange::MarketVolume] {
        &self.aggregate_market_volumes
    }
    pub fn clear_aggregate_market_volumes(&mut self) {
        self.aggregate_market_volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_aggregate_market_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketVolume>) {
        self.aggregate_market_volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aggregate_market_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        &mut self.aggregate_market_volumes
    }

    // Take field
    pub fn take_aggregate_market_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        ::std::mem::replace(&mut self.aggregate_market_volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateVolumesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.aggregate_account_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregate_market_volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregate_account_volumes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.aggregate_market_volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.aggregate_account_volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.aggregate_market_volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aggregate_account_volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.aggregate_market_volumes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateVolumesResponse {
        QueryAggregateVolumesResponse::new()
    }

    fn default_instance() -> &'static QueryAggregateVolumesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateVolumesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateVolumesResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateVolumesResponse {
    fn clear(&mut self) {
        self.aggregate_account_volumes.clear();
        self.aggregate_market_volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateVolumesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateMarketVolumeRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateMarketVolumeRequest {
    fn default() -> &'a QueryAggregateMarketVolumeRequest {
        <QueryAggregateMarketVolumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateMarketVolumeRequest {
    pub fn new() -> QueryAggregateMarketVolumeRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAggregateMarketVolumeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateMarketVolumeRequest {
        QueryAggregateMarketVolumeRequest::new()
    }

    fn default_instance() -> &'static QueryAggregateMarketVolumeRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateMarketVolumeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateMarketVolumeRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateMarketVolumeRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateMarketVolumeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateMarketVolumeResponse {
    // message fields
    pub volume: ::protobuf::SingularPtrField<super::exchange::VolumeRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateMarketVolumeResponse {
    fn default() -> &'a QueryAggregateMarketVolumeResponse {
        <QueryAggregateMarketVolumeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateMarketVolumeResponse {
    pub fn new() -> QueryAggregateMarketVolumeResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.VolumeRecord volume = 1;


    pub fn get_volume(&self) -> &super::exchange::VolumeRecord {
        self.volume.as_ref().unwrap_or_else(|| <super::exchange::VolumeRecord as ::protobuf::Message>::default_instance())
    }
    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: super::exchange::VolumeRecord) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut super::exchange::VolumeRecord {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> super::exchange::VolumeRecord {
        self.volume.take().unwrap_or_else(|| super::exchange::VolumeRecord::new())
    }
}

impl ::protobuf::Message for QueryAggregateMarketVolumeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.volume {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volume)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volume.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateMarketVolumeResponse {
        QueryAggregateMarketVolumeResponse::new()
    }

    fn default_instance() -> &'static QueryAggregateMarketVolumeResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateMarketVolumeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateMarketVolumeResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateMarketVolumeResponse {
    fn clear(&mut self) {
        self.volume.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateMarketVolumeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDenomDecimalRequest {
    // message fields
    pub denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDenomDecimalRequest {
    fn default() -> &'a QueryDenomDecimalRequest {
        <QueryDenomDecimalRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDenomDecimalRequest {
    pub fn new() -> QueryDenomDecimalRequest {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDenomDecimalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDenomDecimalRequest {
        QueryDenomDecimalRequest::new()
    }

    fn default_instance() -> &'static QueryDenomDecimalRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDenomDecimalRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDenomDecimalRequest::new)
    }
}

impl ::protobuf::Clear for QueryDenomDecimalRequest {
    fn clear(&mut self) {
        self.denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDenomDecimalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDenomDecimalResponse {
    // message fields
    pub decimal: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDenomDecimalResponse {
    fn default() -> &'a QueryDenomDecimalResponse {
        <QueryDenomDecimalResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDenomDecimalResponse {
    pub fn new() -> QueryDenomDecimalResponse {
        ::std::default::Default::default()
    }

    // uint64 decimal = 1;


    pub fn get_decimal(&self) -> u64 {
        self.decimal
    }
    pub fn clear_decimal(&mut self) {
        self.decimal = 0;
    }

    // Param is passed by value, moved
    pub fn set_decimal(&mut self, v: u64) {
        self.decimal = v;
    }
}

impl ::protobuf::Message for QueryDenomDecimalResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.decimal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.decimal != 0 {
            my_size += ::protobuf::rt::value_size(1, self.decimal, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.decimal != 0 {
            os.write_uint64(1, self.decimal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDenomDecimalResponse {
        QueryDenomDecimalResponse::new()
    }

    fn default_instance() -> &'static QueryDenomDecimalResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDenomDecimalResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDenomDecimalResponse::new)
    }
}

impl ::protobuf::Clear for QueryDenomDecimalResponse {
    fn clear(&mut self) {
        self.decimal = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDenomDecimalResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDenomDecimalsRequest {
    // message fields
    pub denoms: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDenomDecimalsRequest {
    fn default() -> &'a QueryDenomDecimalsRequest {
        <QueryDenomDecimalsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDenomDecimalsRequest {
    pub fn new() -> QueryDenomDecimalsRequest {
        ::std::default::Default::default()
    }

    // repeated string denoms = 1;


    pub fn get_denoms(&self) -> &[::std::string::String] {
        &self.denoms
    }
    pub fn clear_denoms(&mut self) {
        self.denoms.clear();
    }

    // Param is passed by value, moved
    pub fn set_denoms(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.denoms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denoms(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.denoms
    }

    // Take field
    pub fn take_denoms(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.denoms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDenomDecimalsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.denoms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.denoms {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.denoms {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDenomDecimalsRequest {
        QueryDenomDecimalsRequest::new()
    }

    fn default_instance() -> &'static QueryDenomDecimalsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDenomDecimalsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDenomDecimalsRequest::new)
    }
}

impl ::protobuf::Clear for QueryDenomDecimalsRequest {
    fn clear(&mut self) {
        self.denoms.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDenomDecimalsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDenomDecimalsResponse {
    // message fields
    pub denom_decimals: ::protobuf::RepeatedField<super::exchange::DenomDecimals>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDenomDecimalsResponse {
    fn default() -> &'a QueryDenomDecimalsResponse {
        <QueryDenomDecimalsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDenomDecimalsResponse {
    pub fn new() -> QueryDenomDecimalsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.DenomDecimals denom_decimals = 1;


    pub fn get_denom_decimals(&self) -> &[super::exchange::DenomDecimals] {
        &self.denom_decimals
    }
    pub fn clear_denom_decimals(&mut self) {
        self.denom_decimals.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom_decimals(&mut self, v: ::protobuf::RepeatedField<super::exchange::DenomDecimals>) {
        self.denom_decimals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denom_decimals(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        &mut self.denom_decimals
    }

    // Take field
    pub fn take_denom_decimals(&mut self) -> ::protobuf::RepeatedField<super::exchange::DenomDecimals> {
        ::std::mem::replace(&mut self.denom_decimals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDenomDecimalsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.denom_decimals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.denom_decimals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.denom_decimals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.denom_decimals {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDenomDecimalsResponse {
        QueryDenomDecimalsResponse::new()
    }

    fn default_instance() -> &'static QueryDenomDecimalsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDenomDecimalsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDenomDecimalsResponse::new)
    }
}

impl ::protobuf::Clear for QueryDenomDecimalsResponse {
    fn clear(&mut self) {
        self.denom_decimals.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDenomDecimalsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateMarketVolumesRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateMarketVolumesRequest {
    fn default() -> &'a QueryAggregateMarketVolumesRequest {
        <QueryAggregateMarketVolumesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateMarketVolumesRequest {
    pub fn new() -> QueryAggregateMarketVolumesRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateMarketVolumesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateMarketVolumesRequest {
        QueryAggregateMarketVolumesRequest::new()
    }

    fn default_instance() -> &'static QueryAggregateMarketVolumesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateMarketVolumesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateMarketVolumesRequest::new)
    }
}

impl ::protobuf::Clear for QueryAggregateMarketVolumesRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateMarketVolumesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAggregateMarketVolumesResponse {
    // message fields
    pub volumes: ::protobuf::RepeatedField<super::exchange::MarketVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAggregateMarketVolumesResponse {
    fn default() -> &'a QueryAggregateMarketVolumesResponse {
        <QueryAggregateMarketVolumesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAggregateMarketVolumesResponse {
    pub fn new() -> QueryAggregateMarketVolumesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.MarketVolume volumes = 1;


    pub fn get_volumes(&self) -> &[super::exchange::MarketVolume] {
        &self.volumes
    }
    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<super::exchange::MarketVolume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<super::exchange::MarketVolume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAggregateMarketVolumesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAggregateMarketVolumesResponse {
        QueryAggregateMarketVolumesResponse::new()
    }

    fn default_instance() -> &'static QueryAggregateMarketVolumesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAggregateMarketVolumesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAggregateMarketVolumesResponse::new)
    }
}

impl ::protobuf::Clear for QueryAggregateMarketVolumesResponse {
    fn clear(&mut self) {
        self.volumes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAggregateMarketVolumesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountDepositRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountDepositRequest {
    fn default() -> &'a QuerySubaccountDepositRequest {
        <QuerySubaccountDepositRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountDepositRequest {
    pub fn new() -> QuerySubaccountDepositRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountDepositRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountDepositRequest {
        QuerySubaccountDepositRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountDepositRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountDepositRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountDepositRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountDepositRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountDepositRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountDepositResponse {
    // message fields
    pub deposits: ::protobuf::SingularPtrField<super::exchange::Deposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountDepositResponse {
    fn default() -> &'a QuerySubaccountDepositResponse {
        <QuerySubaccountDepositResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountDepositResponse {
    pub fn new() -> QuerySubaccountDepositResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.Deposit deposits = 1;


    pub fn get_deposits(&self) -> &super::exchange::Deposit {
        self.deposits.as_ref().unwrap_or_else(|| <super::exchange::Deposit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deposits(&mut self) {
        self.deposits.clear();
    }

    pub fn has_deposits(&self) -> bool {
        self.deposits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deposits(&mut self, v: super::exchange::Deposit) {
        self.deposits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposits(&mut self) -> &mut super::exchange::Deposit {
        if self.deposits.is_none() {
            self.deposits.set_default();
        }
        self.deposits.as_mut().unwrap()
    }

    // Take field
    pub fn take_deposits(&mut self) -> super::exchange::Deposit {
        self.deposits.take().unwrap_or_else(|| super::exchange::Deposit::new())
    }
}

impl ::protobuf::Message for QuerySubaccountDepositResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.deposits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deposits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.deposits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.deposits.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountDepositResponse {
        QuerySubaccountDepositResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountDepositResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountDepositResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountDepositResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountDepositResponse {
    fn clear(&mut self) {
        self.deposits.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountDepositResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMarketsRequest {
    // message fields
    pub status: ::std::string::String,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMarketsRequest {
    fn default() -> &'a QuerySpotMarketsRequest {
        <QuerySpotMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMarketsRequest {
    pub fn new() -> QuerySpotMarketsRequest {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // repeated string market_ids = 2;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySpotMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        for v in &self.market_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMarketsRequest {
        QuerySpotMarketsRequest::new()
    }

    fn default_instance() -> &'static QuerySpotMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMarketsRequest::new)
    }
}

impl ::protobuf::Clear for QuerySpotMarketsRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<super::exchange::SpotMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMarketsResponse {
    fn default() -> &'a QuerySpotMarketsResponse {
        <QuerySpotMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMarketsResponse {
    pub fn new() -> QuerySpotMarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.SpotMarket markets = 1;


    pub fn get_markets(&self) -> &[super::exchange::SpotMarket] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<super::exchange::SpotMarket>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::SpotMarket> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<super::exchange::SpotMarket> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySpotMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMarketsResponse {
        QuerySpotMarketsResponse::new()
    }

    fn default_instance() -> &'static QuerySpotMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMarketsResponse::new)
    }
}

impl ::protobuf::Clear for QuerySpotMarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMarketRequest {
    fn default() -> &'a QuerySpotMarketRequest {
        <QuerySpotMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMarketRequest {
    pub fn new() -> QuerySpotMarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySpotMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMarketRequest {
        QuerySpotMarketRequest::new()
    }

    fn default_instance() -> &'static QuerySpotMarketRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMarketRequest::new)
    }
}

impl ::protobuf::Clear for QuerySpotMarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::SpotMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMarketResponse {
    fn default() -> &'a QuerySpotMarketResponse {
        <QuerySpotMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMarketResponse {
    pub fn new() -> QuerySpotMarketResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.SpotMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::SpotMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::SpotMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::SpotMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::SpotMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::SpotMarket {
        self.market.take().unwrap_or_else(|| super::exchange::SpotMarket::new())
    }
}

impl ::protobuf::Message for QuerySpotMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMarketResponse {
        QuerySpotMarketResponse::new()
    }

    fn default_instance() -> &'static QuerySpotMarketResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMarketResponse::new)
    }
}

impl ::protobuf::Clear for QuerySpotMarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotOrderbookRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub limit: u64,
    pub order_side: OrderSide,
    pub limit_cumulative_notional: ::std::string::String,
    pub limit_cumulative_quantity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotOrderbookRequest {
    fn default() -> &'a QuerySpotOrderbookRequest {
        <QuerySpotOrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotOrderbookRequest {
    pub fn new() -> QuerySpotOrderbookRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // .injective.exchange.v1beta1.OrderSide order_side = 3;


    pub fn get_order_side(&self) -> OrderSide {
        self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side = OrderSide::Side_Unspecified;
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: OrderSide) {
        self.order_side = v;
    }

    // string limit_cumulative_notional = 4;


    pub fn get_limit_cumulative_notional(&self) -> &str {
        &self.limit_cumulative_notional
    }
    pub fn clear_limit_cumulative_notional(&mut self) {
        self.limit_cumulative_notional.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit_cumulative_notional(&mut self, v: ::std::string::String) {
        self.limit_cumulative_notional = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit_cumulative_notional(&mut self) -> &mut ::std::string::String {
        &mut self.limit_cumulative_notional
    }

    // Take field
    pub fn take_limit_cumulative_notional(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.limit_cumulative_notional, ::std::string::String::new())
    }

    // string limit_cumulative_quantity = 5;


    pub fn get_limit_cumulative_quantity(&self) -> &str {
        &self.limit_cumulative_quantity
    }
    pub fn clear_limit_cumulative_quantity(&mut self) {
        self.limit_cumulative_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit_cumulative_quantity(&mut self, v: ::std::string::String) {
        self.limit_cumulative_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit_cumulative_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.limit_cumulative_quantity
    }

    // Take field
    pub fn take_limit_cumulative_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.limit_cumulative_quantity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySpotOrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_side, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.limit_cumulative_notional)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.limit_cumulative_quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.order_side != OrderSide::Side_Unspecified {
            my_size += ::protobuf::rt::enum_size(3, self.order_side);
        }
        if !self.limit_cumulative_notional.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.limit_cumulative_notional);
        }
        if !self.limit_cumulative_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.limit_cumulative_quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        if self.order_side != OrderSide::Side_Unspecified {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.order_side))?;
        }
        if !self.limit_cumulative_notional.is_empty() {
            os.write_string(4, &self.limit_cumulative_notional)?;
        }
        if !self.limit_cumulative_quantity.is_empty() {
            os.write_string(5, &self.limit_cumulative_quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotOrderbookRequest {
        QuerySpotOrderbookRequest::new()
    }

    fn default_instance() -> &'static QuerySpotOrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySpotOrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotOrderbookRequest::new)
    }
}

impl ::protobuf::Clear for QuerySpotOrderbookRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.limit = 0;
        self.order_side = OrderSide::Side_Unspecified;
        self.limit_cumulative_notional.clear();
        self.limit_cumulative_quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotOrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotOrderbookResponse {
    // message fields
    pub buys_price_level: ::protobuf::RepeatedField<super::exchange::Level>,
    pub sells_price_level: ::protobuf::RepeatedField<super::exchange::Level>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotOrderbookResponse {
    fn default() -> &'a QuerySpotOrderbookResponse {
        <QuerySpotOrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotOrderbookResponse {
    pub fn new() -> QuerySpotOrderbookResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.Level buys_price_level = 1;


    pub fn get_buys_price_level(&self) -> &[super::exchange::Level] {
        &self.buys_price_level
    }
    pub fn clear_buys_price_level(&mut self) {
        self.buys_price_level.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys_price_level(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.buys_price_level = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys_price_level(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.buys_price_level
    }

    // Take field
    pub fn take_buys_price_level(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.buys_price_level, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.Level sells_price_level = 2;


    pub fn get_sells_price_level(&self) -> &[super::exchange::Level] {
        &self.sells_price_level
    }
    pub fn clear_sells_price_level(&mut self) {
        self.sells_price_level.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells_price_level(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.sells_price_level = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells_price_level(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.sells_price_level
    }

    // Take field
    pub fn take_sells_price_level(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.sells_price_level, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySpotOrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.buys_price_level {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells_price_level {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys_price_level)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells_price_level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys_price_level {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells_price_level {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys_price_level {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells_price_level {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotOrderbookResponse {
        QuerySpotOrderbookResponse::new()
    }

    fn default_instance() -> &'static QuerySpotOrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySpotOrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotOrderbookResponse::new)
    }
}

impl ::protobuf::Clear for QuerySpotOrderbookResponse {
    fn clear(&mut self) {
        self.buys_price_level.clear();
        self.sells_price_level.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotOrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FullSpotMarket {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::SpotMarket>,
    pub mid_price_and_tob: ::protobuf::SingularPtrField<super::exchange::MidPriceAndTOB>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FullSpotMarket {
    fn default() -> &'a FullSpotMarket {
        <FullSpotMarket as ::protobuf::Message>::default_instance()
    }
}

impl FullSpotMarket {
    pub fn new() -> FullSpotMarket {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.SpotMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::SpotMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::SpotMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::SpotMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::SpotMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::SpotMarket {
        self.market.take().unwrap_or_else(|| super::exchange::SpotMarket::new())
    }

    // .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 2;


    pub fn get_mid_price_and_tob(&self) -> &super::exchange::MidPriceAndTOB {
        self.mid_price_and_tob.as_ref().unwrap_or_else(|| <super::exchange::MidPriceAndTOB as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mid_price_and_tob(&mut self) {
        self.mid_price_and_tob.clear();
    }

    pub fn has_mid_price_and_tob(&self) -> bool {
        self.mid_price_and_tob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mid_price_and_tob(&mut self, v: super::exchange::MidPriceAndTOB) {
        self.mid_price_and_tob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid_price_and_tob(&mut self) -> &mut super::exchange::MidPriceAndTOB {
        if self.mid_price_and_tob.is_none() {
            self.mid_price_and_tob.set_default();
        }
        self.mid_price_and_tob.as_mut().unwrap()
    }

    // Take field
    pub fn take_mid_price_and_tob(&mut self) -> super::exchange::MidPriceAndTOB {
        self.mid_price_and_tob.take().unwrap_or_else(|| super::exchange::MidPriceAndTOB::new())
    }
}

impl ::protobuf::Message for FullSpotMarket {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mid_price_and_tob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mid_price_and_tob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mid_price_and_tob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mid_price_and_tob.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FullSpotMarket {
        FullSpotMarket::new()
    }

    fn default_instance() -> &'static FullSpotMarket {
        static instance: ::protobuf::rt::LazyV2<FullSpotMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FullSpotMarket::new)
    }
}

impl ::protobuf::Clear for FullSpotMarket {
    fn clear(&mut self) {
        self.market.clear();
        self.mid_price_and_tob.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FullSpotMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFullSpotMarketsRequest {
    // message fields
    pub status: ::std::string::String,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub with_mid_price_and_tob: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFullSpotMarketsRequest {
    fn default() -> &'a QueryFullSpotMarketsRequest {
        <QueryFullSpotMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFullSpotMarketsRequest {
    pub fn new() -> QueryFullSpotMarketsRequest {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // repeated string market_ids = 2;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // bool with_mid_price_and_tob = 3;


    pub fn get_with_mid_price_and_tob(&self) -> bool {
        self.with_mid_price_and_tob
    }
    pub fn clear_with_mid_price_and_tob(&mut self) {
        self.with_mid_price_and_tob = false;
    }

    // Param is passed by value, moved
    pub fn set_with_mid_price_and_tob(&mut self, v: bool) {
        self.with_mid_price_and_tob = v;
    }
}

impl ::protobuf::Message for QueryFullSpotMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_mid_price_and_tob = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.with_mid_price_and_tob != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        for v in &self.market_ids {
            os.write_string(2, &v)?;
        };
        if self.with_mid_price_and_tob != false {
            os.write_bool(3, self.with_mid_price_and_tob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFullSpotMarketsRequest {
        QueryFullSpotMarketsRequest::new()
    }

    fn default_instance() -> &'static QueryFullSpotMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFullSpotMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFullSpotMarketsRequest::new)
    }
}

impl ::protobuf::Clear for QueryFullSpotMarketsRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.market_ids.clear();
        self.with_mid_price_and_tob = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFullSpotMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFullSpotMarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<FullSpotMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFullSpotMarketsResponse {
    fn default() -> &'a QueryFullSpotMarketsResponse {
        <QueryFullSpotMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFullSpotMarketsResponse {
    pub fn new() -> QueryFullSpotMarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.FullSpotMarket markets = 1;


    pub fn get_markets(&self) -> &[FullSpotMarket] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<FullSpotMarket>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<FullSpotMarket> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<FullSpotMarket> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryFullSpotMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFullSpotMarketsResponse {
        QueryFullSpotMarketsResponse::new()
    }

    fn default_instance() -> &'static QueryFullSpotMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFullSpotMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFullSpotMarketsResponse::new)
    }
}

impl ::protobuf::Clear for QueryFullSpotMarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFullSpotMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFullSpotMarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub with_mid_price_and_tob: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFullSpotMarketRequest {
    fn default() -> &'a QueryFullSpotMarketRequest {
        <QueryFullSpotMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFullSpotMarketRequest {
    pub fn new() -> QueryFullSpotMarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool with_mid_price_and_tob = 2;


    pub fn get_with_mid_price_and_tob(&self) -> bool {
        self.with_mid_price_and_tob
    }
    pub fn clear_with_mid_price_and_tob(&mut self) {
        self.with_mid_price_and_tob = false;
    }

    // Param is passed by value, moved
    pub fn set_with_mid_price_and_tob(&mut self, v: bool) {
        self.with_mid_price_and_tob = v;
    }
}

impl ::protobuf::Message for QueryFullSpotMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_mid_price_and_tob = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.with_mid_price_and_tob != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.with_mid_price_and_tob != false {
            os.write_bool(2, self.with_mid_price_and_tob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFullSpotMarketRequest {
        QueryFullSpotMarketRequest::new()
    }

    fn default_instance() -> &'static QueryFullSpotMarketRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFullSpotMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFullSpotMarketRequest::new)
    }
}

impl ::protobuf::Clear for QueryFullSpotMarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.with_mid_price_and_tob = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFullSpotMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFullSpotMarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<FullSpotMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFullSpotMarketResponse {
    fn default() -> &'a QueryFullSpotMarketResponse {
        <QueryFullSpotMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFullSpotMarketResponse {
    pub fn new() -> QueryFullSpotMarketResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.FullSpotMarket market = 1;


    pub fn get_market(&self) -> &FullSpotMarket {
        self.market.as_ref().unwrap_or_else(|| <FullSpotMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: FullSpotMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut FullSpotMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> FullSpotMarket {
        self.market.take().unwrap_or_else(|| FullSpotMarket::new())
    }
}

impl ::protobuf::Message for QueryFullSpotMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFullSpotMarketResponse {
        QueryFullSpotMarketResponse::new()
    }

    fn default_instance() -> &'static QueryFullSpotMarketResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFullSpotMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFullSpotMarketResponse::new)
    }
}

impl ::protobuf::Clear for QueryFullSpotMarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFullSpotMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotOrdersByHashesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotOrdersByHashesRequest {
    fn default() -> &'a QuerySpotOrdersByHashesRequest {
        <QuerySpotOrdersByHashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotOrdersByHashesRequest {
    pub fn new() -> QuerySpotOrdersByHashesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated string order_hashes = 3;


    pub fn get_order_hashes(&self) -> &[::std::string::String] {
        &self.order_hashes
    }
    pub fn clear_order_hashes(&mut self) {
        self.order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_hashes
    }

    // Take field
    pub fn take_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySpotOrdersByHashesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        for value in &self.order_hashes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        for v in &self.order_hashes {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotOrdersByHashesRequest {
        QuerySpotOrdersByHashesRequest::new()
    }

    fn default_instance() -> &'static QuerySpotOrdersByHashesRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySpotOrdersByHashesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotOrdersByHashesRequest::new)
    }
}

impl ::protobuf::Clear for QuerySpotOrdersByHashesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotOrdersByHashesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotOrdersByHashesResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotOrdersByHashesResponse {
    fn default() -> &'a QuerySpotOrdersByHashesResponse {
        <QuerySpotOrdersByHashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotOrdersByHashesResponse {
    pub fn new() -> QuerySpotOrdersByHashesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedSpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySpotOrdersByHashesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotOrdersByHashesResponse {
        QuerySpotOrdersByHashesResponse::new()
    }

    fn default_instance() -> &'static QuerySpotOrdersByHashesResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySpotOrdersByHashesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotOrdersByHashesResponse::new)
    }
}

impl ::protobuf::Clear for QuerySpotOrdersByHashesResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotOrdersByHashesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderSpotOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderSpotOrdersRequest {
    fn default() -> &'a QueryTraderSpotOrdersRequest {
        <QueryTraderSpotOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderSpotOrdersRequest {
    pub fn new() -> QueryTraderSpotOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTraderSpotOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderSpotOrdersRequest {
        QueryTraderSpotOrdersRequest::new()
    }

    fn default_instance() -> &'static QueryTraderSpotOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTraderSpotOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderSpotOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QueryTraderSpotOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderSpotOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAccountAddressSpotOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub account_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAccountAddressSpotOrdersRequest {
    fn default() -> &'a QueryAccountAddressSpotOrdersRequest {
        <QueryAccountAddressSpotOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAccountAddressSpotOrdersRequest {
    pub fn new() -> QueryAccountAddressSpotOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string account_address = 2;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAccountAddressSpotOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAccountAddressSpotOrdersRequest {
        QueryAccountAddressSpotOrdersRequest::new()
    }

    fn default_instance() -> &'static QueryAccountAddressSpotOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAccountAddressSpotOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAccountAddressSpotOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QueryAccountAddressSpotOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.account_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAccountAddressSpotOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrimmedSpotLimitOrder {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub fillable: ::std::string::String,
    pub isBuy: bool,
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrimmedSpotLimitOrder {
    fn default() -> &'a TrimmedSpotLimitOrder {
        <TrimmedSpotLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl TrimmedSpotLimitOrder {
    pub fn new() -> TrimmedSpotLimitOrder {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string fillable = 3;


    pub fn get_fillable(&self) -> &str {
        &self.fillable
    }
    pub fn clear_fillable(&mut self) {
        self.fillable.clear();
    }

    // Param is passed by value, moved
    pub fn set_fillable(&mut self, v: ::std::string::String) {
        self.fillable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fillable(&mut self) -> &mut ::std::string::String {
        &mut self.fillable
    }

    // Take field
    pub fn take_fillable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fillable, ::std::string::String::new())
    }

    // bool isBuy = 4;


    pub fn get_isBuy(&self) -> bool {
        self.isBuy
    }
    pub fn clear_isBuy(&mut self) {
        self.isBuy = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuy(&mut self, v: bool) {
        self.isBuy = v;
    }

    // string order_hash = 5;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TrimmedSpotLimitOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fillable)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuy = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if !self.fillable.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.fillable);
        }
        if self.isBuy != false {
            my_size += 2;
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if !self.fillable.is_empty() {
            os.write_string(3, &self.fillable)?;
        }
        if self.isBuy != false {
            os.write_bool(4, self.isBuy)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(5, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrimmedSpotLimitOrder {
        TrimmedSpotLimitOrder::new()
    }

    fn default_instance() -> &'static TrimmedSpotLimitOrder {
        static instance: ::protobuf::rt::LazyV2<TrimmedSpotLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrimmedSpotLimitOrder::new)
    }
}

impl ::protobuf::Clear for TrimmedSpotLimitOrder {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.fillable.clear();
        self.isBuy = false;
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrimmedSpotLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderSpotOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderSpotOrdersResponse {
    fn default() -> &'a QueryTraderSpotOrdersResponse {
        <QueryTraderSpotOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderSpotOrdersResponse {
    pub fn new() -> QueryTraderSpotOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedSpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTraderSpotOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderSpotOrdersResponse {
        QueryTraderSpotOrdersResponse::new()
    }

    fn default_instance() -> &'static QueryTraderSpotOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTraderSpotOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderSpotOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QueryTraderSpotOrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderSpotOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAccountAddressSpotOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAccountAddressSpotOrdersResponse {
    fn default() -> &'a QueryAccountAddressSpotOrdersResponse {
        <QueryAccountAddressSpotOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAccountAddressSpotOrdersResponse {
    pub fn new() -> QueryAccountAddressSpotOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedSpotLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedSpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedSpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedSpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAccountAddressSpotOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAccountAddressSpotOrdersResponse {
        QueryAccountAddressSpotOrdersResponse::new()
    }

    fn default_instance() -> &'static QueryAccountAddressSpotOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAccountAddressSpotOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAccountAddressSpotOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QueryAccountAddressSpotOrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAccountAddressSpotOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMidPriceAndTOBRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMidPriceAndTOBRequest {
    fn default() -> &'a QuerySpotMidPriceAndTOBRequest {
        <QuerySpotMidPriceAndTOBRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMidPriceAndTOBRequest {
    pub fn new() -> QuerySpotMidPriceAndTOBRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySpotMidPriceAndTOBRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMidPriceAndTOBRequest {
        QuerySpotMidPriceAndTOBRequest::new()
    }

    fn default_instance() -> &'static QuerySpotMidPriceAndTOBRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMidPriceAndTOBRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMidPriceAndTOBRequest::new)
    }
}

impl ::protobuf::Clear for QuerySpotMidPriceAndTOBRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMidPriceAndTOBRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySpotMidPriceAndTOBResponse {
    // message fields
    pub mid_price: ::std::string::String,
    pub best_buy_price: ::std::string::String,
    pub best_sell_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySpotMidPriceAndTOBResponse {
    fn default() -> &'a QuerySpotMidPriceAndTOBResponse {
        <QuerySpotMidPriceAndTOBResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySpotMidPriceAndTOBResponse {
    pub fn new() -> QuerySpotMidPriceAndTOBResponse {
        ::std::default::Default::default()
    }

    // string mid_price = 1;


    pub fn get_mid_price(&self) -> &str {
        &self.mid_price
    }
    pub fn clear_mid_price(&mut self) {
        self.mid_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mid_price(&mut self, v: ::std::string::String) {
        self.mid_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid_price(&mut self) -> &mut ::std::string::String {
        &mut self.mid_price
    }

    // Take field
    pub fn take_mid_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mid_price, ::std::string::String::new())
    }

    // string best_buy_price = 2;


    pub fn get_best_buy_price(&self) -> &str {
        &self.best_buy_price
    }
    pub fn clear_best_buy_price(&mut self) {
        self.best_buy_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_buy_price(&mut self, v: ::std::string::String) {
        self.best_buy_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_buy_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_buy_price
    }

    // Take field
    pub fn take_best_buy_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_buy_price, ::std::string::String::new())
    }

    // string best_sell_price = 3;


    pub fn get_best_sell_price(&self) -> &str {
        &self.best_sell_price
    }
    pub fn clear_best_sell_price(&mut self) {
        self.best_sell_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_sell_price(&mut self, v: ::std::string::String) {
        self.best_sell_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_sell_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_sell_price
    }

    // Take field
    pub fn take_best_sell_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_sell_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySpotMidPriceAndTOBResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mid_price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_buy_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_sell_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mid_price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mid_price);
        }
        if !self.best_buy_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.best_buy_price);
        }
        if !self.best_sell_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.best_sell_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mid_price.is_empty() {
            os.write_string(1, &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            os.write_string(2, &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            os.write_string(3, &self.best_sell_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySpotMidPriceAndTOBResponse {
        QuerySpotMidPriceAndTOBResponse::new()
    }

    fn default_instance() -> &'static QuerySpotMidPriceAndTOBResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySpotMidPriceAndTOBResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySpotMidPriceAndTOBResponse::new)
    }
}

impl ::protobuf::Clear for QuerySpotMidPriceAndTOBResponse {
    fn clear(&mut self) {
        self.mid_price.clear();
        self.best_buy_price.clear();
        self.best_sell_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySpotMidPriceAndTOBResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMidPriceAndTOBRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMidPriceAndTOBRequest {
    fn default() -> &'a QueryDerivativeMidPriceAndTOBRequest {
        <QueryDerivativeMidPriceAndTOBRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMidPriceAndTOBRequest {
    pub fn new() -> QueryDerivativeMidPriceAndTOBRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMidPriceAndTOBRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMidPriceAndTOBRequest {
        QueryDerivativeMidPriceAndTOBRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeMidPriceAndTOBRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMidPriceAndTOBRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMidPriceAndTOBRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMidPriceAndTOBRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMidPriceAndTOBRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMidPriceAndTOBResponse {
    // message fields
    pub mid_price: ::std::string::String,
    pub best_buy_price: ::std::string::String,
    pub best_sell_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMidPriceAndTOBResponse {
    fn default() -> &'a QueryDerivativeMidPriceAndTOBResponse {
        <QueryDerivativeMidPriceAndTOBResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMidPriceAndTOBResponse {
    pub fn new() -> QueryDerivativeMidPriceAndTOBResponse {
        ::std::default::Default::default()
    }

    // string mid_price = 1;


    pub fn get_mid_price(&self) -> &str {
        &self.mid_price
    }
    pub fn clear_mid_price(&mut self) {
        self.mid_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mid_price(&mut self, v: ::std::string::String) {
        self.mid_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid_price(&mut self) -> &mut ::std::string::String {
        &mut self.mid_price
    }

    // Take field
    pub fn take_mid_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mid_price, ::std::string::String::new())
    }

    // string best_buy_price = 2;


    pub fn get_best_buy_price(&self) -> &str {
        &self.best_buy_price
    }
    pub fn clear_best_buy_price(&mut self) {
        self.best_buy_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_buy_price(&mut self, v: ::std::string::String) {
        self.best_buy_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_buy_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_buy_price
    }

    // Take field
    pub fn take_best_buy_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_buy_price, ::std::string::String::new())
    }

    // string best_sell_price = 3;


    pub fn get_best_sell_price(&self) -> &str {
        &self.best_sell_price
    }
    pub fn clear_best_sell_price(&mut self) {
        self.best_sell_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_best_sell_price(&mut self, v: ::std::string::String) {
        self.best_sell_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_sell_price(&mut self) -> &mut ::std::string::String {
        &mut self.best_sell_price
    }

    // Take field
    pub fn take_best_sell_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.best_sell_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMidPriceAndTOBResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mid_price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_buy_price)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.best_sell_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mid_price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mid_price);
        }
        if !self.best_buy_price.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.best_buy_price);
        }
        if !self.best_sell_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.best_sell_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mid_price.is_empty() {
            os.write_string(1, &self.mid_price)?;
        }
        if !self.best_buy_price.is_empty() {
            os.write_string(2, &self.best_buy_price)?;
        }
        if !self.best_sell_price.is_empty() {
            os.write_string(3, &self.best_sell_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMidPriceAndTOBResponse {
        QueryDerivativeMidPriceAndTOBResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeMidPriceAndTOBResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMidPriceAndTOBResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMidPriceAndTOBResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMidPriceAndTOBResponse {
    fn clear(&mut self) {
        self.mid_price.clear();
        self.best_buy_price.clear();
        self.best_sell_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMidPriceAndTOBResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeOrderbookRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub limit: u64,
    pub limit_cumulative_notional: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeOrderbookRequest {
    fn default() -> &'a QueryDerivativeOrderbookRequest {
        <QueryDerivativeOrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeOrderbookRequest {
    pub fn new() -> QueryDerivativeOrderbookRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 limit = 2;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // string limit_cumulative_notional = 3;


    pub fn get_limit_cumulative_notional(&self) -> &str {
        &self.limit_cumulative_notional
    }
    pub fn clear_limit_cumulative_notional(&mut self) {
        self.limit_cumulative_notional.clear();
    }

    // Param is passed by value, moved
    pub fn set_limit_cumulative_notional(&mut self, v: ::std::string::String) {
        self.limit_cumulative_notional = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit_cumulative_notional(&mut self) -> &mut ::std::string::String {
        &mut self.limit_cumulative_notional
    }

    // Take field
    pub fn take_limit_cumulative_notional(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.limit_cumulative_notional, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeOrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.limit_cumulative_notional)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.limit_cumulative_notional.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.limit_cumulative_notional);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        if !self.limit_cumulative_notional.is_empty() {
            os.write_string(3, &self.limit_cumulative_notional)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeOrderbookRequest {
        QueryDerivativeOrderbookRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeOrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeOrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeOrderbookRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeOrderbookRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.limit = 0;
        self.limit_cumulative_notional.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeOrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeOrderbookResponse {
    // message fields
    pub buys_price_level: ::protobuf::RepeatedField<super::exchange::Level>,
    pub sells_price_level: ::protobuf::RepeatedField<super::exchange::Level>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeOrderbookResponse {
    fn default() -> &'a QueryDerivativeOrderbookResponse {
        <QueryDerivativeOrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeOrderbookResponse {
    pub fn new() -> QueryDerivativeOrderbookResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.Level buys_price_level = 1;


    pub fn get_buys_price_level(&self) -> &[super::exchange::Level] {
        &self.buys_price_level
    }
    pub fn clear_buys_price_level(&mut self) {
        self.buys_price_level.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys_price_level(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.buys_price_level = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys_price_level(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.buys_price_level
    }

    // Take field
    pub fn take_buys_price_level(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.buys_price_level, ::protobuf::RepeatedField::new())
    }

    // repeated .injective.exchange.v1beta1.Level sells_price_level = 2;


    pub fn get_sells_price_level(&self) -> &[super::exchange::Level] {
        &self.sells_price_level
    }
    pub fn clear_sells_price_level(&mut self) {
        self.sells_price_level.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells_price_level(&mut self, v: ::protobuf::RepeatedField<super::exchange::Level>) {
        self.sells_price_level = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells_price_level(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::Level> {
        &mut self.sells_price_level
    }

    // Take field
    pub fn take_sells_price_level(&mut self) -> ::protobuf::RepeatedField<super::exchange::Level> {
        ::std::mem::replace(&mut self.sells_price_level, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDerivativeOrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.buys_price_level {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells_price_level {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys_price_level)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells_price_level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys_price_level {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells_price_level {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys_price_level {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells_price_level {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeOrderbookResponse {
        QueryDerivativeOrderbookResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeOrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeOrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeOrderbookResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeOrderbookResponse {
    fn clear(&mut self) {
        self.buys_price_level.clear();
        self.sells_price_level.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeOrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderSpotOrdersToCancelUpToAmountRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub base_amount: ::std::string::String,
    pub quote_amount: ::std::string::String,
    pub strategy: CancellationStrategy,
    pub reference_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderSpotOrdersToCancelUpToAmountRequest {
    fn default() -> &'a QueryTraderSpotOrdersToCancelUpToAmountRequest {
        <QueryTraderSpotOrdersToCancelUpToAmountRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderSpotOrdersToCancelUpToAmountRequest {
    pub fn new() -> QueryTraderSpotOrdersToCancelUpToAmountRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string base_amount = 3;


    pub fn get_base_amount(&self) -> &str {
        &self.base_amount
    }
    pub fn clear_base_amount(&mut self) {
        self.base_amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_amount(&mut self, v: ::std::string::String) {
        self.base_amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_amount(&mut self) -> &mut ::std::string::String {
        &mut self.base_amount
    }

    // Take field
    pub fn take_base_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_amount, ::std::string::String::new())
    }

    // string quote_amount = 4;


    pub fn get_quote_amount(&self) -> &str {
        &self.quote_amount
    }
    pub fn clear_quote_amount(&mut self) {
        self.quote_amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_amount(&mut self, v: ::std::string::String) {
        self.quote_amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_amount(&mut self) -> &mut ::std::string::String {
        &mut self.quote_amount
    }

    // Take field
    pub fn take_quote_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_amount, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.CancellationStrategy strategy = 5;


    pub fn get_strategy(&self) -> CancellationStrategy {
        self.strategy
    }
    pub fn clear_strategy(&mut self) {
        self.strategy = CancellationStrategy::UnspecifiedOrder;
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: CancellationStrategy) {
        self.strategy = v;
    }

    // string reference_price = 6;


    pub fn get_reference_price(&self) -> &str {
        &self.reference_price
    }
    pub fn clear_reference_price(&mut self) {
        self.reference_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_price(&mut self, v: ::std::string::String) {
        self.reference_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference_price(&mut self) -> &mut ::std::string::String {
        &mut self.reference_price
    }

    // Take field
    pub fn take_reference_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reference_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTraderSpotOrdersToCancelUpToAmountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_amount)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.strategy, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reference_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.base_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.base_amount);
        }
        if !self.quote_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.quote_amount);
        }
        if self.strategy != CancellationStrategy::UnspecifiedOrder {
            my_size += ::protobuf::rt::enum_size(5, self.strategy);
        }
        if !self.reference_price.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.reference_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.base_amount.is_empty() {
            os.write_string(3, &self.base_amount)?;
        }
        if !self.quote_amount.is_empty() {
            os.write_string(4, &self.quote_amount)?;
        }
        if self.strategy != CancellationStrategy::UnspecifiedOrder {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.strategy))?;
        }
        if !self.reference_price.is_empty() {
            os.write_string(6, &self.reference_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderSpotOrdersToCancelUpToAmountRequest {
        QueryTraderSpotOrdersToCancelUpToAmountRequest::new()
    }

    fn default_instance() -> &'static QueryTraderSpotOrdersToCancelUpToAmountRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTraderSpotOrdersToCancelUpToAmountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderSpotOrdersToCancelUpToAmountRequest::new)
    }
}

impl ::protobuf::Clear for QueryTraderSpotOrdersToCancelUpToAmountRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.base_amount.clear();
        self.quote_amount.clear();
        self.strategy = CancellationStrategy::UnspecifiedOrder;
        self.reference_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderSpotOrdersToCancelUpToAmountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub quote_amount: ::std::string::String,
    pub strategy: CancellationStrategy,
    pub reference_price: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    fn default() -> &'a QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        <QueryTraderDerivativeOrdersToCancelUpToAmountRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    pub fn new() -> QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string quote_amount = 3;


    pub fn get_quote_amount(&self) -> &str {
        &self.quote_amount
    }
    pub fn clear_quote_amount(&mut self) {
        self.quote_amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_amount(&mut self, v: ::std::string::String) {
        self.quote_amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_amount(&mut self) -> &mut ::std::string::String {
        &mut self.quote_amount
    }

    // Take field
    pub fn take_quote_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_amount, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.CancellationStrategy strategy = 4;


    pub fn get_strategy(&self) -> CancellationStrategy {
        self.strategy
    }
    pub fn clear_strategy(&mut self) {
        self.strategy = CancellationStrategy::UnspecifiedOrder;
    }

    // Param is passed by value, moved
    pub fn set_strategy(&mut self, v: CancellationStrategy) {
        self.strategy = v;
    }

    // string reference_price = 5;


    pub fn get_reference_price(&self) -> &str {
        &self.reference_price
    }
    pub fn clear_reference_price(&mut self) {
        self.reference_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_price(&mut self, v: ::std::string::String) {
        self.reference_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference_price(&mut self) -> &mut ::std::string::String {
        &mut self.reference_price
    }

    // Take field
    pub fn take_reference_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.reference_price, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_amount)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.strategy, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.reference_price)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.quote_amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_amount);
        }
        if self.strategy != CancellationStrategy::UnspecifiedOrder {
            my_size += ::protobuf::rt::enum_size(4, self.strategy);
        }
        if !self.reference_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.reference_price);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.quote_amount.is_empty() {
            os.write_string(3, &self.quote_amount)?;
        }
        if self.strategy != CancellationStrategy::UnspecifiedOrder {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.strategy))?;
        }
        if !self.reference_price.is_empty() {
            os.write_string(5, &self.reference_price)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        QueryTraderDerivativeOrdersToCancelUpToAmountRequest::new()
    }

    fn default_instance() -> &'static QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTraderDerivativeOrdersToCancelUpToAmountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderDerivativeOrdersToCancelUpToAmountRequest::new)
    }
}

impl ::protobuf::Clear for QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.quote_amount.clear();
        self.strategy = CancellationStrategy::UnspecifiedOrder;
        self.reference_price.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderDerivativeOrdersToCancelUpToAmountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderDerivativeOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderDerivativeOrdersRequest {
    fn default() -> &'a QueryTraderDerivativeOrdersRequest {
        <QueryTraderDerivativeOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderDerivativeOrdersRequest {
    pub fn new() -> QueryTraderDerivativeOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTraderDerivativeOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderDerivativeOrdersRequest {
        QueryTraderDerivativeOrdersRequest::new()
    }

    fn default_instance() -> &'static QueryTraderDerivativeOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTraderDerivativeOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderDerivativeOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QueryTraderDerivativeOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderDerivativeOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAccountAddressDerivativeOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub account_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAccountAddressDerivativeOrdersRequest {
    fn default() -> &'a QueryAccountAddressDerivativeOrdersRequest {
        <QueryAccountAddressDerivativeOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryAccountAddressDerivativeOrdersRequest {
    pub fn new() -> QueryAccountAddressDerivativeOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string account_address = 2;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryAccountAddressDerivativeOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAccountAddressDerivativeOrdersRequest {
        QueryAccountAddressDerivativeOrdersRequest::new()
    }

    fn default_instance() -> &'static QueryAccountAddressDerivativeOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryAccountAddressDerivativeOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAccountAddressDerivativeOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QueryAccountAddressDerivativeOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.account_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAccountAddressDerivativeOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrimmedDerivativeLimitOrder {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub margin: ::std::string::String,
    pub fillable: ::std::string::String,
    pub isBuy: bool,
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrimmedDerivativeLimitOrder {
    fn default() -> &'a TrimmedDerivativeLimitOrder {
        <TrimmedDerivativeLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl TrimmedDerivativeLimitOrder {
    pub fn new() -> TrimmedDerivativeLimitOrder {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string margin = 3;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string fillable = 4;


    pub fn get_fillable(&self) -> &str {
        &self.fillable
    }
    pub fn clear_fillable(&mut self) {
        self.fillable.clear();
    }

    // Param is passed by value, moved
    pub fn set_fillable(&mut self, v: ::std::string::String) {
        self.fillable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fillable(&mut self) -> &mut ::std::string::String {
        &mut self.fillable
    }

    // Take field
    pub fn take_fillable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fillable, ::std::string::String::new())
    }

    // bool isBuy = 5;


    pub fn get_isBuy(&self) -> bool {
        self.isBuy
    }
    pub fn clear_isBuy(&mut self) {
        self.isBuy = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuy(&mut self, v: bool) {
        self.isBuy = v;
    }

    // string order_hash = 6;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TrimmedDerivativeLimitOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fillable)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuy = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.margin);
        }
        if !self.fillable.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.fillable);
        }
        if self.isBuy != false {
            my_size += 2;
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if !self.margin.is_empty() {
            os.write_string(3, &self.margin)?;
        }
        if !self.fillable.is_empty() {
            os.write_string(4, &self.fillable)?;
        }
        if self.isBuy != false {
            os.write_bool(5, self.isBuy)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(6, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrimmedDerivativeLimitOrder {
        TrimmedDerivativeLimitOrder::new()
    }

    fn default_instance() -> &'static TrimmedDerivativeLimitOrder {
        static instance: ::protobuf::rt::LazyV2<TrimmedDerivativeLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrimmedDerivativeLimitOrder::new)
    }
}

impl ::protobuf::Clear for TrimmedDerivativeLimitOrder {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.margin.clear();
        self.fillable.clear();
        self.isBuy = false;
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrimmedDerivativeLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderDerivativeOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderDerivativeOrdersResponse {
    fn default() -> &'a QueryTraderDerivativeOrdersResponse {
        <QueryTraderDerivativeOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderDerivativeOrdersResponse {
    pub fn new() -> QueryTraderDerivativeOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedDerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTraderDerivativeOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderDerivativeOrdersResponse {
        QueryTraderDerivativeOrdersResponse::new()
    }

    fn default_instance() -> &'static QueryTraderDerivativeOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTraderDerivativeOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderDerivativeOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QueryTraderDerivativeOrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderDerivativeOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryAccountAddressDerivativeOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAccountAddressDerivativeOrdersResponse {
    fn default() -> &'a QueryAccountAddressDerivativeOrdersResponse {
        <QueryAccountAddressDerivativeOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAccountAddressDerivativeOrdersResponse {
    pub fn new() -> QueryAccountAddressDerivativeOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedDerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryAccountAddressDerivativeOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAccountAddressDerivativeOrdersResponse {
        QueryAccountAddressDerivativeOrdersResponse::new()
    }

    fn default_instance() -> &'static QueryAccountAddressDerivativeOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryAccountAddressDerivativeOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryAccountAddressDerivativeOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QueryAccountAddressDerivativeOrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAccountAddressDerivativeOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeOrdersByHashesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeOrdersByHashesRequest {
    fn default() -> &'a QueryDerivativeOrdersByHashesRequest {
        <QueryDerivativeOrdersByHashesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeOrdersByHashesRequest {
    pub fn new() -> QueryDerivativeOrdersByHashesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated string order_hashes = 3;


    pub fn get_order_hashes(&self) -> &[::std::string::String] {
        &self.order_hashes
    }
    pub fn clear_order_hashes(&mut self) {
        self.order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_hashes
    }

    // Take field
    pub fn take_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDerivativeOrdersByHashesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        for value in &self.order_hashes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        for v in &self.order_hashes {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeOrdersByHashesRequest {
        QueryDerivativeOrdersByHashesRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeOrdersByHashesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeOrdersByHashesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeOrdersByHashesRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeOrdersByHashesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.subaccount_id.clear();
        self.order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeOrdersByHashesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeOrdersByHashesResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeOrdersByHashesResponse {
    fn default() -> &'a QueryDerivativeOrdersByHashesResponse {
        <QueryDerivativeOrdersByHashesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeOrdersByHashesResponse {
    pub fn new() -> QueryDerivativeOrdersByHashesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedDerivativeLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedDerivativeLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedDerivativeLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDerivativeOrdersByHashesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeOrdersByHashesResponse {
        QueryDerivativeOrdersByHashesResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeOrdersByHashesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeOrdersByHashesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeOrdersByHashesResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeOrdersByHashesResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeOrdersByHashesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketsRequest {
    // message fields
    pub status: ::std::string::String,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub with_mid_price_and_tob: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketsRequest {
    fn default() -> &'a QueryDerivativeMarketsRequest {
        <QueryDerivativeMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketsRequest {
    pub fn new() -> QueryDerivativeMarketsRequest {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // repeated string market_ids = 2;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // bool with_mid_price_and_tob = 3;


    pub fn get_with_mid_price_and_tob(&self) -> bool {
        self.with_mid_price_and_tob
    }
    pub fn clear_with_mid_price_and_tob(&mut self) {
        self.with_mid_price_and_tob = false;
    }

    // Param is passed by value, moved
    pub fn set_with_mid_price_and_tob(&mut self, v: bool) {
        self.with_mid_price_and_tob = v;
    }
}

impl ::protobuf::Message for QueryDerivativeMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.with_mid_price_and_tob = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.with_mid_price_and_tob != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        for v in &self.market_ids {
            os.write_string(2, &v)?;
        };
        if self.with_mid_price_and_tob != false {
            os.write_bool(3, self.with_mid_price_and_tob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketsRequest {
        QueryDerivativeMarketsRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketsRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketsRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.market_ids.clear();
        self.with_mid_price_and_tob = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceLevel {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceLevel {
    fn default() -> &'a PriceLevel {
        <PriceLevel as ::protobuf::Message>::default_instance()
    }
}

impl PriceLevel {
    pub fn new() -> PriceLevel {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PriceLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceLevel {
        PriceLevel::new()
    }

    fn default_instance() -> &'static PriceLevel {
        static instance: ::protobuf::rt::LazyV2<PriceLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PriceLevel::new)
    }
}

impl ::protobuf::Clear for PriceLevel {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerpetualMarketState {
    // message fields
    pub market_info: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketInfo>,
    pub funding_info: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketFunding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerpetualMarketState {
    fn default() -> &'a PerpetualMarketState {
        <PerpetualMarketState as ::protobuf::Message>::default_instance()
    }
}

impl PerpetualMarketState {
    pub fn new() -> PerpetualMarketState {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.PerpetualMarketInfo market_info = 1;


    pub fn get_market_info(&self) -> &super::exchange::PerpetualMarketInfo {
        self.market_info.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market_info(&mut self) {
        self.market_info.clear();
    }

    pub fn has_market_info(&self) -> bool {
        self.market_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market_info(&mut self, v: super::exchange::PerpetualMarketInfo) {
        self.market_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_info(&mut self) -> &mut super::exchange::PerpetualMarketInfo {
        if self.market_info.is_none() {
            self.market_info.set_default();
        }
        self.market_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_market_info(&mut self) -> super::exchange::PerpetualMarketInfo {
        self.market_info.take().unwrap_or_else(|| super::exchange::PerpetualMarketInfo::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding funding_info = 2;


    pub fn get_funding_info(&self) -> &super::exchange::PerpetualMarketFunding {
        self.funding_info.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_funding_info(&mut self) {
        self.funding_info.clear();
    }

    pub fn has_funding_info(&self) -> bool {
        self.funding_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_funding_info(&mut self, v: super::exchange::PerpetualMarketFunding) {
        self.funding_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_funding_info(&mut self) -> &mut super::exchange::PerpetualMarketFunding {
        if self.funding_info.is_none() {
            self.funding_info.set_default();
        }
        self.funding_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_funding_info(&mut self) -> super::exchange::PerpetualMarketFunding {
        self.funding_info.take().unwrap_or_else(|| super::exchange::PerpetualMarketFunding::new())
    }
}

impl ::protobuf::Message for PerpetualMarketState {
    fn is_initialized(&self) -> bool {
        for v in &self.market_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.funding_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.funding_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.funding_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.funding_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerpetualMarketState {
        PerpetualMarketState::new()
    }

    fn default_instance() -> &'static PerpetualMarketState {
        static instance: ::protobuf::rt::LazyV2<PerpetualMarketState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerpetualMarketState::new)
    }
}

impl ::protobuf::Clear for PerpetualMarketState {
    fn clear(&mut self) {
        self.market_info.clear();
        self.funding_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PerpetualMarketState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FullDerivativeMarket {
    // message fields
    pub market: ::protobuf::SingularPtrField<super::exchange::DerivativeMarket>,
    pub mark_price: ::std::string::String,
    pub mid_price_and_tob: ::protobuf::SingularPtrField<super::exchange::MidPriceAndTOB>,
    // message oneof groups
    pub info: ::std::option::Option<FullDerivativeMarket_oneof_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FullDerivativeMarket {
    fn default() -> &'a FullDerivativeMarket {
        <FullDerivativeMarket as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FullDerivativeMarket_oneof_info {
    perpetual_info(PerpetualMarketState),
    futures_info(super::exchange::ExpiryFuturesMarketInfo),
}

impl FullDerivativeMarket {
    pub fn new() -> FullDerivativeMarket {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.DerivativeMarket market = 1;


    pub fn get_market(&self) -> &super::exchange::DerivativeMarket {
        self.market.as_ref().unwrap_or_else(|| <super::exchange::DerivativeMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: super::exchange::DerivativeMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut super::exchange::DerivativeMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> super::exchange::DerivativeMarket {
        self.market.take().unwrap_or_else(|| super::exchange::DerivativeMarket::new())
    }

    // .injective.exchange.v1beta1.PerpetualMarketState perpetual_info = 2;


    pub fn get_perpetual_info(&self) -> &PerpetualMarketState {
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(ref v)) => v,
            _ => <PerpetualMarketState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_perpetual_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_perpetual_info(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_perpetual_info(&mut self, v: PerpetualMarketState) {
        self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_perpetual_info(&mut self) -> &mut PerpetualMarketState {
        if let ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(PerpetualMarketState::new()));
        }
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_perpetual_info(&mut self) -> PerpetualMarketState {
        if self.has_perpetual_info() {
            match self.info.take() {
                ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(v)) => v,
                _ => panic!(),
            }
        } else {
            PerpetualMarketState::new()
        }
    }

    // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo futures_info = 3;


    pub fn get_futures_info(&self) -> &super::exchange::ExpiryFuturesMarketInfo {
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(ref v)) => v,
            _ => <super::exchange::ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_futures_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_futures_info(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_futures_info(&mut self, v: super::exchange::ExpiryFuturesMarketInfo) {
        self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_futures_info(&mut self) -> &mut super::exchange::ExpiryFuturesMarketInfo {
        if let ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(super::exchange::ExpiryFuturesMarketInfo::new()));
        }
        match self.info {
            ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_futures_info(&mut self) -> super::exchange::ExpiryFuturesMarketInfo {
        if self.has_futures_info() {
            match self.info.take() {
                ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(v)) => v,
                _ => panic!(),
            }
        } else {
            super::exchange::ExpiryFuturesMarketInfo::new()
        }
    }

    // string mark_price = 4;


    pub fn get_mark_price(&self) -> &str {
        &self.mark_price
    }
    pub fn clear_mark_price(&mut self) {
        self.mark_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_mark_price(&mut self, v: ::std::string::String) {
        self.mark_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mark_price(&mut self) -> &mut ::std::string::String {
        &mut self.mark_price
    }

    // Take field
    pub fn take_mark_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mark_price, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.MidPriceAndTOB mid_price_and_tob = 5;


    pub fn get_mid_price_and_tob(&self) -> &super::exchange::MidPriceAndTOB {
        self.mid_price_and_tob.as_ref().unwrap_or_else(|| <super::exchange::MidPriceAndTOB as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mid_price_and_tob(&mut self) {
        self.mid_price_and_tob.clear();
    }

    pub fn has_mid_price_and_tob(&self) -> bool {
        self.mid_price_and_tob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mid_price_and_tob(&mut self, v: super::exchange::MidPriceAndTOB) {
        self.mid_price_and_tob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mid_price_and_tob(&mut self) -> &mut super::exchange::MidPriceAndTOB {
        if self.mid_price_and_tob.is_none() {
            self.mid_price_and_tob.set_default();
        }
        self.mid_price_and_tob.as_mut().unwrap()
    }

    // Take field
    pub fn take_mid_price_and_tob(&mut self) -> super::exchange::MidPriceAndTOB {
        self.mid_price_and_tob.take().unwrap_or_else(|| super::exchange::MidPriceAndTOB::new())
    }
}

impl ::protobuf::Message for FullDerivativeMarket {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(FullDerivativeMarket_oneof_info::perpetual_info(ref v)) = self.info {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FullDerivativeMarket_oneof_info::futures_info(ref v)) = self.info {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.mid_price_and_tob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::perpetual_info(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.info = ::std::option::Option::Some(FullDerivativeMarket_oneof_info::futures_info(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mark_price)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mid_price_and_tob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.mark_price.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mark_price);
        }
        if let Some(ref v) = self.mid_price_and_tob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &FullDerivativeMarket_oneof_info::perpetual_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FullDerivativeMarket_oneof_info::futures_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.mark_price.is_empty() {
            os.write_string(4, &self.mark_price)?;
        }
        if let Some(ref v) = self.mid_price_and_tob.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &FullDerivativeMarket_oneof_info::perpetual_info(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FullDerivativeMarket_oneof_info::futures_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FullDerivativeMarket {
        FullDerivativeMarket::new()
    }

    fn default_instance() -> &'static FullDerivativeMarket {
        static instance: ::protobuf::rt::LazyV2<FullDerivativeMarket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FullDerivativeMarket::new)
    }
}

impl ::protobuf::Clear for FullDerivativeMarket {
    fn clear(&mut self) {
        self.market.clear();
        self.info = ::std::option::Option::None;
        self.info = ::std::option::Option::None;
        self.mark_price.clear();
        self.mid_price_and_tob.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FullDerivativeMarket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<FullDerivativeMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketsResponse {
    fn default() -> &'a QueryDerivativeMarketsResponse {
        <QueryDerivativeMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketsResponse {
    pub fn new() -> QueryDerivativeMarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.FullDerivativeMarket markets = 1;


    pub fn get_markets(&self) -> &[FullDerivativeMarket] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<FullDerivativeMarket>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<FullDerivativeMarket> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<FullDerivativeMarket> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketsResponse {
        QueryDerivativeMarketsResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketsResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketRequest {
    fn default() -> &'a QueryDerivativeMarketRequest {
        <QueryDerivativeMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketRequest {
    pub fn new() -> QueryDerivativeMarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketRequest {
        QueryDerivativeMarketRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<FullDerivativeMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketResponse {
    fn default() -> &'a QueryDerivativeMarketResponse {
        <QueryDerivativeMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketResponse {
    pub fn new() -> QueryDerivativeMarketResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.FullDerivativeMarket market = 1;


    pub fn get_market(&self) -> &FullDerivativeMarket {
        self.market.as_ref().unwrap_or_else(|| <FullDerivativeMarket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: FullDerivativeMarket) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut FullDerivativeMarket {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> FullDerivativeMarket {
        self.market.take().unwrap_or_else(|| FullDerivativeMarket::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketResponse {
        QueryDerivativeMarketResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketAddressRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketAddressRequest {
    fn default() -> &'a QueryDerivativeMarketAddressRequest {
        <QueryDerivativeMarketAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketAddressRequest {
    pub fn new() -> QueryDerivativeMarketAddressRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMarketAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketAddressRequest {
        QueryDerivativeMarketAddressRequest::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketAddressRequest {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketAddressRequest::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketAddressRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryDerivativeMarketAddressResponse {
    // message fields
    pub address: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryDerivativeMarketAddressResponse {
    fn default() -> &'a QueryDerivativeMarketAddressResponse {
        <QueryDerivativeMarketAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryDerivativeMarketAddressResponse {
    pub fn new() -> QueryDerivativeMarketAddressResponse {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryDerivativeMarketAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryDerivativeMarketAddressResponse {
        QueryDerivativeMarketAddressResponse::new()
    }

    fn default_instance() -> &'static QueryDerivativeMarketAddressResponse {
        static instance: ::protobuf::rt::LazyV2<QueryDerivativeMarketAddressResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryDerivativeMarketAddressResponse::new)
    }
}

impl ::protobuf::Clear for QueryDerivativeMarketAddressResponse {
    fn clear(&mut self) {
        self.address.clear();
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryDerivativeMarketAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountTradeNonceRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountTradeNonceRequest {
    fn default() -> &'a QuerySubaccountTradeNonceRequest {
        <QuerySubaccountTradeNonceRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountTradeNonceRequest {
    pub fn new() -> QuerySubaccountTradeNonceRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountTradeNonceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountTradeNonceRequest {
        QuerySubaccountTradeNonceRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountTradeNonceRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountTradeNonceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountTradeNonceRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountTradeNonceRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountTradeNonceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountPositionsRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountPositionsRequest {
    fn default() -> &'a QuerySubaccountPositionsRequest {
        <QuerySubaccountPositionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountPositionsRequest {
    pub fn new() -> QuerySubaccountPositionsRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountPositionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountPositionsRequest {
        QuerySubaccountPositionsRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountPositionsRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountPositionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountPositionsRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountPositionsRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountPositionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountPositionInMarketRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountPositionInMarketRequest {
    fn default() -> &'a QuerySubaccountPositionInMarketRequest {
        <QuerySubaccountPositionInMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountPositionInMarketRequest {
    pub fn new() -> QuerySubaccountPositionInMarketRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountPositionInMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountPositionInMarketRequest {
        QuerySubaccountPositionInMarketRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountPositionInMarketRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountPositionInMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountPositionInMarketRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountPositionInMarketRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountPositionInMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountEffectivePositionInMarketRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountEffectivePositionInMarketRequest {
    fn default() -> &'a QuerySubaccountEffectivePositionInMarketRequest {
        <QuerySubaccountEffectivePositionInMarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountEffectivePositionInMarketRequest {
    pub fn new() -> QuerySubaccountEffectivePositionInMarketRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountEffectivePositionInMarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountEffectivePositionInMarketRequest {
        QuerySubaccountEffectivePositionInMarketRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountEffectivePositionInMarketRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountEffectivePositionInMarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountEffectivePositionInMarketRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountEffectivePositionInMarketRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountEffectivePositionInMarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountOrderMetadataRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountOrderMetadataRequest {
    fn default() -> &'a QuerySubaccountOrderMetadataRequest {
        <QuerySubaccountOrderMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountOrderMetadataRequest {
    pub fn new() -> QuerySubaccountOrderMetadataRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuerySubaccountOrderMetadataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountOrderMetadataRequest {
        QuerySubaccountOrderMetadataRequest::new()
    }

    fn default_instance() -> &'static QuerySubaccountOrderMetadataRequest {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountOrderMetadataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountOrderMetadataRequest::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountOrderMetadataRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountOrderMetadataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountPositionsResponse {
    // message fields
    pub state: ::protobuf::RepeatedField<super::genesis::DerivativePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountPositionsResponse {
    fn default() -> &'a QuerySubaccountPositionsResponse {
        <QuerySubaccountPositionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountPositionsResponse {
    pub fn new() -> QuerySubaccountPositionsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.DerivativePosition state = 1;


    pub fn get_state(&self) -> &[super::genesis::DerivativePosition] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::protobuf::RepeatedField<super::genesis::DerivativePosition>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut ::protobuf::RepeatedField<super::genesis::DerivativePosition> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::protobuf::RepeatedField<super::genesis::DerivativePosition> {
        ::std::mem::replace(&mut self.state, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySubaccountPositionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.state {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountPositionsResponse {
        QuerySubaccountPositionsResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountPositionsResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountPositionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountPositionsResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountPositionsResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountPositionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountPositionInMarketResponse {
    // message fields
    pub state: ::protobuf::SingularPtrField<super::exchange::Position>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountPositionInMarketResponse {
    fn default() -> &'a QuerySubaccountPositionInMarketResponse {
        <QuerySubaccountPositionInMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountPositionInMarketResponse {
    pub fn new() -> QuerySubaccountPositionInMarketResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.Position state = 1;


    pub fn get_state(&self) -> &super::exchange::Position {
        self.state.as_ref().unwrap_or_else(|| <super::exchange::Position as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::exchange::Position) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::exchange::Position {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::exchange::Position {
        self.state.take().unwrap_or_else(|| super::exchange::Position::new())
    }
}

impl ::protobuf::Message for QuerySubaccountPositionInMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountPositionInMarketResponse {
        QuerySubaccountPositionInMarketResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountPositionInMarketResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountPositionInMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountPositionInMarketResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountPositionInMarketResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountPositionInMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EffectivePosition {
    // message fields
    pub is_long: bool,
    pub quantity: ::std::string::String,
    pub entry_price: ::std::string::String,
    pub effective_margin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EffectivePosition {
    fn default() -> &'a EffectivePosition {
        <EffectivePosition as ::protobuf::Message>::default_instance()
    }
}

impl EffectivePosition {
    pub fn new() -> EffectivePosition {
        ::std::default::Default::default()
    }

    // bool is_long = 1;


    pub fn get_is_long(&self) -> bool {
        self.is_long
    }
    pub fn clear_is_long(&mut self) {
        self.is_long = false;
    }

    // Param is passed by value, moved
    pub fn set_is_long(&mut self, v: bool) {
        self.is_long = v;
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string entry_price = 3;


    pub fn get_entry_price(&self) -> &str {
        &self.entry_price
    }
    pub fn clear_entry_price(&mut self) {
        self.entry_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_price(&mut self, v: ::std::string::String) {
        self.entry_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_price(&mut self) -> &mut ::std::string::String {
        &mut self.entry_price
    }

    // Take field
    pub fn take_entry_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_price, ::std::string::String::new())
    }

    // string effective_margin = 4;


    pub fn get_effective_margin(&self) -> &str {
        &self.effective_margin
    }
    pub fn clear_effective_margin(&mut self) {
        self.effective_margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_effective_margin(&mut self, v: ::std::string::String) {
        self.effective_margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effective_margin(&mut self) -> &mut ::std::string::String {
        &mut self.effective_margin
    }

    // Take field
    pub fn take_effective_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effective_margin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EffectivePosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_long = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_price)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effective_margin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_long != false {
            my_size += 2;
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if !self.entry_price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.entry_price);
        }
        if !self.effective_margin.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.effective_margin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_long != false {
            os.write_bool(1, self.is_long)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if !self.entry_price.is_empty() {
            os.write_string(3, &self.entry_price)?;
        }
        if !self.effective_margin.is_empty() {
            os.write_string(4, &self.effective_margin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EffectivePosition {
        EffectivePosition::new()
    }

    fn default_instance() -> &'static EffectivePosition {
        static instance: ::protobuf::rt::LazyV2<EffectivePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EffectivePosition::new)
    }
}

impl ::protobuf::Clear for EffectivePosition {
    fn clear(&mut self) {
        self.is_long = false;
        self.quantity.clear();
        self.entry_price.clear();
        self.effective_margin.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EffectivePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountEffectivePositionInMarketResponse {
    // message fields
    pub state: ::protobuf::SingularPtrField<EffectivePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountEffectivePositionInMarketResponse {
    fn default() -> &'a QuerySubaccountEffectivePositionInMarketResponse {
        <QuerySubaccountEffectivePositionInMarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountEffectivePositionInMarketResponse {
    pub fn new() -> QuerySubaccountEffectivePositionInMarketResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.EffectivePosition state = 1;


    pub fn get_state(&self) -> &EffectivePosition {
        self.state.as_ref().unwrap_or_else(|| <EffectivePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EffectivePosition) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut EffectivePosition {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> EffectivePosition {
        self.state.take().unwrap_or_else(|| EffectivePosition::new())
    }
}

impl ::protobuf::Message for QuerySubaccountEffectivePositionInMarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountEffectivePositionInMarketResponse {
        QuerySubaccountEffectivePositionInMarketResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountEffectivePositionInMarketResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountEffectivePositionInMarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountEffectivePositionInMarketResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountEffectivePositionInMarketResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountEffectivePositionInMarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPerpetualMarketInfoRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPerpetualMarketInfoRequest {
    fn default() -> &'a QueryPerpetualMarketInfoRequest {
        <QueryPerpetualMarketInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPerpetualMarketInfoRequest {
    pub fn new() -> QueryPerpetualMarketInfoRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryPerpetualMarketInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPerpetualMarketInfoRequest {
        QueryPerpetualMarketInfoRequest::new()
    }

    fn default_instance() -> &'static QueryPerpetualMarketInfoRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPerpetualMarketInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPerpetualMarketInfoRequest::new)
    }
}

impl ::protobuf::Clear for QueryPerpetualMarketInfoRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPerpetualMarketInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPerpetualMarketInfoResponse {
    // message fields
    pub info: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPerpetualMarketInfoResponse {
    fn default() -> &'a QueryPerpetualMarketInfoResponse {
        <QueryPerpetualMarketInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPerpetualMarketInfoResponse {
    pub fn new() -> QueryPerpetualMarketInfoResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.PerpetualMarketInfo info = 1;


    pub fn get_info(&self) -> &super::exchange::PerpetualMarketInfo {
        self.info.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: super::exchange::PerpetualMarketInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut super::exchange::PerpetualMarketInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> super::exchange::PerpetualMarketInfo {
        self.info.take().unwrap_or_else(|| super::exchange::PerpetualMarketInfo::new())
    }
}

impl ::protobuf::Message for QueryPerpetualMarketInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPerpetualMarketInfoResponse {
        QueryPerpetualMarketInfoResponse::new()
    }

    fn default_instance() -> &'static QueryPerpetualMarketInfoResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPerpetualMarketInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPerpetualMarketInfoResponse::new)
    }
}

impl ::protobuf::Clear for QueryPerpetualMarketInfoResponse {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPerpetualMarketInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExpiryFuturesMarketInfoRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExpiryFuturesMarketInfoRequest {
    fn default() -> &'a QueryExpiryFuturesMarketInfoRequest {
        <QueryExpiryFuturesMarketInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryExpiryFuturesMarketInfoRequest {
    pub fn new() -> QueryExpiryFuturesMarketInfoRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryExpiryFuturesMarketInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExpiryFuturesMarketInfoRequest {
        QueryExpiryFuturesMarketInfoRequest::new()
    }

    fn default_instance() -> &'static QueryExpiryFuturesMarketInfoRequest {
        static instance: ::protobuf::rt::LazyV2<QueryExpiryFuturesMarketInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExpiryFuturesMarketInfoRequest::new)
    }
}

impl ::protobuf::Clear for QueryExpiryFuturesMarketInfoRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExpiryFuturesMarketInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryExpiryFuturesMarketInfoResponse {
    // message fields
    pub info: ::protobuf::SingularPtrField<super::exchange::ExpiryFuturesMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryExpiryFuturesMarketInfoResponse {
    fn default() -> &'a QueryExpiryFuturesMarketInfoResponse {
        <QueryExpiryFuturesMarketInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryExpiryFuturesMarketInfoResponse {
    pub fn new() -> QueryExpiryFuturesMarketInfoResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.ExpiryFuturesMarketInfo info = 1;


    pub fn get_info(&self) -> &super::exchange::ExpiryFuturesMarketInfo {
        self.info.as_ref().unwrap_or_else(|| <super::exchange::ExpiryFuturesMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: super::exchange::ExpiryFuturesMarketInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut super::exchange::ExpiryFuturesMarketInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> super::exchange::ExpiryFuturesMarketInfo {
        self.info.take().unwrap_or_else(|| super::exchange::ExpiryFuturesMarketInfo::new())
    }
}

impl ::protobuf::Message for QueryExpiryFuturesMarketInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryExpiryFuturesMarketInfoResponse {
        QueryExpiryFuturesMarketInfoResponse::new()
    }

    fn default_instance() -> &'static QueryExpiryFuturesMarketInfoResponse {
        static instance: ::protobuf::rt::LazyV2<QueryExpiryFuturesMarketInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryExpiryFuturesMarketInfoResponse::new)
    }
}

impl ::protobuf::Clear for QueryExpiryFuturesMarketInfoResponse {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryExpiryFuturesMarketInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPerpetualMarketFundingRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPerpetualMarketFundingRequest {
    fn default() -> &'a QueryPerpetualMarketFundingRequest {
        <QueryPerpetualMarketFundingRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPerpetualMarketFundingRequest {
    pub fn new() -> QueryPerpetualMarketFundingRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryPerpetualMarketFundingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPerpetualMarketFundingRequest {
        QueryPerpetualMarketFundingRequest::new()
    }

    fn default_instance() -> &'static QueryPerpetualMarketFundingRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPerpetualMarketFundingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPerpetualMarketFundingRequest::new)
    }
}

impl ::protobuf::Clear for QueryPerpetualMarketFundingRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPerpetualMarketFundingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPerpetualMarketFundingResponse {
    // message fields
    pub state: ::protobuf::SingularPtrField<super::exchange::PerpetualMarketFunding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPerpetualMarketFundingResponse {
    fn default() -> &'a QueryPerpetualMarketFundingResponse {
        <QueryPerpetualMarketFundingResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPerpetualMarketFundingResponse {
    pub fn new() -> QueryPerpetualMarketFundingResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.PerpetualMarketFunding state = 1;


    pub fn get_state(&self) -> &super::exchange::PerpetualMarketFunding {
        self.state.as_ref().unwrap_or_else(|| <super::exchange::PerpetualMarketFunding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::exchange::PerpetualMarketFunding) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::exchange::PerpetualMarketFunding {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::exchange::PerpetualMarketFunding {
        self.state.take().unwrap_or_else(|| super::exchange::PerpetualMarketFunding::new())
    }
}

impl ::protobuf::Message for QueryPerpetualMarketFundingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPerpetualMarketFundingResponse {
        QueryPerpetualMarketFundingResponse::new()
    }

    fn default_instance() -> &'static QueryPerpetualMarketFundingResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPerpetualMarketFundingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPerpetualMarketFundingResponse::new)
    }
}

impl ::protobuf::Clear for QueryPerpetualMarketFundingResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPerpetualMarketFundingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountOrderMetadataResponse {
    // message fields
    pub metadata: ::protobuf::RepeatedField<SubaccountOrderbookMetadataWithMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountOrderMetadataResponse {
    fn default() -> &'a QuerySubaccountOrderMetadataResponse {
        <QuerySubaccountOrderMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountOrderMetadataResponse {
    pub fn new() -> QuerySubaccountOrderMetadataResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.SubaccountOrderbookMetadataWithMarket metadata = 1;


    pub fn get_metadata(&self) -> &[SubaccountOrderbookMetadataWithMarket] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<SubaccountOrderbookMetadataWithMarket>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountOrderbookMetadataWithMarket> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<SubaccountOrderbookMetadataWithMarket> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QuerySubaccountOrderMetadataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.metadata {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountOrderMetadataResponse {
        QuerySubaccountOrderMetadataResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountOrderMetadataResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountOrderMetadataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountOrderMetadataResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountOrderMetadataResponse {
    fn clear(&mut self) {
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountOrderMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuerySubaccountTradeNonceResponse {
    // message fields
    pub nonce: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuerySubaccountTradeNonceResponse {
    fn default() -> &'a QuerySubaccountTradeNonceResponse {
        <QuerySubaccountTradeNonceResponse as ::protobuf::Message>::default_instance()
    }
}

impl QuerySubaccountTradeNonceResponse {
    pub fn new() -> QuerySubaccountTradeNonceResponse {
        ::std::default::Default::default()
    }

    // uint32 nonce = 1;


    pub fn get_nonce(&self) -> u32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u32) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for QuerySubaccountTradeNonceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.nonce != 0 {
            os.write_uint32(1, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuerySubaccountTradeNonceResponse {
        QuerySubaccountTradeNonceResponse::new()
    }

    fn default_instance() -> &'static QuerySubaccountTradeNonceResponse {
        static instance: ::protobuf::rt::LazyV2<QuerySubaccountTradeNonceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuerySubaccountTradeNonceResponse::new)
    }
}

impl ::protobuf::Clear for QuerySubaccountTradeNonceResponse {
    fn clear(&mut self) {
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuerySubaccountTradeNonceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryModuleStateRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryModuleStateRequest {
    fn default() -> &'a QueryModuleStateRequest {
        <QueryModuleStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleStateRequest {
    pub fn new() -> QueryModuleStateRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryModuleStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryModuleStateRequest {
        QueryModuleStateRequest::new()
    }

    fn default_instance() -> &'static QueryModuleStateRequest {
        static instance: ::protobuf::rt::LazyV2<QueryModuleStateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryModuleStateRequest::new)
    }
}

impl ::protobuf::Clear for QueryModuleStateRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryModuleStateResponse {
    // message fields
    pub state: ::protobuf::SingularPtrField<super::genesis::GenesisState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryModuleStateResponse {
    fn default() -> &'a QueryModuleStateResponse {
        <QueryModuleStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryModuleStateResponse {
    pub fn new() -> QueryModuleStateResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.GenesisState state = 1;


    pub fn get_state(&self) -> &super::genesis::GenesisState {
        self.state.as_ref().unwrap_or_else(|| <super::genesis::GenesisState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::genesis::GenesisState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut super::genesis::GenesisState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> super::genesis::GenesisState {
        self.state.take().unwrap_or_else(|| super::genesis::GenesisState::new())
    }
}

impl ::protobuf::Message for QueryModuleStateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryModuleStateResponse {
        QueryModuleStateResponse::new()
    }

    fn default_instance() -> &'static QueryModuleStateResponse {
        static instance: ::protobuf::rt::LazyV2<QueryModuleStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryModuleStateResponse::new)
    }
}

impl ::protobuf::Clear for QueryModuleStateResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryModuleStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPositionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPositionsRequest {
    fn default() -> &'a QueryPositionsRequest {
        <QueryPositionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryPositionsRequest {
    pub fn new() -> QueryPositionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryPositionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPositionsRequest {
        QueryPositionsRequest::new()
    }

    fn default_instance() -> &'static QueryPositionsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryPositionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPositionsRequest::new)
    }
}

impl ::protobuf::Clear for QueryPositionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPositionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryPositionsResponse {
    // message fields
    pub state: ::protobuf::RepeatedField<super::genesis::DerivativePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryPositionsResponse {
    fn default() -> &'a QueryPositionsResponse {
        <QueryPositionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryPositionsResponse {
    pub fn new() -> QueryPositionsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.DerivativePosition state = 1;


    pub fn get_state(&self) -> &[super::genesis::DerivativePosition] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::protobuf::RepeatedField<super::genesis::DerivativePosition>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut ::protobuf::RepeatedField<super::genesis::DerivativePosition> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::protobuf::RepeatedField<super::genesis::DerivativePosition> {
        ::std::mem::replace(&mut self.state, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryPositionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.state {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPositionsResponse {
        QueryPositionsResponse::new()
    }

    fn default_instance() -> &'static QueryPositionsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryPositionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryPositionsResponse::new)
    }
}

impl ::protobuf::Clear for QueryPositionsResponse {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPositionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTradeRewardPointsRequest {
    // message fields
    pub accounts: ::protobuf::RepeatedField<::std::string::String>,
    pub pending_pool_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTradeRewardPointsRequest {
    fn default() -> &'a QueryTradeRewardPointsRequest {
        <QueryTradeRewardPointsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTradeRewardPointsRequest {
    pub fn new() -> QueryTradeRewardPointsRequest {
        ::std::default::Default::default()
    }

    // repeated string accounts = 1;


    pub fn get_accounts(&self) -> &[::std::string::String] {
        &self.accounts
    }
    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }

    // int64 pending_pool_timestamp = 2;


    pub fn get_pending_pool_timestamp(&self) -> i64 {
        self.pending_pool_timestamp
    }
    pub fn clear_pending_pool_timestamp(&mut self) {
        self.pending_pool_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_pool_timestamp(&mut self, v: i64) {
        self.pending_pool_timestamp = v;
    }
}

impl ::protobuf::Message for QueryTradeRewardPointsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accounts)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_pool_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.pending_pool_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pending_pool_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_string(1, &v)?;
        };
        if self.pending_pool_timestamp != 0 {
            os.write_int64(2, self.pending_pool_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTradeRewardPointsRequest {
        QueryTradeRewardPointsRequest::new()
    }

    fn default_instance() -> &'static QueryTradeRewardPointsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTradeRewardPointsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTradeRewardPointsRequest::new)
    }
}

impl ::protobuf::Clear for QueryTradeRewardPointsRequest {
    fn clear(&mut self) {
        self.accounts.clear();
        self.pending_pool_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTradeRewardPointsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTradeRewardPointsResponse {
    // message fields
    pub account_trade_reward_points: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTradeRewardPointsResponse {
    fn default() -> &'a QueryTradeRewardPointsResponse {
        <QueryTradeRewardPointsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTradeRewardPointsResponse {
    pub fn new() -> QueryTradeRewardPointsResponse {
        ::std::default::Default::default()
    }

    // repeated string account_trade_reward_points = 1;


    pub fn get_account_trade_reward_points(&self) -> &[::std::string::String] {
        &self.account_trade_reward_points
    }
    pub fn clear_account_trade_reward_points(&mut self) {
        self.account_trade_reward_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_trade_reward_points(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.account_trade_reward_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_trade_reward_points(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.account_trade_reward_points
    }

    // Take field
    pub fn take_account_trade_reward_points(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.account_trade_reward_points, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTradeRewardPointsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.account_trade_reward_points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_trade_reward_points {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_trade_reward_points {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTradeRewardPointsResponse {
        QueryTradeRewardPointsResponse::new()
    }

    fn default_instance() -> &'static QueryTradeRewardPointsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTradeRewardPointsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTradeRewardPointsResponse::new)
    }
}

impl ::protobuf::Clear for QueryTradeRewardPointsResponse {
    fn clear(&mut self) {
        self.account_trade_reward_points.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTradeRewardPointsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTradeRewardCampaignRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTradeRewardCampaignRequest {
    fn default() -> &'a QueryTradeRewardCampaignRequest {
        <QueryTradeRewardCampaignRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTradeRewardCampaignRequest {
    pub fn new() -> QueryTradeRewardCampaignRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryTradeRewardCampaignRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTradeRewardCampaignRequest {
        QueryTradeRewardCampaignRequest::new()
    }

    fn default_instance() -> &'static QueryTradeRewardCampaignRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTradeRewardCampaignRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTradeRewardCampaignRequest::new)
    }
}

impl ::protobuf::Clear for QueryTradeRewardCampaignRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTradeRewardCampaignRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTradeRewardCampaignResponse {
    // message fields
    pub trading_reward_campaign_info: ::protobuf::SingularPtrField<super::exchange::TradingRewardCampaignInfo>,
    pub trading_reward_pool_campaign_schedule: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    pub total_trade_reward_points: ::std::string::String,
    pub pending_trading_reward_pool_campaign_schedule: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>,
    pub pending_total_trade_reward_points: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTradeRewardCampaignResponse {
    fn default() -> &'a QueryTradeRewardCampaignResponse {
        <QueryTradeRewardCampaignResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTradeRewardCampaignResponse {
    pub fn new() -> QueryTradeRewardCampaignResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.TradingRewardCampaignInfo trading_reward_campaign_info = 1;


    pub fn get_trading_reward_campaign_info(&self) -> &super::exchange::TradingRewardCampaignInfo {
        self.trading_reward_campaign_info.as_ref().unwrap_or_else(|| <super::exchange::TradingRewardCampaignInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trading_reward_campaign_info(&mut self) {
        self.trading_reward_campaign_info.clear();
    }

    pub fn has_trading_reward_campaign_info(&self) -> bool {
        self.trading_reward_campaign_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_campaign_info(&mut self, v: super::exchange::TradingRewardCampaignInfo) {
        self.trading_reward_campaign_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_reward_campaign_info(&mut self) -> &mut super::exchange::TradingRewardCampaignInfo {
        if self.trading_reward_campaign_info.is_none() {
            self.trading_reward_campaign_info.set_default();
        }
        self.trading_reward_campaign_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_trading_reward_campaign_info(&mut self) -> super::exchange::TradingRewardCampaignInfo {
        self.trading_reward_campaign_info.take().unwrap_or_else(|| super::exchange::TradingRewardCampaignInfo::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool trading_reward_pool_campaign_schedule = 2;


    pub fn get_trading_reward_pool_campaign_schedule(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.trading_reward_pool_campaign_schedule
    }
    pub fn clear_trading_reward_pool_campaign_schedule(&mut self) {
        self.trading_reward_pool_campaign_schedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_trading_reward_pool_campaign_schedule(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.trading_reward_pool_campaign_schedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trading_reward_pool_campaign_schedule(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.trading_reward_pool_campaign_schedule
    }

    // Take field
    pub fn take_trading_reward_pool_campaign_schedule(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.trading_reward_pool_campaign_schedule, ::protobuf::RepeatedField::new())
    }

    // string total_trade_reward_points = 3;


    pub fn get_total_trade_reward_points(&self) -> &str {
        &self.total_trade_reward_points
    }
    pub fn clear_total_trade_reward_points(&mut self) {
        self.total_trade_reward_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_trade_reward_points(&mut self, v: ::std::string::String) {
        self.total_trade_reward_points = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_trade_reward_points(&mut self) -> &mut ::std::string::String {
        &mut self.total_trade_reward_points
    }

    // Take field
    pub fn take_total_trade_reward_points(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_trade_reward_points, ::std::string::String::new())
    }

    // repeated .injective.exchange.v1beta1.CampaignRewardPool pending_trading_reward_pool_campaign_schedule = 4;


    pub fn get_pending_trading_reward_pool_campaign_schedule(&self) -> &[super::exchange::CampaignRewardPool] {
        &self.pending_trading_reward_pool_campaign_schedule
    }
    pub fn clear_pending_trading_reward_pool_campaign_schedule(&mut self) {
        self.pending_trading_reward_pool_campaign_schedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_trading_reward_pool_campaign_schedule(&mut self, v: ::protobuf::RepeatedField<super::exchange::CampaignRewardPool>) {
        self.pending_trading_reward_pool_campaign_schedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_trading_reward_pool_campaign_schedule(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        &mut self.pending_trading_reward_pool_campaign_schedule
    }

    // Take field
    pub fn take_pending_trading_reward_pool_campaign_schedule(&mut self) -> ::protobuf::RepeatedField<super::exchange::CampaignRewardPool> {
        ::std::mem::replace(&mut self.pending_trading_reward_pool_campaign_schedule, ::protobuf::RepeatedField::new())
    }

    // repeated string pending_total_trade_reward_points = 5;


    pub fn get_pending_total_trade_reward_points(&self) -> &[::std::string::String] {
        &self.pending_total_trade_reward_points
    }
    pub fn clear_pending_total_trade_reward_points(&mut self) {
        self.pending_total_trade_reward_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_total_trade_reward_points(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.pending_total_trade_reward_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_total_trade_reward_points(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.pending_total_trade_reward_points
    }

    // Take field
    pub fn take_pending_total_trade_reward_points(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.pending_total_trade_reward_points, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTradeRewardCampaignResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trading_reward_campaign_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trading_reward_pool_campaign_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_trading_reward_pool_campaign_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trading_reward_campaign_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trading_reward_pool_campaign_schedule)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_trade_reward_points)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_trading_reward_pool_campaign_schedule)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pending_total_trade_reward_points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trading_reward_campaign_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.trading_reward_pool_campaign_schedule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.total_trade_reward_points.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.total_trade_reward_points);
        }
        for value in &self.pending_trading_reward_pool_campaign_schedule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_total_trade_reward_points {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trading_reward_campaign_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.trading_reward_pool_campaign_schedule {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.total_trade_reward_points.is_empty() {
            os.write_string(3, &self.total_trade_reward_points)?;
        }
        for v in &self.pending_trading_reward_pool_campaign_schedule {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_total_trade_reward_points {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTradeRewardCampaignResponse {
        QueryTradeRewardCampaignResponse::new()
    }

    fn default_instance() -> &'static QueryTradeRewardCampaignResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTradeRewardCampaignResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTradeRewardCampaignResponse::new)
    }
}

impl ::protobuf::Clear for QueryTradeRewardCampaignResponse {
    fn clear(&mut self) {
        self.trading_reward_campaign_info.clear();
        self.trading_reward_pool_campaign_schedule.clear();
        self.total_trade_reward_points.clear();
        self.pending_trading_reward_pool_campaign_schedule.clear();
        self.pending_total_trade_reward_points.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTradeRewardCampaignResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryIsOptedOutOfRewardsRequest {
    // message fields
    pub account: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryIsOptedOutOfRewardsRequest {
    fn default() -> &'a QueryIsOptedOutOfRewardsRequest {
        <QueryIsOptedOutOfRewardsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryIsOptedOutOfRewardsRequest {
    pub fn new() -> QueryIsOptedOutOfRewardsRequest {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryIsOptedOutOfRewardsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryIsOptedOutOfRewardsRequest {
        QueryIsOptedOutOfRewardsRequest::new()
    }

    fn default_instance() -> &'static QueryIsOptedOutOfRewardsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryIsOptedOutOfRewardsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryIsOptedOutOfRewardsRequest::new)
    }
}

impl ::protobuf::Clear for QueryIsOptedOutOfRewardsRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryIsOptedOutOfRewardsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryIsOptedOutOfRewardsResponse {
    // message fields
    pub is_opted_out: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryIsOptedOutOfRewardsResponse {
    fn default() -> &'a QueryIsOptedOutOfRewardsResponse {
        <QueryIsOptedOutOfRewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryIsOptedOutOfRewardsResponse {
    pub fn new() -> QueryIsOptedOutOfRewardsResponse {
        ::std::default::Default::default()
    }

    // bool is_opted_out = 1;


    pub fn get_is_opted_out(&self) -> bool {
        self.is_opted_out
    }
    pub fn clear_is_opted_out(&mut self) {
        self.is_opted_out = false;
    }

    // Param is passed by value, moved
    pub fn set_is_opted_out(&mut self, v: bool) {
        self.is_opted_out = v;
    }
}

impl ::protobuf::Message for QueryIsOptedOutOfRewardsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_opted_out = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_opted_out != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_opted_out != false {
            os.write_bool(1, self.is_opted_out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryIsOptedOutOfRewardsResponse {
        QueryIsOptedOutOfRewardsResponse::new()
    }

    fn default_instance() -> &'static QueryIsOptedOutOfRewardsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryIsOptedOutOfRewardsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryIsOptedOutOfRewardsResponse::new)
    }
}

impl ::protobuf::Clear for QueryIsOptedOutOfRewardsResponse {
    fn clear(&mut self) {
        self.is_opted_out = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryIsOptedOutOfRewardsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOptedOutOfRewardsAccountsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOptedOutOfRewardsAccountsRequest {
    fn default() -> &'a QueryOptedOutOfRewardsAccountsRequest {
        <QueryOptedOutOfRewardsAccountsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryOptedOutOfRewardsAccountsRequest {
    pub fn new() -> QueryOptedOutOfRewardsAccountsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryOptedOutOfRewardsAccountsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOptedOutOfRewardsAccountsRequest {
        QueryOptedOutOfRewardsAccountsRequest::new()
    }

    fn default_instance() -> &'static QueryOptedOutOfRewardsAccountsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryOptedOutOfRewardsAccountsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOptedOutOfRewardsAccountsRequest::new)
    }
}

impl ::protobuf::Clear for QueryOptedOutOfRewardsAccountsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOptedOutOfRewardsAccountsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryOptedOutOfRewardsAccountsResponse {
    // message fields
    pub accounts: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryOptedOutOfRewardsAccountsResponse {
    fn default() -> &'a QueryOptedOutOfRewardsAccountsResponse {
        <QueryOptedOutOfRewardsAccountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryOptedOutOfRewardsAccountsResponse {
    pub fn new() -> QueryOptedOutOfRewardsAccountsResponse {
        ::std::default::Default::default()
    }

    // repeated string accounts = 1;


    pub fn get_accounts(&self) -> &[::std::string::String] {
        &self.accounts
    }
    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryOptedOutOfRewardsAccountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryOptedOutOfRewardsAccountsResponse {
        QueryOptedOutOfRewardsAccountsResponse::new()
    }

    fn default_instance() -> &'static QueryOptedOutOfRewardsAccountsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryOptedOutOfRewardsAccountsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryOptedOutOfRewardsAccountsResponse::new)
    }
}

impl ::protobuf::Clear for QueryOptedOutOfRewardsAccountsResponse {
    fn clear(&mut self) {
        self.accounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryOptedOutOfRewardsAccountsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountAccountInfoRequest {
    // message fields
    pub account: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountAccountInfoRequest {
    fn default() -> &'a QueryFeeDiscountAccountInfoRequest {
        <QueryFeeDiscountAccountInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountAccountInfoRequest {
    pub fn new() -> QueryFeeDiscountAccountInfoRequest {
        ::std::default::Default::default()
    }

    // string account = 1;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryFeeDiscountAccountInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_string(1, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountAccountInfoRequest {
        QueryFeeDiscountAccountInfoRequest::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountAccountInfoRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountAccountInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountAccountInfoRequest::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountAccountInfoRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountAccountInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountAccountInfoResponse {
    // message fields
    pub tier_level: u64,
    pub account_info: ::protobuf::SingularPtrField<super::exchange::FeeDiscountTierInfo>,
    pub account_ttl: ::protobuf::SingularPtrField<super::exchange::FeeDiscountTierTTL>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountAccountInfoResponse {
    fn default() -> &'a QueryFeeDiscountAccountInfoResponse {
        <QueryFeeDiscountAccountInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountAccountInfoResponse {
    pub fn new() -> QueryFeeDiscountAccountInfoResponse {
        ::std::default::Default::default()
    }

    // uint64 tier_level = 1;


    pub fn get_tier_level(&self) -> u64 {
        self.tier_level
    }
    pub fn clear_tier_level(&mut self) {
        self.tier_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_tier_level(&mut self, v: u64) {
        self.tier_level = v;
    }

    // .injective.exchange.v1beta1.FeeDiscountTierInfo account_info = 2;


    pub fn get_account_info(&self) -> &super::exchange::FeeDiscountTierInfo {
        self.account_info.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountTierInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_info(&mut self) {
        self.account_info.clear();
    }

    pub fn has_account_info(&self) -> bool {
        self.account_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_info(&mut self, v: super::exchange::FeeDiscountTierInfo) {
        self.account_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_info(&mut self) -> &mut super::exchange::FeeDiscountTierInfo {
        if self.account_info.is_none() {
            self.account_info.set_default();
        }
        self.account_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_info(&mut self) -> super::exchange::FeeDiscountTierInfo {
        self.account_info.take().unwrap_or_else(|| super::exchange::FeeDiscountTierInfo::new())
    }

    // .injective.exchange.v1beta1.FeeDiscountTierTTL account_ttl = 3;


    pub fn get_account_ttl(&self) -> &super::exchange::FeeDiscountTierTTL {
        self.account_ttl.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountTierTTL as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_ttl(&mut self) {
        self.account_ttl.clear();
    }

    pub fn has_account_ttl(&self) -> bool {
        self.account_ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_ttl(&mut self, v: super::exchange::FeeDiscountTierTTL) {
        self.account_ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_ttl(&mut self) -> &mut super::exchange::FeeDiscountTierTTL {
        if self.account_ttl.is_none() {
            self.account_ttl.set_default();
        }
        self.account_ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_ttl(&mut self) -> super::exchange::FeeDiscountTierTTL {
        self.account_ttl.take().unwrap_or_else(|| super::exchange::FeeDiscountTierTTL::new())
    }
}

impl ::protobuf::Message for QueryFeeDiscountAccountInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.account_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tier_level = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tier_level != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tier_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.account_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tier_level != 0 {
            os.write_uint64(1, self.tier_level)?;
        }
        if let Some(ref v) = self.account_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_ttl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountAccountInfoResponse {
        QueryFeeDiscountAccountInfoResponse::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountAccountInfoResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountAccountInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountAccountInfoResponse::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountAccountInfoResponse {
    fn clear(&mut self) {
        self.tier_level = 0;
        self.account_info.clear();
        self.account_ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountAccountInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountScheduleRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountScheduleRequest {
    fn default() -> &'a QueryFeeDiscountScheduleRequest {
        <QueryFeeDiscountScheduleRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountScheduleRequest {
    pub fn new() -> QueryFeeDiscountScheduleRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryFeeDiscountScheduleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountScheduleRequest {
        QueryFeeDiscountScheduleRequest::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountScheduleRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountScheduleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountScheduleRequest::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountScheduleRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountScheduleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountScheduleResponse {
    // message fields
    pub fee_discount_schedule: ::protobuf::SingularPtrField<super::exchange::FeeDiscountSchedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountScheduleResponse {
    fn default() -> &'a QueryFeeDiscountScheduleResponse {
        <QueryFeeDiscountScheduleResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountScheduleResponse {
    pub fn new() -> QueryFeeDiscountScheduleResponse {
        ::std::default::Default::default()
    }

    // .injective.exchange.v1beta1.FeeDiscountSchedule fee_discount_schedule = 1;


    pub fn get_fee_discount_schedule(&self) -> &super::exchange::FeeDiscountSchedule {
        self.fee_discount_schedule.as_ref().unwrap_or_else(|| <super::exchange::FeeDiscountSchedule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fee_discount_schedule(&mut self) {
        self.fee_discount_schedule.clear();
    }

    pub fn has_fee_discount_schedule(&self) -> bool {
        self.fee_discount_schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_discount_schedule(&mut self, v: super::exchange::FeeDiscountSchedule) {
        self.fee_discount_schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_discount_schedule(&mut self) -> &mut super::exchange::FeeDiscountSchedule {
        if self.fee_discount_schedule.is_none() {
            self.fee_discount_schedule.set_default();
        }
        self.fee_discount_schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_discount_schedule(&mut self) -> super::exchange::FeeDiscountSchedule {
        self.fee_discount_schedule.take().unwrap_or_else(|| super::exchange::FeeDiscountSchedule::new())
    }
}

impl ::protobuf::Message for QueryFeeDiscountScheduleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_discount_schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_discount_schedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fee_discount_schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fee_discount_schedule.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountScheduleResponse {
        QueryFeeDiscountScheduleResponse::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountScheduleResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountScheduleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountScheduleResponse::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountScheduleResponse {
    fn clear(&mut self) {
        self.fee_discount_schedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountScheduleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBalanceMismatchesRequest {
    // message fields
    pub dust_factor: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBalanceMismatchesRequest {
    fn default() -> &'a QueryBalanceMismatchesRequest {
        <QueryBalanceMismatchesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBalanceMismatchesRequest {
    pub fn new() -> QueryBalanceMismatchesRequest {
        ::std::default::Default::default()
    }

    // int64 dust_factor = 1;


    pub fn get_dust_factor(&self) -> i64 {
        self.dust_factor
    }
    pub fn clear_dust_factor(&mut self) {
        self.dust_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_dust_factor(&mut self, v: i64) {
        self.dust_factor = v;
    }
}

impl ::protobuf::Message for QueryBalanceMismatchesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dust_factor = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dust_factor != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dust_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dust_factor != 0 {
            os.write_int64(1, self.dust_factor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBalanceMismatchesRequest {
        QueryBalanceMismatchesRequest::new()
    }

    fn default_instance() -> &'static QueryBalanceMismatchesRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBalanceMismatchesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBalanceMismatchesRequest::new)
    }
}

impl ::protobuf::Clear for QueryBalanceMismatchesRequest {
    fn clear(&mut self) {
        self.dust_factor = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBalanceMismatchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BalanceMismatch {
    // message fields
    pub subaccountId: ::std::string::String,
    pub denom: ::std::string::String,
    pub available: ::std::string::String,
    pub total: ::std::string::String,
    pub balance_hold: ::std::string::String,
    pub expected_total: ::std::string::String,
    pub difference: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BalanceMismatch {
    fn default() -> &'a BalanceMismatch {
        <BalanceMismatch as ::protobuf::Message>::default_instance()
    }
}

impl BalanceMismatch {
    pub fn new() -> BalanceMismatch {
        ::std::default::Default::default()
    }

    // string subaccountId = 1;


    pub fn get_subaccountId(&self) -> &str {
        &self.subaccountId
    }
    pub fn clear_subaccountId(&mut self) {
        self.subaccountId.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccountId(&mut self, v: ::std::string::String) {
        self.subaccountId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccountId(&mut self) -> &mut ::std::string::String {
        &mut self.subaccountId
    }

    // Take field
    pub fn take_subaccountId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccountId, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string available = 3;


    pub fn get_available(&self) -> &str {
        &self.available
    }
    pub fn clear_available(&mut self) {
        self.available.clear();
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: ::std::string::String) {
        self.available = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available(&mut self) -> &mut ::std::string::String {
        &mut self.available
    }

    // Take field
    pub fn take_available(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available, ::std::string::String::new())
    }

    // string total = 4;


    pub fn get_total(&self) -> &str {
        &self.total
    }
    pub fn clear_total(&mut self) {
        self.total.clear();
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: ::std::string::String) {
        self.total = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total(&mut self) -> &mut ::std::string::String {
        &mut self.total
    }

    // Take field
    pub fn take_total(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total, ::std::string::String::new())
    }

    // string balance_hold = 5;


    pub fn get_balance_hold(&self) -> &str {
        &self.balance_hold
    }
    pub fn clear_balance_hold(&mut self) {
        self.balance_hold.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance_hold(&mut self, v: ::std::string::String) {
        self.balance_hold = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_hold(&mut self) -> &mut ::std::string::String {
        &mut self.balance_hold
    }

    // Take field
    pub fn take_balance_hold(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance_hold, ::std::string::String::new())
    }

    // string expected_total = 6;


    pub fn get_expected_total(&self) -> &str {
        &self.expected_total
    }
    pub fn clear_expected_total(&mut self) {
        self.expected_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_expected_total(&mut self, v: ::std::string::String) {
        self.expected_total = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected_total(&mut self) -> &mut ::std::string::String {
        &mut self.expected_total
    }

    // Take field
    pub fn take_expected_total(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expected_total, ::std::string::String::new())
    }

    // string difference = 7;


    pub fn get_difference(&self) -> &str {
        &self.difference
    }
    pub fn clear_difference(&mut self) {
        self.difference.clear();
    }

    // Param is passed by value, moved
    pub fn set_difference(&mut self, v: ::std::string::String) {
        self.difference = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_difference(&mut self) -> &mut ::std::string::String {
        &mut self.difference
    }

    // Take field
    pub fn take_difference(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.difference, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BalanceMismatch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccountId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance_hold)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expected_total)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.difference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccountId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccountId);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        if !self.available.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.available);
        }
        if !self.total.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.total);
        }
        if !self.balance_hold.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.balance_hold);
        }
        if !self.expected_total.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.expected_total);
        }
        if !self.difference.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.difference);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccountId.is_empty() {
            os.write_string(1, &self.subaccountId)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        if !self.available.is_empty() {
            os.write_string(3, &self.available)?;
        }
        if !self.total.is_empty() {
            os.write_string(4, &self.total)?;
        }
        if !self.balance_hold.is_empty() {
            os.write_string(5, &self.balance_hold)?;
        }
        if !self.expected_total.is_empty() {
            os.write_string(6, &self.expected_total)?;
        }
        if !self.difference.is_empty() {
            os.write_string(7, &self.difference)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BalanceMismatch {
        BalanceMismatch::new()
    }

    fn default_instance() -> &'static BalanceMismatch {
        static instance: ::protobuf::rt::LazyV2<BalanceMismatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BalanceMismatch::new)
    }
}

impl ::protobuf::Clear for BalanceMismatch {
    fn clear(&mut self) {
        self.subaccountId.clear();
        self.denom.clear();
        self.available.clear();
        self.total.clear();
        self.balance_hold.clear();
        self.expected_total.clear();
        self.difference.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceMismatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBalanceMismatchesResponse {
    // message fields
    pub balance_mismatches: ::protobuf::RepeatedField<BalanceMismatch>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBalanceMismatchesResponse {
    fn default() -> &'a QueryBalanceMismatchesResponse {
        <QueryBalanceMismatchesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBalanceMismatchesResponse {
    pub fn new() -> QueryBalanceMismatchesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.BalanceMismatch balance_mismatches = 1;


    pub fn get_balance_mismatches(&self) -> &[BalanceMismatch] {
        &self.balance_mismatches
    }
    pub fn clear_balance_mismatches(&mut self) {
        self.balance_mismatches.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance_mismatches(&mut self, v: ::protobuf::RepeatedField<BalanceMismatch>) {
        self.balance_mismatches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_balance_mismatches(&mut self) -> &mut ::protobuf::RepeatedField<BalanceMismatch> {
        &mut self.balance_mismatches
    }

    // Take field
    pub fn take_balance_mismatches(&mut self) -> ::protobuf::RepeatedField<BalanceMismatch> {
        ::std::mem::replace(&mut self.balance_mismatches, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBalanceMismatchesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balance_mismatches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.balance_mismatches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.balance_mismatches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.balance_mismatches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBalanceMismatchesResponse {
        QueryBalanceMismatchesResponse::new()
    }

    fn default_instance() -> &'static QueryBalanceMismatchesResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBalanceMismatchesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBalanceMismatchesResponse::new)
    }
}

impl ::protobuf::Clear for QueryBalanceMismatchesResponse {
    fn clear(&mut self) {
        self.balance_mismatches.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBalanceMismatchesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBalanceWithBalanceHoldsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBalanceWithBalanceHoldsRequest {
    fn default() -> &'a QueryBalanceWithBalanceHoldsRequest {
        <QueryBalanceWithBalanceHoldsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBalanceWithBalanceHoldsRequest {
    pub fn new() -> QueryBalanceWithBalanceHoldsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryBalanceWithBalanceHoldsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBalanceWithBalanceHoldsRequest {
        QueryBalanceWithBalanceHoldsRequest::new()
    }

    fn default_instance() -> &'static QueryBalanceWithBalanceHoldsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBalanceWithBalanceHoldsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBalanceWithBalanceHoldsRequest::new)
    }
}

impl ::protobuf::Clear for QueryBalanceWithBalanceHoldsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBalanceWithBalanceHoldsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct BalanceWithMarginHold {
    // message fields
    pub subaccountId: ::std::string::String,
    pub denom: ::std::string::String,
    pub available: ::std::string::String,
    pub total: ::std::string::String,
    pub balance_hold: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BalanceWithMarginHold {
    fn default() -> &'a BalanceWithMarginHold {
        <BalanceWithMarginHold as ::protobuf::Message>::default_instance()
    }
}

impl BalanceWithMarginHold {
    pub fn new() -> BalanceWithMarginHold {
        ::std::default::Default::default()
    }

    // string subaccountId = 1;


    pub fn get_subaccountId(&self) -> &str {
        &self.subaccountId
    }
    pub fn clear_subaccountId(&mut self) {
        self.subaccountId.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccountId(&mut self, v: ::std::string::String) {
        self.subaccountId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccountId(&mut self) -> &mut ::std::string::String {
        &mut self.subaccountId
    }

    // Take field
    pub fn take_subaccountId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccountId, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string available = 3;


    pub fn get_available(&self) -> &str {
        &self.available
    }
    pub fn clear_available(&mut self) {
        self.available.clear();
    }

    // Param is passed by value, moved
    pub fn set_available(&mut self, v: ::std::string::String) {
        self.available = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available(&mut self) -> &mut ::std::string::String {
        &mut self.available
    }

    // Take field
    pub fn take_available(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available, ::std::string::String::new())
    }

    // string total = 4;


    pub fn get_total(&self) -> &str {
        &self.total
    }
    pub fn clear_total(&mut self) {
        self.total.clear();
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: ::std::string::String) {
        self.total = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total(&mut self) -> &mut ::std::string::String {
        &mut self.total
    }

    // Take field
    pub fn take_total(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total, ::std::string::String::new())
    }

    // string balance_hold = 5;


    pub fn get_balance_hold(&self) -> &str {
        &self.balance_hold
    }
    pub fn clear_balance_hold(&mut self) {
        self.balance_hold.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance_hold(&mut self, v: ::std::string::String) {
        self.balance_hold = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_hold(&mut self) -> &mut ::std::string::String {
        &mut self.balance_hold
    }

    // Take field
    pub fn take_balance_hold(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance_hold, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BalanceWithMarginHold {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccountId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance_hold)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccountId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccountId);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        if !self.available.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.available);
        }
        if !self.total.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.total);
        }
        if !self.balance_hold.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.balance_hold);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccountId.is_empty() {
            os.write_string(1, &self.subaccountId)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        if !self.available.is_empty() {
            os.write_string(3, &self.available)?;
        }
        if !self.total.is_empty() {
            os.write_string(4, &self.total)?;
        }
        if !self.balance_hold.is_empty() {
            os.write_string(5, &self.balance_hold)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BalanceWithMarginHold {
        BalanceWithMarginHold::new()
    }

    fn default_instance() -> &'static BalanceWithMarginHold {
        static instance: ::protobuf::rt::LazyV2<BalanceWithMarginHold> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BalanceWithMarginHold::new)
    }
}

impl ::protobuf::Clear for BalanceWithMarginHold {
    fn clear(&mut self) {
        self.subaccountId.clear();
        self.denom.clear();
        self.available.clear();
        self.total.clear();
        self.balance_hold.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceWithMarginHold {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBalanceWithBalanceHoldsResponse {
    // message fields
    pub balance_with_balance_holds: ::protobuf::RepeatedField<BalanceWithMarginHold>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBalanceWithBalanceHoldsResponse {
    fn default() -> &'a QueryBalanceWithBalanceHoldsResponse {
        <QueryBalanceWithBalanceHoldsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBalanceWithBalanceHoldsResponse {
    pub fn new() -> QueryBalanceWithBalanceHoldsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.BalanceWithMarginHold balance_with_balance_holds = 1;


    pub fn get_balance_with_balance_holds(&self) -> &[BalanceWithMarginHold] {
        &self.balance_with_balance_holds
    }
    pub fn clear_balance_with_balance_holds(&mut self) {
        self.balance_with_balance_holds.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance_with_balance_holds(&mut self, v: ::protobuf::RepeatedField<BalanceWithMarginHold>) {
        self.balance_with_balance_holds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_balance_with_balance_holds(&mut self) -> &mut ::protobuf::RepeatedField<BalanceWithMarginHold> {
        &mut self.balance_with_balance_holds
    }

    // Take field
    pub fn take_balance_with_balance_holds(&mut self) -> ::protobuf::RepeatedField<BalanceWithMarginHold> {
        ::std::mem::replace(&mut self.balance_with_balance_holds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBalanceWithBalanceHoldsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balance_with_balance_holds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.balance_with_balance_holds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.balance_with_balance_holds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.balance_with_balance_holds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBalanceWithBalanceHoldsResponse {
        QueryBalanceWithBalanceHoldsResponse::new()
    }

    fn default_instance() -> &'static QueryBalanceWithBalanceHoldsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBalanceWithBalanceHoldsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBalanceWithBalanceHoldsResponse::new)
    }
}

impl ::protobuf::Clear for QueryBalanceWithBalanceHoldsResponse {
    fn clear(&mut self) {
        self.balance_with_balance_holds.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBalanceWithBalanceHoldsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountTierStatisticsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountTierStatisticsRequest {
    fn default() -> &'a QueryFeeDiscountTierStatisticsRequest {
        <QueryFeeDiscountTierStatisticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountTierStatisticsRequest {
    pub fn new() -> QueryFeeDiscountTierStatisticsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryFeeDiscountTierStatisticsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountTierStatisticsRequest {
        QueryFeeDiscountTierStatisticsRequest::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountTierStatisticsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountTierStatisticsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountTierStatisticsRequest::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountTierStatisticsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountTierStatisticsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TierStatistic {
    // message fields
    pub tier: u64,
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TierStatistic {
    fn default() -> &'a TierStatistic {
        <TierStatistic as ::protobuf::Message>::default_instance()
    }
}

impl TierStatistic {
    pub fn new() -> TierStatistic {
        ::std::default::Default::default()
    }

    // uint64 tier = 1;


    pub fn get_tier(&self) -> u64 {
        self.tier
    }
    pub fn clear_tier(&mut self) {
        self.tier = 0;
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u64) {
        self.tier = v;
    }

    // uint64 count = 2;


    pub fn get_count(&self) -> u64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }
}

impl ::protobuf::Message for TierStatistic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tier = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tier != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tier, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tier != 0 {
            os.write_uint64(1, self.tier)?;
        }
        if self.count != 0 {
            os.write_uint64(2, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TierStatistic {
        TierStatistic::new()
    }

    fn default_instance() -> &'static TierStatistic {
        static instance: ::protobuf::rt::LazyV2<TierStatistic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TierStatistic::new)
    }
}

impl ::protobuf::Clear for TierStatistic {
    fn clear(&mut self) {
        self.tier = 0;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TierStatistic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryFeeDiscountTierStatisticsResponse {
    // message fields
    pub statistics: ::protobuf::RepeatedField<TierStatistic>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryFeeDiscountTierStatisticsResponse {
    fn default() -> &'a QueryFeeDiscountTierStatisticsResponse {
        <QueryFeeDiscountTierStatisticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryFeeDiscountTierStatisticsResponse {
    pub fn new() -> QueryFeeDiscountTierStatisticsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TierStatistic statistics = 1;


    pub fn get_statistics(&self) -> &[TierStatistic] {
        &self.statistics
    }
    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ::protobuf::RepeatedField<TierStatistic>) {
        self.statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statistics(&mut self) -> &mut ::protobuf::RepeatedField<TierStatistic> {
        &mut self.statistics
    }

    // Take field
    pub fn take_statistics(&mut self) -> ::protobuf::RepeatedField<TierStatistic> {
        ::std::mem::replace(&mut self.statistics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryFeeDiscountTierStatisticsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statistics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statistics {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFeeDiscountTierStatisticsResponse {
        QueryFeeDiscountTierStatisticsResponse::new()
    }

    fn default_instance() -> &'static QueryFeeDiscountTierStatisticsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryFeeDiscountTierStatisticsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryFeeDiscountTierStatisticsResponse::new)
    }
}

impl ::protobuf::Clear for QueryFeeDiscountTierStatisticsResponse {
    fn clear(&mut self) {
        self.statistics.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFeeDiscountTierStatisticsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MitoVaultInfosRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MitoVaultInfosRequest {
    fn default() -> &'a MitoVaultInfosRequest {
        <MitoVaultInfosRequest as ::protobuf::Message>::default_instance()
    }
}

impl MitoVaultInfosRequest {
    pub fn new() -> MitoVaultInfosRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MitoVaultInfosRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MitoVaultInfosRequest {
        MitoVaultInfosRequest::new()
    }

    fn default_instance() -> &'static MitoVaultInfosRequest {
        static instance: ::protobuf::rt::LazyV2<MitoVaultInfosRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MitoVaultInfosRequest::new)
    }
}

impl ::protobuf::Clear for MitoVaultInfosRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MitoVaultInfosRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MitoVaultInfosResponse {
    // message fields
    pub master_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub derivative_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub spot_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub cw20_addresses: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MitoVaultInfosResponse {
    fn default() -> &'a MitoVaultInfosResponse {
        <MitoVaultInfosResponse as ::protobuf::Message>::default_instance()
    }
}

impl MitoVaultInfosResponse {
    pub fn new() -> MitoVaultInfosResponse {
        ::std::default::Default::default()
    }

    // repeated string master_addresses = 1;


    pub fn get_master_addresses(&self) -> &[::std::string::String] {
        &self.master_addresses
    }
    pub fn clear_master_addresses(&mut self) {
        self.master_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_master_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.master_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_master_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.master_addresses
    }

    // Take field
    pub fn take_master_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.master_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated string derivative_addresses = 2;


    pub fn get_derivative_addresses(&self) -> &[::std::string::String] {
        &self.derivative_addresses
    }
    pub fn clear_derivative_addresses(&mut self) {
        self.derivative_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.derivative_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.derivative_addresses
    }

    // Take field
    pub fn take_derivative_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.derivative_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated string spot_addresses = 3;


    pub fn get_spot_addresses(&self) -> &[::std::string::String] {
        &self.spot_addresses
    }
    pub fn clear_spot_addresses(&mut self) {
        self.spot_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.spot_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.spot_addresses
    }

    // Take field
    pub fn take_spot_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.spot_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated string cw20_addresses = 4;


    pub fn get_cw20_addresses(&self) -> &[::std::string::String] {
        &self.cw20_addresses
    }
    pub fn clear_cw20_addresses(&mut self) {
        self.cw20_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cw20_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cw20_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cw20_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cw20_addresses
    }

    // Take field
    pub fn take_cw20_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cw20_addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MitoVaultInfosResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.master_addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.derivative_addresses)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.spot_addresses)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cw20_addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.master_addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.derivative_addresses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.spot_addresses {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.cw20_addresses {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.master_addresses {
            os.write_string(1, &v)?;
        };
        for v in &self.derivative_addresses {
            os.write_string(2, &v)?;
        };
        for v in &self.spot_addresses {
            os.write_string(3, &v)?;
        };
        for v in &self.cw20_addresses {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MitoVaultInfosResponse {
        MitoVaultInfosResponse::new()
    }

    fn default_instance() -> &'static MitoVaultInfosResponse {
        static instance: ::protobuf::rt::LazyV2<MitoVaultInfosResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MitoVaultInfosResponse::new)
    }
}

impl ::protobuf::Clear for MitoVaultInfosResponse {
    fn clear(&mut self) {
        self.master_addresses.clear();
        self.derivative_addresses.clear();
        self.spot_addresses.clear();
        self.cw20_addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MitoVaultInfosResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketIDFromVaultRequest {
    // message fields
    pub vault_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketIDFromVaultRequest {
    fn default() -> &'a QueryMarketIDFromVaultRequest {
        <QueryMarketIDFromVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketIDFromVaultRequest {
    pub fn new() -> QueryMarketIDFromVaultRequest {
        ::std::default::Default::default()
    }

    // string vault_address = 1;


    pub fn get_vault_address(&self) -> &str {
        &self.vault_address
    }
    pub fn clear_vault_address(&mut self) {
        self.vault_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vault_address(&mut self, v: ::std::string::String) {
        self.vault_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vault_address(&mut self) -> &mut ::std::string::String {
        &mut self.vault_address
    }

    // Take field
    pub fn take_vault_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vault_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMarketIDFromVaultRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vault_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vault_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.vault_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vault_address.is_empty() {
            os.write_string(1, &self.vault_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketIDFromVaultRequest {
        QueryMarketIDFromVaultRequest::new()
    }

    fn default_instance() -> &'static QueryMarketIDFromVaultRequest {
        static instance: ::protobuf::rt::LazyV2<QueryMarketIDFromVaultRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketIDFromVaultRequest::new)
    }
}

impl ::protobuf::Clear for QueryMarketIDFromVaultRequest {
    fn clear(&mut self) {
        self.vault_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketIDFromVaultRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketIDFromVaultResponse {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketIDFromVaultResponse {
    fn default() -> &'a QueryMarketIDFromVaultResponse {
        <QueryMarketIDFromVaultResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketIDFromVaultResponse {
    pub fn new() -> QueryMarketIDFromVaultResponse {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMarketIDFromVaultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketIDFromVaultResponse {
        QueryMarketIDFromVaultResponse::new()
    }

    fn default_instance() -> &'static QueryMarketIDFromVaultResponse {
        static instance: ::protobuf::rt::LazyV2<QueryMarketIDFromVaultResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketIDFromVaultResponse::new)
    }
}

impl ::protobuf::Clear for QueryMarketIDFromVaultResponse {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketIDFromVaultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryHistoricalTradeRecordsRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalTradeRecordsRequest {
    fn default() -> &'a QueryHistoricalTradeRecordsRequest {
        <QueryHistoricalTradeRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalTradeRecordsRequest {
    pub fn new() -> QueryHistoricalTradeRecordsRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryHistoricalTradeRecordsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalTradeRecordsRequest {
        QueryHistoricalTradeRecordsRequest::new()
    }

    fn default_instance() -> &'static QueryHistoricalTradeRecordsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalTradeRecordsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalTradeRecordsRequest::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalTradeRecordsRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalTradeRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryHistoricalTradeRecordsResponse {
    // message fields
    pub trade_records: ::protobuf::RepeatedField<super::exchange::TradeRecords>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHistoricalTradeRecordsResponse {
    fn default() -> &'a QueryHistoricalTradeRecordsResponse {
        <QueryHistoricalTradeRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryHistoricalTradeRecordsResponse {
    pub fn new() -> QueryHistoricalTradeRecordsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TradeRecords trade_records = 1;


    pub fn get_trade_records(&self) -> &[super::exchange::TradeRecords] {
        &self.trade_records
    }
    pub fn clear_trade_records(&mut self) {
        self.trade_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_records(&mut self, v: ::protobuf::RepeatedField<super::exchange::TradeRecords>) {
        self.trade_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trade_records(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::TradeRecords> {
        &mut self.trade_records
    }

    // Take field
    pub fn take_trade_records(&mut self) -> ::protobuf::RepeatedField<super::exchange::TradeRecords> {
        ::std::mem::replace(&mut self.trade_records, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryHistoricalTradeRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trade_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trade_records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trade_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trade_records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHistoricalTradeRecordsResponse {
        QueryHistoricalTradeRecordsResponse::new()
    }

    fn default_instance() -> &'static QueryHistoricalTradeRecordsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryHistoricalTradeRecordsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryHistoricalTradeRecordsResponse::new)
    }
}

impl ::protobuf::Clear for QueryHistoricalTradeRecordsResponse {
    fn clear(&mut self) {
        self.trade_records.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHistoricalTradeRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradeHistoryOptions {
    // message fields
    pub trade_grouping_sec: u64,
    pub max_age: u64,
    pub include_raw_history: bool,
    pub include_metadata: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradeHistoryOptions {
    fn default() -> &'a TradeHistoryOptions {
        <TradeHistoryOptions as ::protobuf::Message>::default_instance()
    }
}

impl TradeHistoryOptions {
    pub fn new() -> TradeHistoryOptions {
        ::std::default::Default::default()
    }

    // uint64 trade_grouping_sec = 1;


    pub fn get_trade_grouping_sec(&self) -> u64 {
        self.trade_grouping_sec
    }
    pub fn clear_trade_grouping_sec(&mut self) {
        self.trade_grouping_sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_grouping_sec(&mut self, v: u64) {
        self.trade_grouping_sec = v;
    }

    // uint64 max_age = 2;


    pub fn get_max_age(&self) -> u64 {
        self.max_age
    }
    pub fn clear_max_age(&mut self) {
        self.max_age = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_age(&mut self, v: u64) {
        self.max_age = v;
    }

    // bool include_raw_history = 4;


    pub fn get_include_raw_history(&self) -> bool {
        self.include_raw_history
    }
    pub fn clear_include_raw_history(&mut self) {
        self.include_raw_history = false;
    }

    // Param is passed by value, moved
    pub fn set_include_raw_history(&mut self, v: bool) {
        self.include_raw_history = v;
    }

    // bool include_metadata = 5;


    pub fn get_include_metadata(&self) -> bool {
        self.include_metadata
    }
    pub fn clear_include_metadata(&mut self) {
        self.include_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_include_metadata(&mut self, v: bool) {
        self.include_metadata = v;
    }
}

impl ::protobuf::Message for TradeHistoryOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trade_grouping_sec = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_age = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_raw_history = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_metadata = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.trade_grouping_sec != 0 {
            my_size += ::protobuf::rt::value_size(1, self.trade_grouping_sec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_age != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_age, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.include_raw_history != false {
            my_size += 2;
        }
        if self.include_metadata != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.trade_grouping_sec != 0 {
            os.write_uint64(1, self.trade_grouping_sec)?;
        }
        if self.max_age != 0 {
            os.write_uint64(2, self.max_age)?;
        }
        if self.include_raw_history != false {
            os.write_bool(4, self.include_raw_history)?;
        }
        if self.include_metadata != false {
            os.write_bool(5, self.include_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradeHistoryOptions {
        TradeHistoryOptions::new()
    }

    fn default_instance() -> &'static TradeHistoryOptions {
        static instance: ::protobuf::rt::LazyV2<TradeHistoryOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradeHistoryOptions::new)
    }
}

impl ::protobuf::Clear for TradeHistoryOptions {
    fn clear(&mut self) {
        self.trade_grouping_sec = 0;
        self.max_age = 0;
        self.include_raw_history = false;
        self.include_metadata = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradeHistoryOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketVolatilityRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub trade_history_options: ::protobuf::SingularPtrField<TradeHistoryOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketVolatilityRequest {
    fn default() -> &'a QueryMarketVolatilityRequest {
        <QueryMarketVolatilityRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketVolatilityRequest {
    pub fn new() -> QueryMarketVolatilityRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective.exchange.v1beta1.TradeHistoryOptions trade_history_options = 2;


    pub fn get_trade_history_options(&self) -> &TradeHistoryOptions {
        self.trade_history_options.as_ref().unwrap_or_else(|| <TradeHistoryOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trade_history_options(&mut self) {
        self.trade_history_options.clear();
    }

    pub fn has_trade_history_options(&self) -> bool {
        self.trade_history_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_history_options(&mut self, v: TradeHistoryOptions) {
        self.trade_history_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_history_options(&mut self) -> &mut TradeHistoryOptions {
        if self.trade_history_options.is_none() {
            self.trade_history_options.set_default();
        }
        self.trade_history_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade_history_options(&mut self) -> TradeHistoryOptions {
        self.trade_history_options.take().unwrap_or_else(|| TradeHistoryOptions::new())
    }
}

impl ::protobuf::Message for QueryMarketVolatilityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.trade_history_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade_history_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.trade_history_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.trade_history_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketVolatilityRequest {
        QueryMarketVolatilityRequest::new()
    }

    fn default_instance() -> &'static QueryMarketVolatilityRequest {
        static instance: ::protobuf::rt::LazyV2<QueryMarketVolatilityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketVolatilityRequest::new)
    }
}

impl ::protobuf::Clear for QueryMarketVolatilityRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.trade_history_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketVolatilityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketVolatilityResponse {
    // message fields
    pub volatility: ::std::string::String,
    pub history_metadata: ::protobuf::SingularPtrField<super::oracle::MetadataStatistics>,
    pub raw_history: ::protobuf::RepeatedField<super::exchange::TradeRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketVolatilityResponse {
    fn default() -> &'a QueryMarketVolatilityResponse {
        <QueryMarketVolatilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketVolatilityResponse {
    pub fn new() -> QueryMarketVolatilityResponse {
        ::std::default::Default::default()
    }

    // string volatility = 1;


    pub fn get_volatility(&self) -> &str {
        &self.volatility
    }
    pub fn clear_volatility(&mut self) {
        self.volatility.clear();
    }

    // Param is passed by value, moved
    pub fn set_volatility(&mut self, v: ::std::string::String) {
        self.volatility = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volatility(&mut self) -> &mut ::std::string::String {
        &mut self.volatility
    }

    // Take field
    pub fn take_volatility(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.volatility, ::std::string::String::new())
    }

    // .injective.oracle.v1beta1.MetadataStatistics history_metadata = 2;


    pub fn get_history_metadata(&self) -> &super::oracle::MetadataStatistics {
        self.history_metadata.as_ref().unwrap_or_else(|| <super::oracle::MetadataStatistics as ::protobuf::Message>::default_instance())
    }
    pub fn clear_history_metadata(&mut self) {
        self.history_metadata.clear();
    }

    pub fn has_history_metadata(&self) -> bool {
        self.history_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_metadata(&mut self, v: super::oracle::MetadataStatistics) {
        self.history_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_history_metadata(&mut self) -> &mut super::oracle::MetadataStatistics {
        if self.history_metadata.is_none() {
            self.history_metadata.set_default();
        }
        self.history_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_history_metadata(&mut self) -> super::oracle::MetadataStatistics {
        self.history_metadata.take().unwrap_or_else(|| super::oracle::MetadataStatistics::new())
    }

    // repeated .injective.exchange.v1beta1.TradeRecord raw_history = 3;


    pub fn get_raw_history(&self) -> &[super::exchange::TradeRecord] {
        &self.raw_history
    }
    pub fn clear_raw_history(&mut self) {
        self.raw_history.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_history(&mut self, v: ::protobuf::RepeatedField<super::exchange::TradeRecord>) {
        self.raw_history = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_history(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::TradeRecord> {
        &mut self.raw_history
    }

    // Take field
    pub fn take_raw_history(&mut self) -> ::protobuf::RepeatedField<super::exchange::TradeRecord> {
        ::std::mem::replace(&mut self.raw_history, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryMarketVolatilityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.history_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.raw_history {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.volatility)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.history_metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.raw_history)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.volatility.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.volatility);
        }
        if let Some(ref v) = self.history_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.raw_history {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.volatility.is_empty() {
            os.write_string(1, &self.volatility)?;
        }
        if let Some(ref v) = self.history_metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.raw_history {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketVolatilityResponse {
        QueryMarketVolatilityResponse::new()
    }

    fn default_instance() -> &'static QueryMarketVolatilityResponse {
        static instance: ::protobuf::rt::LazyV2<QueryMarketVolatilityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketVolatilityResponse::new)
    }
}

impl ::protobuf::Clear for QueryMarketVolatilityResponse {
    fn clear(&mut self) {
        self.volatility.clear();
        self.history_metadata.clear();
        self.raw_history.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketVolatilityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBinaryMarketsRequest {
    // message fields
    pub status: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBinaryMarketsRequest {
    fn default() -> &'a QueryBinaryMarketsRequest {
        <QueryBinaryMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryBinaryMarketsRequest {
    pub fn new() -> QueryBinaryMarketsRequest {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryBinaryMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBinaryMarketsRequest {
        QueryBinaryMarketsRequest::new()
    }

    fn default_instance() -> &'static QueryBinaryMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<QueryBinaryMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBinaryMarketsRequest::new)
    }
}

impl ::protobuf::Clear for QueryBinaryMarketsRequest {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBinaryMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryBinaryMarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBinaryMarketsResponse {
    fn default() -> &'a QueryBinaryMarketsResponse {
        <QueryBinaryMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBinaryMarketsResponse {
    pub fn new() -> QueryBinaryMarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.BinaryOptionsMarket markets = 1;


    pub fn get_markets(&self) -> &[super::exchange::BinaryOptionsMarket] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<super::exchange::BinaryOptionsMarket> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryBinaryMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBinaryMarketsResponse {
        QueryBinaryMarketsResponse::new()
    }

    fn default_instance() -> &'static QueryBinaryMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<QueryBinaryMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryBinaryMarketsResponse::new)
    }
}

impl ::protobuf::Clear for QueryBinaryMarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBinaryMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderDerivativeConditionalOrdersRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderDerivativeConditionalOrdersRequest {
    fn default() -> &'a QueryTraderDerivativeConditionalOrdersRequest {
        <QueryTraderDerivativeConditionalOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderDerivativeConditionalOrdersRequest {
    pub fn new() -> QueryTraderDerivativeConditionalOrdersRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryTraderDerivativeConditionalOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderDerivativeConditionalOrdersRequest {
        QueryTraderDerivativeConditionalOrdersRequest::new()
    }

    fn default_instance() -> &'static QueryTraderDerivativeConditionalOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<QueryTraderDerivativeConditionalOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderDerivativeConditionalOrdersRequest::new)
    }
}

impl ::protobuf::Clear for QueryTraderDerivativeConditionalOrdersRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderDerivativeConditionalOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrimmedDerivativeConditionalOrder {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub margin: ::std::string::String,
    pub triggerPrice: ::std::string::String,
    pub isBuy: bool,
    pub isLimit: bool,
    pub order_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrimmedDerivativeConditionalOrder {
    fn default() -> &'a TrimmedDerivativeConditionalOrder {
        <TrimmedDerivativeConditionalOrder as ::protobuf::Message>::default_instance()
    }
}

impl TrimmedDerivativeConditionalOrder {
    pub fn new() -> TrimmedDerivativeConditionalOrder {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string margin = 3;


    pub fn get_margin(&self) -> &str {
        &self.margin
    }
    pub fn clear_margin(&mut self) {
        self.margin.clear();
    }

    // Param is passed by value, moved
    pub fn set_margin(&mut self, v: ::std::string::String) {
        self.margin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_margin(&mut self) -> &mut ::std::string::String {
        &mut self.margin
    }

    // Take field
    pub fn take_margin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.margin, ::std::string::String::new())
    }

    // string triggerPrice = 4;


    pub fn get_triggerPrice(&self) -> &str {
        &self.triggerPrice
    }
    pub fn clear_triggerPrice(&mut self) {
        self.triggerPrice.clear();
    }

    // Param is passed by value, moved
    pub fn set_triggerPrice(&mut self, v: ::std::string::String) {
        self.triggerPrice = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_triggerPrice(&mut self) -> &mut ::std::string::String {
        &mut self.triggerPrice
    }

    // Take field
    pub fn take_triggerPrice(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.triggerPrice, ::std::string::String::new())
    }

    // bool isBuy = 5;


    pub fn get_isBuy(&self) -> bool {
        self.isBuy
    }
    pub fn clear_isBuy(&mut self) {
        self.isBuy = false;
    }

    // Param is passed by value, moved
    pub fn set_isBuy(&mut self, v: bool) {
        self.isBuy = v;
    }

    // bool isLimit = 6;


    pub fn get_isLimit(&self) -> bool {
        self.isLimit
    }
    pub fn clear_isLimit(&mut self) {
        self.isLimit = false;
    }

    // Param is passed by value, moved
    pub fn set_isLimit(&mut self, v: bool) {
        self.isLimit = v;
    }

    // string order_hash = 7;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TrimmedDerivativeConditionalOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.margin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.triggerPrice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBuy = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLimit = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.margin);
        }
        if !self.triggerPrice.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.triggerPrice);
        }
        if self.isBuy != false {
            my_size += 2;
        }
        if self.isLimit != false {
            my_size += 2;
        }
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.order_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if !self.margin.is_empty() {
            os.write_string(3, &self.margin)?;
        }
        if !self.triggerPrice.is_empty() {
            os.write_string(4, &self.triggerPrice)?;
        }
        if self.isBuy != false {
            os.write_bool(5, self.isBuy)?;
        }
        if self.isLimit != false {
            os.write_bool(6, self.isLimit)?;
        }
        if !self.order_hash.is_empty() {
            os.write_string(7, &self.order_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrimmedDerivativeConditionalOrder {
        TrimmedDerivativeConditionalOrder::new()
    }

    fn default_instance() -> &'static TrimmedDerivativeConditionalOrder {
        static instance: ::protobuf::rt::LazyV2<TrimmedDerivativeConditionalOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrimmedDerivativeConditionalOrder::new)
    }
}

impl ::protobuf::Clear for TrimmedDerivativeConditionalOrder {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.margin.clear();
        self.triggerPrice.clear();
        self.isBuy = false;
        self.isLimit = false;
        self.order_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrimmedDerivativeConditionalOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryTraderDerivativeConditionalOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<TrimmedDerivativeConditionalOrder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryTraderDerivativeConditionalOrdersResponse {
    fn default() -> &'a QueryTraderDerivativeConditionalOrdersResponse {
        <QueryTraderDerivativeConditionalOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryTraderDerivativeConditionalOrdersResponse {
    pub fn new() -> QueryTraderDerivativeConditionalOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective.exchange.v1beta1.TrimmedDerivativeConditionalOrder orders = 1;


    pub fn get_orders(&self) -> &[TrimmedDerivativeConditionalOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<TrimmedDerivativeConditionalOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<TrimmedDerivativeConditionalOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<TrimmedDerivativeConditionalOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryTraderDerivativeConditionalOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryTraderDerivativeConditionalOrdersResponse {
        QueryTraderDerivativeConditionalOrdersResponse::new()
    }

    fn default_instance() -> &'static QueryTraderDerivativeConditionalOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<QueryTraderDerivativeConditionalOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryTraderDerivativeConditionalOrdersResponse::new)
    }
}

impl ::protobuf::Clear for QueryTraderDerivativeConditionalOrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryTraderDerivativeConditionalOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketAtomicExecutionFeeMultiplierRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketAtomicExecutionFeeMultiplierRequest {
    fn default() -> &'a QueryMarketAtomicExecutionFeeMultiplierRequest {
        <QueryMarketAtomicExecutionFeeMultiplierRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketAtomicExecutionFeeMultiplierRequest {
    pub fn new() -> QueryMarketAtomicExecutionFeeMultiplierRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMarketAtomicExecutionFeeMultiplierRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketAtomicExecutionFeeMultiplierRequest {
        QueryMarketAtomicExecutionFeeMultiplierRequest::new()
    }

    fn default_instance() -> &'static QueryMarketAtomicExecutionFeeMultiplierRequest {
        static instance: ::protobuf::rt::LazyV2<QueryMarketAtomicExecutionFeeMultiplierRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketAtomicExecutionFeeMultiplierRequest::new)
    }
}

impl ::protobuf::Clear for QueryMarketAtomicExecutionFeeMultiplierRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketAtomicExecutionFeeMultiplierRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMarketAtomicExecutionFeeMultiplierResponse {
    // message fields
    pub multiplier: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryMarketAtomicExecutionFeeMultiplierResponse {
    fn default() -> &'a QueryMarketAtomicExecutionFeeMultiplierResponse {
        <QueryMarketAtomicExecutionFeeMultiplierResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryMarketAtomicExecutionFeeMultiplierResponse {
    pub fn new() -> QueryMarketAtomicExecutionFeeMultiplierResponse {
        ::std::default::Default::default()
    }

    // string multiplier = 1;


    pub fn get_multiplier(&self) -> &str {
        &self.multiplier
    }
    pub fn clear_multiplier(&mut self) {
        self.multiplier.clear();
    }

    // Param is passed by value, moved
    pub fn set_multiplier(&mut self, v: ::std::string::String) {
        self.multiplier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multiplier(&mut self) -> &mut ::std::string::String {
        &mut self.multiplier
    }

    // Take field
    pub fn take_multiplier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.multiplier, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryMarketAtomicExecutionFeeMultiplierResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.multiplier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.multiplier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.multiplier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.multiplier.is_empty() {
            os.write_string(1, &self.multiplier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryMarketAtomicExecutionFeeMultiplierResponse {
        QueryMarketAtomicExecutionFeeMultiplierResponse::new()
    }

    fn default_instance() -> &'static QueryMarketAtomicExecutionFeeMultiplierResponse {
        static instance: ::protobuf::rt::LazyV2<QueryMarketAtomicExecutionFeeMultiplierResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryMarketAtomicExecutionFeeMultiplierResponse::new)
    }
}

impl ::protobuf::Clear for QueryMarketAtomicExecutionFeeMultiplierResponse {
    fn clear(&mut self) {
        self.multiplier.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMarketAtomicExecutionFeeMultiplierResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderSide {
    Side_Unspecified = 0,
    Buy = 1,
    Sell = 2,
}

impl ::protobuf::ProtobufEnum for OrderSide {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderSide> {
        match value {
            0 => ::std::option::Option::Some(OrderSide::Side_Unspecified),
            1 => ::std::option::Option::Some(OrderSide::Buy),
            2 => ::std::option::Option::Some(OrderSide::Sell),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderSide] = &[
            OrderSide::Side_Unspecified,
            OrderSide::Buy,
            OrderSide::Sell,
        ];
        values
    }
}

impl ::std::marker::Copy for OrderSide {
}

impl ::std::default::Default for OrderSide {
    fn default() -> Self {
        OrderSide::Side_Unspecified
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderSide {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CancellationStrategy {
    UnspecifiedOrder = 0,
    FromWorstToBest = 1,
    FromBestToWorst = 2,
}

impl ::protobuf::ProtobufEnum for CancellationStrategy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CancellationStrategy> {
        match value {
            0 => ::std::option::Option::Some(CancellationStrategy::UnspecifiedOrder),
            1 => ::std::option::Option::Some(CancellationStrategy::FromWorstToBest),
            2 => ::std::option::Option::Some(CancellationStrategy::FromBestToWorst),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CancellationStrategy] = &[
            CancellationStrategy::UnspecifiedOrder,
            CancellationStrategy::FromWorstToBest,
            CancellationStrategy::FromBestToWorst,
        ];
        values
    }
}

impl ::std::marker::Copy for CancellationStrategy {
}

impl ::std::default::Default for CancellationStrategy {
    fn default() -> Self {
        CancellationStrategy::UnspecifiedOrder
    }
}

impl ::protobuf::reflect::ProtobufValue for CancellationStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
