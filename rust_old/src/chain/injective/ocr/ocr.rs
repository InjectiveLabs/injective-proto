// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective/ocr/v1beta1/ocr.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Params {
    // message fields
    pub link_denom: ::std::string::String,
    pub payout_block_interval: u64,
    pub module_admin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Params {
    fn default() -> &'a Params {
        <Params as ::protobuf::Message>::default_instance()
    }
}

impl Params {
    pub fn new() -> Params {
        ::std::default::Default::default()
    }

    // string link_denom = 1;


    pub fn get_link_denom(&self) -> &str {
        &self.link_denom
    }
    pub fn clear_link_denom(&mut self) {
        self.link_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_denom(&mut self, v: ::std::string::String) {
        self.link_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_denom(&mut self) -> &mut ::std::string::String {
        &mut self.link_denom
    }

    // Take field
    pub fn take_link_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_denom, ::std::string::String::new())
    }

    // uint64 payout_block_interval = 2;


    pub fn get_payout_block_interval(&self) -> u64 {
        self.payout_block_interval
    }
    pub fn clear_payout_block_interval(&mut self) {
        self.payout_block_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_payout_block_interval(&mut self, v: u64) {
        self.payout_block_interval = v;
    }

    // string module_admin = 3;


    pub fn get_module_admin(&self) -> &str {
        &self.module_admin
    }
    pub fn clear_module_admin(&mut self) {
        self.module_admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_admin(&mut self, v: ::std::string::String) {
        self.module_admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_admin(&mut self) -> &mut ::std::string::String {
        &mut self.module_admin
    }

    // Take field
    pub fn take_module_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module_admin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Params {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_denom)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.payout_block_interval = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module_admin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.link_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.link_denom);
        }
        if self.payout_block_interval != 0 {
            my_size += ::protobuf::rt::value_size(2, self.payout_block_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.module_admin.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.module_admin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.link_denom.is_empty() {
            os.write_string(1, &self.link_denom)?;
        }
        if self.payout_block_interval != 0 {
            os.write_uint64(2, self.payout_block_interval)?;
        }
        if !self.module_admin.is_empty() {
            os.write_string(3, &self.module_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Params {
        Params::new()
    }

    fn default_instance() -> &'static Params {
        static instance: ::protobuf::rt::LazyV2<Params> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Params::new)
    }
}

impl ::protobuf::Clear for Params {
    fn clear(&mut self) {
        self.link_denom.clear();
        self.payout_block_interval = 0;
        self.module_admin.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Params {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedConfig {
    // message fields
    pub signers: ::protobuf::RepeatedField<::std::string::String>,
    pub transmitters: ::protobuf::RepeatedField<::std::string::String>,
    pub f: u32,
    pub onchain_config: ::std::vec::Vec<u8>,
    pub offchain_config_version: u64,
    pub offchain_config: ::std::vec::Vec<u8>,
    pub module_params: ::protobuf::SingularPtrField<ModuleParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedConfig {
    fn default() -> &'a FeedConfig {
        <FeedConfig as ::protobuf::Message>::default_instance()
    }
}

impl FeedConfig {
    pub fn new() -> FeedConfig {
        ::std::default::Default::default()
    }

    // repeated string signers = 1;


    pub fn get_signers(&self) -> &[::std::string::String] {
        &self.signers
    }
    pub fn clear_signers(&mut self) {
        self.signers.clear();
    }

    // Param is passed by value, moved
    pub fn set_signers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.signers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.signers
    }

    // Take field
    pub fn take_signers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.signers, ::protobuf::RepeatedField::new())
    }

    // repeated string transmitters = 2;


    pub fn get_transmitters(&self) -> &[::std::string::String] {
        &self.transmitters
    }
    pub fn clear_transmitters(&mut self) {
        self.transmitters.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.transmitters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transmitters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.transmitters
    }

    // Take field
    pub fn take_transmitters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.transmitters, ::protobuf::RepeatedField::new())
    }

    // uint32 f = 3;


    pub fn get_f(&self) -> u32 {
        self.f
    }
    pub fn clear_f(&mut self) {
        self.f = 0;
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: u32) {
        self.f = v;
    }

    // bytes onchain_config = 4;


    pub fn get_onchain_config(&self) -> &[u8] {
        &self.onchain_config
    }
    pub fn clear_onchain_config(&mut self) {
        self.onchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_onchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.onchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.onchain_config
    }

    // Take field
    pub fn take_onchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.onchain_config, ::std::vec::Vec::new())
    }

    // uint64 offchain_config_version = 5;


    pub fn get_offchain_config_version(&self) -> u64 {
        self.offchain_config_version
    }
    pub fn clear_offchain_config_version(&mut self) {
        self.offchain_config_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_offchain_config_version(&mut self, v: u64) {
        self.offchain_config_version = v;
    }

    // bytes offchain_config = 6;


    pub fn get_offchain_config(&self) -> &[u8] {
        &self.offchain_config
    }
    pub fn clear_offchain_config(&mut self) {
        self.offchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_offchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.offchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.offchain_config
    }

    // Take field
    pub fn take_offchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.offchain_config, ::std::vec::Vec::new())
    }

    // .injective.ocr.v1beta1.ModuleParams module_params = 7;


    pub fn get_module_params(&self) -> &ModuleParams {
        self.module_params.as_ref().unwrap_or_else(|| <ModuleParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_module_params(&mut self) {
        self.module_params.clear();
    }

    pub fn has_module_params(&self) -> bool {
        self.module_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_params(&mut self, v: ModuleParams) {
        self.module_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_params(&mut self) -> &mut ModuleParams {
        if self.module_params.is_none() {
            self.module_params.set_default();
        }
        self.module_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_params(&mut self) -> ModuleParams {
        self.module_params.take().unwrap_or_else(|| ModuleParams::new())
    }
}

impl ::protobuf::Message for FeedConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.module_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.signers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.transmitters)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.onchain_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offchain_config_version = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.offchain_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.signers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.transmitters {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.f != 0 {
            my_size += ::protobuf::rt::value_size(3, self.f, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.onchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.onchain_config);
        }
        if self.offchain_config_version != 0 {
            my_size += ::protobuf::rt::value_size(5, self.offchain_config_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.offchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.offchain_config);
        }
        if let Some(ref v) = self.module_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.signers {
            os.write_string(1, &v)?;
        };
        for v in &self.transmitters {
            os.write_string(2, &v)?;
        };
        if self.f != 0 {
            os.write_uint32(3, self.f)?;
        }
        if !self.onchain_config.is_empty() {
            os.write_bytes(4, &self.onchain_config)?;
        }
        if self.offchain_config_version != 0 {
            os.write_uint64(5, self.offchain_config_version)?;
        }
        if !self.offchain_config.is_empty() {
            os.write_bytes(6, &self.offchain_config)?;
        }
        if let Some(ref v) = self.module_params.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedConfig {
        FeedConfig::new()
    }

    fn default_instance() -> &'static FeedConfig {
        static instance: ::protobuf::rt::LazyV2<FeedConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedConfig::new)
    }
}

impl ::protobuf::Clear for FeedConfig {
    fn clear(&mut self) {
        self.signers.clear();
        self.transmitters.clear();
        self.f = 0;
        self.onchain_config.clear();
        self.offchain_config_version = 0;
        self.offchain_config.clear();
        self.module_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedConfigInfo {
    // message fields
    pub latest_config_digest: ::std::vec::Vec<u8>,
    pub f: u32,
    pub n: u32,
    pub config_count: u64,
    pub latest_config_block_number: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedConfigInfo {
    fn default() -> &'a FeedConfigInfo {
        <FeedConfigInfo as ::protobuf::Message>::default_instance()
    }
}

impl FeedConfigInfo {
    pub fn new() -> FeedConfigInfo {
        ::std::default::Default::default()
    }

    // bytes latest_config_digest = 1;


    pub fn get_latest_config_digest(&self) -> &[u8] {
        &self.latest_config_digest
    }
    pub fn clear_latest_config_digest(&mut self) {
        self.latest_config_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_config_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.latest_config_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latest_config_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.latest_config_digest
    }

    // Take field
    pub fn take_latest_config_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.latest_config_digest, ::std::vec::Vec::new())
    }

    // uint32 f = 2;


    pub fn get_f(&self) -> u32 {
        self.f
    }
    pub fn clear_f(&mut self) {
        self.f = 0;
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: u32) {
        self.f = v;
    }

    // uint32 n = 3;


    pub fn get_n(&self) -> u32 {
        self.n
    }
    pub fn clear_n(&mut self) {
        self.n = 0;
    }

    // Param is passed by value, moved
    pub fn set_n(&mut self, v: u32) {
        self.n = v;
    }

    // uint64 config_count = 4;


    pub fn get_config_count(&self) -> u64 {
        self.config_count
    }
    pub fn clear_config_count(&mut self) {
        self.config_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_config_count(&mut self, v: u64) {
        self.config_count = v;
    }

    // int64 latest_config_block_number = 5;


    pub fn get_latest_config_block_number(&self) -> i64 {
        self.latest_config_block_number
    }
    pub fn clear_latest_config_block_number(&mut self) {
        self.latest_config_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_config_block_number(&mut self, v: i64) {
        self.latest_config_block_number = v;
    }
}

impl ::protobuf::Message for FeedConfigInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.latest_config_digest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.n = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.config_count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_config_block_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.latest_config_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.latest_config_digest);
        }
        if self.f != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.n != 0 {
            my_size += ::protobuf::rt::value_size(3, self.n, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.config_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.config_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_config_block_number != 0 {
            my_size += ::protobuf::rt::value_size(5, self.latest_config_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.latest_config_digest.is_empty() {
            os.write_bytes(1, &self.latest_config_digest)?;
        }
        if self.f != 0 {
            os.write_uint32(2, self.f)?;
        }
        if self.n != 0 {
            os.write_uint32(3, self.n)?;
        }
        if self.config_count != 0 {
            os.write_uint64(4, self.config_count)?;
        }
        if self.latest_config_block_number != 0 {
            os.write_int64(5, self.latest_config_block_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedConfigInfo {
        FeedConfigInfo::new()
    }

    fn default_instance() -> &'static FeedConfigInfo {
        static instance: ::protobuf::rt::LazyV2<FeedConfigInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedConfigInfo::new)
    }
}

impl ::protobuf::Clear for FeedConfigInfo {
    fn clear(&mut self) {
        self.latest_config_digest.clear();
        self.f = 0;
        self.n = 0;
        self.config_count = 0;
        self.latest_config_block_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedConfigInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModuleParams {
    // message fields
    pub feed_id: ::std::string::String,
    pub min_answer: ::std::string::String,
    pub max_answer: ::std::string::String,
    pub link_per_observation: ::std::string::String,
    pub link_per_transmission: ::std::string::String,
    pub link_denom: ::std::string::String,
    pub unique_reports: bool,
    pub description: ::std::string::String,
    pub feed_admin: ::std::string::String,
    pub billing_admin: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModuleParams {
    fn default() -> &'a ModuleParams {
        <ModuleParams as ::protobuf::Message>::default_instance()
    }
}

impl ModuleParams {
    pub fn new() -> ModuleParams {
        ::std::default::Default::default()
    }

    // string feed_id = 1;


    pub fn get_feed_id(&self) -> &str {
        &self.feed_id
    }
    pub fn clear_feed_id(&mut self) {
        self.feed_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_id(&mut self, v: ::std::string::String) {
        self.feed_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_id(&mut self) -> &mut ::std::string::String {
        &mut self.feed_id
    }

    // Take field
    pub fn take_feed_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_id, ::std::string::String::new())
    }

    // string min_answer = 2;


    pub fn get_min_answer(&self) -> &str {
        &self.min_answer
    }
    pub fn clear_min_answer(&mut self) {
        self.min_answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_answer(&mut self, v: ::std::string::String) {
        self.min_answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_answer(&mut self) -> &mut ::std::string::String {
        &mut self.min_answer
    }

    // Take field
    pub fn take_min_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_answer, ::std::string::String::new())
    }

    // string max_answer = 3;


    pub fn get_max_answer(&self) -> &str {
        &self.max_answer
    }
    pub fn clear_max_answer(&mut self) {
        self.max_answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_answer(&mut self, v: ::std::string::String) {
        self.max_answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_answer(&mut self) -> &mut ::std::string::String {
        &mut self.max_answer
    }

    // Take field
    pub fn take_max_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_answer, ::std::string::String::new())
    }

    // string link_per_observation = 4;


    pub fn get_link_per_observation(&self) -> &str {
        &self.link_per_observation
    }
    pub fn clear_link_per_observation(&mut self) {
        self.link_per_observation.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_per_observation(&mut self, v: ::std::string::String) {
        self.link_per_observation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_per_observation(&mut self) -> &mut ::std::string::String {
        &mut self.link_per_observation
    }

    // Take field
    pub fn take_link_per_observation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_per_observation, ::std::string::String::new())
    }

    // string link_per_transmission = 5;


    pub fn get_link_per_transmission(&self) -> &str {
        &self.link_per_transmission
    }
    pub fn clear_link_per_transmission(&mut self) {
        self.link_per_transmission.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_per_transmission(&mut self, v: ::std::string::String) {
        self.link_per_transmission = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_per_transmission(&mut self) -> &mut ::std::string::String {
        &mut self.link_per_transmission
    }

    // Take field
    pub fn take_link_per_transmission(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_per_transmission, ::std::string::String::new())
    }

    // string link_denom = 6;


    pub fn get_link_denom(&self) -> &str {
        &self.link_denom
    }
    pub fn clear_link_denom(&mut self) {
        self.link_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_denom(&mut self, v: ::std::string::String) {
        self.link_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_denom(&mut self) -> &mut ::std::string::String {
        &mut self.link_denom
    }

    // Take field
    pub fn take_link_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_denom, ::std::string::String::new())
    }

    // bool unique_reports = 7;


    pub fn get_unique_reports(&self) -> bool {
        self.unique_reports
    }
    pub fn clear_unique_reports(&mut self) {
        self.unique_reports = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_reports(&mut self, v: bool) {
        self.unique_reports = v;
    }

    // string description = 8;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string feed_admin = 9;


    pub fn get_feed_admin(&self) -> &str {
        &self.feed_admin
    }
    pub fn clear_feed_admin(&mut self) {
        self.feed_admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_admin(&mut self, v: ::std::string::String) {
        self.feed_admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_admin(&mut self) -> &mut ::std::string::String {
        &mut self.feed_admin
    }

    // Take field
    pub fn take_feed_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_admin, ::std::string::String::new())
    }

    // string billing_admin = 10;


    pub fn get_billing_admin(&self) -> &str {
        &self.billing_admin
    }
    pub fn clear_billing_admin(&mut self) {
        self.billing_admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_billing_admin(&mut self, v: ::std::string::String) {
        self.billing_admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_billing_admin(&mut self) -> &mut ::std::string::String {
        &mut self.billing_admin
    }

    // Take field
    pub fn take_billing_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.billing_admin, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModuleParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_answer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_answer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_per_observation)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_per_transmission)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_denom)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_reports = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_admin)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.billing_admin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.feed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feed_id);
        }
        if !self.min_answer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.min_answer);
        }
        if !self.max_answer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.max_answer);
        }
        if !self.link_per_observation.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.link_per_observation);
        }
        if !self.link_per_transmission.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.link_per_transmission);
        }
        if !self.link_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.link_denom);
        }
        if self.unique_reports != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.description);
        }
        if !self.feed_admin.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.feed_admin);
        }
        if !self.billing_admin.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.billing_admin);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.feed_id.is_empty() {
            os.write_string(1, &self.feed_id)?;
        }
        if !self.min_answer.is_empty() {
            os.write_string(2, &self.min_answer)?;
        }
        if !self.max_answer.is_empty() {
            os.write_string(3, &self.max_answer)?;
        }
        if !self.link_per_observation.is_empty() {
            os.write_string(4, &self.link_per_observation)?;
        }
        if !self.link_per_transmission.is_empty() {
            os.write_string(5, &self.link_per_transmission)?;
        }
        if !self.link_denom.is_empty() {
            os.write_string(6, &self.link_denom)?;
        }
        if self.unique_reports != false {
            os.write_bool(7, self.unique_reports)?;
        }
        if !self.description.is_empty() {
            os.write_string(8, &self.description)?;
        }
        if !self.feed_admin.is_empty() {
            os.write_string(9, &self.feed_admin)?;
        }
        if !self.billing_admin.is_empty() {
            os.write_string(10, &self.billing_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleParams {
        ModuleParams::new()
    }

    fn default_instance() -> &'static ModuleParams {
        static instance: ::protobuf::rt::LazyV2<ModuleParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModuleParams::new)
    }
}

impl ::protobuf::Clear for ModuleParams {
    fn clear(&mut self) {
        self.feed_id.clear();
        self.min_answer.clear();
        self.max_answer.clear();
        self.link_per_observation.clear();
        self.link_per_transmission.clear();
        self.link_denom.clear();
        self.unique_reports = false;
        self.description.clear();
        self.feed_admin.clear();
        self.billing_admin.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ContractConfig {
    // message fields
    pub config_count: u64,
    pub signers: ::protobuf::RepeatedField<::std::string::String>,
    pub transmitters: ::protobuf::RepeatedField<::std::string::String>,
    pub f: u32,
    pub onchain_config: ::std::vec::Vec<u8>,
    pub offchain_config_version: u64,
    pub offchain_config: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractConfig {
    fn default() -> &'a ContractConfig {
        <ContractConfig as ::protobuf::Message>::default_instance()
    }
}

impl ContractConfig {
    pub fn new() -> ContractConfig {
        ::std::default::Default::default()
    }

    // uint64 config_count = 1;


    pub fn get_config_count(&self) -> u64 {
        self.config_count
    }
    pub fn clear_config_count(&mut self) {
        self.config_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_config_count(&mut self, v: u64) {
        self.config_count = v;
    }

    // repeated string signers = 2;


    pub fn get_signers(&self) -> &[::std::string::String] {
        &self.signers
    }
    pub fn clear_signers(&mut self) {
        self.signers.clear();
    }

    // Param is passed by value, moved
    pub fn set_signers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.signers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.signers
    }

    // Take field
    pub fn take_signers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.signers, ::protobuf::RepeatedField::new())
    }

    // repeated string transmitters = 3;


    pub fn get_transmitters(&self) -> &[::std::string::String] {
        &self.transmitters
    }
    pub fn clear_transmitters(&mut self) {
        self.transmitters.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.transmitters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transmitters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.transmitters
    }

    // Take field
    pub fn take_transmitters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.transmitters, ::protobuf::RepeatedField::new())
    }

    // uint32 f = 4;


    pub fn get_f(&self) -> u32 {
        self.f
    }
    pub fn clear_f(&mut self) {
        self.f = 0;
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: u32) {
        self.f = v;
    }

    // bytes onchain_config = 5;


    pub fn get_onchain_config(&self) -> &[u8] {
        &self.onchain_config
    }
    pub fn clear_onchain_config(&mut self) {
        self.onchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_onchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.onchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.onchain_config
    }

    // Take field
    pub fn take_onchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.onchain_config, ::std::vec::Vec::new())
    }

    // uint64 offchain_config_version = 6;


    pub fn get_offchain_config_version(&self) -> u64 {
        self.offchain_config_version
    }
    pub fn clear_offchain_config_version(&mut self) {
        self.offchain_config_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_offchain_config_version(&mut self, v: u64) {
        self.offchain_config_version = v;
    }

    // bytes offchain_config = 7;


    pub fn get_offchain_config(&self) -> &[u8] {
        &self.offchain_config
    }
    pub fn clear_offchain_config(&mut self) {
        self.offchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_offchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.offchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.offchain_config
    }

    // Take field
    pub fn take_offchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.offchain_config, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ContractConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.config_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.signers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.transmitters)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.onchain_config)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offchain_config_version = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.offchain_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.config_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.config_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.signers {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.transmitters {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.f != 0 {
            my_size += ::protobuf::rt::value_size(4, self.f, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.onchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.onchain_config);
        }
        if self.offchain_config_version != 0 {
            my_size += ::protobuf::rt::value_size(6, self.offchain_config_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.offchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.offchain_config);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.config_count != 0 {
            os.write_uint64(1, self.config_count)?;
        }
        for v in &self.signers {
            os.write_string(2, &v)?;
        };
        for v in &self.transmitters {
            os.write_string(3, &v)?;
        };
        if self.f != 0 {
            os.write_uint32(4, self.f)?;
        }
        if !self.onchain_config.is_empty() {
            os.write_bytes(5, &self.onchain_config)?;
        }
        if self.offchain_config_version != 0 {
            os.write_uint64(6, self.offchain_config_version)?;
        }
        if !self.offchain_config.is_empty() {
            os.write_bytes(7, &self.offchain_config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractConfig {
        ContractConfig::new()
    }

    fn default_instance() -> &'static ContractConfig {
        static instance: ::protobuf::rt::LazyV2<ContractConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContractConfig::new)
    }
}

impl ::protobuf::Clear for ContractConfig {
    fn clear(&mut self) {
        self.config_count = 0;
        self.signers.clear();
        self.transmitters.clear();
        self.f = 0;
        self.onchain_config.clear();
        self.offchain_config_version = 0;
        self.offchain_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetConfigProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub config: ::protobuf::SingularPtrField<FeedConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetConfigProposal {
    fn default() -> &'a SetConfigProposal {
        <SetConfigProposal as ::protobuf::Message>::default_instance()
    }
}

impl SetConfigProposal {
    pub fn new() -> SetConfigProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .injective.ocr.v1beta1.FeedConfig config = 3;


    pub fn get_config(&self) -> &FeedConfig {
        self.config.as_ref().unwrap_or_else(|| <FeedConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: FeedConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut FeedConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> FeedConfig {
        self.config.take().unwrap_or_else(|| FeedConfig::new())
    }
}

impl ::protobuf::Message for SetConfigProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetConfigProposal {
        SetConfigProposal::new()
    }

    fn default_instance() -> &'static SetConfigProposal {
        static instance: ::protobuf::rt::LazyV2<SetConfigProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetConfigProposal::new)
    }
}

impl ::protobuf::Clear for SetConfigProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetConfigProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeedProperties {
    // message fields
    pub feed_id: ::std::string::String,
    pub f: u32,
    pub onchain_config: ::std::vec::Vec<u8>,
    pub offchain_config_version: u64,
    pub offchain_config: ::std::vec::Vec<u8>,
    pub min_answer: ::std::string::String,
    pub max_answer: ::std::string::String,
    pub link_per_observation: ::std::string::String,
    pub link_per_transmission: ::std::string::String,
    pub unique_reports: bool,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeedProperties {
    fn default() -> &'a FeedProperties {
        <FeedProperties as ::protobuf::Message>::default_instance()
    }
}

impl FeedProperties {
    pub fn new() -> FeedProperties {
        ::std::default::Default::default()
    }

    // string feed_id = 1;


    pub fn get_feed_id(&self) -> &str {
        &self.feed_id
    }
    pub fn clear_feed_id(&mut self) {
        self.feed_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_id(&mut self, v: ::std::string::String) {
        self.feed_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_id(&mut self) -> &mut ::std::string::String {
        &mut self.feed_id
    }

    // Take field
    pub fn take_feed_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_id, ::std::string::String::new())
    }

    // uint32 f = 2;


    pub fn get_f(&self) -> u32 {
        self.f
    }
    pub fn clear_f(&mut self) {
        self.f = 0;
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: u32) {
        self.f = v;
    }

    // bytes onchain_config = 3;


    pub fn get_onchain_config(&self) -> &[u8] {
        &self.onchain_config
    }
    pub fn clear_onchain_config(&mut self) {
        self.onchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_onchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.onchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.onchain_config
    }

    // Take field
    pub fn take_onchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.onchain_config, ::std::vec::Vec::new())
    }

    // uint64 offchain_config_version = 4;


    pub fn get_offchain_config_version(&self) -> u64 {
        self.offchain_config_version
    }
    pub fn clear_offchain_config_version(&mut self) {
        self.offchain_config_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_offchain_config_version(&mut self, v: u64) {
        self.offchain_config_version = v;
    }

    // bytes offchain_config = 5;


    pub fn get_offchain_config(&self) -> &[u8] {
        &self.offchain_config
    }
    pub fn clear_offchain_config(&mut self) {
        self.offchain_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_offchain_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.offchain_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offchain_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.offchain_config
    }

    // Take field
    pub fn take_offchain_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.offchain_config, ::std::vec::Vec::new())
    }

    // string min_answer = 6;


    pub fn get_min_answer(&self) -> &str {
        &self.min_answer
    }
    pub fn clear_min_answer(&mut self) {
        self.min_answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_answer(&mut self, v: ::std::string::String) {
        self.min_answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_answer(&mut self) -> &mut ::std::string::String {
        &mut self.min_answer
    }

    // Take field
    pub fn take_min_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_answer, ::std::string::String::new())
    }

    // string max_answer = 7;


    pub fn get_max_answer(&self) -> &str {
        &self.max_answer
    }
    pub fn clear_max_answer(&mut self) {
        self.max_answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_answer(&mut self, v: ::std::string::String) {
        self.max_answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_answer(&mut self) -> &mut ::std::string::String {
        &mut self.max_answer
    }

    // Take field
    pub fn take_max_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_answer, ::std::string::String::new())
    }

    // string link_per_observation = 8;


    pub fn get_link_per_observation(&self) -> &str {
        &self.link_per_observation
    }
    pub fn clear_link_per_observation(&mut self) {
        self.link_per_observation.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_per_observation(&mut self, v: ::std::string::String) {
        self.link_per_observation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_per_observation(&mut self) -> &mut ::std::string::String {
        &mut self.link_per_observation
    }

    // Take field
    pub fn take_link_per_observation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_per_observation, ::std::string::String::new())
    }

    // string link_per_transmission = 9;


    pub fn get_link_per_transmission(&self) -> &str {
        &self.link_per_transmission
    }
    pub fn clear_link_per_transmission(&mut self) {
        self.link_per_transmission.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_per_transmission(&mut self, v: ::std::string::String) {
        self.link_per_transmission = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_per_transmission(&mut self) -> &mut ::std::string::String {
        &mut self.link_per_transmission
    }

    // Take field
    pub fn take_link_per_transmission(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_per_transmission, ::std::string::String::new())
    }

    // bool unique_reports = 10;


    pub fn get_unique_reports(&self) -> bool {
        self.unique_reports
    }
    pub fn clear_unique_reports(&mut self) {
        self.unique_reports = false;
    }

    // Param is passed by value, moved
    pub fn set_unique_reports(&mut self, v: bool) {
        self.unique_reports = v;
    }

    // string description = 11;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FeedProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.f = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.onchain_config)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offchain_config_version = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.offchain_config)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_answer)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_answer)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_per_observation)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_per_transmission)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unique_reports = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.feed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feed_id);
        }
        if self.f != 0 {
            my_size += ::protobuf::rt::value_size(2, self.f, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.onchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.onchain_config);
        }
        if self.offchain_config_version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.offchain_config_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.offchain_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.offchain_config);
        }
        if !self.min_answer.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.min_answer);
        }
        if !self.max_answer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.max_answer);
        }
        if !self.link_per_observation.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.link_per_observation);
        }
        if !self.link_per_transmission.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.link_per_transmission);
        }
        if self.unique_reports != false {
            my_size += 2;
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.feed_id.is_empty() {
            os.write_string(1, &self.feed_id)?;
        }
        if self.f != 0 {
            os.write_uint32(2, self.f)?;
        }
        if !self.onchain_config.is_empty() {
            os.write_bytes(3, &self.onchain_config)?;
        }
        if self.offchain_config_version != 0 {
            os.write_uint64(4, self.offchain_config_version)?;
        }
        if !self.offchain_config.is_empty() {
            os.write_bytes(5, &self.offchain_config)?;
        }
        if !self.min_answer.is_empty() {
            os.write_string(6, &self.min_answer)?;
        }
        if !self.max_answer.is_empty() {
            os.write_string(7, &self.max_answer)?;
        }
        if !self.link_per_observation.is_empty() {
            os.write_string(8, &self.link_per_observation)?;
        }
        if !self.link_per_transmission.is_empty() {
            os.write_string(9, &self.link_per_transmission)?;
        }
        if self.unique_reports != false {
            os.write_bool(10, self.unique_reports)?;
        }
        if !self.description.is_empty() {
            os.write_string(11, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeedProperties {
        FeedProperties::new()
    }

    fn default_instance() -> &'static FeedProperties {
        static instance: ::protobuf::rt::LazyV2<FeedProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeedProperties::new)
    }
}

impl ::protobuf::Clear for FeedProperties {
    fn clear(&mut self) {
        self.feed_id.clear();
        self.f = 0;
        self.onchain_config.clear();
        self.offchain_config_version = 0;
        self.offchain_config.clear();
        self.min_answer.clear();
        self.max_answer.clear();
        self.link_per_observation.clear();
        self.link_per_transmission.clear();
        self.unique_reports = false;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FeedProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBatchConfigProposal {
    // message fields
    pub title: ::std::string::String,
    pub description: ::std::string::String,
    pub signers: ::protobuf::RepeatedField<::std::string::String>,
    pub transmitters: ::protobuf::RepeatedField<::std::string::String>,
    pub link_denom: ::std::string::String,
    pub feed_properties: ::protobuf::RepeatedField<FeedProperties>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetBatchConfigProposal {
    fn default() -> &'a SetBatchConfigProposal {
        <SetBatchConfigProposal as ::protobuf::Message>::default_instance()
    }
}

impl SetBatchConfigProposal {
    pub fn new() -> SetBatchConfigProposal {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string signers = 3;


    pub fn get_signers(&self) -> &[::std::string::String] {
        &self.signers
    }
    pub fn clear_signers(&mut self) {
        self.signers.clear();
    }

    // Param is passed by value, moved
    pub fn set_signers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.signers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.signers
    }

    // Take field
    pub fn take_signers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.signers, ::protobuf::RepeatedField::new())
    }

    // repeated string transmitters = 4;


    pub fn get_transmitters(&self) -> &[::std::string::String] {
        &self.transmitters
    }
    pub fn clear_transmitters(&mut self) {
        self.transmitters.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitters(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.transmitters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transmitters(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.transmitters
    }

    // Take field
    pub fn take_transmitters(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.transmitters, ::protobuf::RepeatedField::new())
    }

    // string link_denom = 5;


    pub fn get_link_denom(&self) -> &str {
        &self.link_denom
    }
    pub fn clear_link_denom(&mut self) {
        self.link_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_denom(&mut self, v: ::std::string::String) {
        self.link_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_denom(&mut self) -> &mut ::std::string::String {
        &mut self.link_denom
    }

    // Take field
    pub fn take_link_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_denom, ::std::string::String::new())
    }

    // repeated .injective.ocr.v1beta1.FeedProperties feed_properties = 6;


    pub fn get_feed_properties(&self) -> &[FeedProperties] {
        &self.feed_properties
    }
    pub fn clear_feed_properties(&mut self) {
        self.feed_properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_properties(&mut self, v: ::protobuf::RepeatedField<FeedProperties>) {
        self.feed_properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feed_properties(&mut self) -> &mut ::protobuf::RepeatedField<FeedProperties> {
        &mut self.feed_properties
    }

    // Take field
    pub fn take_feed_properties(&mut self) -> ::protobuf::RepeatedField<FeedProperties> {
        ::std::mem::replace(&mut self.feed_properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetBatchConfigProposal {
    fn is_initialized(&self) -> bool {
        for v in &self.feed_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.signers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.transmitters)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_denom)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.feed_properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.signers {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.transmitters {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.link_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.link_denom);
        }
        for value in &self.feed_properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.signers {
            os.write_string(3, &v)?;
        };
        for v in &self.transmitters {
            os.write_string(4, &v)?;
        };
        if !self.link_denom.is_empty() {
            os.write_string(5, &self.link_denom)?;
        }
        for v in &self.feed_properties {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetBatchConfigProposal {
        SetBatchConfigProposal::new()
    }

    fn default_instance() -> &'static SetBatchConfigProposal {
        static instance: ::protobuf::rt::LazyV2<SetBatchConfigProposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetBatchConfigProposal::new)
    }
}

impl ::protobuf::Clear for SetBatchConfigProposal {
    fn clear(&mut self) {
        self.title.clear();
        self.description.clear();
        self.signers.clear();
        self.transmitters.clear();
        self.link_denom.clear();
        self.feed_properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBatchConfigProposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OracleObservationsCounts {
    // message fields
    pub counts: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OracleObservationsCounts {
    fn default() -> &'a OracleObservationsCounts {
        <OracleObservationsCounts as ::protobuf::Message>::default_instance()
    }
}

impl OracleObservationsCounts {
    pub fn new() -> OracleObservationsCounts {
        ::std::default::Default::default()
    }

    // repeated uint32 counts = 1;


    pub fn get_counts(&self) -> &[u32] {
        &self.counts
    }
    pub fn clear_counts(&mut self) {
        self.counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_counts(&mut self, v: ::std::vec::Vec<u32>) {
        self.counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_counts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.counts
    }

    // Take field
    pub fn take_counts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.counts, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OracleObservationsCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.counts {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.counts {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OracleObservationsCounts {
        OracleObservationsCounts::new()
    }

    fn default_instance() -> &'static OracleObservationsCounts {
        static instance: ::protobuf::rt::LazyV2<OracleObservationsCounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OracleObservationsCounts::new)
    }
}

impl ::protobuf::Clear for OracleObservationsCounts {
    fn clear(&mut self) {
        self.counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OracleObservationsCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GasReimbursements {
    // message fields
    pub reimbursements: ::protobuf::RepeatedField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GasReimbursements {
    fn default() -> &'a GasReimbursements {
        <GasReimbursements as ::protobuf::Message>::default_instance()
    }
}

impl GasReimbursements {
    pub fn new() -> GasReimbursements {
        ::std::default::Default::default()
    }

    // repeated .cosmos.base.v1beta1.Coin reimbursements = 1;


    pub fn get_reimbursements(&self) -> &[super::coin::Coin] {
        &self.reimbursements
    }
    pub fn clear_reimbursements(&mut self) {
        self.reimbursements.clear();
    }

    // Param is passed by value, moved
    pub fn set_reimbursements(&mut self, v: ::protobuf::RepeatedField<super::coin::Coin>) {
        self.reimbursements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reimbursements(&mut self) -> &mut ::protobuf::RepeatedField<super::coin::Coin> {
        &mut self.reimbursements
    }

    // Take field
    pub fn take_reimbursements(&mut self) -> ::protobuf::RepeatedField<super::coin::Coin> {
        ::std::mem::replace(&mut self.reimbursements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GasReimbursements {
    fn is_initialized(&self) -> bool {
        for v in &self.reimbursements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reimbursements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reimbursements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reimbursements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GasReimbursements {
        GasReimbursements::new()
    }

    fn default_instance() -> &'static GasReimbursements {
        static instance: ::protobuf::rt::LazyV2<GasReimbursements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GasReimbursements::new)
    }
}

impl ::protobuf::Clear for GasReimbursements {
    fn clear(&mut self) {
        self.reimbursements.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GasReimbursements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Payee {
    // message fields
    pub transmitter_addr: ::std::string::String,
    pub payment_addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payee {
    fn default() -> &'a Payee {
        <Payee as ::protobuf::Message>::default_instance()
    }
}

impl Payee {
    pub fn new() -> Payee {
        ::std::default::Default::default()
    }

    // string transmitter_addr = 1;


    pub fn get_transmitter_addr(&self) -> &str {
        &self.transmitter_addr
    }
    pub fn clear_transmitter_addr(&mut self) {
        self.transmitter_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitter_addr(&mut self, v: ::std::string::String) {
        self.transmitter_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transmitter_addr(&mut self) -> &mut ::std::string::String {
        &mut self.transmitter_addr
    }

    // Take field
    pub fn take_transmitter_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transmitter_addr, ::std::string::String::new())
    }

    // string payment_addr = 2;


    pub fn get_payment_addr(&self) -> &str {
        &self.payment_addr
    }
    pub fn clear_payment_addr(&mut self) {
        self.payment_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_addr(&mut self, v: ::std::string::String) {
        self.payment_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_addr(&mut self) -> &mut ::std::string::String {
        &mut self.payment_addr
    }

    // Take field
    pub fn take_payment_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Payee {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transmitter_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transmitter_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transmitter_addr);
        }
        if !self.payment_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transmitter_addr.is_empty() {
            os.write_string(1, &self.transmitter_addr)?;
        }
        if !self.payment_addr.is_empty() {
            os.write_string(2, &self.payment_addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payee {
        Payee::new()
    }

    fn default_instance() -> &'static Payee {
        static instance: ::protobuf::rt::LazyV2<Payee> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Payee::new)
    }
}

impl ::protobuf::Clear for Payee {
    fn clear(&mut self) {
        self.transmitter_addr.clear();
        self.payment_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Payee {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Transmission {
    // message fields
    pub answer: ::std::string::String,
    pub observations_timestamp: i64,
    pub transmission_timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transmission {
    fn default() -> &'a Transmission {
        <Transmission as ::protobuf::Message>::default_instance()
    }
}

impl Transmission {
    pub fn new() -> Transmission {
        ::std::default::Default::default()
    }

    // string answer = 1;


    pub fn get_answer(&self) -> &str {
        &self.answer
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        &mut self.answer
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.answer, ::std::string::String::new())
    }

    // int64 observations_timestamp = 2;


    pub fn get_observations_timestamp(&self) -> i64 {
        self.observations_timestamp
    }
    pub fn clear_observations_timestamp(&mut self) {
        self.observations_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_observations_timestamp(&mut self, v: i64) {
        self.observations_timestamp = v;
    }

    // int64 transmission_timestamp = 3;


    pub fn get_transmission_timestamp(&self) -> i64 {
        self.transmission_timestamp
    }
    pub fn clear_transmission_timestamp(&mut self) {
        self.transmission_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_transmission_timestamp(&mut self, v: i64) {
        self.transmission_timestamp = v;
    }
}

impl ::protobuf::Message for Transmission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.answer)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observations_timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.transmission_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.answer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.answer);
        }
        if self.observations_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.observations_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.transmission_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.transmission_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.answer.is_empty() {
            os.write_string(1, &self.answer)?;
        }
        if self.observations_timestamp != 0 {
            os.write_int64(2, self.observations_timestamp)?;
        }
        if self.transmission_timestamp != 0 {
            os.write_int64(3, self.transmission_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transmission {
        Transmission::new()
    }

    fn default_instance() -> &'static Transmission {
        static instance: ::protobuf::rt::LazyV2<Transmission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transmission::new)
    }
}

impl ::protobuf::Clear for Transmission {
    fn clear(&mut self) {
        self.answer.clear();
        self.observations_timestamp = 0;
        self.transmission_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Transmission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EpochAndRound {
    // message fields
    pub epoch: u64,
    pub round: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpochAndRound {
    fn default() -> &'a EpochAndRound {
        <EpochAndRound as ::protobuf::Message>::default_instance()
    }
}

impl EpochAndRound {
    pub fn new() -> EpochAndRound {
        ::std::default::Default::default()
    }

    // uint64 epoch = 1;


    pub fn get_epoch(&self) -> u64 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = v;
    }

    // uint64 round = 2;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }
}

impl ::protobuf::Message for EpochAndRound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(2, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch != 0 {
            os.write_uint64(1, self.epoch)?;
        }
        if self.round != 0 {
            os.write_uint64(2, self.round)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpochAndRound {
        EpochAndRound::new()
    }

    fn default_instance() -> &'static EpochAndRound {
        static instance: ::protobuf::rt::LazyV2<EpochAndRound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EpochAndRound::new)
    }
}

impl ::protobuf::Clear for EpochAndRound {
    fn clear(&mut self) {
        self.epoch = 0;
        self.round = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EpochAndRound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Report {
    // message fields
    pub observations_timestamp: i64,
    pub observers: ::std::vec::Vec<u8>,
    pub observations: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Report {
    fn default() -> &'a Report {
        <Report as ::protobuf::Message>::default_instance()
    }
}

impl Report {
    pub fn new() -> Report {
        ::std::default::Default::default()
    }

    // int64 observations_timestamp = 1;


    pub fn get_observations_timestamp(&self) -> i64 {
        self.observations_timestamp
    }
    pub fn clear_observations_timestamp(&mut self) {
        self.observations_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_observations_timestamp(&mut self, v: i64) {
        self.observations_timestamp = v;
    }

    // bytes observers = 2;


    pub fn get_observers(&self) -> &[u8] {
        &self.observers
    }
    pub fn clear_observers(&mut self) {
        self.observers.clear();
    }

    // Param is passed by value, moved
    pub fn set_observers(&mut self, v: ::std::vec::Vec<u8>) {
        self.observers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observers(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.observers
    }

    // Take field
    pub fn take_observers(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.observers, ::std::vec::Vec::new())
    }

    // repeated string observations = 3;


    pub fn get_observations(&self) -> &[::std::string::String] {
        &self.observations
    }
    pub fn clear_observations(&mut self) {
        self.observations.clear();
    }

    // Param is passed by value, moved
    pub fn set_observations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.observations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_observations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.observations
    }

    // Take field
    pub fn take_observations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.observations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Report {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observations_timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.observers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.observations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.observations_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.observations_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.observers.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.observers);
        }
        for value in &self.observations {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.observations_timestamp != 0 {
            os.write_int64(1, self.observations_timestamp)?;
        }
        if !self.observers.is_empty() {
            os.write_bytes(2, &self.observers)?;
        }
        for v in &self.observations {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Report {
        Report::new()
    }

    fn default_instance() -> &'static Report {
        static instance: ::protobuf::rt::LazyV2<Report> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Report::new)
    }
}

impl ::protobuf::Clear for Report {
    fn clear(&mut self) {
        self.observations_timestamp = 0;
        self.observers.clear();
        self.observations.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Report {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReportToSign {
    // message fields
    pub config_digest: ::std::vec::Vec<u8>,
    pub epoch: u64,
    pub round: u64,
    pub extra_hash: ::std::vec::Vec<u8>,
    pub report: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportToSign {
    fn default() -> &'a ReportToSign {
        <ReportToSign as ::protobuf::Message>::default_instance()
    }
}

impl ReportToSign {
    pub fn new() -> ReportToSign {
        ::std::default::Default::default()
    }

    // bytes config_digest = 1;


    pub fn get_config_digest(&self) -> &[u8] {
        &self.config_digest
    }
    pub fn clear_config_digest(&mut self) {
        self.config_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.config_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config_digest
    }

    // Take field
    pub fn take_config_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config_digest, ::std::vec::Vec::new())
    }

    // uint64 epoch = 2;


    pub fn get_epoch(&self) -> u64 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = v;
    }

    // uint64 round = 3;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // bytes extra_hash = 4;


    pub fn get_extra_hash(&self) -> &[u8] {
        &self.extra_hash
    }
    pub fn clear_extra_hash(&mut self) {
        self.extra_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extra_hash
    }

    // Take field
    pub fn take_extra_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extra_hash, ::std::vec::Vec::new())
    }

    // bytes report = 5;


    pub fn get_report(&self) -> &[u8] {
        &self.report
    }
    pub fn clear_report(&mut self) {
        self.report.clear();
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.report = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.report
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.report, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReportToSign {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config_digest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extra_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.report)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.config_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.config_digest);
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(2, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(3, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.extra_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.extra_hash);
        }
        if !self.report.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.report);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.config_digest.is_empty() {
            os.write_bytes(1, &self.config_digest)?;
        }
        if self.epoch != 0 {
            os.write_uint64(2, self.epoch)?;
        }
        if self.round != 0 {
            os.write_uint64(3, self.round)?;
        }
        if !self.extra_hash.is_empty() {
            os.write_bytes(4, &self.extra_hash)?;
        }
        if !self.report.is_empty() {
            os.write_bytes(5, &self.report)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportToSign {
        ReportToSign::new()
    }

    fn default_instance() -> &'static ReportToSign {
        static instance: ::protobuf::rt::LazyV2<ReportToSign> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReportToSign::new)
    }
}

impl ::protobuf::Clear for ReportToSign {
    fn clear(&mut self) {
        self.config_digest.clear();
        self.epoch = 0;
        self.round = 0;
        self.extra_hash.clear();
        self.report.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportToSign {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventOraclePaid {
    // message fields
    pub transmitter_addr: ::std::string::String,
    pub payee_addr: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<super::coin::Coin>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventOraclePaid {
    fn default() -> &'a EventOraclePaid {
        <EventOraclePaid as ::protobuf::Message>::default_instance()
    }
}

impl EventOraclePaid {
    pub fn new() -> EventOraclePaid {
        ::std::default::Default::default()
    }

    // string transmitter_addr = 1;


    pub fn get_transmitter_addr(&self) -> &str {
        &self.transmitter_addr
    }
    pub fn clear_transmitter_addr(&mut self) {
        self.transmitter_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitter_addr(&mut self, v: ::std::string::String) {
        self.transmitter_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transmitter_addr(&mut self) -> &mut ::std::string::String {
        &mut self.transmitter_addr
    }

    // Take field
    pub fn take_transmitter_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transmitter_addr, ::std::string::String::new())
    }

    // string payee_addr = 2;


    pub fn get_payee_addr(&self) -> &str {
        &self.payee_addr
    }
    pub fn clear_payee_addr(&mut self) {
        self.payee_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_payee_addr(&mut self, v: ::std::string::String) {
        self.payee_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payee_addr(&mut self) -> &mut ::std::string::String {
        &mut self.payee_addr
    }

    // Take field
    pub fn take_payee_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payee_addr, ::std::string::String::new())
    }

    // .cosmos.base.v1beta1.Coin amount = 3;


    pub fn get_amount(&self) -> &super::coin::Coin {
        self.amount.as_ref().unwrap_or_else(|| <super::coin::Coin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: super::coin::Coin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut super::coin::Coin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> super::coin::Coin {
        self.amount.take().unwrap_or_else(|| super::coin::Coin::new())
    }
}

impl ::protobuf::Message for EventOraclePaid {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transmitter_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payee_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transmitter_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transmitter_addr);
        }
        if !self.payee_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payee_addr);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transmitter_addr.is_empty() {
            os.write_string(1, &self.transmitter_addr)?;
        }
        if !self.payee_addr.is_empty() {
            os.write_string(2, &self.payee_addr)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventOraclePaid {
        EventOraclePaid::new()
    }

    fn default_instance() -> &'static EventOraclePaid {
        static instance: ::protobuf::rt::LazyV2<EventOraclePaid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventOraclePaid::new)
    }
}

impl ::protobuf::Clear for EventOraclePaid {
    fn clear(&mut self) {
        self.transmitter_addr.clear();
        self.payee_addr.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventOraclePaid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventAnswerUpdated {
    // message fields
    pub current: ::std::string::String,
    pub round_id: ::std::string::String,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventAnswerUpdated {
    fn default() -> &'a EventAnswerUpdated {
        <EventAnswerUpdated as ::protobuf::Message>::default_instance()
    }
}

impl EventAnswerUpdated {
    pub fn new() -> EventAnswerUpdated {
        ::std::default::Default::default()
    }

    // string current = 1;


    pub fn get_current(&self) -> &str {
        &self.current
    }
    pub fn clear_current(&mut self) {
        self.current.clear();
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: ::std::string::String) {
        self.current = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current(&mut self) -> &mut ::std::string::String {
        &mut self.current
    }

    // Take field
    pub fn take_current(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current, ::std::string::String::new())
    }

    // string round_id = 2;


    pub fn get_round_id(&self) -> &str {
        &self.round_id
    }
    pub fn clear_round_id(&mut self) {
        self.round_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_round_id(&mut self, v: ::std::string::String) {
        self.round_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_round_id(&mut self) -> &mut ::std::string::String {
        &mut self.round_id
    }

    // Take field
    pub fn take_round_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.round_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for EventAnswerUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.round_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.current);
        }
        if !self.round_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.round_id);
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.current.is_empty() {
            os.write_string(1, &self.current)?;
        }
        if !self.round_id.is_empty() {
            os.write_string(2, &self.round_id)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventAnswerUpdated {
        EventAnswerUpdated::new()
    }

    fn default_instance() -> &'static EventAnswerUpdated {
        static instance: ::protobuf::rt::LazyV2<EventAnswerUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventAnswerUpdated::new)
    }
}

impl ::protobuf::Clear for EventAnswerUpdated {
    fn clear(&mut self) {
        self.current.clear();
        self.round_id.clear();
        self.updated_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventAnswerUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventNewRound {
    // message fields
    pub round_id: ::std::string::String,
    pub started_by: ::std::string::String,
    pub started_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventNewRound {
    fn default() -> &'a EventNewRound {
        <EventNewRound as ::protobuf::Message>::default_instance()
    }
}

impl EventNewRound {
    pub fn new() -> EventNewRound {
        ::std::default::Default::default()
    }

    // string round_id = 1;


    pub fn get_round_id(&self) -> &str {
        &self.round_id
    }
    pub fn clear_round_id(&mut self) {
        self.round_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_round_id(&mut self, v: ::std::string::String) {
        self.round_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_round_id(&mut self) -> &mut ::std::string::String {
        &mut self.round_id
    }

    // Take field
    pub fn take_round_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.round_id, ::std::string::String::new())
    }

    // string started_by = 2;


    pub fn get_started_by(&self) -> &str {
        &self.started_by
    }
    pub fn clear_started_by(&mut self) {
        self.started_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_started_by(&mut self, v: ::std::string::String) {
        self.started_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_started_by(&mut self) -> &mut ::std::string::String {
        &mut self.started_by
    }

    // Take field
    pub fn take_started_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.started_by, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp started_at = 3;


    pub fn get_started_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.started_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_started_at(&mut self) {
        self.started_at.clear();
    }

    pub fn has_started_at(&self) -> bool {
        self.started_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.started_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_started_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.started_at.is_none() {
            self.started_at.set_default();
        }
        self.started_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_started_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.started_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for EventNewRound {
    fn is_initialized(&self) -> bool {
        for v in &self.started_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.round_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.started_by)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.started_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.round_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.round_id);
        }
        if !self.started_by.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.started_by);
        }
        if let Some(ref v) = self.started_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.round_id.is_empty() {
            os.write_string(1, &self.round_id)?;
        }
        if !self.started_by.is_empty() {
            os.write_string(2, &self.started_by)?;
        }
        if let Some(ref v) = self.started_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventNewRound {
        EventNewRound::new()
    }

    fn default_instance() -> &'static EventNewRound {
        static instance: ::protobuf::rt::LazyV2<EventNewRound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventNewRound::new)
    }
}

impl ::protobuf::Clear for EventNewRound {
    fn clear(&mut self) {
        self.round_id.clear();
        self.started_by.clear();
        self.started_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNewRound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventTransmitted {
    // message fields
    pub config_digest: ::std::vec::Vec<u8>,
    pub epoch: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventTransmitted {
    fn default() -> &'a EventTransmitted {
        <EventTransmitted as ::protobuf::Message>::default_instance()
    }
}

impl EventTransmitted {
    pub fn new() -> EventTransmitted {
        ::std::default::Default::default()
    }

    // bytes config_digest = 1;


    pub fn get_config_digest(&self) -> &[u8] {
        &self.config_digest
    }
    pub fn clear_config_digest(&mut self) {
        self.config_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.config_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config_digest
    }

    // Take field
    pub fn take_config_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config_digest, ::std::vec::Vec::new())
    }

    // uint64 epoch = 2;


    pub fn get_epoch(&self) -> u64 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = v;
    }
}

impl ::protobuf::Message for EventTransmitted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config_digest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.config_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.config_digest);
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(2, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.config_digest.is_empty() {
            os.write_bytes(1, &self.config_digest)?;
        }
        if self.epoch != 0 {
            os.write_uint64(2, self.epoch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventTransmitted {
        EventTransmitted::new()
    }

    fn default_instance() -> &'static EventTransmitted {
        static instance: ::protobuf::rt::LazyV2<EventTransmitted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventTransmitted::new)
    }
}

impl ::protobuf::Clear for EventTransmitted {
    fn clear(&mut self) {
        self.config_digest.clear();
        self.epoch = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTransmitted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventNewTransmission {
    // message fields
    pub feed_id: ::std::string::String,
    pub aggregator_round_id: u32,
    pub answer: ::std::string::String,
    pub transmitter: ::std::string::String,
    pub observations_timestamp: i64,
    pub observations: ::protobuf::RepeatedField<::std::string::String>,
    pub observers: ::std::vec::Vec<u8>,
    pub config_digest: ::std::vec::Vec<u8>,
    pub epoch_and_round: ::protobuf::SingularPtrField<EpochAndRound>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventNewTransmission {
    fn default() -> &'a EventNewTransmission {
        <EventNewTransmission as ::protobuf::Message>::default_instance()
    }
}

impl EventNewTransmission {
    pub fn new() -> EventNewTransmission {
        ::std::default::Default::default()
    }

    // string feed_id = 1;


    pub fn get_feed_id(&self) -> &str {
        &self.feed_id
    }
    pub fn clear_feed_id(&mut self) {
        self.feed_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_feed_id(&mut self, v: ::std::string::String) {
        self.feed_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feed_id(&mut self) -> &mut ::std::string::String {
        &mut self.feed_id
    }

    // Take field
    pub fn take_feed_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.feed_id, ::std::string::String::new())
    }

    // uint32 aggregator_round_id = 2;


    pub fn get_aggregator_round_id(&self) -> u32 {
        self.aggregator_round_id
    }
    pub fn clear_aggregator_round_id(&mut self) {
        self.aggregator_round_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_aggregator_round_id(&mut self, v: u32) {
        self.aggregator_round_id = v;
    }

    // string answer = 3;


    pub fn get_answer(&self) -> &str {
        &self.answer
    }
    pub fn clear_answer(&mut self) {
        self.answer.clear();
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.answer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        &mut self.answer
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.answer, ::std::string::String::new())
    }

    // string transmitter = 4;


    pub fn get_transmitter(&self) -> &str {
        &self.transmitter
    }
    pub fn clear_transmitter(&mut self) {
        self.transmitter.clear();
    }

    // Param is passed by value, moved
    pub fn set_transmitter(&mut self, v: ::std::string::String) {
        self.transmitter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transmitter(&mut self) -> &mut ::std::string::String {
        &mut self.transmitter
    }

    // Take field
    pub fn take_transmitter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transmitter, ::std::string::String::new())
    }

    // int64 observations_timestamp = 5;


    pub fn get_observations_timestamp(&self) -> i64 {
        self.observations_timestamp
    }
    pub fn clear_observations_timestamp(&mut self) {
        self.observations_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_observations_timestamp(&mut self, v: i64) {
        self.observations_timestamp = v;
    }

    // repeated string observations = 6;


    pub fn get_observations(&self) -> &[::std::string::String] {
        &self.observations
    }
    pub fn clear_observations(&mut self) {
        self.observations.clear();
    }

    // Param is passed by value, moved
    pub fn set_observations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.observations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_observations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.observations
    }

    // Take field
    pub fn take_observations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.observations, ::protobuf::RepeatedField::new())
    }

    // bytes observers = 7;


    pub fn get_observers(&self) -> &[u8] {
        &self.observers
    }
    pub fn clear_observers(&mut self) {
        self.observers.clear();
    }

    // Param is passed by value, moved
    pub fn set_observers(&mut self, v: ::std::vec::Vec<u8>) {
        self.observers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observers(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.observers
    }

    // Take field
    pub fn take_observers(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.observers, ::std::vec::Vec::new())
    }

    // bytes config_digest = 8;


    pub fn get_config_digest(&self) -> &[u8] {
        &self.config_digest
    }
    pub fn clear_config_digest(&mut self) {
        self.config_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.config_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config_digest
    }

    // Take field
    pub fn take_config_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config_digest, ::std::vec::Vec::new())
    }

    // .injective.ocr.v1beta1.EpochAndRound epoch_and_round = 9;


    pub fn get_epoch_and_round(&self) -> &EpochAndRound {
        self.epoch_and_round.as_ref().unwrap_or_else(|| <EpochAndRound as ::protobuf::Message>::default_instance())
    }
    pub fn clear_epoch_and_round(&mut self) {
        self.epoch_and_round.clear();
    }

    pub fn has_epoch_and_round(&self) -> bool {
        self.epoch_and_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch_and_round(&mut self, v: EpochAndRound) {
        self.epoch_and_round = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epoch_and_round(&mut self) -> &mut EpochAndRound {
        if self.epoch_and_round.is_none() {
            self.epoch_and_round.set_default();
        }
        self.epoch_and_round.as_mut().unwrap()
    }

    // Take field
    pub fn take_epoch_and_round(&mut self) -> EpochAndRound {
        self.epoch_and_round.take().unwrap_or_else(|| EpochAndRound::new())
    }
}

impl ::protobuf::Message for EventNewTransmission {
    fn is_initialized(&self) -> bool {
        for v in &self.epoch_and_round {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.feed_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.aggregator_round_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.answer)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transmitter)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observations_timestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.observations)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.observers)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config_digest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epoch_and_round)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.feed_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feed_id);
        }
        if self.aggregator_round_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.aggregator_round_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.answer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.answer);
        }
        if !self.transmitter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.transmitter);
        }
        if self.observations_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.observations_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.observations {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.observers.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.observers);
        }
        if !self.config_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.config_digest);
        }
        if let Some(ref v) = self.epoch_and_round.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.feed_id.is_empty() {
            os.write_string(1, &self.feed_id)?;
        }
        if self.aggregator_round_id != 0 {
            os.write_uint32(2, self.aggregator_round_id)?;
        }
        if !self.answer.is_empty() {
            os.write_string(3, &self.answer)?;
        }
        if !self.transmitter.is_empty() {
            os.write_string(4, &self.transmitter)?;
        }
        if self.observations_timestamp != 0 {
            os.write_int64(5, self.observations_timestamp)?;
        }
        for v in &self.observations {
            os.write_string(6, &v)?;
        };
        if !self.observers.is_empty() {
            os.write_bytes(7, &self.observers)?;
        }
        if !self.config_digest.is_empty() {
            os.write_bytes(8, &self.config_digest)?;
        }
        if let Some(ref v) = self.epoch_and_round.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventNewTransmission {
        EventNewTransmission::new()
    }

    fn default_instance() -> &'static EventNewTransmission {
        static instance: ::protobuf::rt::LazyV2<EventNewTransmission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventNewTransmission::new)
    }
}

impl ::protobuf::Clear for EventNewTransmission {
    fn clear(&mut self) {
        self.feed_id.clear();
        self.aggregator_round_id = 0;
        self.answer.clear();
        self.transmitter.clear();
        self.observations_timestamp = 0;
        self.observations.clear();
        self.observers.clear();
        self.config_digest.clear();
        self.epoch_and_round.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNewTransmission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventConfigSet {
    // message fields
    pub config_digest: ::std::vec::Vec<u8>,
    pub previous_config_block_number: i64,
    pub config: ::protobuf::SingularPtrField<FeedConfig>,
    pub config_info: ::protobuf::SingularPtrField<FeedConfigInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventConfigSet {
    fn default() -> &'a EventConfigSet {
        <EventConfigSet as ::protobuf::Message>::default_instance()
    }
}

impl EventConfigSet {
    pub fn new() -> EventConfigSet {
        ::std::default::Default::default()
    }

    // bytes config_digest = 1;


    pub fn get_config_digest(&self) -> &[u8] {
        &self.config_digest
    }
    pub fn clear_config_digest(&mut self) {
        self.config_digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.config_digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.config_digest
    }

    // Take field
    pub fn take_config_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.config_digest, ::std::vec::Vec::new())
    }

    // int64 previous_config_block_number = 2;


    pub fn get_previous_config_block_number(&self) -> i64 {
        self.previous_config_block_number
    }
    pub fn clear_previous_config_block_number(&mut self) {
        self.previous_config_block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_previous_config_block_number(&mut self, v: i64) {
        self.previous_config_block_number = v;
    }

    // .injective.ocr.v1beta1.FeedConfig config = 3;


    pub fn get_config(&self) -> &FeedConfig {
        self.config.as_ref().unwrap_or_else(|| <FeedConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: FeedConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut FeedConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> FeedConfig {
        self.config.take().unwrap_or_else(|| FeedConfig::new())
    }

    // .injective.ocr.v1beta1.FeedConfigInfo config_info = 4;


    pub fn get_config_info(&self) -> &FeedConfigInfo {
        self.config_info.as_ref().unwrap_or_else(|| <FeedConfigInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config_info(&mut self) {
        self.config_info.clear();
    }

    pub fn has_config_info(&self) -> bool {
        self.config_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_info(&mut self, v: FeedConfigInfo) {
        self.config_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_info(&mut self) -> &mut FeedConfigInfo {
        if self.config_info.is_none() {
            self.config_info.set_default();
        }
        self.config_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_info(&mut self) -> FeedConfigInfo {
        self.config_info.take().unwrap_or_else(|| FeedConfigInfo::new())
    }
}

impl ::protobuf::Message for EventConfigSet {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.config_digest)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.previous_config_block_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.config_digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.config_digest);
        }
        if self.previous_config_block_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.previous_config_block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.config_digest.is_empty() {
            os.write_bytes(1, &self.config_digest)?;
        }
        if self.previous_config_block_number != 0 {
            os.write_int64(2, self.previous_config_block_number)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventConfigSet {
        EventConfigSet::new()
    }

    fn default_instance() -> &'static EventConfigSet {
        static instance: ::protobuf::rt::LazyV2<EventConfigSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventConfigSet::new)
    }
}

impl ::protobuf::Clear for EventConfigSet {
    fn clear(&mut self) {
        self.config_digest.clear();
        self.previous_config_block_number = 0;
        self.config.clear();
        self.config_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EventConfigSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
