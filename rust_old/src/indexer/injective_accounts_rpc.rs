// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective_accounts_rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortfolioRequest {
    // message fields
    pub account_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortfolioRequest {
    fn default() -> &'a PortfolioRequest {
        <PortfolioRequest as ::protobuf::Message>::default_instance()
    }
}

impl PortfolioRequest {
    pub fn new() -> PortfolioRequest {
        ::std::default::Default::default()
    }

    // string account_address = 1;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortfolioRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_address.is_empty() {
            os.write_string(1, &self.account_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortfolioRequest {
        PortfolioRequest::new()
    }

    fn default_instance() -> &'static PortfolioRequest {
        static instance: ::protobuf::rt::LazyV2<PortfolioRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortfolioRequest::new)
    }
}

impl ::protobuf::Clear for PortfolioRequest {
    fn clear(&mut self) {
        self.account_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PortfolioRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortfolioResponse {
    // message fields
    pub portfolio: ::protobuf::SingularPtrField<AccountPortfolio>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortfolioResponse {
    fn default() -> &'a PortfolioResponse {
        <PortfolioResponse as ::protobuf::Message>::default_instance()
    }
}

impl PortfolioResponse {
    pub fn new() -> PortfolioResponse {
        ::std::default::Default::default()
    }

    // .injective_accounts_rpc.AccountPortfolio portfolio = 1;


    pub fn get_portfolio(&self) -> &AccountPortfolio {
        self.portfolio.as_ref().unwrap_or_else(|| <AccountPortfolio as ::protobuf::Message>::default_instance())
    }
    pub fn clear_portfolio(&mut self) {
        self.portfolio.clear();
    }

    pub fn has_portfolio(&self) -> bool {
        self.portfolio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portfolio(&mut self, v: AccountPortfolio) {
        self.portfolio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portfolio(&mut self) -> &mut AccountPortfolio {
        if self.portfolio.is_none() {
            self.portfolio.set_default();
        }
        self.portfolio.as_mut().unwrap()
    }

    // Take field
    pub fn take_portfolio(&mut self) -> AccountPortfolio {
        self.portfolio.take().unwrap_or_else(|| AccountPortfolio::new())
    }
}

impl ::protobuf::Message for PortfolioResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.portfolio {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portfolio)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.portfolio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.portfolio.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortfolioResponse {
        PortfolioResponse::new()
    }

    fn default_instance() -> &'static PortfolioResponse {
        static instance: ::protobuf::rt::LazyV2<PortfolioResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortfolioResponse::new)
    }
}

impl ::protobuf::Clear for PortfolioResponse {
    fn clear(&mut self) {
        self.portfolio.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PortfolioResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountPortfolio {
    // message fields
    pub portfolio_value: ::std::string::String,
    pub available_balance: ::std::string::String,
    pub locked_balance: ::std::string::String,
    pub unrealized_pnl: ::std::string::String,
    pub subaccounts: ::protobuf::RepeatedField<SubaccountPortfolio>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountPortfolio {
    fn default() -> &'a AccountPortfolio {
        <AccountPortfolio as ::protobuf::Message>::default_instance()
    }
}

impl AccountPortfolio {
    pub fn new() -> AccountPortfolio {
        ::std::default::Default::default()
    }

    // string portfolio_value = 1;


    pub fn get_portfolio_value(&self) -> &str {
        &self.portfolio_value
    }
    pub fn clear_portfolio_value(&mut self) {
        self.portfolio_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_portfolio_value(&mut self, v: ::std::string::String) {
        self.portfolio_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portfolio_value(&mut self) -> &mut ::std::string::String {
        &mut self.portfolio_value
    }

    // Take field
    pub fn take_portfolio_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.portfolio_value, ::std::string::String::new())
    }

    // string available_balance = 2;


    pub fn get_available_balance(&self) -> &str {
        &self.available_balance
    }
    pub fn clear_available_balance(&mut self) {
        self.available_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_balance(&mut self, v: ::std::string::String) {
        self.available_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available_balance(&mut self) -> &mut ::std::string::String {
        &mut self.available_balance
    }

    // Take field
    pub fn take_available_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available_balance, ::std::string::String::new())
    }

    // string locked_balance = 3;


    pub fn get_locked_balance(&self) -> &str {
        &self.locked_balance
    }
    pub fn clear_locked_balance(&mut self) {
        self.locked_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_locked_balance(&mut self, v: ::std::string::String) {
        self.locked_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locked_balance(&mut self) -> &mut ::std::string::String {
        &mut self.locked_balance
    }

    // Take field
    pub fn take_locked_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.locked_balance, ::std::string::String::new())
    }

    // string unrealized_pnl = 4;


    pub fn get_unrealized_pnl(&self) -> &str {
        &self.unrealized_pnl
    }
    pub fn clear_unrealized_pnl(&mut self) {
        self.unrealized_pnl.clear();
    }

    // Param is passed by value, moved
    pub fn set_unrealized_pnl(&mut self, v: ::std::string::String) {
        self.unrealized_pnl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unrealized_pnl(&mut self) -> &mut ::std::string::String {
        &mut self.unrealized_pnl
    }

    // Take field
    pub fn take_unrealized_pnl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unrealized_pnl, ::std::string::String::new())
    }

    // repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5;


    pub fn get_subaccounts(&self) -> &[SubaccountPortfolio] {
        &self.subaccounts
    }
    pub fn clear_subaccounts(&mut self) {
        self.subaccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccounts(&mut self, v: ::protobuf::RepeatedField<SubaccountPortfolio>) {
        self.subaccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccounts(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountPortfolio> {
        &mut self.subaccounts
    }

    // Take field
    pub fn take_subaccounts(&mut self) -> ::protobuf::RepeatedField<SubaccountPortfolio> {
        ::std::mem::replace(&mut self.subaccounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccountPortfolio {
    fn is_initialized(&self) -> bool {
        for v in &self.subaccounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.portfolio_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available_balance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.locked_balance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unrealized_pnl)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subaccounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.portfolio_value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.portfolio_value);
        }
        if !self.available_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.available_balance);
        }
        if !self.locked_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.locked_balance);
        }
        if !self.unrealized_pnl.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unrealized_pnl);
        }
        for value in &self.subaccounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.portfolio_value.is_empty() {
            os.write_string(1, &self.portfolio_value)?;
        }
        if !self.available_balance.is_empty() {
            os.write_string(2, &self.available_balance)?;
        }
        if !self.locked_balance.is_empty() {
            os.write_string(3, &self.locked_balance)?;
        }
        if !self.unrealized_pnl.is_empty() {
            os.write_string(4, &self.unrealized_pnl)?;
        }
        for v in &self.subaccounts {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountPortfolio {
        AccountPortfolio::new()
    }

    fn default_instance() -> &'static AccountPortfolio {
        static instance: ::protobuf::rt::LazyV2<AccountPortfolio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountPortfolio::new)
    }
}

impl ::protobuf::Clear for AccountPortfolio {
    fn clear(&mut self) {
        self.portfolio_value.clear();
        self.available_balance.clear();
        self.locked_balance.clear();
        self.unrealized_pnl.clear();
        self.subaccounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountPortfolio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountPortfolio {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub available_balance: ::std::string::String,
    pub locked_balance: ::std::string::String,
    pub unrealized_pnl: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountPortfolio {
    fn default() -> &'a SubaccountPortfolio {
        <SubaccountPortfolio as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountPortfolio {
    pub fn new() -> SubaccountPortfolio {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string available_balance = 2;


    pub fn get_available_balance(&self) -> &str {
        &self.available_balance
    }
    pub fn clear_available_balance(&mut self) {
        self.available_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_balance(&mut self, v: ::std::string::String) {
        self.available_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available_balance(&mut self) -> &mut ::std::string::String {
        &mut self.available_balance
    }

    // Take field
    pub fn take_available_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available_balance, ::std::string::String::new())
    }

    // string locked_balance = 3;


    pub fn get_locked_balance(&self) -> &str {
        &self.locked_balance
    }
    pub fn clear_locked_balance(&mut self) {
        self.locked_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_locked_balance(&mut self, v: ::std::string::String) {
        self.locked_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locked_balance(&mut self) -> &mut ::std::string::String {
        &mut self.locked_balance
    }

    // Take field
    pub fn take_locked_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.locked_balance, ::std::string::String::new())
    }

    // string unrealized_pnl = 4;


    pub fn get_unrealized_pnl(&self) -> &str {
        &self.unrealized_pnl
    }
    pub fn clear_unrealized_pnl(&mut self) {
        self.unrealized_pnl.clear();
    }

    // Param is passed by value, moved
    pub fn set_unrealized_pnl(&mut self, v: ::std::string::String) {
        self.unrealized_pnl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unrealized_pnl(&mut self) -> &mut ::std::string::String {
        &mut self.unrealized_pnl
    }

    // Take field
    pub fn take_unrealized_pnl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unrealized_pnl, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubaccountPortfolio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available_balance)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.locked_balance)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unrealized_pnl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.available_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.available_balance);
        }
        if !self.locked_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.locked_balance);
        }
        if !self.unrealized_pnl.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unrealized_pnl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.available_balance.is_empty() {
            os.write_string(2, &self.available_balance)?;
        }
        if !self.locked_balance.is_empty() {
            os.write_string(3, &self.locked_balance)?;
        }
        if !self.unrealized_pnl.is_empty() {
            os.write_string(4, &self.unrealized_pnl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountPortfolio {
        SubaccountPortfolio::new()
    }

    fn default_instance() -> &'static SubaccountPortfolio {
        static instance: ::protobuf::rt::LazyV2<SubaccountPortfolio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountPortfolio::new)
    }
}

impl ::protobuf::Clear for SubaccountPortfolio {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.available_balance.clear();
        self.locked_balance.clear();
        self.unrealized_pnl.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountPortfolio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderStatesRequest {
    // message fields
    pub spot_order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub derivative_order_hashes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderStatesRequest {
    fn default() -> &'a OrderStatesRequest {
        <OrderStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrderStatesRequest {
    pub fn new() -> OrderStatesRequest {
        ::std::default::Default::default()
    }

    // repeated string spot_order_hashes = 1;


    pub fn get_spot_order_hashes(&self) -> &[::std::string::String] {
        &self.spot_order_hashes
    }
    pub fn clear_spot_order_hashes(&mut self) {
        self.spot_order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.spot_order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.spot_order_hashes
    }

    // Take field
    pub fn take_spot_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.spot_order_hashes, ::protobuf::RepeatedField::new())
    }

    // repeated string derivative_order_hashes = 2;


    pub fn get_derivative_order_hashes(&self) -> &[::std::string::String] {
        &self.derivative_order_hashes
    }
    pub fn clear_derivative_order_hashes(&mut self) {
        self.derivative_order_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_order_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.derivative_order_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_order_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.derivative_order_hashes
    }

    // Take field
    pub fn take_derivative_order_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.derivative_order_hashes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.spot_order_hashes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.derivative_order_hashes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.spot_order_hashes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.derivative_order_hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spot_order_hashes {
            os.write_string(1, &v)?;
        };
        for v in &self.derivative_order_hashes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderStatesRequest {
        OrderStatesRequest::new()
    }

    fn default_instance() -> &'static OrderStatesRequest {
        static instance: ::protobuf::rt::LazyV2<OrderStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderStatesRequest::new)
    }
}

impl ::protobuf::Clear for OrderStatesRequest {
    fn clear(&mut self) {
        self.spot_order_hashes.clear();
        self.derivative_order_hashes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderStatesResponse {
    // message fields
    pub spot_order_states: ::protobuf::RepeatedField<OrderStateRecord>,
    pub derivative_order_states: ::protobuf::RepeatedField<OrderStateRecord>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderStatesResponse {
    fn default() -> &'a OrderStatesResponse {
        <OrderStatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderStatesResponse {
    pub fn new() -> OrderStatesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1;


    pub fn get_spot_order_states(&self) -> &[OrderStateRecord] {
        &self.spot_order_states
    }
    pub fn clear_spot_order_states(&mut self) {
        self.spot_order_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_spot_order_states(&mut self, v: ::protobuf::RepeatedField<OrderStateRecord>) {
        self.spot_order_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spot_order_states(&mut self) -> &mut ::protobuf::RepeatedField<OrderStateRecord> {
        &mut self.spot_order_states
    }

    // Take field
    pub fn take_spot_order_states(&mut self) -> ::protobuf::RepeatedField<OrderStateRecord> {
        ::std::mem::replace(&mut self.spot_order_states, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2;


    pub fn get_derivative_order_states(&self) -> &[OrderStateRecord] {
        &self.derivative_order_states
    }
    pub fn clear_derivative_order_states(&mut self) {
        self.derivative_order_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_derivative_order_states(&mut self, v: ::protobuf::RepeatedField<OrderStateRecord>) {
        self.derivative_order_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_derivative_order_states(&mut self) -> &mut ::protobuf::RepeatedField<OrderStateRecord> {
        &mut self.derivative_order_states
    }

    // Take field
    pub fn take_derivative_order_states(&mut self) -> ::protobuf::RepeatedField<OrderStateRecord> {
        ::std::mem::replace(&mut self.derivative_order_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderStatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.spot_order_states {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.derivative_order_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spot_order_states)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.derivative_order_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.spot_order_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.derivative_order_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.spot_order_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.derivative_order_states {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderStatesResponse {
        OrderStatesResponse::new()
    }

    fn default_instance() -> &'static OrderStatesResponse {
        static instance: ::protobuf::rt::LazyV2<OrderStatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderStatesResponse::new)
    }
}

impl ::protobuf::Clear for OrderStatesResponse {
    fn clear(&mut self) {
        self.spot_order_states.clear();
        self.derivative_order_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderStatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderStateRecord {
    // message fields
    pub order_hash: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub order_type: ::std::string::String,
    pub order_side: ::std::string::String,
    pub state: ::std::string::String,
    pub quantity_filled: ::std::string::String,
    pub quantity_remaining: ::std::string::String,
    pub created_at: i64,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderStateRecord {
    fn default() -> &'a OrderStateRecord {
        <OrderStateRecord as ::protobuf::Message>::default_instance()
    }
}

impl OrderStateRecord {
    pub fn new() -> OrderStateRecord {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_type = 4;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // string order_side = 5;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string state = 6;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string quantity_filled = 7;


    pub fn get_quantity_filled(&self) -> &str {
        &self.quantity_filled
    }
    pub fn clear_quantity_filled(&mut self) {
        self.quantity_filled.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity_filled(&mut self, v: ::std::string::String) {
        self.quantity_filled = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity_filled(&mut self) -> &mut ::std::string::String {
        &mut self.quantity_filled
    }

    // Take field
    pub fn take_quantity_filled(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity_filled, ::std::string::String::new())
    }

    // string quantity_remaining = 8;


    pub fn get_quantity_remaining(&self) -> &str {
        &self.quantity_remaining
    }
    pub fn clear_quantity_remaining(&mut self) {
        self.quantity_remaining.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity_remaining(&mut self, v: ::std::string::String) {
        self.quantity_remaining = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity_remaining(&mut self) -> &mut ::std::string::String {
        &mut self.quantity_remaining
    }

    // Take field
    pub fn take_quantity_remaining(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity_remaining, ::std::string::String::new())
    }

    // sint64 created_at = 9;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // sint64 updated_at = 10;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for OrderStateRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity_filled)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity_remaining)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.order_type);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.order_side);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.state);
        }
        if !self.quantity_filled.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.quantity_filled);
        }
        if !self.quantity_remaining.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.quantity_remaining);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(9, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(10, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(4, &self.order_type)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(5, &self.order_side)?;
        }
        if !self.state.is_empty() {
            os.write_string(6, &self.state)?;
        }
        if !self.quantity_filled.is_empty() {
            os.write_string(7, &self.quantity_filled)?;
        }
        if !self.quantity_remaining.is_empty() {
            os.write_string(8, &self.quantity_remaining)?;
        }
        if self.created_at != 0 {
            os.write_sint64(9, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(10, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderStateRecord {
        OrderStateRecord::new()
    }

    fn default_instance() -> &'static OrderStateRecord {
        static instance: ::protobuf::rt::LazyV2<OrderStateRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderStateRecord::new)
    }
}

impl ::protobuf::Clear for OrderStateRecord {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.subaccount_id.clear();
        self.market_id.clear();
        self.order_type.clear();
        self.order_side.clear();
        self.state.clear();
        self.quantity_filled.clear();
        self.quantity_remaining.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderStateRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountsListRequest {
    // message fields
    pub account_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountsListRequest {
    fn default() -> &'a SubaccountsListRequest {
        <SubaccountsListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountsListRequest {
    pub fn new() -> SubaccountsListRequest {
        ::std::default::Default::default()
    }

    // string account_address = 1;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubaccountsListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_address.is_empty() {
            os.write_string(1, &self.account_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountsListRequest {
        SubaccountsListRequest::new()
    }

    fn default_instance() -> &'static SubaccountsListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountsListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountsListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountsListRequest {
    fn clear(&mut self) {
        self.account_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountsListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountsListResponse {
    // message fields
    pub subaccounts: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountsListResponse {
    fn default() -> &'a SubaccountsListResponse {
        <SubaccountsListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountsListResponse {
    pub fn new() -> SubaccountsListResponse {
        ::std::default::Default::default()
    }

    // repeated string subaccounts = 1;


    pub fn get_subaccounts(&self) -> &[::std::string::String] {
        &self.subaccounts
    }
    pub fn clear_subaccounts(&mut self) {
        self.subaccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccounts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccounts
    }

    // Take field
    pub fn take_subaccounts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountsListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subaccounts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subaccounts {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountsListResponse {
        SubaccountsListResponse::new()
    }

    fn default_instance() -> &'static SubaccountsListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountsListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountsListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountsListResponse {
    fn clear(&mut self) {
        self.subaccounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountsListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalancesListRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denoms: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalancesListRequest {
    fn default() -> &'a SubaccountBalancesListRequest {
        <SubaccountBalancesListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalancesListRequest {
    pub fn new() -> SubaccountBalancesListRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated string denoms = 2;


    pub fn get_denoms(&self) -> &[::std::string::String] {
        &self.denoms
    }
    pub fn clear_denoms(&mut self) {
        self.denoms.clear();
    }

    // Param is passed by value, moved
    pub fn set_denoms(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.denoms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denoms(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.denoms
    }

    // Take field
    pub fn take_denoms(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.denoms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountBalancesListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.denoms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        for value in &self.denoms {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        for v in &self.denoms {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalancesListRequest {
        SubaccountBalancesListRequest::new()
    }

    fn default_instance() -> &'static SubaccountBalancesListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalancesListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalancesListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountBalancesListRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denoms.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalancesListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalancesListResponse {
    // message fields
    pub balances: ::protobuf::RepeatedField<SubaccountBalance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalancesListResponse {
    fn default() -> &'a SubaccountBalancesListResponse {
        <SubaccountBalancesListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalancesListResponse {
    pub fn new() -> SubaccountBalancesListResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_accounts_rpc.SubaccountBalance balances = 1;


    pub fn get_balances(&self) -> &[SubaccountBalance] {
        &self.balances
    }
    pub fn clear_balances(&mut self) {
        self.balances.clear();
    }

    // Param is passed by value, moved
    pub fn set_balances(&mut self, v: ::protobuf::RepeatedField<SubaccountBalance>) {
        self.balances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_balances(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountBalance> {
        &mut self.balances
    }

    // Take field
    pub fn take_balances(&mut self) -> ::protobuf::RepeatedField<SubaccountBalance> {
        ::std::mem::replace(&mut self.balances, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountBalancesListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balances {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.balances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.balances {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.balances {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalancesListResponse {
        SubaccountBalancesListResponse::new()
    }

    fn default_instance() -> &'static SubaccountBalancesListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalancesListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalancesListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountBalancesListResponse {
    fn clear(&mut self) {
        self.balances.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalancesListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalance {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub account_address: ::std::string::String,
    pub denom: ::std::string::String,
    pub deposit: ::protobuf::SingularPtrField<SubaccountDeposit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalance {
    fn default() -> &'a SubaccountBalance {
        <SubaccountBalance as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalance {
    pub fn new() -> SubaccountBalance {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string account_address = 2;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }

    // string denom = 3;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // .injective_accounts_rpc.SubaccountDeposit deposit = 4;


    pub fn get_deposit(&self) -> &SubaccountDeposit {
        self.deposit.as_ref().unwrap_or_else(|| <SubaccountDeposit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deposit(&mut self) {
        self.deposit.clear();
    }

    pub fn has_deposit(&self) -> bool {
        self.deposit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deposit(&mut self, v: SubaccountDeposit) {
        self.deposit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deposit(&mut self) -> &mut SubaccountDeposit {
        if self.deposit.is_none() {
            self.deposit.set_default();
        }
        self.deposit.as_mut().unwrap()
    }

    // Take field
    pub fn take_deposit(&mut self) -> SubaccountDeposit {
        self.deposit.take().unwrap_or_else(|| SubaccountDeposit::new())
    }
}

impl ::protobuf::Message for SubaccountBalance {
    fn is_initialized(&self) -> bool {
        for v in &self.deposit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deposit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.denom);
        }
        if let Some(ref v) = self.deposit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        if !self.denom.is_empty() {
            os.write_string(3, &self.denom)?;
        }
        if let Some(ref v) = self.deposit.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalance {
        SubaccountBalance::new()
    }

    fn default_instance() -> &'static SubaccountBalance {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalance::new)
    }
}

impl ::protobuf::Clear for SubaccountBalance {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.account_address.clear();
        self.denom.clear();
        self.deposit.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountDeposit {
    // message fields
    pub total_balance: ::std::string::String,
    pub available_balance: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountDeposit {
    fn default() -> &'a SubaccountDeposit {
        <SubaccountDeposit as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountDeposit {
    pub fn new() -> SubaccountDeposit {
        ::std::default::Default::default()
    }

    // string total_balance = 1;


    pub fn get_total_balance(&self) -> &str {
        &self.total_balance
    }
    pub fn clear_total_balance(&mut self) {
        self.total_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: ::std::string::String) {
        self.total_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_balance(&mut self) -> &mut ::std::string::String {
        &mut self.total_balance
    }

    // Take field
    pub fn take_total_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_balance, ::std::string::String::new())
    }

    // string available_balance = 2;


    pub fn get_available_balance(&self) -> &str {
        &self.available_balance
    }
    pub fn clear_available_balance(&mut self) {
        self.available_balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_balance(&mut self, v: ::std::string::String) {
        self.available_balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_available_balance(&mut self) -> &mut ::std::string::String {
        &mut self.available_balance
    }

    // Take field
    pub fn take_available_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.available_balance, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubaccountDeposit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_balance)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.available_balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.total_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.total_balance);
        }
        if !self.available_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.available_balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.total_balance.is_empty() {
            os.write_string(1, &self.total_balance)?;
        }
        if !self.available_balance.is_empty() {
            os.write_string(2, &self.available_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountDeposit {
        SubaccountDeposit::new()
    }

    fn default_instance() -> &'static SubaccountDeposit {
        static instance: ::protobuf::rt::LazyV2<SubaccountDeposit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountDeposit::new)
    }
}

impl ::protobuf::Clear for SubaccountDeposit {
    fn clear(&mut self) {
        self.total_balance.clear();
        self.available_balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountDeposit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalanceEndpointRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalanceEndpointRequest {
    fn default() -> &'a SubaccountBalanceEndpointRequest {
        <SubaccountBalanceEndpointRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalanceEndpointRequest {
    pub fn new() -> SubaccountBalanceEndpointRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubaccountBalanceEndpointRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalanceEndpointRequest {
        SubaccountBalanceEndpointRequest::new()
    }

    fn default_instance() -> &'static SubaccountBalanceEndpointRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalanceEndpointRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalanceEndpointRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountBalanceEndpointRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalanceEndpointRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalanceEndpointResponse {
    // message fields
    pub balance: ::protobuf::SingularPtrField<SubaccountBalance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalanceEndpointResponse {
    fn default() -> &'a SubaccountBalanceEndpointResponse {
        <SubaccountBalanceEndpointResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalanceEndpointResponse {
    pub fn new() -> SubaccountBalanceEndpointResponse {
        ::std::default::Default::default()
    }

    // .injective_accounts_rpc.SubaccountBalance balance = 1;


    pub fn get_balance(&self) -> &SubaccountBalance {
        self.balance.as_ref().unwrap_or_else(|| <SubaccountBalance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: SubaccountBalance) {
        self.balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut SubaccountBalance {
        if self.balance.is_none() {
            self.balance.set_default();
        }
        self.balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance(&mut self) -> SubaccountBalance {
        self.balance.take().unwrap_or_else(|| SubaccountBalance::new())
    }
}

impl ::protobuf::Message for SubaccountBalanceEndpointResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalanceEndpointResponse {
        SubaccountBalanceEndpointResponse::new()
    }

    fn default_instance() -> &'static SubaccountBalanceEndpointResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalanceEndpointResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalanceEndpointResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountBalanceEndpointResponse {
    fn clear(&mut self) {
        self.balance.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalanceEndpointResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamSubaccountBalanceRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denoms: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamSubaccountBalanceRequest {
    fn default() -> &'a StreamSubaccountBalanceRequest {
        <StreamSubaccountBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamSubaccountBalanceRequest {
    pub fn new() -> StreamSubaccountBalanceRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // repeated string denoms = 2;


    pub fn get_denoms(&self) -> &[::std::string::String] {
        &self.denoms
    }
    pub fn clear_denoms(&mut self) {
        self.denoms.clear();
    }

    // Param is passed by value, moved
    pub fn set_denoms(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.denoms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_denoms(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.denoms
    }

    // Take field
    pub fn take_denoms(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.denoms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamSubaccountBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.denoms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        for value in &self.denoms {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        for v in &self.denoms {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamSubaccountBalanceRequest {
        StreamSubaccountBalanceRequest::new()
    }

    fn default_instance() -> &'static StreamSubaccountBalanceRequest {
        static instance: ::protobuf::rt::LazyV2<StreamSubaccountBalanceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamSubaccountBalanceRequest::new)
    }
}

impl ::protobuf::Clear for StreamSubaccountBalanceRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denoms.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamSubaccountBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamSubaccountBalanceResponse {
    // message fields
    pub balance: ::protobuf::SingularPtrField<SubaccountBalance>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamSubaccountBalanceResponse {
    fn default() -> &'a StreamSubaccountBalanceResponse {
        <StreamSubaccountBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamSubaccountBalanceResponse {
    pub fn new() -> StreamSubaccountBalanceResponse {
        ::std::default::Default::default()
    }

    // .injective_accounts_rpc.SubaccountBalance balance = 1;


    pub fn get_balance(&self) -> &SubaccountBalance {
        self.balance.as_ref().unwrap_or_else(|| <SubaccountBalance as ::protobuf::Message>::default_instance())
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: SubaccountBalance) {
        self.balance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut SubaccountBalance {
        if self.balance.is_none() {
            self.balance.set_default();
        }
        self.balance.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance(&mut self) -> SubaccountBalance {
        self.balance.take().unwrap_or_else(|| SubaccountBalance::new())
    }

    // sint64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamSubaccountBalanceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.balance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.balance)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.balance.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamSubaccountBalanceResponse {
        StreamSubaccountBalanceResponse::new()
    }

    fn default_instance() -> &'static StreamSubaccountBalanceResponse {
        static instance: ::protobuf::rt::LazyV2<StreamSubaccountBalanceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamSubaccountBalanceResponse::new)
    }
}

impl ::protobuf::Clear for StreamSubaccountBalanceResponse {
    fn clear(&mut self) {
        self.balance.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamSubaccountBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountHistoryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub denom: ::std::string::String,
    pub transfer_types: ::protobuf::RepeatedField<::std::string::String>,
    pub skip: u64,
    pub limit: i32,
    pub end_time: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountHistoryRequest {
    fn default() -> &'a SubaccountHistoryRequest {
        <SubaccountHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountHistoryRequest {
    pub fn new() -> SubaccountHistoryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string denom = 2;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // repeated string transfer_types = 3;


    pub fn get_transfer_types(&self) -> &[::std::string::String] {
        &self.transfer_types
    }
    pub fn clear_transfer_types(&mut self) {
        self.transfer_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_transfer_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.transfer_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transfer_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.transfer_types
    }

    // Take field
    pub fn take_transfer_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.transfer_types, ::protobuf::RepeatedField::new())
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 5;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 end_time = 6;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }
}

impl ::protobuf::Message for SubaccountHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.transfer_types)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.denom);
        }
        for value in &self.transfer_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.limit);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.end_time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.denom.is_empty() {
            os.write_string(2, &self.denom)?;
        }
        for v in &self.transfer_types {
            os.write_string(3, &v)?;
        };
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(5, self.limit)?;
        }
        if self.end_time != 0 {
            os.write_sint64(6, self.end_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountHistoryRequest {
        SubaccountHistoryRequest::new()
    }

    fn default_instance() -> &'static SubaccountHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountHistoryRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountHistoryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.denom.clear();
        self.transfer_types.clear();
        self.skip = 0;
        self.limit = 0;
        self.end_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountHistoryResponse {
    // message fields
    pub transfers: ::protobuf::RepeatedField<SubaccountBalanceTransfer>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountHistoryResponse {
    fn default() -> &'a SubaccountHistoryResponse {
        <SubaccountHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountHistoryResponse {
    pub fn new() -> SubaccountHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1;


    pub fn get_transfers(&self) -> &[SubaccountBalanceTransfer] {
        &self.transfers
    }
    pub fn clear_transfers(&mut self) {
        self.transfers.clear();
    }

    // Param is passed by value, moved
    pub fn set_transfers(&mut self, v: ::protobuf::RepeatedField<SubaccountBalanceTransfer>) {
        self.transfers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transfers(&mut self) -> &mut ::protobuf::RepeatedField<SubaccountBalanceTransfer> {
        &mut self.transfers
    }

    // Take field
    pub fn take_transfers(&mut self) -> ::protobuf::RepeatedField<SubaccountBalanceTransfer> {
        ::std::mem::replace(&mut self.transfers, ::protobuf::RepeatedField::new())
    }

    // .injective_accounts_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for SubaccountHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transfers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transfers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transfers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transfers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountHistoryResponse {
        SubaccountHistoryResponse::new()
    }

    fn default_instance() -> &'static SubaccountHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountHistoryResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountHistoryResponse {
    fn clear(&mut self) {
        self.transfers.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountBalanceTransfer {
    // message fields
    pub transfer_type: ::std::string::String,
    pub src_subaccount_id: ::std::string::String,
    pub src_account_address: ::std::string::String,
    pub dst_subaccount_id: ::std::string::String,
    pub dst_account_address: ::std::string::String,
    pub amount: ::protobuf::SingularPtrField<CosmosCoin>,
    pub executed_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountBalanceTransfer {
    fn default() -> &'a SubaccountBalanceTransfer {
        <SubaccountBalanceTransfer as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountBalanceTransfer {
    pub fn new() -> SubaccountBalanceTransfer {
        ::std::default::Default::default()
    }

    // string transfer_type = 1;


    pub fn get_transfer_type(&self) -> &str {
        &self.transfer_type
    }
    pub fn clear_transfer_type(&mut self) {
        self.transfer_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_transfer_type(&mut self, v: ::std::string::String) {
        self.transfer_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer_type(&mut self) -> &mut ::std::string::String {
        &mut self.transfer_type
    }

    // Take field
    pub fn take_transfer_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transfer_type, ::std::string::String::new())
    }

    // string src_subaccount_id = 2;


    pub fn get_src_subaccount_id(&self) -> &str {
        &self.src_subaccount_id
    }
    pub fn clear_src_subaccount_id(&mut self) {
        self.src_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_subaccount_id(&mut self, v: ::std::string::String) {
        self.src_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.src_subaccount_id
    }

    // Take field
    pub fn take_src_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_subaccount_id, ::std::string::String::new())
    }

    // string src_account_address = 3;


    pub fn get_src_account_address(&self) -> &str {
        &self.src_account_address
    }
    pub fn clear_src_account_address(&mut self) {
        self.src_account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_account_address(&mut self, v: ::std::string::String) {
        self.src_account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.src_account_address
    }

    // Take field
    pub fn take_src_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_account_address, ::std::string::String::new())
    }

    // string dst_subaccount_id = 4;


    pub fn get_dst_subaccount_id(&self) -> &str {
        &self.dst_subaccount_id
    }
    pub fn clear_dst_subaccount_id(&mut self) {
        self.dst_subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_subaccount_id(&mut self, v: ::std::string::String) {
        self.dst_subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.dst_subaccount_id
    }

    // Take field
    pub fn take_dst_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_subaccount_id, ::std::string::String::new())
    }

    // string dst_account_address = 5;


    pub fn get_dst_account_address(&self) -> &str {
        &self.dst_account_address
    }
    pub fn clear_dst_account_address(&mut self) {
        self.dst_account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_account_address(&mut self, v: ::std::string::String) {
        self.dst_account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.dst_account_address
    }

    // Take field
    pub fn take_dst_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_account_address, ::std::string::String::new())
    }

    // .injective_accounts_rpc.CosmosCoin amount = 6;


    pub fn get_amount(&self) -> &CosmosCoin {
        self.amount.as_ref().unwrap_or_else(|| <CosmosCoin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: CosmosCoin) {
        self.amount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut CosmosCoin {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> CosmosCoin {
        self.amount.take().unwrap_or_else(|| CosmosCoin::new())
    }

    // sint64 executed_at = 7;


    pub fn get_executed_at(&self) -> i64 {
        self.executed_at
    }
    pub fn clear_executed_at(&mut self) {
        self.executed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_executed_at(&mut self, v: i64) {
        self.executed_at = v;
    }
}

impl ::protobuf::Message for SubaccountBalanceTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.amount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transfer_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_account_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_subaccount_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_account_address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amount)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.executed_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transfer_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transfer_type);
        }
        if !self.src_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.src_subaccount_id);
        }
        if !self.src_account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.src_account_address);
        }
        if !self.dst_subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.dst_subaccount_id);
        }
        if !self.dst_account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dst_account_address);
        }
        if let Some(ref v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.executed_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.executed_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transfer_type.is_empty() {
            os.write_string(1, &self.transfer_type)?;
        }
        if !self.src_subaccount_id.is_empty() {
            os.write_string(2, &self.src_subaccount_id)?;
        }
        if !self.src_account_address.is_empty() {
            os.write_string(3, &self.src_account_address)?;
        }
        if !self.dst_subaccount_id.is_empty() {
            os.write_string(4, &self.dst_subaccount_id)?;
        }
        if !self.dst_account_address.is_empty() {
            os.write_string(5, &self.dst_account_address)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.executed_at != 0 {
            os.write_sint64(7, self.executed_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountBalanceTransfer {
        SubaccountBalanceTransfer::new()
    }

    fn default_instance() -> &'static SubaccountBalanceTransfer {
        static instance: ::protobuf::rt::LazyV2<SubaccountBalanceTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountBalanceTransfer::new)
    }
}

impl ::protobuf::Clear for SubaccountBalanceTransfer {
    fn clear(&mut self) {
        self.transfer_type.clear();
        self.src_subaccount_id.clear();
        self.src_account_address.clear();
        self.dst_subaccount_id.clear();
        self.dst_account_address.clear();
        self.amount.clear();
        self.executed_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountBalanceTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CosmosCoin {
    // message fields
    pub denom: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CosmosCoin {
    fn default() -> &'a CosmosCoin {
        <CosmosCoin as ::protobuf::Message>::default_instance()
    }
}

impl CosmosCoin {
    pub fn new() -> CosmosCoin {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string amount = 2;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CosmosCoin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        if !self.amount.is_empty() {
            os.write_string(2, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CosmosCoin {
        CosmosCoin::new()
    }

    fn default_instance() -> &'static CosmosCoin {
        static instance: ::protobuf::rt::LazyV2<CosmosCoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CosmosCoin::new)
    }
}

impl ::protobuf::Clear for CosmosCoin {
    fn clear(&mut self) {
        self.denom.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CosmosCoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Paging {
    // message fields
    pub total: i64,
    pub from: i32,
    pub to: i32,
    pub count_by_subaccount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Paging {
    fn default() -> &'a Paging {
        <Paging as ::protobuf::Message>::default_instance()
    }
}

impl Paging {
    pub fn new() -> Paging {
        ::std::default::Default::default()
    }

    // sint64 total = 1;


    pub fn get_total(&self) -> i64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i64) {
        self.total = v;
    }

    // sint32 from = 2;


    pub fn get_from(&self) -> i32 {
        self.from
    }
    pub fn clear_from(&mut self) {
        self.from = 0;
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = v;
    }

    // sint32 to = 3;


    pub fn get_to(&self) -> i32 {
        self.to
    }
    pub fn clear_to(&mut self) {
        self.to = 0;
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = v;
    }

    // sint64 count_by_subaccount = 4;


    pub fn get_count_by_subaccount(&self) -> i64 {
        self.count_by_subaccount
    }
    pub fn clear_count_by_subaccount(&mut self) {
        self.count_by_subaccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_by_subaccount(&mut self, v: i64) {
        self.count_by_subaccount = v;
    }
}

impl ::protobuf::Message for Paging {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.from = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.to = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.count_by_subaccount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.total);
        }
        if self.from != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.from);
        }
        if self.to != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.to);
        }
        if self.count_by_subaccount != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.count_by_subaccount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_sint64(1, self.total)?;
        }
        if self.from != 0 {
            os.write_sint32(2, self.from)?;
        }
        if self.to != 0 {
            os.write_sint32(3, self.to)?;
        }
        if self.count_by_subaccount != 0 {
            os.write_sint64(4, self.count_by_subaccount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Paging {
        Paging::new()
    }

    fn default_instance() -> &'static Paging {
        static instance: ::protobuf::rt::LazyV2<Paging> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Paging::new)
    }
}

impl ::protobuf::Clear for Paging {
    fn clear(&mut self) {
        self.total = 0;
        self.from = 0;
        self.to = 0;
        self.count_by_subaccount = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Paging {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrderSummaryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub order_direction: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrderSummaryRequest {
    fn default() -> &'a SubaccountOrderSummaryRequest {
        <SubaccountOrderSummaryRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrderSummaryRequest {
    pub fn new() -> SubaccountOrderSummaryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_direction = 3;


    pub fn get_order_direction(&self) -> &str {
        &self.order_direction
    }
    pub fn clear_order_direction(&mut self) {
        self.order_direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_direction(&mut self, v: ::std::string::String) {
        self.order_direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_direction(&mut self) -> &mut ::std::string::String {
        &mut self.order_direction
    }

    // Take field
    pub fn take_order_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_direction, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubaccountOrderSummaryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_direction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.order_direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.order_direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.order_direction.is_empty() {
            os.write_string(3, &self.order_direction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrderSummaryRequest {
        SubaccountOrderSummaryRequest::new()
    }

    fn default_instance() -> &'static SubaccountOrderSummaryRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrderSummaryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrderSummaryRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountOrderSummaryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.order_direction.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrderSummaryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrderSummaryResponse {
    // message fields
    pub spot_orders_total: i64,
    pub derivative_orders_total: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrderSummaryResponse {
    fn default() -> &'a SubaccountOrderSummaryResponse {
        <SubaccountOrderSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrderSummaryResponse {
    pub fn new() -> SubaccountOrderSummaryResponse {
        ::std::default::Default::default()
    }

    // sint64 spot_orders_total = 1;


    pub fn get_spot_orders_total(&self) -> i64 {
        self.spot_orders_total
    }
    pub fn clear_spot_orders_total(&mut self) {
        self.spot_orders_total = 0;
    }

    // Param is passed by value, moved
    pub fn set_spot_orders_total(&mut self, v: i64) {
        self.spot_orders_total = v;
    }

    // sint64 derivative_orders_total = 2;


    pub fn get_derivative_orders_total(&self) -> i64 {
        self.derivative_orders_total
    }
    pub fn clear_derivative_orders_total(&mut self) {
        self.derivative_orders_total = 0;
    }

    // Param is passed by value, moved
    pub fn set_derivative_orders_total(&mut self, v: i64) {
        self.derivative_orders_total = v;
    }
}

impl ::protobuf::Message for SubaccountOrderSummaryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.spot_orders_total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.derivative_orders_total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.spot_orders_total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.spot_orders_total);
        }
        if self.derivative_orders_total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.derivative_orders_total);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.spot_orders_total != 0 {
            os.write_sint64(1, self.spot_orders_total)?;
        }
        if self.derivative_orders_total != 0 {
            os.write_sint64(2, self.derivative_orders_total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrderSummaryResponse {
        SubaccountOrderSummaryResponse::new()
    }

    fn default_instance() -> &'static SubaccountOrderSummaryResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrderSummaryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrderSummaryResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountOrderSummaryResponse {
    fn clear(&mut self) {
        self.spot_orders_total = 0;
        self.derivative_orders_total = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrderSummaryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RewardsRequest {
    // message fields
    pub epoch: i64,
    pub account_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewardsRequest {
    fn default() -> &'a RewardsRequest {
        <RewardsRequest as ::protobuf::Message>::default_instance()
    }
}

impl RewardsRequest {
    pub fn new() -> RewardsRequest {
        ::std::default::Default::default()
    }

    // sint64 epoch = 1;


    pub fn get_epoch(&self) -> i64 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: i64) {
        self.epoch = v;
    }

    // string account_address = 2;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RewardsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.epoch = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.epoch);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch != 0 {
            os.write_sint64(1, self.epoch)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewardsRequest {
        RewardsRequest::new()
    }

    fn default_instance() -> &'static RewardsRequest {
        static instance: ::protobuf::rt::LazyV2<RewardsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewardsRequest::new)
    }
}

impl ::protobuf::Clear for RewardsRequest {
    fn clear(&mut self) {
        self.epoch = 0;
        self.account_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RewardsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RewardsResponse {
    // message fields
    pub rewards: ::protobuf::RepeatedField<Reward>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewardsResponse {
    fn default() -> &'a RewardsResponse {
        <RewardsResponse as ::protobuf::Message>::default_instance()
    }
}

impl RewardsResponse {
    pub fn new() -> RewardsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_accounts_rpc.Reward rewards = 1;


    pub fn get_rewards(&self) -> &[Reward] {
        &self.rewards
    }
    pub fn clear_rewards(&mut self) {
        self.rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewards(&mut self, v: ::protobuf::RepeatedField<Reward>) {
        self.rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewards(&mut self) -> &mut ::protobuf::RepeatedField<Reward> {
        &mut self.rewards
    }

    // Take field
    pub fn take_rewards(&mut self) -> ::protobuf::RepeatedField<Reward> {
        ::std::mem::replace(&mut self.rewards, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RewardsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rewards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rewards {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewardsResponse {
        RewardsResponse::new()
    }

    fn default_instance() -> &'static RewardsResponse {
        static instance: ::protobuf::rt::LazyV2<RewardsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewardsResponse::new)
    }
}

impl ::protobuf::Clear for RewardsResponse {
    fn clear(&mut self) {
        self.rewards.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RewardsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Reward {
    // message fields
    pub account_address: ::std::string::String,
    pub rewards: ::protobuf::RepeatedField<Coin>,
    pub distributed_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reward {
    fn default() -> &'a Reward {
        <Reward as ::protobuf::Message>::default_instance()
    }
}

impl Reward {
    pub fn new() -> Reward {
        ::std::default::Default::default()
    }

    // string account_address = 1;


    pub fn get_account_address(&self) -> &str {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::string::String) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::string::String {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_address, ::std::string::String::new())
    }

    // repeated .injective_accounts_rpc.Coin rewards = 2;


    pub fn get_rewards(&self) -> &[Coin] {
        &self.rewards
    }
    pub fn clear_rewards(&mut self) {
        self.rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewards(&mut self, v: ::protobuf::RepeatedField<Coin>) {
        self.rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewards(&mut self) -> &mut ::protobuf::RepeatedField<Coin> {
        &mut self.rewards
    }

    // Take field
    pub fn take_rewards(&mut self) -> ::protobuf::RepeatedField<Coin> {
        ::std::mem::replace(&mut self.rewards, ::protobuf::RepeatedField::new())
    }

    // sint64 distributed_at = 3;


    pub fn get_distributed_at(&self) -> i64 {
        self.distributed_at
    }
    pub fn clear_distributed_at(&mut self) {
        self.distributed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_distributed_at(&mut self, v: i64) {
        self.distributed_at = v;
    }
}

impl ::protobuf::Message for Reward {
    fn is_initialized(&self) -> bool {
        for v in &self.rewards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rewards)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.distributed_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.account_address);
        }
        for value in &self.rewards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.distributed_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.distributed_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_address.is_empty() {
            os.write_string(1, &self.account_address)?;
        }
        for v in &self.rewards {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.distributed_at != 0 {
            os.write_sint64(3, self.distributed_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reward {
        Reward::new()
    }

    fn default_instance() -> &'static Reward {
        static instance: ::protobuf::rt::LazyV2<Reward> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reward::new)
    }
}

impl ::protobuf::Clear for Reward {
    fn clear(&mut self) {
        self.account_address.clear();
        self.rewards.clear();
        self.distributed_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Reward {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Coin {
    // message fields
    pub denom: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Coin {
    fn default() -> &'a Coin {
        <Coin as ::protobuf::Message>::default_instance()
    }
}

impl Coin {
    pub fn new() -> Coin {
        ::std::default::Default::default()
    }

    // string denom = 1;


    pub fn get_denom(&self) -> &str {
        &self.denom
    }
    pub fn clear_denom(&mut self) {
        self.denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_denom(&mut self, v: ::std::string::String) {
        self.denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denom(&mut self) -> &mut ::std::string::String {
        &mut self.denom
    }

    // Take field
    pub fn take_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.denom, ::std::string::String::new())
    }

    // string amount = 2;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Coin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.denom)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.denom.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.denom);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.denom.is_empty() {
            os.write_string(1, &self.denom)?;
        }
        if !self.amount.is_empty() {
            os.write_string(2, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Coin {
        Coin::new()
    }

    fn default_instance() -> &'static Coin {
        static instance: ::protobuf::rt::LazyV2<Coin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Coin::new)
    }
}

impl ::protobuf::Clear for Coin {
    fn clear(&mut self) {
        self.denom.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Coin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
