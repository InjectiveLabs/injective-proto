// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `injective_spot_exchange_rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketsRequest {
    // message fields
    pub market_status: ::std::string::String,
    pub base_denom: ::std::string::String,
    pub quote_denom: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketsRequest {
    fn default() -> &'a MarketsRequest {
        <MarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarketsRequest {
    pub fn new() -> MarketsRequest {
        ::std::default::Default::default()
    }

    // string market_status = 1;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string base_denom = 2;


    pub fn get_base_denom(&self) -> &str {
        &self.base_denom
    }
    pub fn clear_base_denom(&mut self) {
        self.base_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_denom(&mut self, v: ::std::string::String) {
        self.base_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_denom(&mut self) -> &mut ::std::string::String {
        &mut self.base_denom
    }

    // Take field
    pub fn take_base_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_denom, ::std::string::String::new())
    }

    // string quote_denom = 3;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_denom)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_status);
        }
        if !self.base_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.base_denom);
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.quote_denom);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_status.is_empty() {
            os.write_string(1, &self.market_status)?;
        }
        if !self.base_denom.is_empty() {
            os.write_string(2, &self.base_denom)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(3, &self.quote_denom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketsRequest {
        MarketsRequest::new()
    }

    fn default_instance() -> &'static MarketsRequest {
        static instance: ::protobuf::rt::LazyV2<MarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketsRequest::new)
    }
}

impl ::protobuf::Clear for MarketsRequest {
    fn clear(&mut self) {
        self.market_status.clear();
        self.base_denom.clear();
        self.quote_denom.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketsResponse {
    // message fields
    pub markets: ::protobuf::RepeatedField<SpotMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketsResponse {
    fn default() -> &'a MarketsResponse {
        <MarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarketsResponse {
    pub fn new() -> MarketsResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotMarketInfo markets = 1;


    pub fn get_markets(&self) -> &[SpotMarketInfo] {
        &self.markets
    }
    pub fn clear_markets(&mut self) {
        self.markets.clear();
    }

    // Param is passed by value, moved
    pub fn set_markets(&mut self, v: ::protobuf::RepeatedField<SpotMarketInfo>) {
        self.markets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_markets(&mut self) -> &mut ::protobuf::RepeatedField<SpotMarketInfo> {
        &mut self.markets
    }

    // Take field
    pub fn take_markets(&mut self) -> ::protobuf::RepeatedField<SpotMarketInfo> {
        ::std::mem::replace(&mut self.markets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.markets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.markets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.markets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.markets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketsResponse {
        MarketsResponse::new()
    }

    fn default_instance() -> &'static MarketsResponse {
        static instance: ::protobuf::rt::LazyV2<MarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketsResponse::new)
    }
}

impl ::protobuf::Clear for MarketsResponse {
    fn clear(&mut self) {
        self.markets.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotMarketInfo {
    // message fields
    pub market_id: ::std::string::String,
    pub market_status: ::std::string::String,
    pub ticker: ::std::string::String,
    pub base_denom: ::std::string::String,
    pub base_token_meta: ::protobuf::SingularPtrField<TokenMeta>,
    pub quote_denom: ::std::string::String,
    pub quote_token_meta: ::protobuf::SingularPtrField<TokenMeta>,
    pub maker_fee_rate: ::std::string::String,
    pub taker_fee_rate: ::std::string::String,
    pub service_provider_fee: ::std::string::String,
    pub min_price_tick_size: ::std::string::String,
    pub min_quantity_tick_size: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotMarketInfo {
    fn default() -> &'a SpotMarketInfo {
        <SpotMarketInfo as ::protobuf::Message>::default_instance()
    }
}

impl SpotMarketInfo {
    pub fn new() -> SpotMarketInfo {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string market_status = 2;


    pub fn get_market_status(&self) -> &str {
        &self.market_status
    }
    pub fn clear_market_status(&mut self) {
        self.market_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_status(&mut self, v: ::std::string::String) {
        self.market_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_status(&mut self) -> &mut ::std::string::String {
        &mut self.market_status
    }

    // Take field
    pub fn take_market_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_status, ::std::string::String::new())
    }

    // string ticker = 3;


    pub fn get_ticker(&self) -> &str {
        &self.ticker
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        &mut self.ticker
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticker, ::std::string::String::new())
    }

    // string base_denom = 4;


    pub fn get_base_denom(&self) -> &str {
        &self.base_denom
    }
    pub fn clear_base_denom(&mut self) {
        self.base_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_base_denom(&mut self, v: ::std::string::String) {
        self.base_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_denom(&mut self) -> &mut ::std::string::String {
        &mut self.base_denom
    }

    // Take field
    pub fn take_base_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.base_denom, ::std::string::String::new())
    }

    // .injective_spot_exchange_rpc.TokenMeta base_token_meta = 5;


    pub fn get_base_token_meta(&self) -> &TokenMeta {
        self.base_token_meta.as_ref().unwrap_or_else(|| <TokenMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base_token_meta(&mut self) {
        self.base_token_meta.clear();
    }

    pub fn has_base_token_meta(&self) -> bool {
        self.base_token_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_token_meta(&mut self, v: TokenMeta) {
        self.base_token_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_token_meta(&mut self) -> &mut TokenMeta {
        if self.base_token_meta.is_none() {
            self.base_token_meta.set_default();
        }
        self.base_token_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_token_meta(&mut self) -> TokenMeta {
        self.base_token_meta.take().unwrap_or_else(|| TokenMeta::new())
    }

    // string quote_denom = 6;


    pub fn get_quote_denom(&self) -> &str {
        &self.quote_denom
    }
    pub fn clear_quote_denom(&mut self) {
        self.quote_denom.clear();
    }

    // Param is passed by value, moved
    pub fn set_quote_denom(&mut self, v: ::std::string::String) {
        self.quote_denom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_denom(&mut self) -> &mut ::std::string::String {
        &mut self.quote_denom
    }

    // Take field
    pub fn take_quote_denom(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quote_denom, ::std::string::String::new())
    }

    // .injective_spot_exchange_rpc.TokenMeta quote_token_meta = 7;


    pub fn get_quote_token_meta(&self) -> &TokenMeta {
        self.quote_token_meta.as_ref().unwrap_or_else(|| <TokenMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quote_token_meta(&mut self) {
        self.quote_token_meta.clear();
    }

    pub fn has_quote_token_meta(&self) -> bool {
        self.quote_token_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_token_meta(&mut self, v: TokenMeta) {
        self.quote_token_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote_token_meta(&mut self) -> &mut TokenMeta {
        if self.quote_token_meta.is_none() {
            self.quote_token_meta.set_default();
        }
        self.quote_token_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote_token_meta(&mut self) -> TokenMeta {
        self.quote_token_meta.take().unwrap_or_else(|| TokenMeta::new())
    }

    // string maker_fee_rate = 8;


    pub fn get_maker_fee_rate(&self) -> &str {
        &self.maker_fee_rate
    }
    pub fn clear_maker_fee_rate(&mut self) {
        self.maker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_fee_rate(&mut self, v: ::std::string::String) {
        self.maker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.maker_fee_rate
    }

    // Take field
    pub fn take_maker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_fee_rate, ::std::string::String::new())
    }

    // string taker_fee_rate = 9;


    pub fn get_taker_fee_rate(&self) -> &str {
        &self.taker_fee_rate
    }
    pub fn clear_taker_fee_rate(&mut self) {
        self.taker_fee_rate.clear();
    }

    // Param is passed by value, moved
    pub fn set_taker_fee_rate(&mut self, v: ::std::string::String) {
        self.taker_fee_rate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker_fee_rate(&mut self) -> &mut ::std::string::String {
        &mut self.taker_fee_rate
    }

    // Take field
    pub fn take_taker_fee_rate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.taker_fee_rate, ::std::string::String::new())
    }

    // string service_provider_fee = 10;


    pub fn get_service_provider_fee(&self) -> &str {
        &self.service_provider_fee
    }
    pub fn clear_service_provider_fee(&mut self) {
        self.service_provider_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_provider_fee(&mut self, v: ::std::string::String) {
        self.service_provider_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_provider_fee(&mut self) -> &mut ::std::string::String {
        &mut self.service_provider_fee
    }

    // Take field
    pub fn take_service_provider_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_provider_fee, ::std::string::String::new())
    }

    // string min_price_tick_size = 11;


    pub fn get_min_price_tick_size(&self) -> &str {
        &self.min_price_tick_size
    }
    pub fn clear_min_price_tick_size(&mut self) {
        self.min_price_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_price_tick_size(&mut self, v: ::std::string::String) {
        self.min_price_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_price_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_price_tick_size
    }

    // Take field
    pub fn take_min_price_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_price_tick_size, ::std::string::String::new())
    }

    // string min_quantity_tick_size = 12;


    pub fn get_min_quantity_tick_size(&self) -> &str {
        &self.min_quantity_tick_size
    }
    pub fn clear_min_quantity_tick_size(&mut self) {
        self.min_quantity_tick_size.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_quantity_tick_size(&mut self, v: ::std::string::String) {
        self.min_quantity_tick_size = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_quantity_tick_size(&mut self) -> &mut ::std::string::String {
        &mut self.min_quantity_tick_size
    }

    // Take field
    pub fn take_min_quantity_tick_size(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_quantity_tick_size, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotMarketInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.base_token_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quote_token_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticker)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.base_denom)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_token_meta)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quote_denom)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote_token_meta)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_fee_rate)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.taker_fee_rate)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_provider_fee)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_price_tick_size)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_quantity_tick_size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.market_status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_status);
        }
        if !self.ticker.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ticker);
        }
        if !self.base_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.base_denom);
        }
        if let Some(ref v) = self.base_token_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.quote_denom.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.quote_denom);
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.maker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.maker_fee_rate);
        }
        if !self.taker_fee_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.taker_fee_rate);
        }
        if !self.service_provider_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.service_provider_fee);
        }
        if !self.min_price_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.min_price_tick_size);
        }
        if !self.min_quantity_tick_size.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.min_quantity_tick_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.market_status.is_empty() {
            os.write_string(2, &self.market_status)?;
        }
        if !self.ticker.is_empty() {
            os.write_string(3, &self.ticker)?;
        }
        if !self.base_denom.is_empty() {
            os.write_string(4, &self.base_denom)?;
        }
        if let Some(ref v) = self.base_token_meta.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.quote_denom.is_empty() {
            os.write_string(6, &self.quote_denom)?;
        }
        if let Some(ref v) = self.quote_token_meta.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.maker_fee_rate.is_empty() {
            os.write_string(8, &self.maker_fee_rate)?;
        }
        if !self.taker_fee_rate.is_empty() {
            os.write_string(9, &self.taker_fee_rate)?;
        }
        if !self.service_provider_fee.is_empty() {
            os.write_string(10, &self.service_provider_fee)?;
        }
        if !self.min_price_tick_size.is_empty() {
            os.write_string(11, &self.min_price_tick_size)?;
        }
        if !self.min_quantity_tick_size.is_empty() {
            os.write_string(12, &self.min_quantity_tick_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotMarketInfo {
        SpotMarketInfo::new()
    }

    fn default_instance() -> &'static SpotMarketInfo {
        static instance: ::protobuf::rt::LazyV2<SpotMarketInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotMarketInfo::new)
    }
}

impl ::protobuf::Clear for SpotMarketInfo {
    fn clear(&mut self) {
        self.market_id.clear();
        self.market_status.clear();
        self.ticker.clear();
        self.base_denom.clear();
        self.base_token_meta.clear();
        self.quote_denom.clear();
        self.quote_token_meta.clear();
        self.maker_fee_rate.clear();
        self.taker_fee_rate.clear();
        self.service_provider_fee.clear();
        self.min_price_tick_size.clear();
        self.min_quantity_tick_size.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotMarketInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenMeta {
    // message fields
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub symbol: ::std::string::String,
    pub logo: ::std::string::String,
    pub decimals: i32,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenMeta {
    fn default() -> &'a TokenMeta {
        <TokenMeta as ::protobuf::Message>::default_instance()
    }
}

impl TokenMeta {
    pub fn new() -> TokenMeta {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string symbol = 3;


    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::std::string::String) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbol(&mut self) -> &mut ::std::string::String {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symbol, ::std::string::String::new())
    }

    // string logo = 4;


    pub fn get_logo(&self) -> &str {
        &self.logo
    }
    pub fn clear_logo(&mut self) {
        self.logo.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: ::std::string::String) {
        self.logo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo(&mut self) -> &mut ::std::string::String {
        &mut self.logo
    }

    // Take field
    pub fn take_logo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo, ::std::string::String::new())
    }

    // sint32 decimals = 5;


    pub fn get_decimals(&self) -> i32 {
        self.decimals
    }
    pub fn clear_decimals(&mut self) {
        self.decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_decimals(&mut self, v: i32) {
        self.decimals = v;
    }

    // sint64 updated_at = 6;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for TokenMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symbol)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.decimals = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.symbol);
        }
        if !self.logo.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.logo);
        }
        if self.decimals != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.decimals);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if !self.symbol.is_empty() {
            os.write_string(3, &self.symbol)?;
        }
        if !self.logo.is_empty() {
            os.write_string(4, &self.logo)?;
        }
        if self.decimals != 0 {
            os.write_sint32(5, self.decimals)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(6, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenMeta {
        TokenMeta::new()
    }

    fn default_instance() -> &'static TokenMeta {
        static instance: ::protobuf::rt::LazyV2<TokenMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TokenMeta::new)
    }
}

impl ::protobuf::Clear for TokenMeta {
    fn clear(&mut self) {
        self.name.clear();
        self.address.clear();
        self.symbol.clear();
        self.logo.clear();
        self.decimals = 0;
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketRequest {
    fn default() -> &'a MarketRequest {
        <MarketRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarketRequest {
    pub fn new() -> MarketRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarketRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketRequest {
        MarketRequest::new()
    }

    fn default_instance() -> &'static MarketRequest {
        static instance: ::protobuf::rt::LazyV2<MarketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketRequest::new)
    }
}

impl ::protobuf::Clear for MarketRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MarketResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<SpotMarketInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarketResponse {
    fn default() -> &'a MarketResponse {
        <MarketResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarketResponse {
    pub fn new() -> MarketResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotMarketInfo market = 1;


    pub fn get_market(&self) -> &SpotMarketInfo {
        self.market.as_ref().unwrap_or_else(|| <SpotMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: SpotMarketInfo) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut SpotMarketInfo {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> SpotMarketInfo {
        self.market.take().unwrap_or_else(|| SpotMarketInfo::new())
    }
}

impl ::protobuf::Message for MarketResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarketResponse {
        MarketResponse::new()
    }

    fn default_instance() -> &'static MarketResponse {
        static instance: ::protobuf::rt::LazyV2<MarketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarketResponse::new)
    }
}

impl ::protobuf::Clear for MarketResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MarketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamMarketsRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMarketsRequest {
    fn default() -> &'a StreamMarketsRequest {
        <StreamMarketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamMarketsRequest {
    pub fn new() -> StreamMarketsRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamMarketsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMarketsRequest {
        StreamMarketsRequest::new()
    }

    fn default_instance() -> &'static StreamMarketsRequest {
        static instance: ::protobuf::rt::LazyV2<StreamMarketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMarketsRequest::new)
    }
}

impl ::protobuf::Clear for StreamMarketsRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMarketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamMarketsResponse {
    // message fields
    pub market: ::protobuf::SingularPtrField<SpotMarketInfo>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamMarketsResponse {
    fn default() -> &'a StreamMarketsResponse {
        <StreamMarketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamMarketsResponse {
    pub fn new() -> StreamMarketsResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotMarketInfo market = 1;


    pub fn get_market(&self) -> &SpotMarketInfo {
        self.market.as_ref().unwrap_or_else(|| <SpotMarketInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    pub fn has_market(&self) -> bool {
        self.market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: SpotMarketInfo) {
        self.market = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut SpotMarketInfo {
        if self.market.is_none() {
            self.market.set_default();
        }
        self.market.as_mut().unwrap()
    }

    // Take field
    pub fn take_market(&mut self) -> SpotMarketInfo {
        self.market.take().unwrap_or_else(|| SpotMarketInfo::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamMarketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.market {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.market)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.market.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.market.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamMarketsResponse {
        StreamMarketsResponse::new()
    }

    fn default_instance() -> &'static StreamMarketsResponse {
        static instance: ::protobuf::rt::LazyV2<StreamMarketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamMarketsResponse::new)
    }
}

impl ::protobuf::Clear for StreamMarketsResponse {
    fn clear(&mut self) {
        self.market.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamMarketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookRequest {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookRequest {
    fn default() -> &'a OrderbookRequest {
        <OrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookRequest {
    pub fn new() -> OrderbookRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookRequest {
        OrderbookRequest::new()
    }

    fn default_instance() -> &'static OrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<OrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookRequest::new)
    }
}

impl ::protobuf::Clear for OrderbookRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookResponse {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookResponse {
    fn default() -> &'a OrderbookResponse {
        <OrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookResponse {
    pub fn new() -> OrderbookResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbook::new())
    }
}

impl ::protobuf::Message for OrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookResponse {
        OrderbookResponse::new()
    }

    fn default_instance() -> &'static OrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<OrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookResponse::new)
    }
}

impl ::protobuf::Clear for OrderbookResponse {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotLimitOrderbook {
    // message fields
    pub buys: ::protobuf::RepeatedField<PriceLevel>,
    pub sells: ::protobuf::RepeatedField<PriceLevel>,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotLimitOrderbook {
    fn default() -> &'a SpotLimitOrderbook {
        <SpotLimitOrderbook as ::protobuf::Message>::default_instance()
    }
}

impl SpotLimitOrderbook {
    pub fn new() -> SpotLimitOrderbook {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1;


    pub fn get_buys(&self) -> &[PriceLevel] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2;


    pub fn get_sells(&self) -> &[PriceLevel] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for SpotLimitOrderbook {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotLimitOrderbook {
        SpotLimitOrderbook::new()
    }

    fn default_instance() -> &'static SpotLimitOrderbook {
        static instance: ::protobuf::rt::LazyV2<SpotLimitOrderbook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotLimitOrderbook::new)
    }
}

impl ::protobuf::Clear for SpotLimitOrderbook {
    fn clear(&mut self) {
        self.buys.clear();
        self.sells.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotLimitOrderbook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceLevel {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceLevel {
    fn default() -> &'a PriceLevel {
        <PriceLevel as ::protobuf::Message>::default_instance()
    }
}

impl PriceLevel {
    pub fn new() -> PriceLevel {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PriceLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceLevel {
        PriceLevel::new()
    }

    fn default_instance() -> &'static PriceLevel {
        static instance: ::protobuf::rt::LazyV2<PriceLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PriceLevel::new)
    }
}

impl ::protobuf::Clear for PriceLevel {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookV2Request {
    // message fields
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookV2Request {
    fn default() -> &'a OrderbookV2Request {
        <OrderbookV2Request as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookV2Request {
    pub fn new() -> OrderbookV2Request {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OrderbookV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookV2Request {
        OrderbookV2Request::new()
    }

    fn default_instance() -> &'static OrderbookV2Request {
        static instance: ::protobuf::rt::LazyV2<OrderbookV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookV2Request::new)
    }
}

impl ::protobuf::Clear for OrderbookV2Request {
    fn clear(&mut self) {
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookV2Response {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookV2Response {
    fn default() -> &'a OrderbookV2Response {
        <OrderbookV2Response as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookV2Response {
    pub fn new() -> OrderbookV2Response {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbookV2::new())
    }
}

impl ::protobuf::Message for OrderbookV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookV2Response {
        OrderbookV2Response::new()
    }

    fn default_instance() -> &'static OrderbookV2Response {
        static instance: ::protobuf::rt::LazyV2<OrderbookV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookV2Response::new)
    }
}

impl ::protobuf::Clear for OrderbookV2Response {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotLimitOrderbookV2 {
    // message fields
    pub buys: ::protobuf::RepeatedField<PriceLevel>,
    pub sells: ::protobuf::RepeatedField<PriceLevel>,
    pub sequence: u64,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotLimitOrderbookV2 {
    fn default() -> &'a SpotLimitOrderbookV2 {
        <SpotLimitOrderbookV2 as ::protobuf::Message>::default_instance()
    }
}

impl SpotLimitOrderbookV2 {
    pub fn new() -> SpotLimitOrderbookV2 {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.PriceLevel buys = 1;


    pub fn get_buys(&self) -> &[PriceLevel] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_spot_exchange_rpc.PriceLevel sells = 2;


    pub fn get_sells(&self) -> &[PriceLevel] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevel>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevel> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevel> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // uint64 sequence = 3;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for SpotLimitOrderbookV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.buys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.sequence != 0 {
            os.write_uint64(3, self.sequence)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotLimitOrderbookV2 {
        SpotLimitOrderbookV2::new()
    }

    fn default_instance() -> &'static SpotLimitOrderbookV2 {
        static instance: ::protobuf::rt::LazyV2<SpotLimitOrderbookV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotLimitOrderbookV2::new)
    }
}

impl ::protobuf::Clear for SpotLimitOrderbookV2 {
    fn clear(&mut self) {
        self.buys.clear();
        self.sells.clear();
        self.sequence = 0;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotLimitOrderbookV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksRequest {
    fn default() -> &'a OrderbooksRequest {
        <OrderbooksRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksRequest {
    pub fn new() -> OrderbooksRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksRequest {
        OrderbooksRequest::new()
    }

    fn default_instance() -> &'static OrderbooksRequest {
        static instance: ::protobuf::rt::LazyV2<OrderbooksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksRequest::new)
    }
}

impl ::protobuf::Clear for OrderbooksRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksResponse {
    // message fields
    pub orderbooks: ::protobuf::RepeatedField<SingleSpotLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksResponse {
    fn default() -> &'a OrderbooksResponse {
        <OrderbooksResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksResponse {
    pub fn new() -> OrderbooksResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbook orderbooks = 1;


    pub fn get_orderbooks(&self) -> &[SingleSpotLimitOrderbook] {
        &self.orderbooks
    }
    pub fn clear_orderbooks(&mut self) {
        self.orderbooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderbooks(&mut self, v: ::protobuf::RepeatedField<SingleSpotLimitOrderbook>) {
        self.orderbooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderbooks(&mut self) -> &mut ::protobuf::RepeatedField<SingleSpotLimitOrderbook> {
        &mut self.orderbooks
    }

    // Take field
    pub fn take_orderbooks(&mut self) -> ::protobuf::RepeatedField<SingleSpotLimitOrderbook> {
        ::std::mem::replace(&mut self.orderbooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbooks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orderbooks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orderbooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orderbooks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksResponse {
        OrderbooksResponse::new()
    }

    fn default_instance() -> &'static OrderbooksResponse {
        static instance: ::protobuf::rt::LazyV2<OrderbooksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksResponse::new)
    }
}

impl ::protobuf::Clear for OrderbooksResponse {
    fn clear(&mut self) {
        self.orderbooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleSpotLimitOrderbook {
    // message fields
    pub market_id: ::std::string::String,
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbook>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleSpotLimitOrderbook {
    fn default() -> &'a SingleSpotLimitOrderbook {
        <SingleSpotLimitOrderbook as ::protobuf::Message>::default_instance()
    }
}

impl SingleSpotLimitOrderbook {
    pub fn new() -> SingleSpotLimitOrderbook {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 2;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbook::new())
    }
}

impl ::protobuf::Message for SingleSpotLimitOrderbook {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleSpotLimitOrderbook {
        SingleSpotLimitOrderbook::new()
    }

    fn default_instance() -> &'static SingleSpotLimitOrderbook {
        static instance: ::protobuf::rt::LazyV2<SingleSpotLimitOrderbook> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleSpotLimitOrderbook::new)
    }
}

impl ::protobuf::Clear for SingleSpotLimitOrderbook {
    fn clear(&mut self) {
        self.market_id.clear();
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSpotLimitOrderbook {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksV2Request {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksV2Request {
    fn default() -> &'a OrderbooksV2Request {
        <OrderbooksV2Request as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksV2Request {
    pub fn new() -> OrderbooksV2Request {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksV2Request {
        OrderbooksV2Request::new()
    }

    fn default_instance() -> &'static OrderbooksV2Request {
        static instance: ::protobuf::rt::LazyV2<OrderbooksV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksV2Request::new)
    }
}

impl ::protobuf::Clear for OrderbooksV2Request {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbooksV2Response {
    // message fields
    pub orderbooks: ::protobuf::RepeatedField<SingleSpotLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbooksV2Response {
    fn default() -> &'a OrderbooksV2Response {
        <OrderbooksV2Response as ::protobuf::Message>::default_instance()
    }
}

impl OrderbooksV2Response {
    pub fn new() -> OrderbooksV2Response {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SingleSpotLimitOrderbookV2 orderbooks = 1;


    pub fn get_orderbooks(&self) -> &[SingleSpotLimitOrderbookV2] {
        &self.orderbooks
    }
    pub fn clear_orderbooks(&mut self) {
        self.orderbooks.clear();
    }

    // Param is passed by value, moved
    pub fn set_orderbooks(&mut self, v: ::protobuf::RepeatedField<SingleSpotLimitOrderbookV2>) {
        self.orderbooks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orderbooks(&mut self) -> &mut ::protobuf::RepeatedField<SingleSpotLimitOrderbookV2> {
        &mut self.orderbooks
    }

    // Take field
    pub fn take_orderbooks(&mut self) -> ::protobuf::RepeatedField<SingleSpotLimitOrderbookV2> {
        ::std::mem::replace(&mut self.orderbooks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrderbooksV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbooks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orderbooks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orderbooks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orderbooks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbooksV2Response {
        OrderbooksV2Response::new()
    }

    fn default_instance() -> &'static OrderbooksV2Response {
        static instance: ::protobuf::rt::LazyV2<OrderbooksV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbooksV2Response::new)
    }
}

impl ::protobuf::Clear for OrderbooksV2Response {
    fn clear(&mut self) {
        self.orderbooks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbooksV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleSpotLimitOrderbookV2 {
    // message fields
    pub market_id: ::std::string::String,
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbookV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SingleSpotLimitOrderbookV2 {
    fn default() -> &'a SingleSpotLimitOrderbookV2 {
        <SingleSpotLimitOrderbookV2 as ::protobuf::Message>::default_instance()
    }
}

impl SingleSpotLimitOrderbookV2 {
    pub fn new() -> SingleSpotLimitOrderbookV2 {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 2;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbookV2::new())
    }
}

impl ::protobuf::Message for SingleSpotLimitOrderbookV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleSpotLimitOrderbookV2 {
        SingleSpotLimitOrderbookV2::new()
    }

    fn default_instance() -> &'static SingleSpotLimitOrderbookV2 {
        static instance: ::protobuf::rt::LazyV2<SingleSpotLimitOrderbookV2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SingleSpotLimitOrderbookV2::new)
    }
}

impl ::protobuf::Clear for SingleSpotLimitOrderbookV2 {
    fn clear(&mut self) {
        self.market_id.clear();
        self.orderbook.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSpotLimitOrderbookV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookRequest {
    fn default() -> &'a StreamOrderbookRequest {
        <StreamOrderbookRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookRequest {
    pub fn new() -> StreamOrderbookRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookRequest {
        StreamOrderbookRequest::new()
    }

    fn default_instance() -> &'static StreamOrderbookRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookResponse {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbook>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookResponse {
    fn default() -> &'a StreamOrderbookResponse {
        <StreamOrderbookResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookResponse {
    pub fn new() -> StreamOrderbookResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbook orderbook = 1;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbook {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbook as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbook) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbook {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbook {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbook::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookResponse {
        StreamOrderbookResponse::new()
    }

    fn default_instance() -> &'static StreamOrderbookResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookResponse {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookV2Request {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookV2Request {
    fn default() -> &'a StreamOrderbookV2Request {
        <StreamOrderbookV2Request as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookV2Request {
    pub fn new() -> StreamOrderbookV2Request {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookV2Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookV2Request {
        StreamOrderbookV2Request::new()
    }

    fn default_instance() -> &'static StreamOrderbookV2Request {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookV2Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookV2Request::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookV2Request {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookV2Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookV2Response {
    // message fields
    pub orderbook: ::protobuf::SingularPtrField<SpotLimitOrderbookV2>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookV2Response {
    fn default() -> &'a StreamOrderbookV2Response {
        <StreamOrderbookV2Response as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookV2Response {
    pub fn new() -> StreamOrderbookV2Response {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotLimitOrderbookV2 orderbook = 1;


    pub fn get_orderbook(&self) -> &SpotLimitOrderbookV2 {
        self.orderbook.as_ref().unwrap_or_else(|| <SpotLimitOrderbookV2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook(&mut self) {
        self.orderbook.clear();
    }

    pub fn has_orderbook(&self) -> bool {
        self.orderbook.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook(&mut self, v: SpotLimitOrderbookV2) {
        self.orderbook = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook(&mut self) -> &mut SpotLimitOrderbookV2 {
        if self.orderbook.is_none() {
            self.orderbook.set_default();
        }
        self.orderbook.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook(&mut self) -> SpotLimitOrderbookV2 {
        self.orderbook.take().unwrap_or_else(|| SpotLimitOrderbookV2::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookV2Response {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookV2Response {
        StreamOrderbookV2Response::new()
    }

    fn default_instance() -> &'static StreamOrderbookV2Response {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookV2Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookV2Response::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookV2Response {
    fn clear(&mut self) {
        self.orderbook.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookV2Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookUpdateRequest {
    // message fields
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookUpdateRequest {
    fn default() -> &'a StreamOrderbookUpdateRequest {
        <StreamOrderbookUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookUpdateRequest {
    pub fn new() -> StreamOrderbookUpdateRequest {
        ::std::default::Default::default()
    }

    // repeated string market_ids = 1;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrderbookUpdateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.market_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookUpdateRequest {
        StreamOrderbookUpdateRequest::new()
    }

    fn default_instance() -> &'static StreamOrderbookUpdateRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookUpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookUpdateRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookUpdateRequest {
    fn clear(&mut self) {
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrderbookUpdateResponse {
    // message fields
    pub orderbook_level_updates: ::protobuf::SingularPtrField<OrderbookLevelUpdates>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    pub market_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrderbookUpdateResponse {
    fn default() -> &'a StreamOrderbookUpdateResponse {
        <StreamOrderbookUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrderbookUpdateResponse {
    pub fn new() -> StreamOrderbookUpdateResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1;


    pub fn get_orderbook_level_updates(&self) -> &OrderbookLevelUpdates {
        self.orderbook_level_updates.as_ref().unwrap_or_else(|| <OrderbookLevelUpdates as ::protobuf::Message>::default_instance())
    }
    pub fn clear_orderbook_level_updates(&mut self) {
        self.orderbook_level_updates.clear();
    }

    pub fn has_orderbook_level_updates(&self) -> bool {
        self.orderbook_level_updates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderbook_level_updates(&mut self, v: OrderbookLevelUpdates) {
        self.orderbook_level_updates = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderbook_level_updates(&mut self) -> &mut OrderbookLevelUpdates {
        if self.orderbook_level_updates.is_none() {
            self.orderbook_level_updates.set_default();
        }
        self.orderbook_level_updates.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderbook_level_updates(&mut self) -> OrderbookLevelUpdates {
        self.orderbook_level_updates.take().unwrap_or_else(|| OrderbookLevelUpdates::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string market_id = 4;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamOrderbookUpdateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orderbook_level_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.orderbook_level_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.orderbook_level_updates.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.market_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.orderbook_level_updates.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(4, &self.market_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrderbookUpdateResponse {
        StreamOrderbookUpdateResponse::new()
    }

    fn default_instance() -> &'static StreamOrderbookUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrderbookUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrderbookUpdateResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrderbookUpdateResponse {
    fn clear(&mut self) {
        self.orderbook_level_updates.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.market_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrderbookUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrderbookLevelUpdates {
    // message fields
    pub market_id: ::std::string::String,
    pub sequence: u64,
    pub buys: ::protobuf::RepeatedField<PriceLevelUpdate>,
    pub sells: ::protobuf::RepeatedField<PriceLevelUpdate>,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrderbookLevelUpdates {
    fn default() -> &'a OrderbookLevelUpdates {
        <OrderbookLevelUpdates as ::protobuf::Message>::default_instance()
    }
}

impl OrderbookLevelUpdates {
    pub fn new() -> OrderbookLevelUpdates {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 sequence = 2;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // repeated .injective_spot_exchange_rpc.PriceLevelUpdate buys = 3;


    pub fn get_buys(&self) -> &[PriceLevelUpdate] {
        &self.buys
    }
    pub fn clear_buys(&mut self) {
        self.buys.clear();
    }

    // Param is passed by value, moved
    pub fn set_buys(&mut self, v: ::protobuf::RepeatedField<PriceLevelUpdate>) {
        self.buys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buys(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevelUpdate> {
        &mut self.buys
    }

    // Take field
    pub fn take_buys(&mut self) -> ::protobuf::RepeatedField<PriceLevelUpdate> {
        ::std::mem::replace(&mut self.buys, ::protobuf::RepeatedField::new())
    }

    // repeated .injective_spot_exchange_rpc.PriceLevelUpdate sells = 4;


    pub fn get_sells(&self) -> &[PriceLevelUpdate] {
        &self.sells
    }
    pub fn clear_sells(&mut self) {
        self.sells.clear();
    }

    // Param is passed by value, moved
    pub fn set_sells(&mut self, v: ::protobuf::RepeatedField<PriceLevelUpdate>) {
        self.sells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sells(&mut self) -> &mut ::protobuf::RepeatedField<PriceLevelUpdate> {
        &mut self.sells
    }

    // Take field
    pub fn take_sells(&mut self) -> ::protobuf::RepeatedField<PriceLevelUpdate> {
        ::std::mem::replace(&mut self.sells, ::protobuf::RepeatedField::new())
    }

    // sint64 updated_at = 5;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for OrderbookLevelUpdates {
    fn is_initialized(&self) -> bool {
        for v in &self.buys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buys)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sells)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.buys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.sells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if self.sequence != 0 {
            os.write_uint64(2, self.sequence)?;
        }
        for v in &self.buys {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.sells {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.updated_at != 0 {
            os.write_sint64(5, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderbookLevelUpdates {
        OrderbookLevelUpdates::new()
    }

    fn default_instance() -> &'static OrderbookLevelUpdates {
        static instance: ::protobuf::rt::LazyV2<OrderbookLevelUpdates> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrderbookLevelUpdates::new)
    }
}

impl ::protobuf::Clear for OrderbookLevelUpdates {
    fn clear(&mut self) {
        self.market_id.clear();
        self.sequence = 0;
        self.buys.clear();
        self.sells.clear();
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderbookLevelUpdates {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceLevelUpdate {
    // message fields
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub is_active: bool,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PriceLevelUpdate {
    fn default() -> &'a PriceLevelUpdate {
        <PriceLevelUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PriceLevelUpdate {
    pub fn new() -> PriceLevelUpdate {
        ::std::default::Default::default()
    }

    // string price = 1;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 2;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // bool is_active = 3;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // sint64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for PriceLevelUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quantity);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.price.is_empty() {
            os.write_string(1, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(2, &self.quantity)?;
        }
        if self.is_active != false {
            os.write_bool(3, self.is_active)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PriceLevelUpdate {
        PriceLevelUpdate::new()
    }

    fn default_instance() -> &'static PriceLevelUpdate {
        static instance: ::protobuf::rt::LazyV2<PriceLevelUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PriceLevelUpdate::new)
    }
}

impl ::protobuf::Clear for PriceLevelUpdate {
    fn clear(&mut self) {
        self.price.clear();
        self.quantity.clear();
        self.is_active = false;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceLevelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub order_side: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub include_inactive: bool,
    pub subaccount_total_orders: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersRequest {
    fn default() -> &'a OrdersRequest {
        <OrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrdersRequest {
    pub fn new() -> OrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 5;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 6;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 7;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 8;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // bool include_inactive = 9;


    pub fn get_include_inactive(&self) -> bool {
        self.include_inactive
    }
    pub fn clear_include_inactive(&mut self) {
        self.include_inactive = false;
    }

    // Param is passed by value, moved
    pub fn set_include_inactive(&mut self, v: bool) {
        self.include_inactive = v;
    }

    // bool subaccount_total_orders = 10;


    pub fn get_subaccount_total_orders(&self) -> bool {
        self.subaccount_total_orders
    }
    pub fn clear_subaccount_total_orders(&mut self) {
        self.subaccount_total_orders = false;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_total_orders(&mut self, v: bool) {
        self.subaccount_total_orders = v;
    }
}

impl ::protobuf::Message for OrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_inactive = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subaccount_total_orders = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.include_inactive != false {
            my_size += 2;
        }
        if self.subaccount_total_orders != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(5, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(6, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(7, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(8, &v)?;
        };
        if self.include_inactive != false {
            os.write_bool(9, self.include_inactive)?;
        }
        if self.subaccount_total_orders != false {
            os.write_bool(10, self.subaccount_total_orders)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersRequest {
        OrdersRequest::new()
    }

    fn default_instance() -> &'static OrdersRequest {
        static instance: ::protobuf::rt::LazyV2<OrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersRequest::new)
    }
}

impl ::protobuf::Clear for OrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_side.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.include_inactive = false;
        self.subaccount_total_orders = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<SpotLimitOrder>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersResponse {
    fn default() -> &'a OrdersResponse {
        <OrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrdersResponse {
    pub fn new() -> OrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[SpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<SpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<SpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<SpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_spot_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for OrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersResponse {
        OrdersResponse::new()
    }

    fn default_instance() -> &'static OrdersResponse {
        static instance: ::protobuf::rt::LazyV2<OrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersResponse::new)
    }
}

impl ::protobuf::Clear for OrdersResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotLimitOrder {
    // message fields
    pub order_hash: ::std::string::String,
    pub order_side: ::std::string::String,
    pub market_id: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub unfilled_quantity: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub fee_recipient: ::std::string::String,
    pub state: ::std::string::String,
    pub created_at: i64,
    pub updated_at: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotLimitOrder {
    fn default() -> &'a SpotLimitOrder {
        <SpotLimitOrder as ::protobuf::Message>::default_instance()
    }
}

impl SpotLimitOrder {
    pub fn new() -> SpotLimitOrder {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string price = 5;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string quantity = 6;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string unfilled_quantity = 7;


    pub fn get_unfilled_quantity(&self) -> &str {
        &self.unfilled_quantity
    }
    pub fn clear_unfilled_quantity(&mut self) {
        self.unfilled_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_unfilled_quantity(&mut self, v: ::std::string::String) {
        self.unfilled_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unfilled_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.unfilled_quantity
    }

    // Take field
    pub fn take_unfilled_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unfilled_quantity, ::std::string::String::new())
    }

    // string trigger_price = 8;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // string fee_recipient = 9;


    pub fn get_fee_recipient(&self) -> &str {
        &self.fee_recipient
    }
    pub fn clear_fee_recipient(&mut self) {
        self.fee_recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient(&mut self, v: ::std::string::String) {
        self.fee_recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.fee_recipient
    }

    // Take field
    pub fn take_fee_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_recipient, ::std::string::String::new())
    }

    // string state = 10;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint64 created_at = 11;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // sint64 updated_at = 12;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }
}

impl ::protobuf::Message for SpotLimitOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unfilled_quantity)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_recipient)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.quantity);
        }
        if !self.unfilled_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.unfilled_quantity);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.trigger_price);
        }
        if !self.fee_recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.fee_recipient);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(11, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.updated_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if !self.price.is_empty() {
            os.write_string(5, &self.price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(6, &self.quantity)?;
        }
        if !self.unfilled_quantity.is_empty() {
            os.write_string(7, &self.unfilled_quantity)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(8, &self.trigger_price)?;
        }
        if !self.fee_recipient.is_empty() {
            os.write_string(9, &self.fee_recipient)?;
        }
        if !self.state.is_empty() {
            os.write_string(10, &self.state)?;
        }
        if self.created_at != 0 {
            os.write_sint64(11, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(12, self.updated_at)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotLimitOrder {
        SpotLimitOrder::new()
    }

    fn default_instance() -> &'static SpotLimitOrder {
        static instance: ::protobuf::rt::LazyV2<SpotLimitOrder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotLimitOrder::new)
    }
}

impl ::protobuf::Clear for SpotLimitOrder {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.order_side.clear();
        self.market_id.clear();
        self.subaccount_id.clear();
        self.price.clear();
        self.quantity.clear();
        self.unfilled_quantity.clear();
        self.trigger_price.clear();
        self.fee_recipient.clear();
        self.state.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotLimitOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Paging {
    // message fields
    pub total: i64,
    pub from: i32,
    pub to: i32,
    pub count_by_subaccount: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Paging {
    fn default() -> &'a Paging {
        <Paging as ::protobuf::Message>::default_instance()
    }
}

impl Paging {
    pub fn new() -> Paging {
        ::std::default::Default::default()
    }

    // sint64 total = 1;


    pub fn get_total(&self) -> i64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i64) {
        self.total = v;
    }

    // sint32 from = 2;


    pub fn get_from(&self) -> i32 {
        self.from
    }
    pub fn clear_from(&mut self) {
        self.from = 0;
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = v;
    }

    // sint32 to = 3;


    pub fn get_to(&self) -> i32 {
        self.to
    }
    pub fn clear_to(&mut self) {
        self.to = 0;
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = v;
    }

    // sint64 count_by_subaccount = 4;


    pub fn get_count_by_subaccount(&self) -> i64 {
        self.count_by_subaccount
    }
    pub fn clear_count_by_subaccount(&mut self) {
        self.count_by_subaccount = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_by_subaccount(&mut self, v: i64) {
        self.count_by_subaccount = v;
    }
}

impl ::protobuf::Message for Paging {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.from = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.to = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.count_by_subaccount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.total);
        }
        if self.from != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, self.from);
        }
        if self.to != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.to);
        }
        if self.count_by_subaccount != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.count_by_subaccount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_sint64(1, self.total)?;
        }
        if self.from != 0 {
            os.write_sint32(2, self.from)?;
        }
        if self.to != 0 {
            os.write_sint32(3, self.to)?;
        }
        if self.count_by_subaccount != 0 {
            os.write_sint64(4, self.count_by_subaccount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Paging {
        Paging::new()
    }

    fn default_instance() -> &'static Paging {
        static instance: ::protobuf::rt::LazyV2<Paging> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Paging::new)
    }
}

impl ::protobuf::Clear for Paging {
    fn clear(&mut self) {
        self.total = 0;
        self.from = 0;
        self.to = 0;
        self.count_by_subaccount = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Paging {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub order_side: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub include_inactive: bool,
    pub subaccount_total_orders: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersRequest {
    fn default() -> &'a StreamOrdersRequest {
        <StreamOrdersRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersRequest {
    pub fn new() -> StreamOrdersRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string order_side = 2;


    pub fn get_order_side(&self) -> &str {
        &self.order_side
    }
    pub fn clear_order_side(&mut self) {
        self.order_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_side(&mut self, v: ::std::string::String) {
        self.order_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_side(&mut self) -> &mut ::std::string::String {
        &mut self.order_side
    }

    // Take field
    pub fn take_order_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_side, ::std::string::String::new())
    }

    // string subaccount_id = 3;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 4;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 5;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 6;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 7;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 8;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // bool include_inactive = 9;


    pub fn get_include_inactive(&self) -> bool {
        self.include_inactive
    }
    pub fn clear_include_inactive(&mut self) {
        self.include_inactive = false;
    }

    // Param is passed by value, moved
    pub fn set_include_inactive(&mut self, v: bool) {
        self.include_inactive = v;
    }

    // bool subaccount_total_orders = 10;


    pub fn get_subaccount_total_orders(&self) -> bool {
        self.subaccount_total_orders
    }
    pub fn clear_subaccount_total_orders(&mut self) {
        self.subaccount_total_orders = false;
    }

    // Param is passed by value, moved
    pub fn set_subaccount_total_orders(&mut self, v: bool) {
        self.subaccount_total_orders = v;
    }
}

impl ::protobuf::Message for StreamOrdersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_inactive = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subaccount_total_orders = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.order_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_side);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.include_inactive != false {
            my_size += 2;
        }
        if self.subaccount_total_orders != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.order_side.is_empty() {
            os.write_string(2, &self.order_side)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(3, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(4, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(5, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(6, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(7, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(8, &v)?;
        };
        if self.include_inactive != false {
            os.write_bool(9, self.include_inactive)?;
        }
        if self.subaccount_total_orders != false {
            os.write_bool(10, self.subaccount_total_orders)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersRequest {
        StreamOrdersRequest::new()
    }

    fn default_instance() -> &'static StreamOrdersRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrdersRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.order_side.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.include_inactive = false;
        self.subaccount_total_orders = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersResponse {
    // message fields
    pub order: ::protobuf::SingularPtrField<SpotLimitOrder>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersResponse {
    fn default() -> &'a StreamOrdersResponse {
        <StreamOrdersResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersResponse {
    pub fn new() -> StreamOrdersResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotLimitOrder order = 1;


    pub fn get_order(&self) -> &SpotLimitOrder {
        self.order.as_ref().unwrap_or_else(|| <SpotLimitOrder as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: SpotLimitOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut SpotLimitOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> SpotLimitOrder {
        self.order.take().unwrap_or_else(|| SpotLimitOrder::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersResponse {
        StreamOrdersResponse::new()
    }

    fn default_instance() -> &'static StreamOrdersResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrdersResponse {
    fn clear(&mut self) {
        self.order.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    pub direction: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub subaccount_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradesRequest {
    fn default() -> &'a TradesRequest {
        <TradesRequest as ::protobuf::Message>::default_instance()
    }
}

impl TradesRequest {
    pub fn new() -> TradesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_side = 2;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }

    // string direction = 3;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 9;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string subaccount_ids = 10;


    pub fn get_subaccount_ids(&self) -> &[::std::string::String] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string execution_types = 11;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TradesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_side);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.direction);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(2, &self.execution_side)?;
        }
        if !self.direction.is_empty() {
            os.write_string(3, &self.direction)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.subaccount_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.execution_types {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradesRequest {
        TradesRequest::new()
    }

    fn default_instance() -> &'static TradesRequest {
        static instance: ::protobuf::rt::LazyV2<TradesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradesRequest::new)
    }
}

impl ::protobuf::Clear for TradesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.execution_side.clear();
        self.direction.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.subaccount_ids.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TradesResponse {
    // message fields
    pub trades: ::protobuf::RepeatedField<SpotTrade>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TradesResponse {
    fn default() -> &'a TradesResponse {
        <TradesResponse as ::protobuf::Message>::default_instance()
    }
}

impl TradesResponse {
    pub fn new() -> TradesResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1;


    pub fn get_trades(&self) -> &[SpotTrade] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<SpotTrade>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<SpotTrade> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<SpotTrade> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }

    // .injective_spot_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for TradesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trades {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TradesResponse {
        TradesResponse::new()
    }

    fn default_instance() -> &'static TradesResponse {
        static instance: ::protobuf::rt::LazyV2<TradesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TradesResponse::new)
    }
}

impl ::protobuf::Clear for TradesResponse {
    fn clear(&mut self) {
        self.trades.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TradesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotTrade {
    // message fields
    pub order_hash: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub trade_execution_type: ::std::string::String,
    pub trade_direction: ::std::string::String,
    pub price: ::protobuf::SingularPtrField<PriceLevel>,
    pub fee: ::std::string::String,
    pub executed_at: i64,
    pub fee_recipient: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotTrade {
    fn default() -> &'a SpotTrade {
        <SpotTrade as ::protobuf::Message>::default_instance()
    }
}

impl SpotTrade {
    pub fn new() -> SpotTrade {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string subaccount_id = 2;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 3;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string trade_execution_type = 4;


    pub fn get_trade_execution_type(&self) -> &str {
        &self.trade_execution_type
    }
    pub fn clear_trade_execution_type(&mut self) {
        self.trade_execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_execution_type(&mut self, v: ::std::string::String) {
        self.trade_execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.trade_execution_type
    }

    // Take field
    pub fn take_trade_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_execution_type, ::std::string::String::new())
    }

    // string trade_direction = 5;


    pub fn get_trade_direction(&self) -> &str {
        &self.trade_direction
    }
    pub fn clear_trade_direction(&mut self) {
        self.trade_direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_direction(&mut self, v: ::std::string::String) {
        self.trade_direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_direction(&mut self) -> &mut ::std::string::String {
        &mut self.trade_direction
    }

    // Take field
    pub fn take_trade_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_direction, ::std::string::String::new())
    }

    // .injective_spot_exchange_rpc.PriceLevel price = 6;


    pub fn get_price(&self) -> &PriceLevel {
        self.price.as_ref().unwrap_or_else(|| <PriceLevel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: PriceLevel) {
        self.price = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut PriceLevel {
        if self.price.is_none() {
            self.price.set_default();
        }
        self.price.as_mut().unwrap()
    }

    // Take field
    pub fn take_price(&mut self) -> PriceLevel {
        self.price.take().unwrap_or_else(|| PriceLevel::new())
    }

    // string fee = 7;


    pub fn get_fee(&self) -> &str {
        &self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: ::std::string::String) {
        self.fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fee
    }

    // Take field
    pub fn take_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee, ::std::string::String::new())
    }

    // sint64 executed_at = 8;


    pub fn get_executed_at(&self) -> i64 {
        self.executed_at
    }
    pub fn clear_executed_at(&mut self) {
        self.executed_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_executed_at(&mut self, v: i64) {
        self.executed_at = v;
    }

    // string fee_recipient = 9;


    pub fn get_fee_recipient(&self) -> &str {
        &self.fee_recipient
    }
    pub fn clear_fee_recipient(&mut self) {
        self.fee_recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_fee_recipient(&mut self, v: ::std::string::String) {
        self.fee_recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.fee_recipient
    }

    // Take field
    pub fn take_fee_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fee_recipient, ::std::string::String::new())
    }

    // string trade_id = 10;


    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }
    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    // string execution_side = 11;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotTrade {
    fn is_initialized(&self) -> bool {
        for v in &self.price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_execution_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_direction)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.price)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.executed_at = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fee_recipient)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trade_id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.market_id);
        }
        if !self.trade_execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trade_execution_type);
        }
        if !self.trade_direction.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.trade_direction);
        }
        if let Some(ref v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.fee.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.fee);
        }
        if self.executed_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.executed_at);
        }
        if !self.fee_recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.fee_recipient);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.trade_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.execution_side);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(2, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(3, &self.market_id)?;
        }
        if !self.trade_execution_type.is_empty() {
            os.write_string(4, &self.trade_execution_type)?;
        }
        if !self.trade_direction.is_empty() {
            os.write_string(5, &self.trade_direction)?;
        }
        if let Some(ref v) = self.price.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.fee.is_empty() {
            os.write_string(7, &self.fee)?;
        }
        if self.executed_at != 0 {
            os.write_sint64(8, self.executed_at)?;
        }
        if !self.fee_recipient.is_empty() {
            os.write_string(9, &self.fee_recipient)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(10, &self.trade_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(11, &self.execution_side)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotTrade {
        SpotTrade::new()
    }

    fn default_instance() -> &'static SpotTrade {
        static instance: ::protobuf::rt::LazyV2<SpotTrade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotTrade::new)
    }
}

impl ::protobuf::Clear for SpotTrade {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.subaccount_id.clear();
        self.market_id.clear();
        self.trade_execution_type.clear();
        self.trade_direction.clear();
        self.price.clear();
        self.fee.clear();
        self.executed_at = 0;
        self.fee_recipient.clear();
        self.trade_id.clear();
        self.execution_side.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotTrade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTradesRequest {
    // message fields
    pub market_id: ::std::string::String,
    pub execution_side: ::std::string::String,
    pub direction: ::std::string::String,
    pub subaccount_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub subaccount_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTradesRequest {
    fn default() -> &'a StreamTradesRequest {
        <StreamTradesRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamTradesRequest {
    pub fn new() -> StreamTradesRequest {
        ::std::default::Default::default()
    }

    // string market_id = 1;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_side = 2;


    pub fn get_execution_side(&self) -> &str {
        &self.execution_side
    }
    pub fn clear_execution_side(&mut self) {
        self.execution_side.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_side(&mut self, v: ::std::string::String) {
        self.execution_side = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_side(&mut self) -> &mut ::std::string::String {
        &mut self.execution_side
    }

    // Take field
    pub fn take_execution_side(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_side, ::std::string::String::new())
    }

    // string direction = 3;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // repeated string market_ids = 9;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string subaccount_ids = 10;


    pub fn get_subaccount_ids(&self) -> &[::std::string::String] {
        &self.subaccount_ids
    }
    pub fn clear_subaccount_ids(&mut self) {
        self.subaccount_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subaccount_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subaccount_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subaccount_ids
    }

    // Take field
    pub fn take_subaccount_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subaccount_ids, ::protobuf::RepeatedField::new())
    }

    // repeated string execution_types = 11;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamTradesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_side)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subaccount_ids)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.market_id);
        }
        if !self.execution_side.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.execution_side);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.direction);
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.subaccount_ids {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.market_id.is_empty() {
            os.write_string(1, &self.market_id)?;
        }
        if !self.execution_side.is_empty() {
            os.write_string(2, &self.execution_side)?;
        }
        if !self.direction.is_empty() {
            os.write_string(3, &self.direction)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        for v in &self.market_ids {
            os.write_string(9, &v)?;
        };
        for v in &self.subaccount_ids {
            os.write_string(10, &v)?;
        };
        for v in &self.execution_types {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTradesRequest {
        StreamTradesRequest::new()
    }

    fn default_instance() -> &'static StreamTradesRequest {
        static instance: ::protobuf::rt::LazyV2<StreamTradesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTradesRequest::new)
    }
}

impl ::protobuf::Clear for StreamTradesRequest {
    fn clear(&mut self) {
        self.market_id.clear();
        self.execution_side.clear();
        self.direction.clear();
        self.subaccount_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.market_ids.clear();
        self.subaccount_ids.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTradesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamTradesResponse {
    // message fields
    pub trade: ::protobuf::SingularPtrField<SpotTrade>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamTradesResponse {
    fn default() -> &'a StreamTradesResponse {
        <StreamTradesResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamTradesResponse {
    pub fn new() -> StreamTradesResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotTrade trade = 1;


    pub fn get_trade(&self) -> &SpotTrade {
        self.trade.as_ref().unwrap_or_else(|| <SpotTrade as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trade(&mut self) {
        self.trade.clear();
    }

    pub fn has_trade(&self) -> bool {
        self.trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade(&mut self, v: SpotTrade) {
        self.trade = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade(&mut self) -> &mut SpotTrade {
        if self.trade.is_none() {
            self.trade.set_default();
        }
        self.trade.as_mut().unwrap()
    }

    // Take field
    pub fn take_trade(&mut self) -> SpotTrade {
        self.trade.take().unwrap_or_else(|| SpotTrade::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamTradesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trade {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trade)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trade.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamTradesResponse {
        StreamTradesResponse::new()
    }

    fn default_instance() -> &'static StreamTradesResponse {
        static instance: ::protobuf::rt::LazyV2<StreamTradesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamTradesResponse::new)
    }
}

impl ::protobuf::Clear for StreamTradesResponse {
    fn clear(&mut self) {
        self.trade.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamTradesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrdersListRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrdersListRequest {
    fn default() -> &'a SubaccountOrdersListRequest {
        <SubaccountOrdersListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrdersListRequest {
    pub fn new() -> SubaccountOrdersListRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for SubaccountOrdersListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrdersListRequest {
        SubaccountOrdersListRequest::new()
    }

    fn default_instance() -> &'static SubaccountOrdersListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrdersListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrdersListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountOrdersListRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrdersListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountOrdersListResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<SpotLimitOrder>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountOrdersListResponse {
    fn default() -> &'a SubaccountOrdersListResponse {
        <SubaccountOrdersListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountOrdersListResponse {
    pub fn new() -> SubaccountOrdersListResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotLimitOrder orders = 1;


    pub fn get_orders(&self) -> &[SpotLimitOrder] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<SpotLimitOrder>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<SpotLimitOrder> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<SpotLimitOrder> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_spot_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for SubaccountOrdersListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountOrdersListResponse {
        SubaccountOrdersListResponse::new()
    }

    fn default_instance() -> &'static SubaccountOrdersListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountOrdersListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountOrdersListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountOrdersListResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountOrdersListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountTradesListRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub execution_type: ::std::string::String,
    pub direction: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountTradesListRequest {
    fn default() -> &'a SubaccountTradesListRequest {
        <SubaccountTradesListRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountTradesListRequest {
    pub fn new() -> SubaccountTradesListRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // string execution_type = 3;


    pub fn get_execution_type(&self) -> &str {
        &self.execution_type
    }
    pub fn clear_execution_type(&mut self) {
        self.execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_type(&mut self, v: ::std::string::String) {
        self.execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.execution_type
    }

    // Take field
    pub fn take_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_type, ::std::string::String::new())
    }

    // string direction = 4;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // uint64 skip = 5;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for SubaccountTradesListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if !self.execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.execution_type);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(5, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if !self.execution_type.is_empty() {
            os.write_string(3, &self.execution_type)?;
        }
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if self.skip != 0 {
            os.write_uint64(5, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(6, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountTradesListRequest {
        SubaccountTradesListRequest::new()
    }

    fn default_instance() -> &'static SubaccountTradesListRequest {
        static instance: ::protobuf::rt::LazyV2<SubaccountTradesListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountTradesListRequest::new)
    }
}

impl ::protobuf::Clear for SubaccountTradesListRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.execution_type.clear();
        self.direction.clear();
        self.skip = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountTradesListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubaccountTradesListResponse {
    // message fields
    pub trades: ::protobuf::RepeatedField<SpotTrade>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubaccountTradesListResponse {
    fn default() -> &'a SubaccountTradesListResponse {
        <SubaccountTradesListResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubaccountTradesListResponse {
    pub fn new() -> SubaccountTradesListResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotTrade trades = 1;


    pub fn get_trades(&self) -> &[SpotTrade] {
        &self.trades
    }
    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<SpotTrade>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<SpotTrade> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<SpotTrade> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubaccountTradesListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trades {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubaccountTradesListResponse {
        SubaccountTradesListResponse::new()
    }

    fn default_instance() -> &'static SubaccountTradesListResponse {
        static instance: ::protobuf::rt::LazyV2<SubaccountTradesListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubaccountTradesListResponse::new)
    }
}

impl ::protobuf::Clear for SubaccountTradesListResponse {
    fn clear(&mut self) {
        self.trades.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SubaccountTradesListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersHistoryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub skip: u64,
    pub limit: i32,
    pub order_types: ::protobuf::RepeatedField<::std::string::String>,
    pub direction: ::std::string::String,
    pub start_time: i64,
    pub end_time: i64,
    pub state: ::std::string::String,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    pub market_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersHistoryRequest {
    fn default() -> &'a OrdersHistoryRequest {
        <OrdersHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl OrdersHistoryRequest {
    pub fn new() -> OrdersHistoryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // uint64 skip = 3;


    pub fn get_skip(&self) -> u64 {
        self.skip
    }
    pub fn clear_skip(&mut self) {
        self.skip = 0;
    }

    // Param is passed by value, moved
    pub fn set_skip(&mut self, v: u64) {
        self.skip = v;
    }

    // sint32 limit = 4;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // repeated string order_types = 5;


    pub fn get_order_types(&self) -> &[::std::string::String] {
        &self.order_types
    }
    pub fn clear_order_types(&mut self) {
        self.order_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_types
    }

    // Take field
    pub fn take_order_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_types, ::protobuf::RepeatedField::new())
    }

    // string direction = 6;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // sint64 start_time = 7;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // sint64 end_time = 8;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // string state = 9;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // repeated string execution_types = 10;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }

    // repeated string market_ids = 11;


    pub fn get_market_ids(&self) -> &[::std::string::String] {
        &self.market_ids
    }
    pub fn clear_market_ids(&mut self) {
        self.market_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.market_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_market_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.market_ids
    }

    // Take field
    pub fn take_market_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.market_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OrdersHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.skip = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.limit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_types)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.start_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.end_time = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.market_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.skip != 0 {
            my_size += ::protobuf::rt::value_size(3, self.skip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, self.limit);
        }
        for value in &self.order_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.direction);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, self.start_time);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, self.end_time);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.state);
        }
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.market_ids {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.skip != 0 {
            os.write_uint64(3, self.skip)?;
        }
        if self.limit != 0 {
            os.write_sint32(4, self.limit)?;
        }
        for v in &self.order_types {
            os.write_string(5, &v)?;
        };
        if !self.direction.is_empty() {
            os.write_string(6, &self.direction)?;
        }
        if self.start_time != 0 {
            os.write_sint64(7, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_sint64(8, self.end_time)?;
        }
        if !self.state.is_empty() {
            os.write_string(9, &self.state)?;
        }
        for v in &self.execution_types {
            os.write_string(10, &v)?;
        };
        for v in &self.market_ids {
            os.write_string(11, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersHistoryRequest {
        OrdersHistoryRequest::new()
    }

    fn default_instance() -> &'static OrdersHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<OrdersHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersHistoryRequest::new)
    }
}

impl ::protobuf::Clear for OrdersHistoryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.skip = 0;
        self.limit = 0;
        self.order_types.clear();
        self.direction.clear();
        self.start_time = 0;
        self.end_time = 0;
        self.state.clear();
        self.execution_types.clear();
        self.market_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OrdersHistoryResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<SpotOrderHistory>,
    pub paging: ::protobuf::SingularPtrField<Paging>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OrdersHistoryResponse {
    fn default() -> &'a OrdersHistoryResponse {
        <OrdersHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl OrdersHistoryResponse {
    pub fn new() -> OrdersHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .injective_spot_exchange_rpc.SpotOrderHistory orders = 1;


    pub fn get_orders(&self) -> &[SpotOrderHistory] {
        &self.orders
    }
    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<SpotOrderHistory>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<SpotOrderHistory> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<SpotOrderHistory> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    // .injective_spot_exchange_rpc.Paging paging = 2;


    pub fn get_paging(&self) -> &Paging {
        self.paging.as_ref().unwrap_or_else(|| <Paging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paging(&mut self) {
        self.paging.clear();
    }

    pub fn has_paging(&self) -> bool {
        self.paging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paging(&mut self, v: Paging) {
        self.paging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paging(&mut self) -> &mut Paging {
        if self.paging.is_none() {
            self.paging.set_default();
        }
        self.paging.as_mut().unwrap()
    }

    // Take field
    pub fn take_paging(&mut self) -> Paging {
        self.paging.take().unwrap_or_else(|| Paging::new())
    }
}

impl ::protobuf::Message for OrdersHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paging {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paging)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paging.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paging.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrdersHistoryResponse {
        OrdersHistoryResponse::new()
    }

    fn default_instance() -> &'static OrdersHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<OrdersHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OrdersHistoryResponse::new)
    }
}

impl ::protobuf::Clear for OrdersHistoryResponse {
    fn clear(&mut self) {
        self.orders.clear();
        self.paging.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OrdersHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpotOrderHistory {
    // message fields
    pub order_hash: ::std::string::String,
    pub market_id: ::std::string::String,
    pub is_active: bool,
    pub subaccount_id: ::std::string::String,
    pub execution_type: ::std::string::String,
    pub order_type: ::std::string::String,
    pub price: ::std::string::String,
    pub trigger_price: ::std::string::String,
    pub quantity: ::std::string::String,
    pub filled_quantity: ::std::string::String,
    pub state: ::std::string::String,
    pub created_at: i64,
    pub updated_at: i64,
    pub direction: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpotOrderHistory {
    fn default() -> &'a SpotOrderHistory {
        <SpotOrderHistory as ::protobuf::Message>::default_instance()
    }
}

impl SpotOrderHistory {
    pub fn new() -> SpotOrderHistory {
        ::std::default::Default::default()
    }

    // string order_hash = 1;


    pub fn get_order_hash(&self) -> &str {
        &self.order_hash
    }
    pub fn clear_order_hash(&mut self) {
        self.order_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_hash(&mut self, v: ::std::string::String) {
        self.order_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_hash(&mut self) -> &mut ::std::string::String {
        &mut self.order_hash
    }

    // Take field
    pub fn take_order_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_hash, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // bool is_active = 3;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }

    // string subaccount_id = 4;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string execution_type = 5;


    pub fn get_execution_type(&self) -> &str {
        &self.execution_type
    }
    pub fn clear_execution_type(&mut self) {
        self.execution_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_type(&mut self, v: ::std::string::String) {
        self.execution_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_type(&mut self) -> &mut ::std::string::String {
        &mut self.execution_type
    }

    // Take field
    pub fn take_execution_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_type, ::std::string::String::new())
    }

    // string order_type = 6;


    pub fn get_order_type(&self) -> &str {
        &self.order_type
    }
    pub fn clear_order_type(&mut self) {
        self.order_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: ::std::string::String) {
        self.order_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_type(&mut self) -> &mut ::std::string::String {
        &mut self.order_type
    }

    // Take field
    pub fn take_order_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_type, ::std::string::String::new())
    }

    // string price = 7;


    pub fn get_price(&self) -> &str {
        &self.price
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: ::std::string::String) {
        self.price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut ::std::string::String {
        &mut self.price
    }

    // Take field
    pub fn take_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.price, ::std::string::String::new())
    }

    // string trigger_price = 8;


    pub fn get_trigger_price(&self) -> &str {
        &self.trigger_price
    }
    pub fn clear_trigger_price(&mut self) {
        self.trigger_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_trigger_price(&mut self, v: ::std::string::String) {
        self.trigger_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_price(&mut self) -> &mut ::std::string::String {
        &mut self.trigger_price
    }

    // Take field
    pub fn take_trigger_price(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trigger_price, ::std::string::String::new())
    }

    // string quantity = 9;


    pub fn get_quantity(&self) -> &str {
        &self.quantity
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: ::std::string::String) {
        self.quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.quantity
    }

    // Take field
    pub fn take_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quantity, ::std::string::String::new())
    }

    // string filled_quantity = 10;


    pub fn get_filled_quantity(&self) -> &str {
        &self.filled_quantity
    }
    pub fn clear_filled_quantity(&mut self) {
        self.filled_quantity.clear();
    }

    // Param is passed by value, moved
    pub fn set_filled_quantity(&mut self, v: ::std::string::String) {
        self.filled_quantity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filled_quantity(&mut self) -> &mut ::std::string::String {
        &mut self.filled_quantity
    }

    // Take field
    pub fn take_filled_quantity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filled_quantity, ::std::string::String::new())
    }

    // string state = 11;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // sint64 created_at = 12;


    pub fn get_created_at(&self) -> i64 {
        self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: i64) {
        self.created_at = v;
    }

    // sint64 updated_at = 13;


    pub fn get_updated_at(&self) -> i64 {
        self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: i64) {
        self.updated_at = v;
    }

    // string direction = 14;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpotOrderHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.price)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.trigger_price)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quantity)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filled_quantity)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.created_at = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.updated_at = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.order_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.order_hash);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        if self.is_active != false {
            my_size += 2;
        }
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subaccount_id);
        }
        if !self.execution_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.execution_type);
        }
        if !self.order_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_type);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.price);
        }
        if !self.trigger_price.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.trigger_price);
        }
        if !self.quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.quantity);
        }
        if !self.filled_quantity.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.filled_quantity);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.state);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(12, self.created_at);
        }
        if self.updated_at != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(13, self.updated_at);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.order_hash.is_empty() {
            os.write_string(1, &self.order_hash)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        if self.is_active != false {
            os.write_bool(3, self.is_active)?;
        }
        if !self.subaccount_id.is_empty() {
            os.write_string(4, &self.subaccount_id)?;
        }
        if !self.execution_type.is_empty() {
            os.write_string(5, &self.execution_type)?;
        }
        if !self.order_type.is_empty() {
            os.write_string(6, &self.order_type)?;
        }
        if !self.price.is_empty() {
            os.write_string(7, &self.price)?;
        }
        if !self.trigger_price.is_empty() {
            os.write_string(8, &self.trigger_price)?;
        }
        if !self.quantity.is_empty() {
            os.write_string(9, &self.quantity)?;
        }
        if !self.filled_quantity.is_empty() {
            os.write_string(10, &self.filled_quantity)?;
        }
        if !self.state.is_empty() {
            os.write_string(11, &self.state)?;
        }
        if self.created_at != 0 {
            os.write_sint64(12, self.created_at)?;
        }
        if self.updated_at != 0 {
            os.write_sint64(13, self.updated_at)?;
        }
        if !self.direction.is_empty() {
            os.write_string(14, &self.direction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpotOrderHistory {
        SpotOrderHistory::new()
    }

    fn default_instance() -> &'static SpotOrderHistory {
        static instance: ::protobuf::rt::LazyV2<SpotOrderHistory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpotOrderHistory::new)
    }
}

impl ::protobuf::Clear for SpotOrderHistory {
    fn clear(&mut self) {
        self.order_hash.clear();
        self.market_id.clear();
        self.is_active = false;
        self.subaccount_id.clear();
        self.execution_type.clear();
        self.order_type.clear();
        self.price.clear();
        self.trigger_price.clear();
        self.quantity.clear();
        self.filled_quantity.clear();
        self.state.clear();
        self.created_at = 0;
        self.updated_at = 0;
        self.direction.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SpotOrderHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersHistoryRequest {
    // message fields
    pub subaccount_id: ::std::string::String,
    pub market_id: ::std::string::String,
    pub order_types: ::protobuf::RepeatedField<::std::string::String>,
    pub direction: ::std::string::String,
    pub state: ::std::string::String,
    pub execution_types: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersHistoryRequest {
    fn default() -> &'a StreamOrdersHistoryRequest {
        <StreamOrdersHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersHistoryRequest {
    pub fn new() -> StreamOrdersHistoryRequest {
        ::std::default::Default::default()
    }

    // string subaccount_id = 1;


    pub fn get_subaccount_id(&self) -> &str {
        &self.subaccount_id
    }
    pub fn clear_subaccount_id(&mut self) {
        self.subaccount_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_subaccount_id(&mut self, v: ::std::string::String) {
        self.subaccount_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subaccount_id(&mut self) -> &mut ::std::string::String {
        &mut self.subaccount_id
    }

    // Take field
    pub fn take_subaccount_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subaccount_id, ::std::string::String::new())
    }

    // string market_id = 2;


    pub fn get_market_id(&self) -> &str {
        &self.market_id
    }
    pub fn clear_market_id(&mut self) {
        self.market_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_market_id(&mut self, v: ::std::string::String) {
        self.market_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market_id(&mut self) -> &mut ::std::string::String {
        &mut self.market_id
    }

    // Take field
    pub fn take_market_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market_id, ::std::string::String::new())
    }

    // repeated string order_types = 3;


    pub fn get_order_types(&self) -> &[::std::string::String] {
        &self.order_types
    }
    pub fn clear_order_types(&mut self) {
        self.order_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.order_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.order_types
    }

    // Take field
    pub fn take_order_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.order_types, ::protobuf::RepeatedField::new())
    }

    // string direction = 4;


    pub fn get_direction(&self) -> &str {
        &self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        &mut self.direction
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.direction, ::std::string::String::new())
    }

    // string state = 5;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // repeated string execution_types = 6;


    pub fn get_execution_types(&self) -> &[::std::string::String] {
        &self.execution_types
    }
    pub fn clear_execution_types(&mut self) {
        self.execution_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.execution_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.execution_types
    }

    // Take field
    pub fn take_execution_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.execution_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamOrdersHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subaccount_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.market_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.order_types)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.direction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.execution_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subaccount_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subaccount_id);
        }
        if !self.market_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.market_id);
        }
        for value in &self.order_types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.direction);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.state);
        }
        for value in &self.execution_types {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subaccount_id.is_empty() {
            os.write_string(1, &self.subaccount_id)?;
        }
        if !self.market_id.is_empty() {
            os.write_string(2, &self.market_id)?;
        }
        for v in &self.order_types {
            os.write_string(3, &v)?;
        };
        if !self.direction.is_empty() {
            os.write_string(4, &self.direction)?;
        }
        if !self.state.is_empty() {
            os.write_string(5, &self.state)?;
        }
        for v in &self.execution_types {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersHistoryRequest {
        StreamOrdersHistoryRequest::new()
    }

    fn default_instance() -> &'static StreamOrdersHistoryRequest {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersHistoryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersHistoryRequest::new)
    }
}

impl ::protobuf::Clear for StreamOrdersHistoryRequest {
    fn clear(&mut self) {
        self.subaccount_id.clear();
        self.market_id.clear();
        self.order_types.clear();
        self.direction.clear();
        self.state.clear();
        self.execution_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamOrdersHistoryResponse {
    // message fields
    pub order: ::protobuf::SingularPtrField<SpotOrderHistory>,
    pub operation_type: ::std::string::String,
    pub timestamp: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamOrdersHistoryResponse {
    fn default() -> &'a StreamOrdersHistoryResponse {
        <StreamOrdersHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamOrdersHistoryResponse {
    pub fn new() -> StreamOrdersHistoryResponse {
        ::std::default::Default::default()
    }

    // .injective_spot_exchange_rpc.SpotOrderHistory order = 1;


    pub fn get_order(&self) -> &SpotOrderHistory {
        self.order.as_ref().unwrap_or_else(|| <SpotOrderHistory as ::protobuf::Message>::default_instance())
    }
    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: SpotOrderHistory) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut SpotOrderHistory {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> SpotOrderHistory {
        self.order.take().unwrap_or_else(|| SpotOrderHistory::new())
    }

    // string operation_type = 2;


    pub fn get_operation_type(&self) -> &str {
        &self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: ::std::string::String) {
        self.operation_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_type(&mut self) -> &mut ::std::string::String {
        &mut self.operation_type
    }

    // Take field
    pub fn take_operation_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_type, ::std::string::String::new())
    }

    // sint64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for StreamOrdersHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.operation_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.operation_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.operation_type.is_empty() {
            os.write_string(2, &self.operation_type)?;
        }
        if self.timestamp != 0 {
            os.write_sint64(3, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamOrdersHistoryResponse {
        StreamOrdersHistoryResponse::new()
    }

    fn default_instance() -> &'static StreamOrdersHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<StreamOrdersHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamOrdersHistoryResponse::new)
    }
}

impl ::protobuf::Clear for StreamOrdersHistoryResponse {
    fn clear(&mut self) {
        self.order.clear();
        self.operation_type.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamOrdersHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
