// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmwasm/wasm/v1/proposal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fproposal_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fproposal_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "cosmwasm/wasm/v1/types.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmwasm_2fwasm_2fv1_2fproposal_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
namespace cosmwasm {
namespace wasm {
namespace v1 {
class AccessConfigUpdate;
struct AccessConfigUpdateDefaultTypeInternal;
extern AccessConfigUpdateDefaultTypeInternal _AccessConfigUpdate_default_instance_;
class ClearAdminProposal;
struct ClearAdminProposalDefaultTypeInternal;
extern ClearAdminProposalDefaultTypeInternal _ClearAdminProposal_default_instance_;
class ExecuteContractProposal;
struct ExecuteContractProposalDefaultTypeInternal;
extern ExecuteContractProposalDefaultTypeInternal _ExecuteContractProposal_default_instance_;
class InstantiateContract2Proposal;
struct InstantiateContract2ProposalDefaultTypeInternal;
extern InstantiateContract2ProposalDefaultTypeInternal _InstantiateContract2Proposal_default_instance_;
class InstantiateContractProposal;
struct InstantiateContractProposalDefaultTypeInternal;
extern InstantiateContractProposalDefaultTypeInternal _InstantiateContractProposal_default_instance_;
class MigrateContractProposal;
struct MigrateContractProposalDefaultTypeInternal;
extern MigrateContractProposalDefaultTypeInternal _MigrateContractProposal_default_instance_;
class PinCodesProposal;
struct PinCodesProposalDefaultTypeInternal;
extern PinCodesProposalDefaultTypeInternal _PinCodesProposal_default_instance_;
class StoreAndInstantiateContractProposal;
struct StoreAndInstantiateContractProposalDefaultTypeInternal;
extern StoreAndInstantiateContractProposalDefaultTypeInternal _StoreAndInstantiateContractProposal_default_instance_;
class StoreCodeProposal;
struct StoreCodeProposalDefaultTypeInternal;
extern StoreCodeProposalDefaultTypeInternal _StoreCodeProposal_default_instance_;
class SudoContractProposal;
struct SudoContractProposalDefaultTypeInternal;
extern SudoContractProposalDefaultTypeInternal _SudoContractProposal_default_instance_;
class UnpinCodesProposal;
struct UnpinCodesProposalDefaultTypeInternal;
extern UnpinCodesProposalDefaultTypeInternal _UnpinCodesProposal_default_instance_;
class UpdateAdminProposal;
struct UpdateAdminProposalDefaultTypeInternal;
extern UpdateAdminProposalDefaultTypeInternal _UpdateAdminProposal_default_instance_;
class UpdateInstantiateConfigProposal;
struct UpdateInstantiateConfigProposalDefaultTypeInternal;
extern UpdateInstantiateConfigProposalDefaultTypeInternal _UpdateInstantiateConfigProposal_default_instance_;
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmwasm::wasm::v1::AccessConfigUpdate* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfigUpdate>(Arena*);
template <>
::cosmwasm::wasm::v1::ClearAdminProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ClearAdminProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::ExecuteContractProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ExecuteContractProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::InstantiateContract2Proposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::InstantiateContract2Proposal>(Arena*);
template <>
::cosmwasm::wasm::v1::InstantiateContractProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::InstantiateContractProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::MigrateContractProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::MigrateContractProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::PinCodesProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::PinCodesProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::StoreAndInstantiateContractProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::StoreAndInstantiateContractProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::StoreCodeProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::StoreCodeProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::SudoContractProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::SudoContractProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::UnpinCodesProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::UnpinCodesProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::UpdateAdminProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::UpdateAdminProposal>(Arena*);
template <>
::cosmwasm::wasm::v1::UpdateInstantiateConfigProposal* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::UpdateInstantiateConfigProposal>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmwasm {
namespace wasm {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class StoreCodeProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.StoreCodeProposal) */ {
 public:
  inline StoreCodeProposal() : StoreCodeProposal(nullptr) {}
  ~StoreCodeProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StoreCodeProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreCodeProposal(const StoreCodeProposal& from);
  StoreCodeProposal(StoreCodeProposal&& from) noexcept
    : StoreCodeProposal() {
    *this = ::std::move(from);
  }

  inline StoreCodeProposal& operator=(const StoreCodeProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreCodeProposal& operator=(StoreCodeProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreCodeProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreCodeProposal* internal_default_instance() {
    return reinterpret_cast<const StoreCodeProposal*>(
               &_StoreCodeProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StoreCodeProposal& a, StoreCodeProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreCodeProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreCodeProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreCodeProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreCodeProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreCodeProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreCodeProposal& from) {
    StoreCodeProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreCodeProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.StoreCodeProposal";
  }
  protected:
  explicit StoreCodeProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRunAsFieldNumber = 3,
    kWasmByteCodeFieldNumber = 4,
    kSourceFieldNumber = 9,
    kBuilderFieldNumber = 10,
    kCodeHashFieldNumber = 11,
    kInstantiatePermissionFieldNumber = 7,
    kUnpinCodeFieldNumber = 8,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string run_as = 3 [json_name = "runAs"];
  void clear_run_as() ;
  const std::string& run_as() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_as(Arg_&& arg, Args_... args);
  std::string* mutable_run_as();
  PROTOBUF_NODISCARD std::string* release_run_as();
  void set_allocated_run_as(std::string* ptr);

  private:
  const std::string& _internal_run_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_as(
      const std::string& value);
  std::string* _internal_mutable_run_as();

  public:
  // bytes wasm_byte_code = 4 [json_name = "wasmByteCode", (.gogoproto.customname) = "WASMByteCode"];
  void clear_wasm_byte_code() ;
  const std::string& wasm_byte_code() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wasm_byte_code(Arg_&& arg, Args_... args);
  std::string* mutable_wasm_byte_code();
  PROTOBUF_NODISCARD std::string* release_wasm_byte_code();
  void set_allocated_wasm_byte_code(std::string* ptr);

  private:
  const std::string& _internal_wasm_byte_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wasm_byte_code(
      const std::string& value);
  std::string* _internal_mutable_wasm_byte_code();

  public:
  // string source = 9 [json_name = "source"];
  void clear_source() ;
  const std::string& source() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // string builder = 10 [json_name = "builder"];
  void clear_builder() ;
  const std::string& builder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_builder(Arg_&& arg, Args_... args);
  std::string* mutable_builder();
  PROTOBUF_NODISCARD std::string* release_builder();
  void set_allocated_builder(std::string* ptr);

  private:
  const std::string& _internal_builder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_builder(
      const std::string& value);
  std::string* _internal_mutable_builder();

  public:
  // bytes code_hash = 11 [json_name = "codeHash"];
  void clear_code_hash() ;
  const std::string& code_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_hash(Arg_&& arg, Args_... args);
  std::string* mutable_code_hash();
  PROTOBUF_NODISCARD std::string* release_code_hash();
  void set_allocated_code_hash(std::string* ptr);

  private:
  const std::string& _internal_code_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_hash(
      const std::string& value);
  std::string* _internal_mutable_code_hash();

  public:
  // .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 7 [json_name = "instantiatePermission"];
  bool has_instantiate_permission() const;
  void clear_instantiate_permission() ;
  const ::cosmwasm::wasm::v1::AccessConfig& instantiate_permission() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_instantiate_permission();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_instantiate_permission();
  void set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_instantiate_permission() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_instantiate_permission();
  public:
  void unsafe_arena_set_allocated_instantiate_permission(
      ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_instantiate_permission();
  // bool unpin_code = 8 [json_name = "unpinCode"];
  void clear_unpin_code() ;
  bool unpin_code() const;
  void set_unpin_code(bool value);

  private:
  bool _internal_unpin_code() const;
  void _internal_set_unpin_code(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.StoreCodeProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wasm_byte_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_hash_;
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission_;
    bool unpin_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class InstantiateContractProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.InstantiateContractProposal) */ {
 public:
  inline InstantiateContractProposal() : InstantiateContractProposal(nullptr) {}
  ~InstantiateContractProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstantiateContractProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstantiateContractProposal(const InstantiateContractProposal& from);
  InstantiateContractProposal(InstantiateContractProposal&& from) noexcept
    : InstantiateContractProposal() {
    *this = ::std::move(from);
  }

  inline InstantiateContractProposal& operator=(const InstantiateContractProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstantiateContractProposal& operator=(InstantiateContractProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstantiateContractProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstantiateContractProposal* internal_default_instance() {
    return reinterpret_cast<const InstantiateContractProposal*>(
               &_InstantiateContractProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InstantiateContractProposal& a, InstantiateContractProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(InstantiateContractProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstantiateContractProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstantiateContractProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstantiateContractProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstantiateContractProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstantiateContractProposal& from) {
    InstantiateContractProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstantiateContractProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.InstantiateContractProposal";
  }
  protected:
  explicit InstantiateContractProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 8,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRunAsFieldNumber = 3,
    kAdminFieldNumber = 4,
    kLabelFieldNumber = 6,
    kMsgFieldNumber = 7,
    kCodeIdFieldNumber = 5,
  };
  // repeated .cosmos.base.v1beta1.Coin funds = 8 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::cosmos::base::v1beta1::Coin* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_funds();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_funds(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_funds();
  public:
  const ::cosmos::base::v1beta1::Coin& funds(int index) const;
  ::cosmos::base::v1beta1::Coin* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      funds() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string run_as = 3 [json_name = "runAs"];
  void clear_run_as() ;
  const std::string& run_as() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_as(Arg_&& arg, Args_... args);
  std::string* mutable_run_as();
  PROTOBUF_NODISCARD std::string* release_run_as();
  void set_allocated_run_as(std::string* ptr);

  private:
  const std::string& _internal_run_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_as(
      const std::string& value);
  std::string* _internal_mutable_run_as();

  public:
  // string admin = 4 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string label = 6 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // bytes msg = 7 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.InstantiateContractProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::uint64_t code_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class InstantiateContract2Proposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.InstantiateContract2Proposal) */ {
 public:
  inline InstantiateContract2Proposal() : InstantiateContract2Proposal(nullptr) {}
  ~InstantiateContract2Proposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InstantiateContract2Proposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstantiateContract2Proposal(const InstantiateContract2Proposal& from);
  InstantiateContract2Proposal(InstantiateContract2Proposal&& from) noexcept
    : InstantiateContract2Proposal() {
    *this = ::std::move(from);
  }

  inline InstantiateContract2Proposal& operator=(const InstantiateContract2Proposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstantiateContract2Proposal& operator=(InstantiateContract2Proposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstantiateContract2Proposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstantiateContract2Proposal* internal_default_instance() {
    return reinterpret_cast<const InstantiateContract2Proposal*>(
               &_InstantiateContract2Proposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InstantiateContract2Proposal& a, InstantiateContract2Proposal& b) {
    a.Swap(&b);
  }
  inline void Swap(InstantiateContract2Proposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstantiateContract2Proposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstantiateContract2Proposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstantiateContract2Proposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstantiateContract2Proposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstantiateContract2Proposal& from) {
    InstantiateContract2Proposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstantiateContract2Proposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.InstantiateContract2Proposal";
  }
  protected:
  explicit InstantiateContract2Proposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 8,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRunAsFieldNumber = 3,
    kAdminFieldNumber = 4,
    kLabelFieldNumber = 6,
    kMsgFieldNumber = 7,
    kSaltFieldNumber = 9,
    kCodeIdFieldNumber = 5,
    kFixMsgFieldNumber = 10,
  };
  // repeated .cosmos.base.v1beta1.Coin funds = 8 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::cosmos::base::v1beta1::Coin* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_funds();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_funds(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_funds();
  public:
  const ::cosmos::base::v1beta1::Coin& funds(int index) const;
  ::cosmos::base::v1beta1::Coin* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      funds() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string run_as = 3 [json_name = "runAs"];
  void clear_run_as() ;
  const std::string& run_as() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_as(Arg_&& arg, Args_... args);
  std::string* mutable_run_as();
  PROTOBUF_NODISCARD std::string* release_run_as();
  void set_allocated_run_as(std::string* ptr);

  private:
  const std::string& _internal_run_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_as(
      const std::string& value);
  std::string* _internal_mutable_run_as();

  public:
  // string admin = 4 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string label = 6 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // bytes msg = 7 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bytes salt = 9 [json_name = "salt"];
  void clear_salt() ;
  const std::string& salt() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_salt(Arg_&& arg, Args_... args);
  std::string* mutable_salt();
  PROTOBUF_NODISCARD std::string* release_salt();
  void set_allocated_salt(std::string* ptr);

  private:
  const std::string& _internal_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_salt(
      const std::string& value);
  std::string* _internal_mutable_salt();

  public:
  // uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // bool fix_msg = 10 [json_name = "fixMsg"];
  void clear_fix_msg() ;
  bool fix_msg() const;
  void set_fix_msg(bool value);

  private:
  bool _internal_fix_msg() const;
  void _internal_set_fix_msg(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.InstantiateContract2Proposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr salt_;
    ::uint64_t code_id_;
    bool fix_msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class MigrateContractProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.MigrateContractProposal) */ {
 public:
  inline MigrateContractProposal() : MigrateContractProposal(nullptr) {}
  ~MigrateContractProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MigrateContractProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateContractProposal(const MigrateContractProposal& from);
  MigrateContractProposal(MigrateContractProposal&& from) noexcept
    : MigrateContractProposal() {
    *this = ::std::move(from);
  }

  inline MigrateContractProposal& operator=(const MigrateContractProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateContractProposal& operator=(MigrateContractProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateContractProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateContractProposal* internal_default_instance() {
    return reinterpret_cast<const MigrateContractProposal*>(
               &_MigrateContractProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MigrateContractProposal& a, MigrateContractProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateContractProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateContractProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigrateContractProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigrateContractProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateContractProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigrateContractProposal& from) {
    MigrateContractProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateContractProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.MigrateContractProposal";
  }
  protected:
  explicit MigrateContractProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kContractFieldNumber = 4,
    kMsgFieldNumber = 6,
    kCodeIdFieldNumber = 5,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string contract = 4 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // bytes msg = 6 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.MigrateContractProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::uint64_t code_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class SudoContractProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.SudoContractProposal) */ {
 public:
  inline SudoContractProposal() : SudoContractProposal(nullptr) {}
  ~SudoContractProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SudoContractProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SudoContractProposal(const SudoContractProposal& from);
  SudoContractProposal(SudoContractProposal&& from) noexcept
    : SudoContractProposal() {
    *this = ::std::move(from);
  }

  inline SudoContractProposal& operator=(const SudoContractProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SudoContractProposal& operator=(SudoContractProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SudoContractProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SudoContractProposal* internal_default_instance() {
    return reinterpret_cast<const SudoContractProposal*>(
               &_SudoContractProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SudoContractProposal& a, SudoContractProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(SudoContractProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SudoContractProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SudoContractProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SudoContractProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SudoContractProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SudoContractProposal& from) {
    SudoContractProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SudoContractProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.SudoContractProposal";
  }
  protected:
  explicit SudoContractProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kContractFieldNumber = 3,
    kMsgFieldNumber = 4,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string contract = 3 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // bytes msg = 4 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.SudoContractProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class ExecuteContractProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ExecuteContractProposal) */ {
 public:
  inline ExecuteContractProposal() : ExecuteContractProposal(nullptr) {}
  ~ExecuteContractProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExecuteContractProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteContractProposal(const ExecuteContractProposal& from);
  ExecuteContractProposal(ExecuteContractProposal&& from) noexcept
    : ExecuteContractProposal() {
    *this = ::std::move(from);
  }

  inline ExecuteContractProposal& operator=(const ExecuteContractProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteContractProposal& operator=(ExecuteContractProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteContractProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteContractProposal* internal_default_instance() {
    return reinterpret_cast<const ExecuteContractProposal*>(
               &_ExecuteContractProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExecuteContractProposal& a, ExecuteContractProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteContractProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteContractProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteContractProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteContractProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteContractProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteContractProposal& from) {
    ExecuteContractProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteContractProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ExecuteContractProposal";
  }
  protected:
  explicit ExecuteContractProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 6,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRunAsFieldNumber = 3,
    kContractFieldNumber = 4,
    kMsgFieldNumber = 5,
  };
  // repeated .cosmos.base.v1beta1.Coin funds = 6 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::cosmos::base::v1beta1::Coin* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_funds();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_funds(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_funds();
  public:
  const ::cosmos::base::v1beta1::Coin& funds(int index) const;
  ::cosmos::base::v1beta1::Coin* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      funds() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string run_as = 3 [json_name = "runAs"];
  void clear_run_as() ;
  const std::string& run_as() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_as(Arg_&& arg, Args_... args);
  std::string* mutable_run_as();
  PROTOBUF_NODISCARD std::string* release_run_as();
  void set_allocated_run_as(std::string* ptr);

  private:
  const std::string& _internal_run_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_as(
      const std::string& value);
  std::string* _internal_mutable_run_as();

  public:
  // string contract = 4 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // bytes msg = 5 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ExecuteContractProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class UpdateAdminProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.UpdateAdminProposal) */ {
 public:
  inline UpdateAdminProposal() : UpdateAdminProposal(nullptr) {}
  ~UpdateAdminProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAdminProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateAdminProposal(const UpdateAdminProposal& from);
  UpdateAdminProposal(UpdateAdminProposal&& from) noexcept
    : UpdateAdminProposal() {
    *this = ::std::move(from);
  }

  inline UpdateAdminProposal& operator=(const UpdateAdminProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAdminProposal& operator=(UpdateAdminProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAdminProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAdminProposal* internal_default_instance() {
    return reinterpret_cast<const UpdateAdminProposal*>(
               &_UpdateAdminProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateAdminProposal& a, UpdateAdminProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAdminProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAdminProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAdminProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAdminProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateAdminProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateAdminProposal& from) {
    UpdateAdminProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAdminProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.UpdateAdminProposal";
  }
  protected:
  explicit UpdateAdminProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kNewAdminFieldNumber = 3,
    kContractFieldNumber = 4,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string new_admin = 3 [json_name = "newAdmin", (.gogoproto.moretags) = "yaml:\"new_admin\""];
  void clear_new_admin() ;
  const std::string& new_admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_admin(Arg_&& arg, Args_... args);
  std::string* mutable_new_admin();
  PROTOBUF_NODISCARD std::string* release_new_admin();
  void set_allocated_new_admin(std::string* ptr);

  private:
  const std::string& _internal_new_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_admin(
      const std::string& value);
  std::string* _internal_mutable_new_admin();

  public:
  // string contract = 4 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.UpdateAdminProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class ClearAdminProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ClearAdminProposal) */ {
 public:
  inline ClearAdminProposal() : ClearAdminProposal(nullptr) {}
  ~ClearAdminProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClearAdminProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAdminProposal(const ClearAdminProposal& from);
  ClearAdminProposal(ClearAdminProposal&& from) noexcept
    : ClearAdminProposal() {
    *this = ::std::move(from);
  }

  inline ClearAdminProposal& operator=(const ClearAdminProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAdminProposal& operator=(ClearAdminProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAdminProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAdminProposal* internal_default_instance() {
    return reinterpret_cast<const ClearAdminProposal*>(
               &_ClearAdminProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClearAdminProposal& a, ClearAdminProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAdminProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAdminProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAdminProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAdminProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearAdminProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearAdminProposal& from) {
    ClearAdminProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAdminProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ClearAdminProposal";
  }
  protected:
  explicit ClearAdminProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kContractFieldNumber = 3,
  };
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string contract = 3 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ClearAdminProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class PinCodesProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.PinCodesProposal) */ {
 public:
  inline PinCodesProposal() : PinCodesProposal(nullptr) {}
  ~PinCodesProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PinCodesProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PinCodesProposal(const PinCodesProposal& from);
  PinCodesProposal(PinCodesProposal&& from) noexcept
    : PinCodesProposal() {
    *this = ::std::move(from);
  }

  inline PinCodesProposal& operator=(const PinCodesProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PinCodesProposal& operator=(PinCodesProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PinCodesProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const PinCodesProposal* internal_default_instance() {
    return reinterpret_cast<const PinCodesProposal*>(
               &_PinCodesProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PinCodesProposal& a, PinCodesProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(PinCodesProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PinCodesProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PinCodesProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PinCodesProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PinCodesProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PinCodesProposal& from) {
    PinCodesProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PinCodesProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.PinCodesProposal";
  }
  protected:
  explicit PinCodesProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated uint64 code_ids = 3 [json_name = "codeIds", (.gogoproto.customname) = "CodeIDs", (.gogoproto.moretags) = "yaml:\"code_ids\""];
  int code_ids_size() const;
  private:
  int _internal_code_ids_size() const;

  public:
  void clear_code_ids() ;
  ::uint64_t code_ids(int index) const;
  void set_code_ids(int index, ::uint64_t value);
  void add_code_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& code_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_code_ids();

  private:
  ::uint64_t _internal_code_ids(int index) const;
  void _internal_add_code_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_code_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_code_ids();

  public:
  // string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.PinCodesProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> code_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _code_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class UnpinCodesProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.UnpinCodesProposal) */ {
 public:
  inline UnpinCodesProposal() : UnpinCodesProposal(nullptr) {}
  ~UnpinCodesProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnpinCodesProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpinCodesProposal(const UnpinCodesProposal& from);
  UnpinCodesProposal(UnpinCodesProposal&& from) noexcept
    : UnpinCodesProposal() {
    *this = ::std::move(from);
  }

  inline UnpinCodesProposal& operator=(const UnpinCodesProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpinCodesProposal& operator=(UnpinCodesProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpinCodesProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpinCodesProposal* internal_default_instance() {
    return reinterpret_cast<const UnpinCodesProposal*>(
               &_UnpinCodesProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UnpinCodesProposal& a, UnpinCodesProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpinCodesProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpinCodesProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpinCodesProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpinCodesProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpinCodesProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpinCodesProposal& from) {
    UnpinCodesProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpinCodesProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.UnpinCodesProposal";
  }
  protected:
  explicit UnpinCodesProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated uint64 code_ids = 3 [json_name = "codeIds", (.gogoproto.customname) = "CodeIDs", (.gogoproto.moretags) = "yaml:\"code_ids\""];
  int code_ids_size() const;
  private:
  int _internal_code_ids_size() const;

  public:
  void clear_code_ids() ;
  ::uint64_t code_ids(int index) const;
  void set_code_ids(int index, ::uint64_t value);
  void add_code_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& code_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_code_ids();

  private:
  ::uint64_t _internal_code_ids(int index) const;
  void _internal_add_code_ids(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_code_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_code_ids();

  public:
  // string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.UnpinCodesProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> code_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _code_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class AccessConfigUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AccessConfigUpdate) */ {
 public:
  inline AccessConfigUpdate() : AccessConfigUpdate(nullptr) {}
  ~AccessConfigUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccessConfigUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessConfigUpdate(const AccessConfigUpdate& from);
  AccessConfigUpdate(AccessConfigUpdate&& from) noexcept
    : AccessConfigUpdate() {
    *this = ::std::move(from);
  }

  inline AccessConfigUpdate& operator=(const AccessConfigUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessConfigUpdate& operator=(AccessConfigUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessConfigUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessConfigUpdate* internal_default_instance() {
    return reinterpret_cast<const AccessConfigUpdate*>(
               &_AccessConfigUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AccessConfigUpdate& a, AccessConfigUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessConfigUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessConfigUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessConfigUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessConfigUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccessConfigUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccessConfigUpdate& from) {
    AccessConfigUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessConfigUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AccessConfigUpdate";
  }
  protected:
  explicit AccessConfigUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstantiatePermissionFieldNumber = 2,
    kCodeIdFieldNumber = 1,
  };
  // .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 2 [json_name = "instantiatePermission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_instantiate_permission() const;
  void clear_instantiate_permission() ;
  const ::cosmwasm::wasm::v1::AccessConfig& instantiate_permission() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_instantiate_permission();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_instantiate_permission();
  void set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_instantiate_permission() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_instantiate_permission();
  public:
  void unsafe_arena_set_allocated_instantiate_permission(
      ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_instantiate_permission();
  // uint64 code_id = 1 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AccessConfigUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission_;
    ::uint64_t code_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class UpdateInstantiateConfigProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal) */ {
 public:
  inline UpdateInstantiateConfigProposal() : UpdateInstantiateConfigProposal(nullptr) {}
  ~UpdateInstantiateConfigProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateInstantiateConfigProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInstantiateConfigProposal(const UpdateInstantiateConfigProposal& from);
  UpdateInstantiateConfigProposal(UpdateInstantiateConfigProposal&& from) noexcept
    : UpdateInstantiateConfigProposal() {
    *this = ::std::move(from);
  }

  inline UpdateInstantiateConfigProposal& operator=(const UpdateInstantiateConfigProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInstantiateConfigProposal& operator=(UpdateInstantiateConfigProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInstantiateConfigProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInstantiateConfigProposal* internal_default_instance() {
    return reinterpret_cast<const UpdateInstantiateConfigProposal*>(
               &_UpdateInstantiateConfigProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateInstantiateConfigProposal& a, UpdateInstantiateConfigProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInstantiateConfigProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInstantiateConfigProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInstantiateConfigProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInstantiateConfigProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInstantiateConfigProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInstantiateConfigProposal& from) {
    UpdateInstantiateConfigProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInstantiateConfigProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.UpdateInstantiateConfigProposal";
  }
  protected:
  explicit UpdateInstantiateConfigProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessConfigUpdatesFieldNumber = 3,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated .cosmwasm.wasm.v1.AccessConfigUpdate access_config_updates = 3 [json_name = "accessConfigUpdates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int access_config_updates_size() const;
  private:
  int _internal_access_config_updates_size() const;

  public:
  void clear_access_config_updates() ;
  ::cosmwasm::wasm::v1::AccessConfigUpdate* mutable_access_config_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::AccessConfigUpdate >*
      mutable_access_config_updates();
  private:
  const ::cosmwasm::wasm::v1::AccessConfigUpdate& _internal_access_config_updates(int index) const;
  ::cosmwasm::wasm::v1::AccessConfigUpdate* _internal_add_access_config_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::AccessConfigUpdate>& _internal_access_config_updates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::AccessConfigUpdate>* _internal_mutable_access_config_updates();
  public:
  const ::cosmwasm::wasm::v1::AccessConfigUpdate& access_config_updates(int index) const;
  ::cosmwasm::wasm::v1::AccessConfigUpdate* add_access_config_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::AccessConfigUpdate >&
      access_config_updates() const;
  // string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::AccessConfigUpdate > access_config_updates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};// -------------------------------------------------------------------

class StoreAndInstantiateContractProposal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal) */ {
 public:
  inline StoreAndInstantiateContractProposal() : StoreAndInstantiateContractProposal(nullptr) {}
  ~StoreAndInstantiateContractProposal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StoreAndInstantiateContractProposal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreAndInstantiateContractProposal(const StoreAndInstantiateContractProposal& from);
  StoreAndInstantiateContractProposal(StoreAndInstantiateContractProposal&& from) noexcept
    : StoreAndInstantiateContractProposal() {
    *this = ::std::move(from);
  }

  inline StoreAndInstantiateContractProposal& operator=(const StoreAndInstantiateContractProposal& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreAndInstantiateContractProposal& operator=(StoreAndInstantiateContractProposal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreAndInstantiateContractProposal& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreAndInstantiateContractProposal* internal_default_instance() {
    return reinterpret_cast<const StoreAndInstantiateContractProposal*>(
               &_StoreAndInstantiateContractProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StoreAndInstantiateContractProposal& a, StoreAndInstantiateContractProposal& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreAndInstantiateContractProposal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreAndInstantiateContractProposal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreAndInstantiateContractProposal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreAndInstantiateContractProposal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreAndInstantiateContractProposal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreAndInstantiateContractProposal& from) {
    StoreAndInstantiateContractProposal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreAndInstantiateContractProposal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.StoreAndInstantiateContractProposal";
  }
  protected:
  explicit StoreAndInstantiateContractProposal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 10,
    kTitleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kRunAsFieldNumber = 3,
    kWasmByteCodeFieldNumber = 4,
    kAdminFieldNumber = 7,
    kLabelFieldNumber = 8,
    kMsgFieldNumber = 9,
    kSourceFieldNumber = 11,
    kBuilderFieldNumber = 12,
    kCodeHashFieldNumber = 13,
    kInstantiatePermissionFieldNumber = 5,
    kUnpinCodeFieldNumber = 6,
  };
  // repeated .cosmos.base.v1beta1.Coin funds = 10 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::cosmos::base::v1beta1::Coin* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_funds();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_funds(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_funds();
  public:
  const ::cosmos::base::v1beta1::Coin& funds(int index) const;
  ::cosmos::base::v1beta1::Coin* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      funds() const;
  // string title = 1 [json_name = "title"];
  void clear_title() ;
  const std::string& title() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* ptr);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string run_as = 3 [json_name = "runAs"];
  void clear_run_as() ;
  const std::string& run_as() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_run_as(Arg_&& arg, Args_... args);
  std::string* mutable_run_as();
  PROTOBUF_NODISCARD std::string* release_run_as();
  void set_allocated_run_as(std::string* ptr);

  private:
  const std::string& _internal_run_as() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_run_as(
      const std::string& value);
  std::string* _internal_mutable_run_as();

  public:
  // bytes wasm_byte_code = 4 [json_name = "wasmByteCode", (.gogoproto.customname) = "WASMByteCode"];
  void clear_wasm_byte_code() ;
  const std::string& wasm_byte_code() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wasm_byte_code(Arg_&& arg, Args_... args);
  std::string* mutable_wasm_byte_code();
  PROTOBUF_NODISCARD std::string* release_wasm_byte_code();
  void set_allocated_wasm_byte_code(std::string* ptr);

  private:
  const std::string& _internal_wasm_byte_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wasm_byte_code(
      const std::string& value);
  std::string* _internal_mutable_wasm_byte_code();

  public:
  // string admin = 7 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string label = 8 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // bytes msg = 9 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // string source = 11 [json_name = "source"];
  void clear_source() ;
  const std::string& source() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* ptr);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // string builder = 12 [json_name = "builder"];
  void clear_builder() ;
  const std::string& builder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_builder(Arg_&& arg, Args_... args);
  std::string* mutable_builder();
  PROTOBUF_NODISCARD std::string* release_builder();
  void set_allocated_builder(std::string* ptr);

  private:
  const std::string& _internal_builder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_builder(
      const std::string& value);
  std::string* _internal_mutable_builder();

  public:
  // bytes code_hash = 13 [json_name = "codeHash"];
  void clear_code_hash() ;
  const std::string& code_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_hash(Arg_&& arg, Args_... args);
  std::string* mutable_code_hash();
  PROTOBUF_NODISCARD std::string* release_code_hash();
  void set_allocated_code_hash(std::string* ptr);

  private:
  const std::string& _internal_code_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_hash(
      const std::string& value);
  std::string* _internal_mutable_code_hash();

  public:
  // .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 5 [json_name = "instantiatePermission"];
  bool has_instantiate_permission() const;
  void clear_instantiate_permission() ;
  const ::cosmwasm::wasm::v1::AccessConfig& instantiate_permission() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_instantiate_permission();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_instantiate_permission();
  void set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_instantiate_permission() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_instantiate_permission();
  public:
  void unsafe_arena_set_allocated_instantiate_permission(
      ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_instantiate_permission();
  // bool unpin_code = 6 [json_name = "unpinCode"];
  void clear_unpin_code() ;
  bool unpin_code() const;
  void set_unpin_code(bool value);

  private:
  bool _internal_unpin_code() const;
  void _internal_set_unpin_code(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr run_as_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wasm_byte_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr builder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_hash_;
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission_;
    bool unpin_code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fproposal_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// StoreCodeProposal

// string title = 1 [json_name = "title"];
inline void StoreCodeProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.title)
}
inline std::string* StoreCodeProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.title)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void StoreCodeProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.title)
  return _impl_.title_.Release();
}
inline void StoreCodeProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.title)
}

// string description = 2 [json_name = "description"];
inline void StoreCodeProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.description)
}
inline std::string* StoreCodeProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.description)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void StoreCodeProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.description)
  return _impl_.description_.Release();
}
inline void StoreCodeProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.description)
}

// string run_as = 3 [json_name = "runAs"];
inline void StoreCodeProposal::clear_run_as() {
  _impl_.run_as_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::run_as() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.run_as)
  return _internal_run_as();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_run_as(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.run_as_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.run_as)
}
inline std::string* StoreCodeProposal::mutable_run_as() {
  std::string* _s = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.run_as)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_run_as() const {
  return _impl_.run_as_.Get();
}
inline void StoreCodeProposal::_internal_set_run_as(const std::string& value) {
  ;


  _impl_.run_as_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_run_as() {
  ;
  return _impl_.run_as_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_run_as() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.run_as)
  return _impl_.run_as_.Release();
}
inline void StoreCodeProposal::set_allocated_run_as(std::string* value) {
  _impl_.run_as_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_as_.IsDefault()) {
          _impl_.run_as_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.run_as)
}

// bytes wasm_byte_code = 4 [json_name = "wasmByteCode", (.gogoproto.customname) = "WASMByteCode"];
inline void StoreCodeProposal::clear_wasm_byte_code() {
  _impl_.wasm_byte_code_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::wasm_byte_code() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.wasm_byte_code)
  return _internal_wasm_byte_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_wasm_byte_code(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.wasm_byte_code_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.wasm_byte_code)
}
inline std::string* StoreCodeProposal::mutable_wasm_byte_code() {
  std::string* _s = _internal_mutable_wasm_byte_code();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.wasm_byte_code)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_wasm_byte_code() const {
  return _impl_.wasm_byte_code_.Get();
}
inline void StoreCodeProposal::_internal_set_wasm_byte_code(const std::string& value) {
  ;


  _impl_.wasm_byte_code_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_wasm_byte_code() {
  ;
  return _impl_.wasm_byte_code_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_wasm_byte_code() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.wasm_byte_code)
  return _impl_.wasm_byte_code_.Release();
}
inline void StoreCodeProposal::set_allocated_wasm_byte_code(std::string* value) {
  _impl_.wasm_byte_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wasm_byte_code_.IsDefault()) {
          _impl_.wasm_byte_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.wasm_byte_code)
}

// .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 7 [json_name = "instantiatePermission"];
inline bool StoreCodeProposal::has_instantiate_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantiate_permission_ != nullptr);
  return value;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& StoreCodeProposal::_internal_instantiate_permission() const {
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.instantiate_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(
      ::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& StoreCodeProposal::instantiate_permission() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.instantiate_permission)
  return _internal_instantiate_permission();
}
inline void StoreCodeProposal::unsafe_arena_set_allocated_instantiate_permission(
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  if (instantiate_permission) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.instantiate_permission)
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreCodeProposal::release_instantiate_permission() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreCodeProposal::unsafe_arena_release_instantiate_permission() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.instantiate_permission)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreCodeProposal::_internal_mutable_instantiate_permission() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instantiate_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(GetArenaForAllocation());
    _impl_.instantiate_permission_ = p;
  }
  return _impl_.instantiate_permission_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreCodeProposal::mutable_instantiate_permission() {
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_instantiate_permission();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.instantiate_permission)
  return _msg;
}
inline void StoreCodeProposal::set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  if (instantiate_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantiate_permission));
    if (message_arena != submessage_arena) {
      instantiate_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantiate_permission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.instantiate_permission)
}

// bool unpin_code = 8 [json_name = "unpinCode"];
inline void StoreCodeProposal::clear_unpin_code() {
  _impl_.unpin_code_ = false;
}
inline bool StoreCodeProposal::unpin_code() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.unpin_code)
  return _internal_unpin_code();
}
inline void StoreCodeProposal::set_unpin_code(bool value) {
  _internal_set_unpin_code(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.unpin_code)
}
inline bool StoreCodeProposal::_internal_unpin_code() const {
  return _impl_.unpin_code_;
}
inline void StoreCodeProposal::_internal_set_unpin_code(bool value) {
  ;
  _impl_.unpin_code_ = value;
}

// string source = 9 [json_name = "source"];
inline void StoreCodeProposal::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::source() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_source(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.source)
}
inline std::string* StoreCodeProposal::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.source)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_source() const {
  return _impl_.source_.Get();
}
inline void StoreCodeProposal::_internal_set_source(const std::string& value) {
  ;


  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_source() {
  ;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_source() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.source)
  return _impl_.source_.Release();
}
inline void StoreCodeProposal::set_allocated_source(std::string* value) {
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.source)
}

// string builder = 10 [json_name = "builder"];
inline void StoreCodeProposal::clear_builder() {
  _impl_.builder_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::builder() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.builder)
  return _internal_builder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_builder(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.builder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.builder)
}
inline std::string* StoreCodeProposal::mutable_builder() {
  std::string* _s = _internal_mutable_builder();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.builder)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_builder() const {
  return _impl_.builder_.Get();
}
inline void StoreCodeProposal::_internal_set_builder(const std::string& value) {
  ;


  _impl_.builder_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_builder() {
  ;
  return _impl_.builder_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_builder() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.builder)
  return _impl_.builder_.Release();
}
inline void StoreCodeProposal::set_allocated_builder(std::string* value) {
  _impl_.builder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.builder_.IsDefault()) {
          _impl_.builder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.builder)
}

// bytes code_hash = 11 [json_name = "codeHash"];
inline void StoreCodeProposal::clear_code_hash() {
  _impl_.code_hash_.ClearToEmpty();
}
inline const std::string& StoreCodeProposal::code_hash() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreCodeProposal.code_hash)
  return _internal_code_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreCodeProposal::set_code_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreCodeProposal.code_hash)
}
inline std::string* StoreCodeProposal::mutable_code_hash() {
  std::string* _s = _internal_mutable_code_hash();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreCodeProposal.code_hash)
  return _s;
}
inline const std::string& StoreCodeProposal::_internal_code_hash() const {
  return _impl_.code_hash_.Get();
}
inline void StoreCodeProposal::_internal_set_code_hash(const std::string& value) {
  ;


  _impl_.code_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::_internal_mutable_code_hash() {
  ;
  return _impl_.code_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreCodeProposal::release_code_hash() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreCodeProposal.code_hash)
  return _impl_.code_hash_.Release();
}
inline void StoreCodeProposal::set_allocated_code_hash(std::string* value) {
  _impl_.code_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_hash_.IsDefault()) {
          _impl_.code_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreCodeProposal.code_hash)
}

// -------------------------------------------------------------------

// InstantiateContractProposal

// string title = 1 [json_name = "title"];
inline void InstantiateContractProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.title)
}
inline std::string* InstantiateContractProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.title)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void InstantiateContractProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.title)
  return _impl_.title_.Release();
}
inline void InstantiateContractProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.title)
}

// string description = 2 [json_name = "description"];
inline void InstantiateContractProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.description)
}
inline std::string* InstantiateContractProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.description)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void InstantiateContractProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.description)
  return _impl_.description_.Release();
}
inline void InstantiateContractProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.description)
}

// string run_as = 3 [json_name = "runAs"];
inline void InstantiateContractProposal::clear_run_as() {
  _impl_.run_as_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::run_as() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.run_as)
  return _internal_run_as();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_run_as(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.run_as_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.run_as)
}
inline std::string* InstantiateContractProposal::mutable_run_as() {
  std::string* _s = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.run_as)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_run_as() const {
  return _impl_.run_as_.Get();
}
inline void InstantiateContractProposal::_internal_set_run_as(const std::string& value) {
  ;


  _impl_.run_as_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_run_as() {
  ;
  return _impl_.run_as_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_run_as() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.run_as)
  return _impl_.run_as_.Release();
}
inline void InstantiateContractProposal::set_allocated_run_as(std::string* value) {
  _impl_.run_as_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_as_.IsDefault()) {
          _impl_.run_as_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.run_as)
}

// string admin = 4 [json_name = "admin"];
inline void InstantiateContractProposal::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::admin() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.admin)
}
inline std::string* InstantiateContractProposal::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.admin)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void InstantiateContractProposal::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_admin() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.admin)
  return _impl_.admin_.Release();
}
inline void InstantiateContractProposal::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.admin)
}

// uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void InstantiateContractProposal::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t InstantiateContractProposal::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.code_id)
  return _internal_code_id();
}
inline void InstantiateContractProposal::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.code_id)
}
inline ::uint64_t InstantiateContractProposal::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void InstantiateContractProposal::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string label = 6 [json_name = "label"];
inline void InstantiateContractProposal::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::label() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.label)
}
inline std::string* InstantiateContractProposal::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.label)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_label() const {
  return _impl_.label_.Get();
}
inline void InstantiateContractProposal::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_label() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.label)
  return _impl_.label_.Release();
}
inline void InstantiateContractProposal::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.label)
}

// bytes msg = 7 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void InstantiateContractProposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& InstantiateContractProposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContractProposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContractProposal.msg)
}
inline std::string* InstantiateContractProposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.msg)
  return _s;
}
inline const std::string& InstantiateContractProposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void InstantiateContractProposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContractProposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContractProposal.msg)
  return _impl_.msg_.Release();
}
inline void InstantiateContractProposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContractProposal.msg)
}

// repeated .cosmos.base.v1beta1.Coin funds = 8 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int InstantiateContractProposal::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int InstantiateContractProposal::funds_size() const {
  return _internal_funds_size();
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContractProposal::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContractProposal.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
InstantiateContractProposal::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.InstantiateContractProposal.funds)
  return _internal_mutable_funds();
}
inline const ::cosmos::base::v1beta1::Coin& InstantiateContractProposal::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& InstantiateContractProposal::funds(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContractProposal.funds)
  return _internal_funds(index);
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContractProposal::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContractProposal::add_funds() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.InstantiateContractProposal.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
InstantiateContractProposal::funds() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.InstantiateContractProposal.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
InstantiateContractProposal::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
InstantiateContractProposal::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// -------------------------------------------------------------------

// InstantiateContract2Proposal

// string title = 1 [json_name = "title"];
inline void InstantiateContract2Proposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.title)
}
inline std::string* InstantiateContract2Proposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.title)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.title)
  return _impl_.title_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.title)
}

// string description = 2 [json_name = "description"];
inline void InstantiateContract2Proposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.description)
}
inline std::string* InstantiateContract2Proposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.description)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.description)
  return _impl_.description_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.description)
}

// string run_as = 3 [json_name = "runAs"];
inline void InstantiateContract2Proposal::clear_run_as() {
  _impl_.run_as_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::run_as() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.run_as)
  return _internal_run_as();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_run_as(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.run_as_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.run_as)
}
inline std::string* InstantiateContract2Proposal::mutable_run_as() {
  std::string* _s = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.run_as)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_run_as() const {
  return _impl_.run_as_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_run_as(const std::string& value) {
  ;


  _impl_.run_as_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_run_as() {
  ;
  return _impl_.run_as_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_run_as() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.run_as)
  return _impl_.run_as_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_run_as(std::string* value) {
  _impl_.run_as_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_as_.IsDefault()) {
          _impl_.run_as_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.run_as)
}

// string admin = 4 [json_name = "admin"];
inline void InstantiateContract2Proposal::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::admin() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.admin)
}
inline std::string* InstantiateContract2Proposal::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.admin)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_admin() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.admin)
  return _impl_.admin_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.admin)
}

// uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void InstantiateContract2Proposal::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t InstantiateContract2Proposal::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.code_id)
  return _internal_code_id();
}
inline void InstantiateContract2Proposal::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.code_id)
}
inline ::uint64_t InstantiateContract2Proposal::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void InstantiateContract2Proposal::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string label = 6 [json_name = "label"];
inline void InstantiateContract2Proposal::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::label() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.label)
}
inline std::string* InstantiateContract2Proposal::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.label)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_label() const {
  return _impl_.label_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_label() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.label)
  return _impl_.label_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.label)
}

// bytes msg = 7 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void InstantiateContract2Proposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.msg)
}
inline std::string* InstantiateContract2Proposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.msg)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.msg)
  return _impl_.msg_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.msg)
}

// repeated .cosmos.base.v1beta1.Coin funds = 8 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int InstantiateContract2Proposal::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int InstantiateContract2Proposal::funds_size() const {
  return _internal_funds_size();
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContract2Proposal::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
InstantiateContract2Proposal::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.InstantiateContract2Proposal.funds)
  return _internal_mutable_funds();
}
inline const ::cosmos::base::v1beta1::Coin& InstantiateContract2Proposal::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& InstantiateContract2Proposal::funds(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.funds)
  return _internal_funds(index);
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContract2Proposal::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::cosmos::base::v1beta1::Coin* InstantiateContract2Proposal::add_funds() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.InstantiateContract2Proposal.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
InstantiateContract2Proposal::funds() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.InstantiateContract2Proposal.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
InstantiateContract2Proposal::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
InstantiateContract2Proposal::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// bytes salt = 9 [json_name = "salt"];
inline void InstantiateContract2Proposal::clear_salt() {
  _impl_.salt_.ClearToEmpty();
}
inline const std::string& InstantiateContract2Proposal::salt() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.salt)
  return _internal_salt();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstantiateContract2Proposal::set_salt(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.salt_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.salt)
}
inline std::string* InstantiateContract2Proposal::mutable_salt() {
  std::string* _s = _internal_mutable_salt();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.InstantiateContract2Proposal.salt)
  return _s;
}
inline const std::string& InstantiateContract2Proposal::_internal_salt() const {
  return _impl_.salt_.Get();
}
inline void InstantiateContract2Proposal::_internal_set_salt(const std::string& value) {
  ;


  _impl_.salt_.Set(value, GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::_internal_mutable_salt() {
  ;
  return _impl_.salt_.Mutable( GetArenaForAllocation());
}
inline std::string* InstantiateContract2Proposal::release_salt() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.InstantiateContract2Proposal.salt)
  return _impl_.salt_.Release();
}
inline void InstantiateContract2Proposal::set_allocated_salt(std::string* value) {
  _impl_.salt_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.salt_.IsDefault()) {
          _impl_.salt_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.InstantiateContract2Proposal.salt)
}

// bool fix_msg = 10 [json_name = "fixMsg"];
inline void InstantiateContract2Proposal::clear_fix_msg() {
  _impl_.fix_msg_ = false;
}
inline bool InstantiateContract2Proposal::fix_msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.InstantiateContract2Proposal.fix_msg)
  return _internal_fix_msg();
}
inline void InstantiateContract2Proposal::set_fix_msg(bool value) {
  _internal_set_fix_msg(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.InstantiateContract2Proposal.fix_msg)
}
inline bool InstantiateContract2Proposal::_internal_fix_msg() const {
  return _impl_.fix_msg_;
}
inline void InstantiateContract2Proposal::_internal_set_fix_msg(bool value) {
  ;
  _impl_.fix_msg_ = value;
}

// -------------------------------------------------------------------

// MigrateContractProposal

// string title = 1 [json_name = "title"];
inline void MigrateContractProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& MigrateContractProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MigrateContractProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MigrateContractProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MigrateContractProposal.title)
}
inline std::string* MigrateContractProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MigrateContractProposal.title)
  return _s;
}
inline const std::string& MigrateContractProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void MigrateContractProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.MigrateContractProposal.title)
  return _impl_.title_.Release();
}
inline void MigrateContractProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.MigrateContractProposal.title)
}

// string description = 2 [json_name = "description"];
inline void MigrateContractProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& MigrateContractProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MigrateContractProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MigrateContractProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MigrateContractProposal.description)
}
inline std::string* MigrateContractProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MigrateContractProposal.description)
  return _s;
}
inline const std::string& MigrateContractProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MigrateContractProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.MigrateContractProposal.description)
  return _impl_.description_.Release();
}
inline void MigrateContractProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.MigrateContractProposal.description)
}

// string contract = 4 [json_name = "contract"];
inline void MigrateContractProposal::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& MigrateContractProposal::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MigrateContractProposal.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MigrateContractProposal::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MigrateContractProposal.contract)
}
inline std::string* MigrateContractProposal::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MigrateContractProposal.contract)
  return _s;
}
inline const std::string& MigrateContractProposal::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void MigrateContractProposal::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.MigrateContractProposal.contract)
  return _impl_.contract_.Release();
}
inline void MigrateContractProposal::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.MigrateContractProposal.contract)
}

// uint64 code_id = 5 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void MigrateContractProposal::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t MigrateContractProposal::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MigrateContractProposal.code_id)
  return _internal_code_id();
}
inline void MigrateContractProposal::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MigrateContractProposal.code_id)
}
inline ::uint64_t MigrateContractProposal::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void MigrateContractProposal::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// bytes msg = 6 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void MigrateContractProposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& MigrateContractProposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MigrateContractProposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MigrateContractProposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MigrateContractProposal.msg)
}
inline std::string* MigrateContractProposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MigrateContractProposal.msg)
  return _s;
}
inline const std::string& MigrateContractProposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void MigrateContractProposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* MigrateContractProposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.MigrateContractProposal.msg)
  return _impl_.msg_.Release();
}
inline void MigrateContractProposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.MigrateContractProposal.msg)
}

// -------------------------------------------------------------------

// SudoContractProposal

// string title = 1 [json_name = "title"];
inline void SudoContractProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SudoContractProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.SudoContractProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SudoContractProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.SudoContractProposal.title)
}
inline std::string* SudoContractProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.SudoContractProposal.title)
  return _s;
}
inline const std::string& SudoContractProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SudoContractProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SudoContractProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* SudoContractProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.SudoContractProposal.title)
  return _impl_.title_.Release();
}
inline void SudoContractProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.SudoContractProposal.title)
}

// string description = 2 [json_name = "description"];
inline void SudoContractProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& SudoContractProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.SudoContractProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SudoContractProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.SudoContractProposal.description)
}
inline std::string* SudoContractProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.SudoContractProposal.description)
  return _s;
}
inline const std::string& SudoContractProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void SudoContractProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* SudoContractProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* SudoContractProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.SudoContractProposal.description)
  return _impl_.description_.Release();
}
inline void SudoContractProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.SudoContractProposal.description)
}

// string contract = 3 [json_name = "contract"];
inline void SudoContractProposal::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& SudoContractProposal::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.SudoContractProposal.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SudoContractProposal::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.SudoContractProposal.contract)
}
inline std::string* SudoContractProposal::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.SudoContractProposal.contract)
  return _s;
}
inline const std::string& SudoContractProposal::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void SudoContractProposal::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* SudoContractProposal::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* SudoContractProposal::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.SudoContractProposal.contract)
  return _impl_.contract_.Release();
}
inline void SudoContractProposal::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.SudoContractProposal.contract)
}

// bytes msg = 4 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void SudoContractProposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SudoContractProposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.SudoContractProposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SudoContractProposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.SudoContractProposal.msg)
}
inline std::string* SudoContractProposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.SudoContractProposal.msg)
  return _s;
}
inline const std::string& SudoContractProposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SudoContractProposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SudoContractProposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* SudoContractProposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.SudoContractProposal.msg)
  return _impl_.msg_.Release();
}
inline void SudoContractProposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.SudoContractProposal.msg)
}

// -------------------------------------------------------------------

// ExecuteContractProposal

// string title = 1 [json_name = "title"];
inline void ExecuteContractProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ExecuteContractProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteContractProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ExecuteContractProposal.title)
}
inline std::string* ExecuteContractProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.title)
  return _s;
}
inline const std::string& ExecuteContractProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ExecuteContractProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ExecuteContractProposal.title)
  return _impl_.title_.Release();
}
inline void ExecuteContractProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ExecuteContractProposal.title)
}

// string description = 2 [json_name = "description"];
inline void ExecuteContractProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ExecuteContractProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteContractProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ExecuteContractProposal.description)
}
inline std::string* ExecuteContractProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.description)
  return _s;
}
inline const std::string& ExecuteContractProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ExecuteContractProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ExecuteContractProposal.description)
  return _impl_.description_.Release();
}
inline void ExecuteContractProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ExecuteContractProposal.description)
}

// string run_as = 3 [json_name = "runAs"];
inline void ExecuteContractProposal::clear_run_as() {
  _impl_.run_as_.ClearToEmpty();
}
inline const std::string& ExecuteContractProposal::run_as() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.run_as)
  return _internal_run_as();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteContractProposal::set_run_as(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.run_as_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ExecuteContractProposal.run_as)
}
inline std::string* ExecuteContractProposal::mutable_run_as() {
  std::string* _s = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.run_as)
  return _s;
}
inline const std::string& ExecuteContractProposal::_internal_run_as() const {
  return _impl_.run_as_.Get();
}
inline void ExecuteContractProposal::_internal_set_run_as(const std::string& value) {
  ;


  _impl_.run_as_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::_internal_mutable_run_as() {
  ;
  return _impl_.run_as_.Mutable( GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::release_run_as() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ExecuteContractProposal.run_as)
  return _impl_.run_as_.Release();
}
inline void ExecuteContractProposal::set_allocated_run_as(std::string* value) {
  _impl_.run_as_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_as_.IsDefault()) {
          _impl_.run_as_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ExecuteContractProposal.run_as)
}

// string contract = 4 [json_name = "contract"];
inline void ExecuteContractProposal::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& ExecuteContractProposal::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteContractProposal::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ExecuteContractProposal.contract)
}
inline std::string* ExecuteContractProposal::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.contract)
  return _s;
}
inline const std::string& ExecuteContractProposal::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void ExecuteContractProposal::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ExecuteContractProposal.contract)
  return _impl_.contract_.Release();
}
inline void ExecuteContractProposal::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ExecuteContractProposal.contract)
}

// bytes msg = 5 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void ExecuteContractProposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ExecuteContractProposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExecuteContractProposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ExecuteContractProposal.msg)
}
inline std::string* ExecuteContractProposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.msg)
  return _s;
}
inline const std::string& ExecuteContractProposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ExecuteContractProposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* ExecuteContractProposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ExecuteContractProposal.msg)
  return _impl_.msg_.Release();
}
inline void ExecuteContractProposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ExecuteContractProposal.msg)
}

// repeated .cosmos.base.v1beta1.Coin funds = 6 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int ExecuteContractProposal::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int ExecuteContractProposal::funds_size() const {
  return _internal_funds_size();
}
inline ::cosmos::base::v1beta1::Coin* ExecuteContractProposal::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ExecuteContractProposal.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
ExecuteContractProposal::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.ExecuteContractProposal.funds)
  return _internal_mutable_funds();
}
inline const ::cosmos::base::v1beta1::Coin& ExecuteContractProposal::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& ExecuteContractProposal::funds(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ExecuteContractProposal.funds)
  return _internal_funds(index);
}
inline ::cosmos::base::v1beta1::Coin* ExecuteContractProposal::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::cosmos::base::v1beta1::Coin* ExecuteContractProposal::add_funds() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.ExecuteContractProposal.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
ExecuteContractProposal::funds() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.ExecuteContractProposal.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
ExecuteContractProposal::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
ExecuteContractProposal::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// -------------------------------------------------------------------

// UpdateAdminProposal

// string title = 1 [json_name = "title"];
inline void UpdateAdminProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UpdateAdminProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateAdminProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateAdminProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateAdminProposal.title)
}
inline std::string* UpdateAdminProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateAdminProposal.title)
  return _s;
}
inline const std::string& UpdateAdminProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UpdateAdminProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateAdminProposal.title)
  return _impl_.title_.Release();
}
inline void UpdateAdminProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateAdminProposal.title)
}

// string description = 2 [json_name = "description"];
inline void UpdateAdminProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateAdminProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateAdminProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateAdminProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateAdminProposal.description)
}
inline std::string* UpdateAdminProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateAdminProposal.description)
  return _s;
}
inline const std::string& UpdateAdminProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateAdminProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateAdminProposal.description)
  return _impl_.description_.Release();
}
inline void UpdateAdminProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateAdminProposal.description)
}

// string new_admin = 3 [json_name = "newAdmin", (.gogoproto.moretags) = "yaml:\"new_admin\""];
inline void UpdateAdminProposal::clear_new_admin() {
  _impl_.new_admin_.ClearToEmpty();
}
inline const std::string& UpdateAdminProposal::new_admin() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateAdminProposal.new_admin)
  return _internal_new_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateAdminProposal::set_new_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.new_admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateAdminProposal.new_admin)
}
inline std::string* UpdateAdminProposal::mutable_new_admin() {
  std::string* _s = _internal_mutable_new_admin();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateAdminProposal.new_admin)
  return _s;
}
inline const std::string& UpdateAdminProposal::_internal_new_admin() const {
  return _impl_.new_admin_.Get();
}
inline void UpdateAdminProposal::_internal_set_new_admin(const std::string& value) {
  ;


  _impl_.new_admin_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::_internal_mutable_new_admin() {
  ;
  return _impl_.new_admin_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::release_new_admin() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateAdminProposal.new_admin)
  return _impl_.new_admin_.Release();
}
inline void UpdateAdminProposal::set_allocated_new_admin(std::string* value) {
  _impl_.new_admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_admin_.IsDefault()) {
          _impl_.new_admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateAdminProposal.new_admin)
}

// string contract = 4 [json_name = "contract"];
inline void UpdateAdminProposal::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& UpdateAdminProposal::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateAdminProposal.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateAdminProposal::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateAdminProposal.contract)
}
inline std::string* UpdateAdminProposal::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateAdminProposal.contract)
  return _s;
}
inline const std::string& UpdateAdminProposal::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void UpdateAdminProposal::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateAdminProposal::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateAdminProposal.contract)
  return _impl_.contract_.Release();
}
inline void UpdateAdminProposal::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateAdminProposal.contract)
}

// -------------------------------------------------------------------

// ClearAdminProposal

// string title = 1 [json_name = "title"];
inline void ClearAdminProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ClearAdminProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ClearAdminProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClearAdminProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ClearAdminProposal.title)
}
inline std::string* ClearAdminProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ClearAdminProposal.title)
  return _s;
}
inline const std::string& ClearAdminProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ClearAdminProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ClearAdminProposal.title)
  return _impl_.title_.Release();
}
inline void ClearAdminProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ClearAdminProposal.title)
}

// string description = 2 [json_name = "description"];
inline void ClearAdminProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ClearAdminProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ClearAdminProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClearAdminProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ClearAdminProposal.description)
}
inline std::string* ClearAdminProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ClearAdminProposal.description)
  return _s;
}
inline const std::string& ClearAdminProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ClearAdminProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ClearAdminProposal.description)
  return _impl_.description_.Release();
}
inline void ClearAdminProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ClearAdminProposal.description)
}

// string contract = 3 [json_name = "contract"];
inline void ClearAdminProposal::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& ClearAdminProposal::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ClearAdminProposal.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClearAdminProposal::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ClearAdminProposal.contract)
}
inline std::string* ClearAdminProposal::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ClearAdminProposal.contract)
  return _s;
}
inline const std::string& ClearAdminProposal::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void ClearAdminProposal::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* ClearAdminProposal::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ClearAdminProposal.contract)
  return _impl_.contract_.Release();
}
inline void ClearAdminProposal::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ClearAdminProposal.contract)
}

// -------------------------------------------------------------------

// PinCodesProposal

// string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
inline void PinCodesProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& PinCodesProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.PinCodesProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PinCodesProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.PinCodesProposal.title)
}
inline std::string* PinCodesProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.PinCodesProposal.title)
  return _s;
}
inline const std::string& PinCodesProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void PinCodesProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PinCodesProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* PinCodesProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.PinCodesProposal.title)
  return _impl_.title_.Release();
}
inline void PinCodesProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.PinCodesProposal.title)
}

// string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
inline void PinCodesProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PinCodesProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.PinCodesProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PinCodesProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.PinCodesProposal.description)
}
inline std::string* PinCodesProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.PinCodesProposal.description)
  return _s;
}
inline const std::string& PinCodesProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PinCodesProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PinCodesProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* PinCodesProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.PinCodesProposal.description)
  return _impl_.description_.Release();
}
inline void PinCodesProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.PinCodesProposal.description)
}

// repeated uint64 code_ids = 3 [json_name = "codeIds", (.gogoproto.customname) = "CodeIDs", (.gogoproto.moretags) = "yaml:\"code_ids\""];
inline int PinCodesProposal::_internal_code_ids_size() const {
  return _impl_.code_ids_.size();
}
inline int PinCodesProposal::code_ids_size() const {
  return _internal_code_ids_size();
}
inline void PinCodesProposal::clear_code_ids() {
  _internal_mutable_code_ids()->Clear();
}
inline ::uint64_t PinCodesProposal::code_ids(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.PinCodesProposal.code_ids)
  return _internal_code_ids(index);
}
inline void PinCodesProposal::set_code_ids(int index, ::uint64_t value) {
  _internal_mutable_code_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.PinCodesProposal.code_ids)
}
inline void PinCodesProposal::add_code_ids(::uint64_t value) {
  _internal_add_code_ids(value);
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.PinCodesProposal.code_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& PinCodesProposal::code_ids() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.PinCodesProposal.code_ids)
  return _internal_code_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* PinCodesProposal::mutable_code_ids() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.PinCodesProposal.code_ids)
  return _internal_mutable_code_ids();
}

inline ::uint64_t PinCodesProposal::_internal_code_ids(int index) const {
  return _internal_code_ids().Get(index);
}
inline void PinCodesProposal::_internal_add_code_ids(::uint64_t value) {
  _internal_mutable_code_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& PinCodesProposal::_internal_code_ids() const {
  return _impl_.code_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* PinCodesProposal::_internal_mutable_code_ids() {
  return &_impl_.code_ids_;
}

// -------------------------------------------------------------------

// UnpinCodesProposal

// string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
inline void UnpinCodesProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UnpinCodesProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UnpinCodesProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnpinCodesProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UnpinCodesProposal.title)
}
inline std::string* UnpinCodesProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UnpinCodesProposal.title)
  return _s;
}
inline const std::string& UnpinCodesProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UnpinCodesProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpinCodesProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* UnpinCodesProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UnpinCodesProposal.title)
  return _impl_.title_.Release();
}
inline void UnpinCodesProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UnpinCodesProposal.title)
}

// string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
inline void UnpinCodesProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UnpinCodesProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UnpinCodesProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnpinCodesProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UnpinCodesProposal.description)
}
inline std::string* UnpinCodesProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UnpinCodesProposal.description)
  return _s;
}
inline const std::string& UnpinCodesProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UnpinCodesProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpinCodesProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* UnpinCodesProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UnpinCodesProposal.description)
  return _impl_.description_.Release();
}
inline void UnpinCodesProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UnpinCodesProposal.description)
}

// repeated uint64 code_ids = 3 [json_name = "codeIds", (.gogoproto.customname) = "CodeIDs", (.gogoproto.moretags) = "yaml:\"code_ids\""];
inline int UnpinCodesProposal::_internal_code_ids_size() const {
  return _impl_.code_ids_.size();
}
inline int UnpinCodesProposal::code_ids_size() const {
  return _internal_code_ids_size();
}
inline void UnpinCodesProposal::clear_code_ids() {
  _internal_mutable_code_ids()->Clear();
}
inline ::uint64_t UnpinCodesProposal::code_ids(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UnpinCodesProposal.code_ids)
  return _internal_code_ids(index);
}
inline void UnpinCodesProposal::set_code_ids(int index, ::uint64_t value) {
  _internal_mutable_code_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UnpinCodesProposal.code_ids)
}
inline void UnpinCodesProposal::add_code_ids(::uint64_t value) {
  _internal_add_code_ids(value);
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.UnpinCodesProposal.code_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& UnpinCodesProposal::code_ids() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.UnpinCodesProposal.code_ids)
  return _internal_code_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* UnpinCodesProposal::mutable_code_ids() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.UnpinCodesProposal.code_ids)
  return _internal_mutable_code_ids();
}

inline ::uint64_t UnpinCodesProposal::_internal_code_ids(int index) const {
  return _internal_code_ids().Get(index);
}
inline void UnpinCodesProposal::_internal_add_code_ids(::uint64_t value) {
  _internal_mutable_code_ids()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& UnpinCodesProposal::_internal_code_ids() const {
  return _impl_.code_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* UnpinCodesProposal::_internal_mutable_code_ids() {
  return &_impl_.code_ids_;
}

// -------------------------------------------------------------------

// AccessConfigUpdate

// uint64 code_id = 1 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void AccessConfigUpdate::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t AccessConfigUpdate::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AccessConfigUpdate.code_id)
  return _internal_code_id();
}
inline void AccessConfigUpdate::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AccessConfigUpdate.code_id)
}
inline ::uint64_t AccessConfigUpdate::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void AccessConfigUpdate::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 2 [json_name = "instantiatePermission", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool AccessConfigUpdate::has_instantiate_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantiate_permission_ != nullptr);
  return value;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& AccessConfigUpdate::_internal_instantiate_permission() const {
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.instantiate_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(
      ::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& AccessConfigUpdate::instantiate_permission() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AccessConfigUpdate.instantiate_permission)
  return _internal_instantiate_permission();
}
inline void AccessConfigUpdate::unsafe_arena_set_allocated_instantiate_permission(
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  if (instantiate_permission) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.AccessConfigUpdate.instantiate_permission)
}
inline ::cosmwasm::wasm::v1::AccessConfig* AccessConfigUpdate::release_instantiate_permission() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* AccessConfigUpdate::unsafe_arena_release_instantiate_permission() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.AccessConfigUpdate.instantiate_permission)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* AccessConfigUpdate::_internal_mutable_instantiate_permission() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instantiate_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(GetArenaForAllocation());
    _impl_.instantiate_permission_ = p;
  }
  return _impl_.instantiate_permission_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* AccessConfigUpdate::mutable_instantiate_permission() {
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_instantiate_permission();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AccessConfigUpdate.instantiate_permission)
  return _msg;
}
inline void AccessConfigUpdate::set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  if (instantiate_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantiate_permission));
    if (message_arena != submessage_arena) {
      instantiate_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantiate_permission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.AccessConfigUpdate.instantiate_permission)
}

// -------------------------------------------------------------------

// UpdateInstantiateConfigProposal

// string title = 1 [json_name = "title", (.gogoproto.moretags) = "yaml:\"title\""];
inline void UpdateInstantiateConfigProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UpdateInstantiateConfigProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInstantiateConfigProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.title)
}
inline std::string* UpdateInstantiateConfigProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.title)
  return _s;
}
inline const std::string& UpdateInstantiateConfigProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UpdateInstantiateConfigProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateInstantiateConfigProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateInstantiateConfigProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.title)
  return _impl_.title_.Release();
}
inline void UpdateInstantiateConfigProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.title)
}

// string description = 2 [json_name = "description", (.gogoproto.moretags) = "yaml:\"description\""];
inline void UpdateInstantiateConfigProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateInstantiateConfigProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateInstantiateConfigProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.description)
}
inline std::string* UpdateInstantiateConfigProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.description)
  return _s;
}
inline const std::string& UpdateInstantiateConfigProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateInstantiateConfigProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateInstantiateConfigProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* UpdateInstantiateConfigProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.description)
  return _impl_.description_.Release();
}
inline void UpdateInstantiateConfigProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.description)
}

// repeated .cosmwasm.wasm.v1.AccessConfigUpdate access_config_updates = 3 [json_name = "accessConfigUpdates", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int UpdateInstantiateConfigProposal::_internal_access_config_updates_size() const {
  return _impl_.access_config_updates_.size();
}
inline int UpdateInstantiateConfigProposal::access_config_updates_size() const {
  return _internal_access_config_updates_size();
}
inline void UpdateInstantiateConfigProposal::clear_access_config_updates() {
  _internal_mutable_access_config_updates()->Clear();
}
inline ::cosmwasm::wasm::v1::AccessConfigUpdate* UpdateInstantiateConfigProposal::mutable_access_config_updates(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.access_config_updates)
  return _internal_mutable_access_config_updates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::AccessConfigUpdate >*
UpdateInstantiateConfigProposal::mutable_access_config_updates() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.access_config_updates)
  return _internal_mutable_access_config_updates();
}
inline const ::cosmwasm::wasm::v1::AccessConfigUpdate& UpdateInstantiateConfigProposal::_internal_access_config_updates(int index) const {
  return _internal_access_config_updates().Get(index);
}
inline const ::cosmwasm::wasm::v1::AccessConfigUpdate& UpdateInstantiateConfigProposal::access_config_updates(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.access_config_updates)
  return _internal_access_config_updates(index);
}
inline ::cosmwasm::wasm::v1::AccessConfigUpdate* UpdateInstantiateConfigProposal::_internal_add_access_config_updates() {
  return _internal_mutable_access_config_updates()->Add();
}
inline ::cosmwasm::wasm::v1::AccessConfigUpdate* UpdateInstantiateConfigProposal::add_access_config_updates() {
  ::cosmwasm::wasm::v1::AccessConfigUpdate* _add = _internal_add_access_config_updates();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.access_config_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::AccessConfigUpdate >&
UpdateInstantiateConfigProposal::access_config_updates() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.UpdateInstantiateConfigProposal.access_config_updates)
  return _internal_access_config_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::AccessConfigUpdate>&
UpdateInstantiateConfigProposal::_internal_access_config_updates() const {
  return _impl_.access_config_updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::AccessConfigUpdate>*
UpdateInstantiateConfigProposal::_internal_mutable_access_config_updates() {
  return &_impl_.access_config_updates_;
}

// -------------------------------------------------------------------

// StoreAndInstantiateContractProposal

// string title = 1 [json_name = "title"];
inline void StoreAndInstantiateContractProposal::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::title() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_title(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.title)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.title)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_title() const {
  return _impl_.title_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_title(const std::string& value) {
  ;


  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_title() {
  ;
  return _impl_.title_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_title() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.title)
  return _impl_.title_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_title(std::string* value) {
  _impl_.title_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.title)
}

// string description = 2 [json_name = "description"];
inline void StoreAndInstantiateContractProposal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::description() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.description)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.description)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_description() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.description)
  return _impl_.description_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.description)
}

// string run_as = 3 [json_name = "runAs"];
inline void StoreAndInstantiateContractProposal::clear_run_as() {
  _impl_.run_as_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::run_as() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.run_as)
  return _internal_run_as();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_run_as(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.run_as_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.run_as)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_run_as() {
  std::string* _s = _internal_mutable_run_as();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.run_as)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_run_as() const {
  return _impl_.run_as_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_run_as(const std::string& value) {
  ;


  _impl_.run_as_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_run_as() {
  ;
  return _impl_.run_as_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_run_as() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.run_as)
  return _impl_.run_as_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_run_as(std::string* value) {
  _impl_.run_as_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.run_as_.IsDefault()) {
          _impl_.run_as_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.run_as)
}

// bytes wasm_byte_code = 4 [json_name = "wasmByteCode", (.gogoproto.customname) = "WASMByteCode"];
inline void StoreAndInstantiateContractProposal::clear_wasm_byte_code() {
  _impl_.wasm_byte_code_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::wasm_byte_code() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.wasm_byte_code)
  return _internal_wasm_byte_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_wasm_byte_code(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.wasm_byte_code_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.wasm_byte_code)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_wasm_byte_code() {
  std::string* _s = _internal_mutable_wasm_byte_code();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.wasm_byte_code)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_wasm_byte_code() const {
  return _impl_.wasm_byte_code_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_wasm_byte_code(const std::string& value) {
  ;


  _impl_.wasm_byte_code_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_wasm_byte_code() {
  ;
  return _impl_.wasm_byte_code_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_wasm_byte_code() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.wasm_byte_code)
  return _impl_.wasm_byte_code_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_wasm_byte_code(std::string* value) {
  _impl_.wasm_byte_code_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wasm_byte_code_.IsDefault()) {
          _impl_.wasm_byte_code_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.wasm_byte_code)
}

// .cosmwasm.wasm.v1.AccessConfig instantiate_permission = 5 [json_name = "instantiatePermission"];
inline bool StoreAndInstantiateContractProposal::has_instantiate_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantiate_permission_ != nullptr);
  return value;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& StoreAndInstantiateContractProposal::_internal_instantiate_permission() const {
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.instantiate_permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(
      ::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& StoreAndInstantiateContractProposal::instantiate_permission() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.instantiate_permission)
  return _internal_instantiate_permission();
}
inline void StoreAndInstantiateContractProposal::unsafe_arena_set_allocated_instantiate_permission(
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  if (instantiate_permission) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.instantiate_permission)
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreAndInstantiateContractProposal::release_instantiate_permission() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreAndInstantiateContractProposal::unsafe_arena_release_instantiate_permission() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.instantiate_permission)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_permission_;
  _impl_.instantiate_permission_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreAndInstantiateContractProposal::_internal_mutable_instantiate_permission() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instantiate_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(GetArenaForAllocation());
    _impl_.instantiate_permission_ = p;
  }
  return _impl_.instantiate_permission_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* StoreAndInstantiateContractProposal::mutable_instantiate_permission() {
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_instantiate_permission();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.instantiate_permission)
  return _msg;
}
inline void StoreAndInstantiateContractProposal::set_allocated_instantiate_permission(::cosmwasm::wasm::v1::AccessConfig* instantiate_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_permission_);
  }
  if (instantiate_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantiate_permission));
    if (message_arena != submessage_arena) {
      instantiate_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantiate_permission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instantiate_permission_ = instantiate_permission;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.instantiate_permission)
}

// bool unpin_code = 6 [json_name = "unpinCode"];
inline void StoreAndInstantiateContractProposal::clear_unpin_code() {
  _impl_.unpin_code_ = false;
}
inline bool StoreAndInstantiateContractProposal::unpin_code() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.unpin_code)
  return _internal_unpin_code();
}
inline void StoreAndInstantiateContractProposal::set_unpin_code(bool value) {
  _internal_set_unpin_code(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.unpin_code)
}
inline bool StoreAndInstantiateContractProposal::_internal_unpin_code() const {
  return _impl_.unpin_code_;
}
inline void StoreAndInstantiateContractProposal::_internal_set_unpin_code(bool value) {
  ;
  _impl_.unpin_code_ = value;
}

// string admin = 7 [json_name = "admin"];
inline void StoreAndInstantiateContractProposal::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::admin() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.admin)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.admin)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_admin() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.admin)
  return _impl_.admin_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.admin)
}

// string label = 8 [json_name = "label"];
inline void StoreAndInstantiateContractProposal::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::label() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.label)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.label)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_label() const {
  return _impl_.label_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_label() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.label)
  return _impl_.label_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.label)
}

// bytes msg = 9 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void StoreAndInstantiateContractProposal::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.msg)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.msg)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.msg)
  return _impl_.msg_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.msg)
}

// repeated .cosmos.base.v1beta1.Coin funds = 10 [json_name = "funds", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int StoreAndInstantiateContractProposal::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int StoreAndInstantiateContractProposal::funds_size() const {
  return _internal_funds_size();
}
inline ::cosmos::base::v1beta1::Coin* StoreAndInstantiateContractProposal::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
StoreAndInstantiateContractProposal::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.funds)
  return _internal_mutable_funds();
}
inline const ::cosmos::base::v1beta1::Coin& StoreAndInstantiateContractProposal::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& StoreAndInstantiateContractProposal::funds(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.funds)
  return _internal_funds(index);
}
inline ::cosmos::base::v1beta1::Coin* StoreAndInstantiateContractProposal::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::cosmos::base::v1beta1::Coin* StoreAndInstantiateContractProposal::add_funds() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
StoreAndInstantiateContractProposal::funds() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
StoreAndInstantiateContractProposal::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
StoreAndInstantiateContractProposal::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// string source = 11 [json_name = "source"];
inline void StoreAndInstantiateContractProposal::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::source() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_source(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.source)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.source)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_source() const {
  return _impl_.source_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_source(const std::string& value) {
  ;


  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_source() {
  ;
  return _impl_.source_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_source() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.source)
  return _impl_.source_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_source(std::string* value) {
  _impl_.source_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.source)
}

// string builder = 12 [json_name = "builder"];
inline void StoreAndInstantiateContractProposal::clear_builder() {
  _impl_.builder_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::builder() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.builder)
  return _internal_builder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_builder(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.builder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.builder)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_builder() {
  std::string* _s = _internal_mutable_builder();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.builder)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_builder() const {
  return _impl_.builder_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_builder(const std::string& value) {
  ;


  _impl_.builder_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_builder() {
  ;
  return _impl_.builder_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_builder() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.builder)
  return _impl_.builder_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_builder(std::string* value) {
  _impl_.builder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.builder_.IsDefault()) {
          _impl_.builder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.builder)
}

// bytes code_hash = 13 [json_name = "codeHash"];
inline void StoreAndInstantiateContractProposal::clear_code_hash() {
  _impl_.code_hash_.ClearToEmpty();
}
inline const std::string& StoreAndInstantiateContractProposal::code_hash() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.code_hash)
  return _internal_code_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreAndInstantiateContractProposal::set_code_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.code_hash)
}
inline std::string* StoreAndInstantiateContractProposal::mutable_code_hash() {
  std::string* _s = _internal_mutable_code_hash();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.code_hash)
  return _s;
}
inline const std::string& StoreAndInstantiateContractProposal::_internal_code_hash() const {
  return _impl_.code_hash_.Get();
}
inline void StoreAndInstantiateContractProposal::_internal_set_code_hash(const std::string& value) {
  ;


  _impl_.code_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::_internal_mutable_code_hash() {
  ;
  return _impl_.code_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* StoreAndInstantiateContractProposal::release_code_hash() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.code_hash)
  return _impl_.code_hash_.Release();
}
inline void StoreAndInstantiateContractProposal::set_allocated_code_hash(std::string* value) {
  _impl_.code_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_hash_.IsDefault()) {
          _impl_.code_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.StoreAndInstantiateContractProposal.code_hash)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fproposal_2eproto_2epb_2eh
