// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmwasm/wasm/v1/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "cosmos_proto/cosmos.pb.h"
#include "gogoproto/gogo.pb.h"
#include "google/protobuf/any.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmwasm_2fwasm_2fv1_2ftypes_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
namespace cosmwasm {
namespace wasm {
namespace v1 {
class AbsoluteTxPosition;
struct AbsoluteTxPositionDefaultTypeInternal;
extern AbsoluteTxPositionDefaultTypeInternal _AbsoluteTxPosition_default_instance_;
class AccessConfig;
struct AccessConfigDefaultTypeInternal;
extern AccessConfigDefaultTypeInternal _AccessConfig_default_instance_;
class AccessTypeParam;
struct AccessTypeParamDefaultTypeInternal;
extern AccessTypeParamDefaultTypeInternal _AccessTypeParam_default_instance_;
class CodeInfo;
struct CodeInfoDefaultTypeInternal;
extern CodeInfoDefaultTypeInternal _CodeInfo_default_instance_;
class ContractCodeHistoryEntry;
struct ContractCodeHistoryEntryDefaultTypeInternal;
extern ContractCodeHistoryEntryDefaultTypeInternal _ContractCodeHistoryEntry_default_instance_;
class ContractInfo;
struct ContractInfoDefaultTypeInternal;
extern ContractInfoDefaultTypeInternal _ContractInfo_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Params;
struct ParamsDefaultTypeInternal;
extern ParamsDefaultTypeInternal _Params_default_instance_;
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmwasm::wasm::v1::AbsoluteTxPosition* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AbsoluteTxPosition>(Arena*);
template <>
::cosmwasm::wasm::v1::AccessConfig* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(Arena*);
template <>
::cosmwasm::wasm::v1::AccessTypeParam* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AccessTypeParam>(Arena*);
template <>
::cosmwasm::wasm::v1::CodeInfo* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::CodeInfo>(Arena*);
template <>
::cosmwasm::wasm::v1::ContractCodeHistoryEntry* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ContractCodeHistoryEntry>(Arena*);
template <>
::cosmwasm::wasm::v1::ContractInfo* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ContractInfo>(Arena*);
template <>
::cosmwasm::wasm::v1::Model* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::Model>(Arena*);
template <>
::cosmwasm::wasm::v1::Params* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::Params>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmwasm {
namespace wasm {
namespace v1 {
enum AccessType : int {
  ACCESS_TYPE_UNSPECIFIED = 0,
  ACCESS_TYPE_NOBODY = 1,
  ACCESS_TYPE_EVERYBODY = 3,
  ACCESS_TYPE_ANY_OF_ADDRESSES = 4,
  AccessType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccessType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccessType_IsValid(int value);
constexpr AccessType AccessType_MIN = static_cast<AccessType>(0);
constexpr AccessType AccessType_MAX = static_cast<AccessType>(4);
constexpr int AccessType_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
AccessType_descriptor();
template <typename T>
const std::string& AccessType_Name(T value) {
  static_assert(std::is_same<T, AccessType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccessType_Name().");
  return AccessType_Name(static_cast<AccessType>(value));
}
template <>
inline const std::string& AccessType_Name(AccessType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<AccessType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AccessType_Parse(absl::string_view name, AccessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccessType>(
      AccessType_descriptor(), name, value);
}
enum ContractCodeHistoryOperationType : int {
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2,
  CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3,
  ContractCodeHistoryOperationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ContractCodeHistoryOperationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ContractCodeHistoryOperationType_IsValid(int value);
constexpr ContractCodeHistoryOperationType ContractCodeHistoryOperationType_MIN = static_cast<ContractCodeHistoryOperationType>(0);
constexpr ContractCodeHistoryOperationType ContractCodeHistoryOperationType_MAX = static_cast<ContractCodeHistoryOperationType>(3);
constexpr int ContractCodeHistoryOperationType_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ContractCodeHistoryOperationType_descriptor();
template <typename T>
const std::string& ContractCodeHistoryOperationType_Name(T value) {
  static_assert(std::is_same<T, ContractCodeHistoryOperationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ContractCodeHistoryOperationType_Name().");
  return ContractCodeHistoryOperationType_Name(static_cast<ContractCodeHistoryOperationType>(value));
}
template <>
inline const std::string& ContractCodeHistoryOperationType_Name(ContractCodeHistoryOperationType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ContractCodeHistoryOperationType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ContractCodeHistoryOperationType_Parse(absl::string_view name, ContractCodeHistoryOperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContractCodeHistoryOperationType>(
      ContractCodeHistoryOperationType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class AccessTypeParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AccessTypeParam) */ {
 public:
  inline AccessTypeParam() : AccessTypeParam(nullptr) {}
  ~AccessTypeParam() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccessTypeParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessTypeParam(const AccessTypeParam& from);
  AccessTypeParam(AccessTypeParam&& from) noexcept
    : AccessTypeParam() {
    *this = ::std::move(from);
  }

  inline AccessTypeParam& operator=(const AccessTypeParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessTypeParam& operator=(AccessTypeParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessTypeParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessTypeParam* internal_default_instance() {
    return reinterpret_cast<const AccessTypeParam*>(
               &_AccessTypeParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AccessTypeParam& a, AccessTypeParam& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessTypeParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessTypeParam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessTypeParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessTypeParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccessTypeParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccessTypeParam& from) {
    AccessTypeParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessTypeParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AccessTypeParam";
  }
  protected:
  explicit AccessTypeParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .cosmwasm.wasm.v1.AccessType value = 1 [json_name = "value", (.gogoproto.moretags) = "yaml:\"value\""];
  void clear_value() ;
  ::cosmwasm::wasm::v1::AccessType value() const;
  void set_value(::cosmwasm::wasm::v1::AccessType value);

  private:
  ::cosmwasm::wasm::v1::AccessType _internal_value() const;
  void _internal_set_value(::cosmwasm::wasm::v1::AccessType value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AccessTypeParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class AccessConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AccessConfig) */ {
 public:
  inline AccessConfig() : AccessConfig(nullptr) {}
  ~AccessConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccessConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccessConfig(const AccessConfig& from);
  AccessConfig(AccessConfig&& from) noexcept
    : AccessConfig() {
    *this = ::std::move(from);
  }

  inline AccessConfig& operator=(const AccessConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessConfig& operator=(AccessConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccessConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccessConfig* internal_default_instance() {
    return reinterpret_cast<const AccessConfig*>(
               &_AccessConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AccessConfig& a, AccessConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccessConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccessConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccessConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccessConfig& from) {
    AccessConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AccessConfig";
  }
  protected:
  explicit AccessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 3,
    kPermissionFieldNumber = 1,
  };
  // repeated string addresses = 3 [json_name = "addresses", (.gogoproto.moretags) = "yaml:\"addresses\""];
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;

  public:
  void clear_addresses() ;
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, std::size_t size);
  void set_addresses(int index, absl::string_view value);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, std::size_t size);
  void add_addresses(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();

  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_addresses();

  public:
  // .cosmwasm.wasm.v1.AccessType permission = 1 [json_name = "permission", (.gogoproto.moretags) = "yaml:\"permission\""];
  void clear_permission() ;
  ::cosmwasm::wasm::v1::AccessType permission() const;
  void set_permission(::cosmwasm::wasm::v1::AccessType value);

  private:
  ::cosmwasm::wasm::v1::AccessType _internal_permission() const;
  void _internal_set_permission(::cosmwasm::wasm::v1::AccessType value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AccessConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
    int permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Params final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.Params) */ {
 public:
  inline Params() : Params(nullptr) {}
  ~Params() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Params(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Params(const Params& from);
  Params(Params&& from) noexcept
    : Params() {
    *this = ::std::move(from);
  }

  inline Params& operator=(const Params& from) {
    CopyFrom(from);
    return *this;
  }
  inline Params& operator=(Params&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Params& default_instance() {
    return *internal_default_instance();
  }
  static inline const Params* internal_default_instance() {
    return reinterpret_cast<const Params*>(
               &_Params_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Params& a, Params& b) {
    a.Swap(&b);
  }
  inline void Swap(Params* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Params* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Params* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Params>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Params& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Params& from) {
    Params::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Params* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.Params";
  }
  protected:
  explicit Params(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeUploadAccessFieldNumber = 1,
    kInstantiateDefaultPermissionFieldNumber = 2,
  };
  // .cosmwasm.wasm.v1.AccessConfig code_upload_access = 1 [json_name = "codeUploadAccess", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"code_upload_access\"", (.amino.dont_omitempty) = true];
  bool has_code_upload_access() const;
  void clear_code_upload_access() ;
  const ::cosmwasm::wasm::v1::AccessConfig& code_upload_access() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_code_upload_access();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_code_upload_access();
  void set_allocated_code_upload_access(::cosmwasm::wasm::v1::AccessConfig* code_upload_access);
  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_code_upload_access() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_code_upload_access();
  public:
  void unsafe_arena_set_allocated_code_upload_access(
      ::cosmwasm::wasm::v1::AccessConfig* code_upload_access);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_code_upload_access();
  // .cosmwasm.wasm.v1.AccessType instantiate_default_permission = 2 [json_name = "instantiateDefaultPermission", (.gogoproto.moretags) = "yaml:\"instantiate_default_permission\""];
  void clear_instantiate_default_permission() ;
  ::cosmwasm::wasm::v1::AccessType instantiate_default_permission() const;
  void set_instantiate_default_permission(::cosmwasm::wasm::v1::AccessType value);

  private:
  ::cosmwasm::wasm::v1::AccessType _internal_instantiate_default_permission() const;
  void _internal_set_instantiate_default_permission(::cosmwasm::wasm::v1::AccessType value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.Params)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::cosmwasm::wasm::v1::AccessConfig* code_upload_access_;
    int instantiate_default_permission_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class CodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.CodeInfo) */ {
 public:
  inline CodeInfo() : CodeInfo(nullptr) {}
  ~CodeInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CodeInfo(const CodeInfo& from);
  CodeInfo(CodeInfo&& from) noexcept
    : CodeInfo() {
    *this = ::std::move(from);
  }

  inline CodeInfo& operator=(const CodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeInfo& operator=(CodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodeInfo* internal_default_instance() {
    return reinterpret_cast<const CodeInfo*>(
               &_CodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CodeInfo& a, CodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CodeInfo& from) {
    CodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.CodeInfo";
  }
  protected:
  explicit CodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeHashFieldNumber = 1,
    kCreatorFieldNumber = 2,
    kInstantiateConfigFieldNumber = 5,
  };
  // bytes code_hash = 1 [json_name = "codeHash"];
  void clear_code_hash() ;
  const std::string& code_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_hash(Arg_&& arg, Args_... args);
  std::string* mutable_code_hash();
  PROTOBUF_NODISCARD std::string* release_code_hash();
  void set_allocated_code_hash(std::string* ptr);

  private:
  const std::string& _internal_code_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_hash(
      const std::string& value);
  std::string* _internal_mutable_code_hash();

  public:
  // string creator = 2 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // .cosmwasm.wasm.v1.AccessConfig instantiate_config = 5 [json_name = "instantiateConfig", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  bool has_instantiate_config() const;
  void clear_instantiate_config() ;
  const ::cosmwasm::wasm::v1::AccessConfig& instantiate_config() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AccessConfig* release_instantiate_config();
  ::cosmwasm::wasm::v1::AccessConfig* mutable_instantiate_config();
  void set_allocated_instantiate_config(::cosmwasm::wasm::v1::AccessConfig* instantiate_config);
  private:
  const ::cosmwasm::wasm::v1::AccessConfig& _internal_instantiate_config() const;
  ::cosmwasm::wasm::v1::AccessConfig* _internal_mutable_instantiate_config();
  public:
  void unsafe_arena_set_allocated_instantiate_config(
      ::cosmwasm::wasm::v1::AccessConfig* instantiate_config);
  ::cosmwasm::wasm::v1::AccessConfig* unsafe_arena_release_instantiate_config();
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.CodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_config_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ContractInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractInfo) */ {
 public:
  inline ContractInfo() : ContractInfo(nullptr) {}
  ~ContractInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractInfo(const ContractInfo& from);
  ContractInfo(ContractInfo&& from) noexcept
    : ContractInfo() {
    *this = ::std::move(from);
  }

  inline ContractInfo& operator=(const ContractInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractInfo& operator=(ContractInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractInfo* internal_default_instance() {
    return reinterpret_cast<const ContractInfo*>(
               &_ContractInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContractInfo& a, ContractInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractInfo& from) {
    ContractInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ContractInfo";
  }
  protected:
  explicit ContractInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorFieldNumber = 2,
    kAdminFieldNumber = 3,
    kLabelFieldNumber = 4,
    kIbcPortIdFieldNumber = 6,
    kCreatedFieldNumber = 5,
    kExtensionFieldNumber = 7,
    kCodeIdFieldNumber = 1,
  };
  // string creator = 2 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // string admin = 3 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string label = 4 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // string ibc_port_id = 6 [json_name = "ibcPortId", (.gogoproto.customname) = "IBCPortID"];
  void clear_ibc_port_id() ;
  const std::string& ibc_port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ibc_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_ibc_port_id();
  PROTOBUF_NODISCARD std::string* release_ibc_port_id();
  void set_allocated_ibc_port_id(std::string* ptr);

  private:
  const std::string& _internal_ibc_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ibc_port_id(
      const std::string& value);
  std::string* _internal_mutable_ibc_port_id();

  public:
  // .cosmwasm.wasm.v1.AbsoluteTxPosition created = 5 [json_name = "created"];
  bool has_created() const;
  void clear_created() ;
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition& created() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AbsoluteTxPosition* release_created();
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* mutable_created();
  void set_allocated_created(::cosmwasm::wasm::v1::AbsoluteTxPosition* created);
  private:
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition& _internal_created() const;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::cosmwasm::wasm::v1::AbsoluteTxPosition* created);
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* unsafe_arena_release_created();
  // .google.protobuf.Any extension = 7 [json_name = "extension", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractInfoExtension"];
  bool has_extension() const;
  void clear_extension() ;
  const ::PROTOBUF_NAMESPACE_ID::Any& extension() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_extension();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_extension();
  void set_allocated_extension(::PROTOBUF_NAMESPACE_ID::Any* extension);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_extension() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_extension();
  public:
  void unsafe_arena_set_allocated_extension(
      ::PROTOBUF_NAMESPACE_ID::Any* extension);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_extension();
  // uint64 code_id = 1 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ibc_port_id_;
    ::cosmwasm::wasm::v1::AbsoluteTxPosition* created_;
    ::PROTOBUF_NAMESPACE_ID::Any* extension_;
    ::uint64_t code_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class ContractCodeHistoryEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractCodeHistoryEntry) */ {
 public:
  inline ContractCodeHistoryEntry() : ContractCodeHistoryEntry(nullptr) {}
  ~ContractCodeHistoryEntry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractCodeHistoryEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractCodeHistoryEntry(const ContractCodeHistoryEntry& from);
  ContractCodeHistoryEntry(ContractCodeHistoryEntry&& from) noexcept
    : ContractCodeHistoryEntry() {
    *this = ::std::move(from);
  }

  inline ContractCodeHistoryEntry& operator=(const ContractCodeHistoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractCodeHistoryEntry& operator=(ContractCodeHistoryEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractCodeHistoryEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractCodeHistoryEntry* internal_default_instance() {
    return reinterpret_cast<const ContractCodeHistoryEntry*>(
               &_ContractCodeHistoryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ContractCodeHistoryEntry& a, ContractCodeHistoryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractCodeHistoryEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractCodeHistoryEntry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractCodeHistoryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractCodeHistoryEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractCodeHistoryEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractCodeHistoryEntry& from) {
    ContractCodeHistoryEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractCodeHistoryEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ContractCodeHistoryEntry";
  }
  protected:
  explicit ContractCodeHistoryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 4,
    kUpdatedFieldNumber = 3,
    kCodeIdFieldNumber = 2,
    kOperationFieldNumber = 1,
  };
  // bytes msg = 4 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
  void clear_msg() ;
  const std::string& msg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* ptr);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // .cosmwasm.wasm.v1.AbsoluteTxPosition updated = 3 [json_name = "updated"];
  bool has_updated() const;
  void clear_updated() ;
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition& updated() const;
  PROTOBUF_NODISCARD ::cosmwasm::wasm::v1::AbsoluteTxPosition* release_updated();
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* mutable_updated();
  void set_allocated_updated(::cosmwasm::wasm::v1::AbsoluteTxPosition* updated);
  private:
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition& _internal_updated() const;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* _internal_mutable_updated();
  public:
  void unsafe_arena_set_allocated_updated(
      ::cosmwasm::wasm::v1::AbsoluteTxPosition* updated);
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* unsafe_arena_release_updated();
  // uint64 code_id = 2 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // .cosmwasm.wasm.v1.ContractCodeHistoryOperationType operation = 1 [json_name = "operation"];
  void clear_operation() ;
  ::cosmwasm::wasm::v1::ContractCodeHistoryOperationType operation() const;
  void set_operation(::cosmwasm::wasm::v1::ContractCodeHistoryOperationType value);

  private:
  ::cosmwasm::wasm::v1::ContractCodeHistoryOperationType _internal_operation() const;
  void _internal_set_operation(::cosmwasm::wasm::v1::ContractCodeHistoryOperationType value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractCodeHistoryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::cosmwasm::wasm::v1::AbsoluteTxPosition* updated_;
    ::uint64_t code_id_;
    int operation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class AbsoluteTxPosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AbsoluteTxPosition) */ {
 public:
  inline AbsoluteTxPosition() : AbsoluteTxPosition(nullptr) {}
  ~AbsoluteTxPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AbsoluteTxPosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbsoluteTxPosition(const AbsoluteTxPosition& from);
  AbsoluteTxPosition(AbsoluteTxPosition&& from) noexcept
    : AbsoluteTxPosition() {
    *this = ::std::move(from);
  }

  inline AbsoluteTxPosition& operator=(const AbsoluteTxPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteTxPosition& operator=(AbsoluteTxPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbsoluteTxPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbsoluteTxPosition* internal_default_instance() {
    return reinterpret_cast<const AbsoluteTxPosition*>(
               &_AbsoluteTxPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AbsoluteTxPosition& a, AbsoluteTxPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteTxPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteTxPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbsoluteTxPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbsoluteTxPosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbsoluteTxPosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AbsoluteTxPosition& from) {
    AbsoluteTxPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteTxPosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AbsoluteTxPosition";
  }
  protected:
  explicit AbsoluteTxPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockHeightFieldNumber = 1,
    kTxIndexFieldNumber = 2,
  };
  // uint64 block_height = 1 [json_name = "blockHeight"];
  void clear_block_height() ;
  ::uint64_t block_height() const;
  void set_block_height(::uint64_t value);

  private:
  ::uint64_t _internal_block_height() const;
  void _internal_set_block_height(::uint64_t value);

  public:
  // uint64 tx_index = 2 [json_name = "txIndex"];
  void clear_tx_index() ;
  ::uint64_t tx_index() const;
  void set_tx_index(::uint64_t value);

  private:
  ::uint64_t _internal_tx_index() const;
  void _internal_set_tx_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AbsoluteTxPosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t block_height_;
    ::uint64_t tx_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes key = 1 [json_name = "key", (.gogoproto.casttype) = "github.com/cometbft/cometbft/libs/bytes.HexBytes"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // bytes value = 2 [json_name = "value"];
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AccessTypeParam

// .cosmwasm.wasm.v1.AccessType value = 1 [json_name = "value", (.gogoproto.moretags) = "yaml:\"value\""];
inline void AccessTypeParam::clear_value() {
  _impl_.value_ = 0;
}
inline ::cosmwasm::wasm::v1::AccessType AccessTypeParam::value() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AccessTypeParam.value)
  return _internal_value();
}
inline void AccessTypeParam::set_value(::cosmwasm::wasm::v1::AccessType value) {
   _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AccessTypeParam.value)
}
inline ::cosmwasm::wasm::v1::AccessType AccessTypeParam::_internal_value() const {
  return static_cast<::cosmwasm::wasm::v1::AccessType>(_impl_.value_);
}
inline void AccessTypeParam::_internal_set_value(::cosmwasm::wasm::v1::AccessType value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// AccessConfig

// .cosmwasm.wasm.v1.AccessType permission = 1 [json_name = "permission", (.gogoproto.moretags) = "yaml:\"permission\""];
inline void AccessConfig::clear_permission() {
  _impl_.permission_ = 0;
}
inline ::cosmwasm::wasm::v1::AccessType AccessConfig::permission() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AccessConfig.permission)
  return _internal_permission();
}
inline void AccessConfig::set_permission(::cosmwasm::wasm::v1::AccessType value) {
   _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AccessConfig.permission)
}
inline ::cosmwasm::wasm::v1::AccessType AccessConfig::_internal_permission() const {
  return static_cast<::cosmwasm::wasm::v1::AccessType>(_impl_.permission_);
}
inline void AccessConfig::_internal_set_permission(::cosmwasm::wasm::v1::AccessType value) {
  ;
  _impl_.permission_ = value;
}

// repeated string addresses = 3 [json_name = "addresses", (.gogoproto.moretags) = "yaml:\"addresses\""];
inline int AccessConfig::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int AccessConfig::addresses_size() const {
  return _internal_addresses_size();
}
inline void AccessConfig::clear_addresses() {
  _internal_mutable_addresses()->Clear();
}
inline std::string* AccessConfig::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:cosmwasm.wasm.v1.AccessConfig.addresses)
  return _s;
}
inline const std::string& AccessConfig::addresses(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AccessConfig.addresses)
  return _internal_addresses(index);
}
inline std::string* AccessConfig::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AccessConfig.addresses)
  return _internal_mutable_addresses()->Mutable(index);
}
inline void AccessConfig::set_addresses(int index, const std::string& value) {
  _internal_mutable_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::set_addresses(int index, std::string&& value) {
  _internal_mutable_addresses()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::set_addresses(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_addresses()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::set_addresses(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_addresses()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::set_addresses(int index, absl::string_view value) {
  _internal_mutable_addresses()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::add_addresses(const std::string& value) {
  _internal_mutable_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::add_addresses(std::string&& value) {
  _internal_mutable_addresses()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::add_addresses(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_addresses()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::add_addresses(const char* value, std::size_t size) {
  _internal_mutable_addresses()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline void AccessConfig::add_addresses(absl::string_view value) {
  _internal_mutable_addresses()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmwasm.wasm.v1.AccessConfig.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccessConfig::addresses() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.AccessConfig.addresses)
  return _internal_addresses();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AccessConfig::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.AccessConfig.addresses)
  return _internal_mutable_addresses();
}
inline const std::string& AccessConfig::_internal_addresses(int index) const {
  return _internal_addresses().Get(index);
}
inline std::string* AccessConfig::_internal_add_addresses() {
  return _internal_mutable_addresses()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccessConfig::_internal_addresses() const {
  return _impl_.addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccessConfig::_internal_mutable_addresses() {
  return &_impl_.addresses_;
}

// -------------------------------------------------------------------

// Params

// .cosmwasm.wasm.v1.AccessConfig code_upload_access = 1 [json_name = "codeUploadAccess", (.gogoproto.nullable) = false, (.gogoproto.moretags) = "yaml:\"code_upload_access\"", (.amino.dont_omitempty) = true];
inline bool Params::has_code_upload_access() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.code_upload_access_ != nullptr);
  return value;
}
inline void Params::clear_code_upload_access() {
  if (_impl_.code_upload_access_ != nullptr) _impl_.code_upload_access_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& Params::_internal_code_upload_access() const {
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.code_upload_access_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(
      ::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& Params::code_upload_access() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.Params.code_upload_access)
  return _internal_code_upload_access();
}
inline void Params::unsafe_arena_set_allocated_code_upload_access(
    ::cosmwasm::wasm::v1::AccessConfig* code_upload_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.code_upload_access_);
  }
  _impl_.code_upload_access_ = code_upload_access;
  if (code_upload_access) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.Params.code_upload_access)
}
inline ::cosmwasm::wasm::v1::AccessConfig* Params::release_code_upload_access() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.code_upload_access_;
  _impl_.code_upload_access_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* Params::unsafe_arena_release_code_upload_access() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.Params.code_upload_access)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.code_upload_access_;
  _impl_.code_upload_access_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* Params::_internal_mutable_code_upload_access() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.code_upload_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(GetArenaForAllocation());
    _impl_.code_upload_access_ = p;
  }
  return _impl_.code_upload_access_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* Params::mutable_code_upload_access() {
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_code_upload_access();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.Params.code_upload_access)
  return _msg;
}
inline void Params::set_allocated_code_upload_access(::cosmwasm::wasm::v1::AccessConfig* code_upload_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.code_upload_access_;
  }
  if (code_upload_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(code_upload_access);
    if (message_arena != submessage_arena) {
      code_upload_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, code_upload_access, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_upload_access_ = code_upload_access;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.Params.code_upload_access)
}

// .cosmwasm.wasm.v1.AccessType instantiate_default_permission = 2 [json_name = "instantiateDefaultPermission", (.gogoproto.moretags) = "yaml:\"instantiate_default_permission\""];
inline void Params::clear_instantiate_default_permission() {
  _impl_.instantiate_default_permission_ = 0;
}
inline ::cosmwasm::wasm::v1::AccessType Params::instantiate_default_permission() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.Params.instantiate_default_permission)
  return _internal_instantiate_default_permission();
}
inline void Params::set_instantiate_default_permission(::cosmwasm::wasm::v1::AccessType value) {
   _internal_set_instantiate_default_permission(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.Params.instantiate_default_permission)
}
inline ::cosmwasm::wasm::v1::AccessType Params::_internal_instantiate_default_permission() const {
  return static_cast<::cosmwasm::wasm::v1::AccessType>(_impl_.instantiate_default_permission_);
}
inline void Params::_internal_set_instantiate_default_permission(::cosmwasm::wasm::v1::AccessType value) {
  ;
  _impl_.instantiate_default_permission_ = value;
}

// -------------------------------------------------------------------

// CodeInfo

// bytes code_hash = 1 [json_name = "codeHash"];
inline void CodeInfo::clear_code_hash() {
  _impl_.code_hash_.ClearToEmpty();
}
inline const std::string& CodeInfo::code_hash() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CodeInfo.code_hash)
  return _internal_code_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CodeInfo::set_code_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.CodeInfo.code_hash)
}
inline std::string* CodeInfo::mutable_code_hash() {
  std::string* _s = _internal_mutable_code_hash();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CodeInfo.code_hash)
  return _s;
}
inline const std::string& CodeInfo::_internal_code_hash() const {
  return _impl_.code_hash_.Get();
}
inline void CodeInfo::_internal_set_code_hash(const std::string& value) {
  ;


  _impl_.code_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CodeInfo::_internal_mutable_code_hash() {
  ;
  return _impl_.code_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* CodeInfo::release_code_hash() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.CodeInfo.code_hash)
  return _impl_.code_hash_.Release();
}
inline void CodeInfo::set_allocated_code_hash(std::string* value) {
  _impl_.code_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_hash_.IsDefault()) {
          _impl_.code_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.CodeInfo.code_hash)
}

// string creator = 2 [json_name = "creator"];
inline void CodeInfo::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& CodeInfo::creator() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CodeInfo.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CodeInfo::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.CodeInfo.creator)
}
inline std::string* CodeInfo::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CodeInfo.creator)
  return _s;
}
inline const std::string& CodeInfo::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void CodeInfo::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* CodeInfo::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* CodeInfo::release_creator() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.CodeInfo.creator)
  return _impl_.creator_.Release();
}
inline void CodeInfo::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.CodeInfo.creator)
}

// .cosmwasm.wasm.v1.AccessConfig instantiate_config = 5 [json_name = "instantiateConfig", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline bool CodeInfo::has_instantiate_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantiate_config_ != nullptr);
  return value;
}
inline void CodeInfo::clear_instantiate_config() {
  if (_impl_.instantiate_config_ != nullptr) _impl_.instantiate_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmwasm::wasm::v1::AccessConfig& CodeInfo::_internal_instantiate_config() const {
  const ::cosmwasm::wasm::v1::AccessConfig* p = _impl_.instantiate_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AccessConfig&>(
      ::cosmwasm::wasm::v1::_AccessConfig_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AccessConfig& CodeInfo::instantiate_config() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CodeInfo.instantiate_config)
  return _internal_instantiate_config();
}
inline void CodeInfo::unsafe_arena_set_allocated_instantiate_config(
    ::cosmwasm::wasm::v1::AccessConfig* instantiate_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantiate_config_);
  }
  _impl_.instantiate_config_ = instantiate_config;
  if (instantiate_config) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.CodeInfo.instantiate_config)
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeInfo::release_instantiate_config() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_config_;
  _impl_.instantiate_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeInfo::unsafe_arena_release_instantiate_config() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.CodeInfo.instantiate_config)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AccessConfig* temp = _impl_.instantiate_config_;
  _impl_.instantiate_config_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeInfo::_internal_mutable_instantiate_config() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.instantiate_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AccessConfig>(GetArenaForAllocation());
    _impl_.instantiate_config_ = p;
  }
  return _impl_.instantiate_config_;
}
inline ::cosmwasm::wasm::v1::AccessConfig* CodeInfo::mutable_instantiate_config() {
  ::cosmwasm::wasm::v1::AccessConfig* _msg = _internal_mutable_instantiate_config();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CodeInfo.instantiate_config)
  return _msg;
}
inline void CodeInfo::set_allocated_instantiate_config(::cosmwasm::wasm::v1::AccessConfig* instantiate_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instantiate_config_;
  }
  if (instantiate_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instantiate_config);
    if (message_arena != submessage_arena) {
      instantiate_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantiate_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.instantiate_config_ = instantiate_config;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.CodeInfo.instantiate_config)
}

// -------------------------------------------------------------------

// ContractInfo

// uint64 code_id = 1 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void ContractInfo::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t ContractInfo::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.code_id)
  return _internal_code_id();
}
inline void ContractInfo::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractInfo.code_id)
}
inline ::uint64_t ContractInfo::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void ContractInfo::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string creator = 2 [json_name = "creator"];
inline void ContractInfo::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& ContractInfo::creator() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractInfo::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractInfo.creator)
}
inline std::string* ContractInfo::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.creator)
  return _s;
}
inline const std::string& ContractInfo::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void ContractInfo::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractInfo::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractInfo::release_creator() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.creator)
  return _impl_.creator_.Release();
}
inline void ContractInfo::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.creator)
}

// string admin = 3 [json_name = "admin"];
inline void ContractInfo::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& ContractInfo::admin() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractInfo::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractInfo.admin)
}
inline std::string* ContractInfo::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.admin)
  return _s;
}
inline const std::string& ContractInfo::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void ContractInfo::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractInfo::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractInfo::release_admin() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.admin)
  return _impl_.admin_.Release();
}
inline void ContractInfo::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.admin)
}

// string label = 4 [json_name = "label"];
inline void ContractInfo::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& ContractInfo::label() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractInfo::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractInfo.label)
}
inline std::string* ContractInfo::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.label)
  return _s;
}
inline const std::string& ContractInfo::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ContractInfo::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractInfo::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractInfo::release_label() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.label)
  return _impl_.label_.Release();
}
inline void ContractInfo::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.label)
}

// .cosmwasm.wasm.v1.AbsoluteTxPosition created = 5 [json_name = "created"];
inline bool ContractInfo::has_created() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_ != nullptr);
  return value;
}
inline void ContractInfo::clear_created() {
  if (_impl_.created_ != nullptr) _impl_.created_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmwasm::wasm::v1::AbsoluteTxPosition& ContractInfo::_internal_created() const {
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition* p = _impl_.created_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AbsoluteTxPosition&>(
      ::cosmwasm::wasm::v1::_AbsoluteTxPosition_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AbsoluteTxPosition& ContractInfo::created() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.created)
  return _internal_created();
}
inline void ContractInfo::unsafe_arena_set_allocated_created(
    ::cosmwasm::wasm::v1::AbsoluteTxPosition* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_);
  }
  _impl_.created_ = created;
  if (created) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractInfo.created)
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractInfo::release_created() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* temp = _impl_.created_;
  _impl_.created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractInfo::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.created)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* temp = _impl_.created_;
  _impl_.created_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractInfo::_internal_mutable_created() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AbsoluteTxPosition>(GetArenaForAllocation());
    _impl_.created_ = p;
  }
  return _impl_.created_;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractInfo::mutable_created() {
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.created)
  return _msg;
}
inline void ContractInfo::set_allocated_created(::cosmwasm::wasm::v1::AbsoluteTxPosition* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.created_;
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(created);
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.created_ = created;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.created)
}

// string ibc_port_id = 6 [json_name = "ibcPortId", (.gogoproto.customname) = "IBCPortID"];
inline void ContractInfo::clear_ibc_port_id() {
  _impl_.ibc_port_id_.ClearToEmpty();
}
inline const std::string& ContractInfo::ibc_port_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.ibc_port_id)
  return _internal_ibc_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractInfo::set_ibc_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ibc_port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractInfo.ibc_port_id)
}
inline std::string* ContractInfo::mutable_ibc_port_id() {
  std::string* _s = _internal_mutable_ibc_port_id();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.ibc_port_id)
  return _s;
}
inline const std::string& ContractInfo::_internal_ibc_port_id() const {
  return _impl_.ibc_port_id_.Get();
}
inline void ContractInfo::_internal_set_ibc_port_id(const std::string& value) {
  ;


  _impl_.ibc_port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractInfo::_internal_mutable_ibc_port_id() {
  ;
  return _impl_.ibc_port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractInfo::release_ibc_port_id() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.ibc_port_id)
  return _impl_.ibc_port_id_.Release();
}
inline void ContractInfo::set_allocated_ibc_port_id(std::string* value) {
  _impl_.ibc_port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ibc_port_id_.IsDefault()) {
          _impl_.ibc_port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.ibc_port_id)
}

// .google.protobuf.Any extension = 7 [json_name = "extension", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractInfoExtension"];
inline bool ContractInfo::has_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extension_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractInfo::_internal_extension() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractInfo::extension() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractInfo.extension)
  return _internal_extension();
}
inline void ContractInfo::unsafe_arena_set_allocated_extension(
    ::PROTOBUF_NAMESPACE_ID::Any* extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  _impl_.extension_ = extension;
  if (extension) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractInfo.extension)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractInfo::release_extension() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractInfo::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractInfo.extension)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.extension_;
  _impl_.extension_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractInfo::_internal_mutable_extension() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.extension_ = p;
  }
  return _impl_.extension_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractInfo::mutable_extension() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractInfo.extension)
  return _msg;
}
inline void ContractInfo::set_allocated_extension(::PROTOBUF_NAMESPACE_ID::Any* extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_);
  }
  if (extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension));
    if (message_arena != submessage_arena) {
      extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractInfo.extension)
}

// -------------------------------------------------------------------

// ContractCodeHistoryEntry

// .cosmwasm.wasm.v1.ContractCodeHistoryOperationType operation = 1 [json_name = "operation"];
inline void ContractCodeHistoryEntry::clear_operation() {
  _impl_.operation_ = 0;
}
inline ::cosmwasm::wasm::v1::ContractCodeHistoryOperationType ContractCodeHistoryEntry::operation() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractCodeHistoryEntry.operation)
  return _internal_operation();
}
inline void ContractCodeHistoryEntry::set_operation(::cosmwasm::wasm::v1::ContractCodeHistoryOperationType value) {
   _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractCodeHistoryEntry.operation)
}
inline ::cosmwasm::wasm::v1::ContractCodeHistoryOperationType ContractCodeHistoryEntry::_internal_operation() const {
  return static_cast<::cosmwasm::wasm::v1::ContractCodeHistoryOperationType>(_impl_.operation_);
}
inline void ContractCodeHistoryEntry::_internal_set_operation(::cosmwasm::wasm::v1::ContractCodeHistoryOperationType value) {
  ;
  _impl_.operation_ = value;
}

// uint64 code_id = 2 [json_name = "codeId", (.gogoproto.customname) = "CodeID"];
inline void ContractCodeHistoryEntry::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t ContractCodeHistoryEntry::code_id() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractCodeHistoryEntry.code_id)
  return _internal_code_id();
}
inline void ContractCodeHistoryEntry::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractCodeHistoryEntry.code_id)
}
inline ::uint64_t ContractCodeHistoryEntry::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void ContractCodeHistoryEntry::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// .cosmwasm.wasm.v1.AbsoluteTxPosition updated = 3 [json_name = "updated"];
inline bool ContractCodeHistoryEntry::has_updated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_ != nullptr);
  return value;
}
inline void ContractCodeHistoryEntry::clear_updated() {
  if (_impl_.updated_ != nullptr) _impl_.updated_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::cosmwasm::wasm::v1::AbsoluteTxPosition& ContractCodeHistoryEntry::_internal_updated() const {
  const ::cosmwasm::wasm::v1::AbsoluteTxPosition* p = _impl_.updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::cosmwasm::wasm::v1::AbsoluteTxPosition&>(
      ::cosmwasm::wasm::v1::_AbsoluteTxPosition_default_instance_);
}
inline const ::cosmwasm::wasm::v1::AbsoluteTxPosition& ContractCodeHistoryEntry::updated() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractCodeHistoryEntry.updated)
  return _internal_updated();
}
inline void ContractCodeHistoryEntry::unsafe_arena_set_allocated_updated(
    ::cosmwasm::wasm::v1::AbsoluteTxPosition* updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_);
  }
  _impl_.updated_ = updated;
  if (updated) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractCodeHistoryEntry.updated)
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractCodeHistoryEntry::release_updated() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* temp = _impl_.updated_;
  _impl_.updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractCodeHistoryEntry::unsafe_arena_release_updated() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractCodeHistoryEntry.updated)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* temp = _impl_.updated_;
  _impl_.updated_ = nullptr;
  return temp;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractCodeHistoryEntry::_internal_mutable_updated() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::cosmwasm::wasm::v1::AbsoluteTxPosition>(GetArenaForAllocation());
    _impl_.updated_ = p;
  }
  return _impl_.updated_;
}
inline ::cosmwasm::wasm::v1::AbsoluteTxPosition* ContractCodeHistoryEntry::mutable_updated() {
  ::cosmwasm::wasm::v1::AbsoluteTxPosition* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractCodeHistoryEntry.updated)
  return _msg;
}
inline void ContractCodeHistoryEntry::set_allocated_updated(::cosmwasm::wasm::v1::AbsoluteTxPosition* updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.updated_;
  }
  if (updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updated);
    if (message_arena != submessage_arena) {
      updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.updated_ = updated;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractCodeHistoryEntry.updated)
}

// bytes msg = 4 [json_name = "msg", (.gogoproto.casttype) = "RawContractMessage"];
inline void ContractCodeHistoryEntry::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& ContractCodeHistoryEntry::msg() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractCodeHistoryEntry.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractCodeHistoryEntry::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractCodeHistoryEntry.msg)
}
inline std::string* ContractCodeHistoryEntry::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractCodeHistoryEntry.msg)
  return _s;
}
inline const std::string& ContractCodeHistoryEntry::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void ContractCodeHistoryEntry::_internal_set_msg(const std::string& value) {
  ;


  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractCodeHistoryEntry::_internal_mutable_msg() {
  ;
  return _impl_.msg_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractCodeHistoryEntry::release_msg() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractCodeHistoryEntry.msg)
  return _impl_.msg_.Release();
}
inline void ContractCodeHistoryEntry::set_allocated_msg(std::string* value) {
  _impl_.msg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractCodeHistoryEntry.msg)
}

// -------------------------------------------------------------------

// AbsoluteTxPosition

// uint64 block_height = 1 [json_name = "blockHeight"];
inline void AbsoluteTxPosition::clear_block_height() {
  _impl_.block_height_ = ::uint64_t{0u};
}
inline ::uint64_t AbsoluteTxPosition::block_height() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AbsoluteTxPosition.block_height)
  return _internal_block_height();
}
inline void AbsoluteTxPosition::set_block_height(::uint64_t value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AbsoluteTxPosition.block_height)
}
inline ::uint64_t AbsoluteTxPosition::_internal_block_height() const {
  return _impl_.block_height_;
}
inline void AbsoluteTxPosition::_internal_set_block_height(::uint64_t value) {
  ;
  _impl_.block_height_ = value;
}

// uint64 tx_index = 2 [json_name = "txIndex"];
inline void AbsoluteTxPosition::clear_tx_index() {
  _impl_.tx_index_ = ::uint64_t{0u};
}
inline ::uint64_t AbsoluteTxPosition::tx_index() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AbsoluteTxPosition.tx_index)
  return _internal_tx_index();
}
inline void AbsoluteTxPosition::set_tx_index(::uint64_t value) {
  _internal_set_tx_index(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AbsoluteTxPosition.tx_index)
}
inline ::uint64_t AbsoluteTxPosition::_internal_tx_index() const {
  return _impl_.tx_index_;
}
inline void AbsoluteTxPosition::_internal_set_tx_index(::uint64_t value) {
  ;
  _impl_.tx_index_ = value;
}

// -------------------------------------------------------------------

// Model

// bytes key = 1 [json_name = "key", (.gogoproto.casttype) = "github.com/cometbft/cometbft/libs/bytes.HexBytes"];
inline void Model::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Model::key() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.Model.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Model::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.Model.key)
}
inline std::string* Model::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.Model.key)
  return _s;
}
inline const std::string& Model::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Model::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* Model::release_key() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.Model.key)
  return _impl_.key_.Release();
}
inline void Model::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.Model.key)
}

// bytes value = 2 [json_name = "value"];
inline void Model::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Model::value() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.Model.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Model::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.Model.value)
}
inline std::string* Model::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.Model.value)
  return _s;
}
inline const std::string& Model::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Model::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* Model::release_value() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.Model.value)
  return _impl_.value_.Release();
}
inline void Model::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.Model.value)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::cosmwasm::wasm::v1::AccessType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmwasm::wasm::v1::AccessType>() {
  return ::cosmwasm::wasm::v1::AccessType_descriptor();
}
template <>
struct is_proto_enum<::cosmwasm::wasm::v1::ContractCodeHistoryOperationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::cosmwasm::wasm::v1::ContractCodeHistoryOperationType>() {
  return ::cosmwasm::wasm::v1::ContractCodeHistoryOperationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2ftypes_2eproto_2epb_2eh
