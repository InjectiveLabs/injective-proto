// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmwasm/wasm/v1/authz.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "cosmos_proto/cosmos.pb.h"
#include "cosmos/base/v1beta1/coin.pb.h"
#include "google/protobuf/any.pb.h"
#include "amino/amino.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_cosmwasm_2fwasm_2fv1_2fauthz_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
namespace cosmwasm {
namespace wasm {
namespace v1 {
class AcceptedMessageKeysFilter;
struct AcceptedMessageKeysFilterDefaultTypeInternal;
extern AcceptedMessageKeysFilterDefaultTypeInternal _AcceptedMessageKeysFilter_default_instance_;
class AcceptedMessagesFilter;
struct AcceptedMessagesFilterDefaultTypeInternal;
extern AcceptedMessagesFilterDefaultTypeInternal _AcceptedMessagesFilter_default_instance_;
class AllowAllMessagesFilter;
struct AllowAllMessagesFilterDefaultTypeInternal;
extern AllowAllMessagesFilterDefaultTypeInternal _AllowAllMessagesFilter_default_instance_;
class CombinedLimit;
struct CombinedLimitDefaultTypeInternal;
extern CombinedLimitDefaultTypeInternal _CombinedLimit_default_instance_;
class ContractExecutionAuthorization;
struct ContractExecutionAuthorizationDefaultTypeInternal;
extern ContractExecutionAuthorizationDefaultTypeInternal _ContractExecutionAuthorization_default_instance_;
class ContractGrant;
struct ContractGrantDefaultTypeInternal;
extern ContractGrantDefaultTypeInternal _ContractGrant_default_instance_;
class ContractMigrationAuthorization;
struct ContractMigrationAuthorizationDefaultTypeInternal;
extern ContractMigrationAuthorizationDefaultTypeInternal _ContractMigrationAuthorization_default_instance_;
class MaxCallsLimit;
struct MaxCallsLimitDefaultTypeInternal;
extern MaxCallsLimitDefaultTypeInternal _MaxCallsLimit_default_instance_;
class MaxFundsLimit;
struct MaxFundsLimitDefaultTypeInternal;
extern MaxFundsLimitDefaultTypeInternal _MaxFundsLimit_default_instance_;
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm
PROTOBUF_NAMESPACE_OPEN
template <>
::cosmwasm::wasm::v1::AcceptedMessageKeysFilter* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AcceptedMessageKeysFilter>(Arena*);
template <>
::cosmwasm::wasm::v1::AcceptedMessagesFilter* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AcceptedMessagesFilter>(Arena*);
template <>
::cosmwasm::wasm::v1::AllowAllMessagesFilter* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::AllowAllMessagesFilter>(Arena*);
template <>
::cosmwasm::wasm::v1::CombinedLimit* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::CombinedLimit>(Arena*);
template <>
::cosmwasm::wasm::v1::ContractExecutionAuthorization* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ContractExecutionAuthorization>(Arena*);
template <>
::cosmwasm::wasm::v1::ContractGrant* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ContractGrant>(Arena*);
template <>
::cosmwasm::wasm::v1::ContractMigrationAuthorization* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::ContractMigrationAuthorization>(Arena*);
template <>
::cosmwasm::wasm::v1::MaxCallsLimit* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::MaxCallsLimit>(Arena*);
template <>
::cosmwasm::wasm::v1::MaxFundsLimit* Arena::CreateMaybeMessage<::cosmwasm::wasm::v1::MaxFundsLimit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace cosmwasm {
namespace wasm {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class ContractExecutionAuthorization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractExecutionAuthorization) */ {
 public:
  inline ContractExecutionAuthorization() : ContractExecutionAuthorization(nullptr) {}
  ~ContractExecutionAuthorization() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractExecutionAuthorization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractExecutionAuthorization(const ContractExecutionAuthorization& from);
  ContractExecutionAuthorization(ContractExecutionAuthorization&& from) noexcept
    : ContractExecutionAuthorization() {
    *this = ::std::move(from);
  }

  inline ContractExecutionAuthorization& operator=(const ContractExecutionAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractExecutionAuthorization& operator=(ContractExecutionAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractExecutionAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractExecutionAuthorization* internal_default_instance() {
    return reinterpret_cast<const ContractExecutionAuthorization*>(
               &_ContractExecutionAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContractExecutionAuthorization& a, ContractExecutionAuthorization& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractExecutionAuthorization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractExecutionAuthorization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractExecutionAuthorization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractExecutionAuthorization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractExecutionAuthorization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractExecutionAuthorization& from) {
    ContractExecutionAuthorization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractExecutionAuthorization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ContractExecutionAuthorization";
  }
  protected:
  explicit ContractExecutionAuthorization(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantsFieldNumber = 1,
  };
  // repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int grants_size() const;
  private:
  int _internal_grants_size() const;

  public:
  void clear_grants() ;
  ::cosmwasm::wasm::v1::ContractGrant* mutable_grants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >*
      mutable_grants();
  private:
  const ::cosmwasm::wasm::v1::ContractGrant& _internal_grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* _internal_add_grants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& _internal_grants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* _internal_mutable_grants();
  public:
  const ::cosmwasm::wasm::v1::ContractGrant& grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* add_grants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >&
      grants() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractExecutionAuthorization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant > grants_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class ContractMigrationAuthorization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractMigrationAuthorization) */ {
 public:
  inline ContractMigrationAuthorization() : ContractMigrationAuthorization(nullptr) {}
  ~ContractMigrationAuthorization() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractMigrationAuthorization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractMigrationAuthorization(const ContractMigrationAuthorization& from);
  ContractMigrationAuthorization(ContractMigrationAuthorization&& from) noexcept
    : ContractMigrationAuthorization() {
    *this = ::std::move(from);
  }

  inline ContractMigrationAuthorization& operator=(const ContractMigrationAuthorization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractMigrationAuthorization& operator=(ContractMigrationAuthorization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractMigrationAuthorization& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractMigrationAuthorization* internal_default_instance() {
    return reinterpret_cast<const ContractMigrationAuthorization*>(
               &_ContractMigrationAuthorization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContractMigrationAuthorization& a, ContractMigrationAuthorization& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractMigrationAuthorization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractMigrationAuthorization* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractMigrationAuthorization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractMigrationAuthorization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractMigrationAuthorization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractMigrationAuthorization& from) {
    ContractMigrationAuthorization::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractMigrationAuthorization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ContractMigrationAuthorization";
  }
  protected:
  explicit ContractMigrationAuthorization(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantsFieldNumber = 1,
  };
  // repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
  int grants_size() const;
  private:
  int _internal_grants_size() const;

  public:
  void clear_grants() ;
  ::cosmwasm::wasm::v1::ContractGrant* mutable_grants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >*
      mutable_grants();
  private:
  const ::cosmwasm::wasm::v1::ContractGrant& _internal_grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* _internal_add_grants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>& _internal_grants() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>* _internal_mutable_grants();
  public:
  const ::cosmwasm::wasm::v1::ContractGrant& grants(int index) const;
  ::cosmwasm::wasm::v1::ContractGrant* add_grants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >&
      grants() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractMigrationAuthorization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant > grants_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class ContractGrant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.ContractGrant) */ {
 public:
  inline ContractGrant() : ContractGrant(nullptr) {}
  ~ContractGrant() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractGrant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractGrant(const ContractGrant& from);
  ContractGrant(ContractGrant&& from) noexcept
    : ContractGrant() {
    *this = ::std::move(from);
  }

  inline ContractGrant& operator=(const ContractGrant& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractGrant& operator=(ContractGrant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractGrant& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractGrant* internal_default_instance() {
    return reinterpret_cast<const ContractGrant*>(
               &_ContractGrant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContractGrant& a, ContractGrant& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractGrant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractGrant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractGrant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractGrant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractGrant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractGrant& from) {
    ContractGrant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractGrant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.ContractGrant";
  }
  protected:
  explicit ContractGrant(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractFieldNumber = 1,
    kLimitFieldNumber = 2,
    kFilterFieldNumber = 3,
  };
  // string contract = 1 [json_name = "contract"];
  void clear_contract() ;
  const std::string& contract() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract(Arg_&& arg, Args_... args);
  std::string* mutable_contract();
  PROTOBUF_NODISCARD std::string* release_contract();
  void set_allocated_contract(std::string* ptr);

  private:
  const std::string& _internal_contract() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract(
      const std::string& value);
  std::string* _internal_mutable_contract();

  public:
  // .google.protobuf.Any limit = 2 [json_name = "limit", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzLimitX"];
  bool has_limit() const;
  void clear_limit() ;
  const ::PROTOBUF_NAMESPACE_ID::Any& limit() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_limit();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_limit();
  void set_allocated_limit(::PROTOBUF_NAMESPACE_ID::Any* limit);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_limit();
  public:
  void unsafe_arena_set_allocated_limit(
      ::PROTOBUF_NAMESPACE_ID::Any* limit);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_limit();
  // .google.protobuf.Any filter = 3 [json_name = "filter", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzFilterX"];
  bool has_filter() const;
  void clear_filter() ;
  const ::PROTOBUF_NAMESPACE_ID::Any& filter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_filter();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_filter();
  void set_allocated_filter(::PROTOBUF_NAMESPACE_ID::Any* filter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_filter() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::PROTOBUF_NAMESPACE_ID::Any* filter);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_filter();
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.ContractGrant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_;
    ::PROTOBUF_NAMESPACE_ID::Any* limit_;
    ::PROTOBUF_NAMESPACE_ID::Any* filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class MaxCallsLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.MaxCallsLimit) */ {
 public:
  inline MaxCallsLimit() : MaxCallsLimit(nullptr) {}
  ~MaxCallsLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MaxCallsLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaxCallsLimit(const MaxCallsLimit& from);
  MaxCallsLimit(MaxCallsLimit&& from) noexcept
    : MaxCallsLimit() {
    *this = ::std::move(from);
  }

  inline MaxCallsLimit& operator=(const MaxCallsLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxCallsLimit& operator=(MaxCallsLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxCallsLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxCallsLimit* internal_default_instance() {
    return reinterpret_cast<const MaxCallsLimit*>(
               &_MaxCallsLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MaxCallsLimit& a, MaxCallsLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxCallsLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxCallsLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxCallsLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaxCallsLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaxCallsLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaxCallsLimit& from) {
    MaxCallsLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxCallsLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.MaxCallsLimit";
  }
  protected:
  explicit MaxCallsLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemainingFieldNumber = 1,
  };
  // uint64 remaining = 1 [json_name = "remaining"];
  void clear_remaining() ;
  ::uint64_t remaining() const;
  void set_remaining(::uint64_t value);

  private:
  ::uint64_t _internal_remaining() const;
  void _internal_set_remaining(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.MaxCallsLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t remaining_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class MaxFundsLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.MaxFundsLimit) */ {
 public:
  inline MaxFundsLimit() : MaxFundsLimit(nullptr) {}
  ~MaxFundsLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MaxFundsLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaxFundsLimit(const MaxFundsLimit& from);
  MaxFundsLimit(MaxFundsLimit&& from) noexcept
    : MaxFundsLimit() {
    *this = ::std::move(from);
  }

  inline MaxFundsLimit& operator=(const MaxFundsLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaxFundsLimit& operator=(MaxFundsLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaxFundsLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaxFundsLimit* internal_default_instance() {
    return reinterpret_cast<const MaxFundsLimit*>(
               &_MaxFundsLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MaxFundsLimit& a, MaxFundsLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(MaxFundsLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaxFundsLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaxFundsLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaxFundsLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaxFundsLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaxFundsLimit& from) {
    MaxFundsLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxFundsLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.MaxFundsLimit";
  }
  protected:
  explicit MaxFundsLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountsFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin amounts = 1 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int amounts_size() const;
  private:
  int _internal_amounts_size() const;

  public:
  void clear_amounts() ;
  ::cosmos::base::v1beta1::Coin* mutable_amounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_amounts();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_amounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amounts();
  public:
  const ::cosmos::base::v1beta1::Coin& amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      amounts() const;
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.MaxFundsLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class CombinedLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.CombinedLimit) */ {
 public:
  inline CombinedLimit() : CombinedLimit(nullptr) {}
  ~CombinedLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CombinedLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CombinedLimit(const CombinedLimit& from);
  CombinedLimit(CombinedLimit&& from) noexcept
    : CombinedLimit() {
    *this = ::std::move(from);
  }

  inline CombinedLimit& operator=(const CombinedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombinedLimit& operator=(CombinedLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombinedLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombinedLimit* internal_default_instance() {
    return reinterpret_cast<const CombinedLimit*>(
               &_CombinedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CombinedLimit& a, CombinedLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(CombinedLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombinedLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombinedLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CombinedLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CombinedLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CombinedLimit& from) {
    CombinedLimit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CombinedLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.CombinedLimit";
  }
  protected:
  explicit CombinedLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountsFieldNumber = 2,
    kCallsRemainingFieldNumber = 1,
  };
  // repeated .cosmos.base.v1beta1.Coin amounts = 2 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
  int amounts_size() const;
  private:
  int _internal_amounts_size() const;

  public:
  void clear_amounts() ;
  ::cosmos::base::v1beta1::Coin* mutable_amounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
      mutable_amounts();
  private:
  const ::cosmos::base::v1beta1::Coin& _internal_amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* _internal_add_amounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>& _internal_amounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>* _internal_mutable_amounts();
  public:
  const ::cosmos::base::v1beta1::Coin& amounts(int index) const;
  ::cosmos::base::v1beta1::Coin* add_amounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
      amounts() const;
  // uint64 calls_remaining = 1 [json_name = "callsRemaining"];
  void clear_calls_remaining() ;
  ::uint64_t calls_remaining() const;
  void set_calls_remaining(::uint64_t value);

  private:
  ::uint64_t _internal_calls_remaining() const;
  void _internal_set_calls_remaining(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.CombinedLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin > amounts_;
    ::uint64_t calls_remaining_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class AllowAllMessagesFilter final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AllowAllMessagesFilter) */ {
 public:
  inline AllowAllMessagesFilter() : AllowAllMessagesFilter(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllowAllMessagesFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllowAllMessagesFilter(const AllowAllMessagesFilter& from);
  AllowAllMessagesFilter(AllowAllMessagesFilter&& from) noexcept
    : AllowAllMessagesFilter() {
    *this = ::std::move(from);
  }

  inline AllowAllMessagesFilter& operator=(const AllowAllMessagesFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllowAllMessagesFilter& operator=(AllowAllMessagesFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllowAllMessagesFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllowAllMessagesFilter* internal_default_instance() {
    return reinterpret_cast<const AllowAllMessagesFilter*>(
               &_AllowAllMessagesFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AllowAllMessagesFilter& a, AllowAllMessagesFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AllowAllMessagesFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllowAllMessagesFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllowAllMessagesFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllowAllMessagesFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AllowAllMessagesFilter& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AllowAllMessagesFilter& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AllowAllMessagesFilter";
  }
  protected:
  explicit AllowAllMessagesFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AllowAllMessagesFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class AcceptedMessageKeysFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AcceptedMessageKeysFilter) */ {
 public:
  inline AcceptedMessageKeysFilter() : AcceptedMessageKeysFilter(nullptr) {}
  ~AcceptedMessageKeysFilter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptedMessageKeysFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcceptedMessageKeysFilter(const AcceptedMessageKeysFilter& from);
  AcceptedMessageKeysFilter(AcceptedMessageKeysFilter&& from) noexcept
    : AcceptedMessageKeysFilter() {
    *this = ::std::move(from);
  }

  inline AcceptedMessageKeysFilter& operator=(const AcceptedMessageKeysFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptedMessageKeysFilter& operator=(AcceptedMessageKeysFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptedMessageKeysFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptedMessageKeysFilter* internal_default_instance() {
    return reinterpret_cast<const AcceptedMessageKeysFilter*>(
               &_AcceptedMessageKeysFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AcceptedMessageKeysFilter& a, AcceptedMessageKeysFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptedMessageKeysFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptedMessageKeysFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptedMessageKeysFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcceptedMessageKeysFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcceptedMessageKeysFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcceptedMessageKeysFilter& from) {
    AcceptedMessageKeysFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptedMessageKeysFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AcceptedMessageKeysFilter";
  }
  protected:
  explicit AcceptedMessageKeysFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1 [json_name = "keys"];
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, std::size_t size);
  void set_keys(int index, absl::string_view value);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, std::size_t size);
  void add_keys(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();

  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_keys();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AcceptedMessageKeysFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};// -------------------------------------------------------------------

class AcceptedMessagesFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cosmwasm.wasm.v1.AcceptedMessagesFilter) */ {
 public:
  inline AcceptedMessagesFilter() : AcceptedMessagesFilter(nullptr) {}
  ~AcceptedMessagesFilter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AcceptedMessagesFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcceptedMessagesFilter(const AcceptedMessagesFilter& from);
  AcceptedMessagesFilter(AcceptedMessagesFilter&& from) noexcept
    : AcceptedMessagesFilter() {
    *this = ::std::move(from);
  }

  inline AcceptedMessagesFilter& operator=(const AcceptedMessagesFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptedMessagesFilter& operator=(AcceptedMessagesFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptedMessagesFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptedMessagesFilter* internal_default_instance() {
    return reinterpret_cast<const AcceptedMessagesFilter*>(
               &_AcceptedMessagesFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AcceptedMessagesFilter& a, AcceptedMessagesFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptedMessagesFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptedMessagesFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptedMessagesFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcceptedMessagesFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcceptedMessagesFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcceptedMessagesFilter& from) {
    AcceptedMessagesFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptedMessagesFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cosmwasm.wasm.v1.AcceptedMessagesFilter";
  }
  protected:
  explicit AcceptedMessagesFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated bytes messages = 1 [json_name = "messages", (.gogoproto.casttype) = "RawContractMessage"];
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  void set_messages(int index, const std::string& value);
  void set_messages(int index, std::string&& value);
  void set_messages(int index, const char* value);
  void set_messages(int index, const void* value, std::size_t size);
  void set_messages(int index, absl::string_view value);
  std::string* add_messages();
  void add_messages(const std::string& value);
  void add_messages(std::string&& value);
  void add_messages(const char* value);
  void add_messages(const void* value, std::size_t size);
  void add_messages(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messages();

  private:
  const std::string& _internal_messages(int index) const;
  std::string* _internal_add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_messages();

  public:
  // @@protoc_insertion_point(class_scope:cosmwasm.wasm.v1.AcceptedMessagesFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cosmwasm_2fwasm_2fv1_2fauthz_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ContractExecutionAuthorization

// repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ContractExecutionAuthorization::_internal_grants_size() const {
  return _impl_.grants_.size();
}
inline int ContractExecutionAuthorization::grants_size() const {
  return _internal_grants_size();
}
inline void ContractExecutionAuthorization::clear_grants() {
  _internal_mutable_grants()->Clear();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractExecutionAuthorization::mutable_grants(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_mutable_grants()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >*
ContractExecutionAuthorization::mutable_grants() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_mutable_grants();
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractExecutionAuthorization::_internal_grants(int index) const {
  return _internal_grants().Get(index);
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractExecutionAuthorization::grants(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_grants(index);
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractExecutionAuthorization::_internal_add_grants() {
  return _internal_mutable_grants()->Add();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractExecutionAuthorization::add_grants() {
  ::cosmwasm::wasm::v1::ContractGrant* _add = _internal_add_grants();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >&
ContractExecutionAuthorization::grants() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.ContractExecutionAuthorization.grants)
  return _internal_grants();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>&
ContractExecutionAuthorization::_internal_grants() const {
  return _impl_.grants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>*
ContractExecutionAuthorization::_internal_mutable_grants() {
  return &_impl_.grants_;
}

// -------------------------------------------------------------------

// ContractMigrationAuthorization

// repeated .cosmwasm.wasm.v1.ContractGrant grants = 1 [json_name = "grants", (.gogoproto.nullable) = false, (.amino.dont_omitempty) = true];
inline int ContractMigrationAuthorization::_internal_grants_size() const {
  return _impl_.grants_.size();
}
inline int ContractMigrationAuthorization::grants_size() const {
  return _internal_grants_size();
}
inline void ContractMigrationAuthorization::clear_grants() {
  _internal_mutable_grants()->Clear();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractMigrationAuthorization::mutable_grants(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_mutable_grants()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >*
ContractMigrationAuthorization::mutable_grants() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_mutable_grants();
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractMigrationAuthorization::_internal_grants(int index) const {
  return _internal_grants().Get(index);
}
inline const ::cosmwasm::wasm::v1::ContractGrant& ContractMigrationAuthorization::grants(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_grants(index);
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractMigrationAuthorization::_internal_add_grants() {
  return _internal_mutable_grants()->Add();
}
inline ::cosmwasm::wasm::v1::ContractGrant* ContractMigrationAuthorization::add_grants() {
  ::cosmwasm::wasm::v1::ContractGrant* _add = _internal_add_grants();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmwasm::wasm::v1::ContractGrant >&
ContractMigrationAuthorization::grants() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.ContractMigrationAuthorization.grants)
  return _internal_grants();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>&
ContractMigrationAuthorization::_internal_grants() const {
  return _impl_.grants_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmwasm::wasm::v1::ContractGrant>*
ContractMigrationAuthorization::_internal_mutable_grants() {
  return &_impl_.grants_;
}

// -------------------------------------------------------------------

// ContractGrant

// string contract = 1 [json_name = "contract"];
inline void ContractGrant::clear_contract() {
  _impl_.contract_.ClearToEmpty();
}
inline const std::string& ContractGrant::contract() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.contract)
  return _internal_contract();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractGrant::set_contract(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.ContractGrant.contract)
}
inline std::string* ContractGrant::mutable_contract() {
  std::string* _s = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.contract)
  return _s;
}
inline const std::string& ContractGrant::_internal_contract() const {
  return _impl_.contract_.Get();
}
inline void ContractGrant::_internal_set_contract(const std::string& value) {
  ;


  _impl_.contract_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractGrant::_internal_mutable_contract() {
  ;
  return _impl_.contract_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractGrant::release_contract() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.contract)
  return _impl_.contract_.Release();
}
inline void ContractGrant::set_allocated_contract(std::string* value) {
  _impl_.contract_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_.IsDefault()) {
          _impl_.contract_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.contract)
}

// .google.protobuf.Any limit = 2 [json_name = "limit", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzLimitX"];
inline bool ContractGrant::has_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.limit_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractGrant::_internal_limit() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractGrant::limit() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.limit)
  return _internal_limit();
}
inline void ContractGrant::unsafe_arena_set_allocated_limit(
    ::PROTOBUF_NAMESPACE_ID::Any* limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_);
  }
  _impl_.limit_ = limit;
  if (limit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractGrant.limit)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::release_limit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.limit_;
  _impl_.limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::unsafe_arena_release_limit() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.limit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.limit_;
  _impl_.limit_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::_internal_mutable_limit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.limit_ = p;
  }
  return _impl_.limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::mutable_limit() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_limit();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.limit)
  return _msg;
}
inline void ContractGrant::set_allocated_limit(::PROTOBUF_NAMESPACE_ID::Any* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_);
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit));
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.limit)
}

// .google.protobuf.Any filter = 3 [json_name = "filter", (.cosmos_proto.accepts_interface) = "cosmwasm.wasm.v1.ContractAuthzFilterX"];
inline bool ContractGrant::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractGrant::_internal_filter() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ContractGrant::filter() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.ContractGrant.filter)
  return _internal_filter();
}
inline void ContractGrant::unsafe_arena_set_allocated_filter(
    ::PROTOBUF_NAMESPACE_ID::Any* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cosmwasm.wasm.v1.ContractGrant.filter)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::release_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:cosmwasm.wasm.v1.ContractGrant.filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ContractGrant::mutable_filter() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.ContractGrant.filter)
  return _msg;
}
inline void ContractGrant::set_allocated_filter(::PROTOBUF_NAMESPACE_ID::Any* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter));
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:cosmwasm.wasm.v1.ContractGrant.filter)
}

// -------------------------------------------------------------------

// MaxCallsLimit

// uint64 remaining = 1 [json_name = "remaining"];
inline void MaxCallsLimit::clear_remaining() {
  _impl_.remaining_ = ::uint64_t{0u};
}
inline ::uint64_t MaxCallsLimit::remaining() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MaxCallsLimit.remaining)
  return _internal_remaining();
}
inline void MaxCallsLimit::set_remaining(::uint64_t value) {
  _internal_set_remaining(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.MaxCallsLimit.remaining)
}
inline ::uint64_t MaxCallsLimit::_internal_remaining() const {
  return _impl_.remaining_;
}
inline void MaxCallsLimit::_internal_set_remaining(::uint64_t value) {
  ;
  _impl_.remaining_ = value;
}

// -------------------------------------------------------------------

// MaxFundsLimit

// repeated .cosmos.base.v1beta1.Coin amounts = 1 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int MaxFundsLimit::_internal_amounts_size() const {
  return _impl_.amounts_.size();
}
inline int MaxFundsLimit::amounts_size() const {
  return _internal_amounts_size();
}
inline ::cosmos::base::v1beta1::Coin* MaxFundsLimit::mutable_amounts(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_mutable_amounts()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
MaxFundsLimit::mutable_amounts() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_mutable_amounts();
}
inline const ::cosmos::base::v1beta1::Coin& MaxFundsLimit::_internal_amounts(int index) const {
  return _internal_amounts().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& MaxFundsLimit::amounts(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_amounts(index);
}
inline ::cosmos::base::v1beta1::Coin* MaxFundsLimit::_internal_add_amounts() {
  return _internal_mutable_amounts()->Add();
}
inline ::cosmos::base::v1beta1::Coin* MaxFundsLimit::add_amounts() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_amounts();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
MaxFundsLimit::amounts() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.MaxFundsLimit.amounts)
  return _internal_amounts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
MaxFundsLimit::_internal_amounts() const {
  return _impl_.amounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
MaxFundsLimit::_internal_mutable_amounts() {
  return &_impl_.amounts_;
}

// -------------------------------------------------------------------

// CombinedLimit

// uint64 calls_remaining = 1 [json_name = "callsRemaining"];
inline void CombinedLimit::clear_calls_remaining() {
  _impl_.calls_remaining_ = ::uint64_t{0u};
}
inline ::uint64_t CombinedLimit::calls_remaining() const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CombinedLimit.calls_remaining)
  return _internal_calls_remaining();
}
inline void CombinedLimit::set_calls_remaining(::uint64_t value) {
  _internal_set_calls_remaining(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.CombinedLimit.calls_remaining)
}
inline ::uint64_t CombinedLimit::_internal_calls_remaining() const {
  return _impl_.calls_remaining_;
}
inline void CombinedLimit::_internal_set_calls_remaining(::uint64_t value) {
  ;
  _impl_.calls_remaining_ = value;
}

// repeated .cosmos.base.v1beta1.Coin amounts = 2 [json_name = "amounts", (.gogoproto.nullable) = false, (.gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins", (.amino.dont_omitempty) = true];
inline int CombinedLimit::_internal_amounts_size() const {
  return _impl_.amounts_.size();
}
inline int CombinedLimit::amounts_size() const {
  return _internal_amounts_size();
}
inline ::cosmos::base::v1beta1::Coin* CombinedLimit::mutable_amounts(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_mutable_amounts()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >*
CombinedLimit::mutable_amounts() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_mutable_amounts();
}
inline const ::cosmos::base::v1beta1::Coin& CombinedLimit::_internal_amounts(int index) const {
  return _internal_amounts().Get(index);
}
inline const ::cosmos::base::v1beta1::Coin& CombinedLimit::amounts(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_amounts(index);
}
inline ::cosmos::base::v1beta1::Coin* CombinedLimit::_internal_add_amounts() {
  return _internal_mutable_amounts()->Add();
}
inline ::cosmos::base::v1beta1::Coin* CombinedLimit::add_amounts() {
  ::cosmos::base::v1beta1::Coin* _add = _internal_add_amounts();
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cosmos::base::v1beta1::Coin >&
CombinedLimit::amounts() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.CombinedLimit.amounts)
  return _internal_amounts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>&
CombinedLimit::_internal_amounts() const {
  return _impl_.amounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::cosmos::base::v1beta1::Coin>*
CombinedLimit::_internal_mutable_amounts() {
  return &_impl_.amounts_;
}

// -------------------------------------------------------------------

// AllowAllMessagesFilter

// -------------------------------------------------------------------

// AcceptedMessageKeysFilter

// repeated string keys = 1 [json_name = "keys"];
inline int AcceptedMessageKeysFilter::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int AcceptedMessageKeysFilter::keys_size() const {
  return _internal_keys_size();
}
inline void AcceptedMessageKeysFilter::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline std::string* AcceptedMessageKeysFilter::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _s;
}
inline const std::string& AcceptedMessageKeysFilter::keys(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_keys(index);
}
inline std::string* AcceptedMessageKeysFilter::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline void AcceptedMessageKeysFilter::set_keys(int index, const std::string& value) {
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::set_keys(int index, std::string&& value) {
  _internal_mutable_keys()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::set_keys(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::set_keys(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_keys()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::set_keys(int index, absl::string_view value) {
  _internal_mutable_keys()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::add_keys(const std::string& value) {
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::add_keys(std::string&& value) {
  _internal_mutable_keys()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::add_keys(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_keys()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::add_keys(const char* value, std::size_t size) {
  _internal_mutable_keys()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline void AcceptedMessageKeysFilter::add_keys(absl::string_view value) {
  _internal_mutable_keys()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcceptedMessageKeysFilter::keys() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AcceptedMessageKeysFilter::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.AcceptedMessageKeysFilter.keys)
  return _internal_mutable_keys();
}
inline const std::string& AcceptedMessageKeysFilter::_internal_keys(int index) const {
  return _internal_keys().Get(index);
}
inline std::string* AcceptedMessageKeysFilter::_internal_add_keys() {
  return _internal_mutable_keys()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcceptedMessageKeysFilter::_internal_keys() const {
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AcceptedMessageKeysFilter::_internal_mutable_keys() {
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// AcceptedMessagesFilter

// repeated bytes messages = 1 [json_name = "messages", (.gogoproto.casttype) = "RawContractMessage"];
inline int AcceptedMessagesFilter::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int AcceptedMessagesFilter::messages_size() const {
  return _internal_messages_size();
}
inline void AcceptedMessagesFilter::clear_messages() {
  _internal_mutable_messages()->Clear();
}
inline std::string* AcceptedMessagesFilter::add_messages() {
  std::string* _s = _internal_add_messages();
  // @@protoc_insertion_point(field_add_mutable:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _s;
}
inline const std::string& AcceptedMessagesFilter::messages(int index) const {
  // @@protoc_insertion_point(field_get:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_messages(index);
}
inline std::string* AcceptedMessagesFilter::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_mutable_messages()->Mutable(index);
}
inline void AcceptedMessagesFilter::set_messages(int index, const std::string& value) {
  _internal_mutable_messages()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::set_messages(int index, std::string&& value) {
  _internal_mutable_messages()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::set_messages(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_messages()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::set_messages(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_messages()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::set_messages(int index, absl::string_view value) {
  _internal_mutable_messages()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::add_messages(const std::string& value) {
  _internal_mutable_messages()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::add_messages(std::string&& value) {
  _internal_mutable_messages()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::add_messages(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_messages()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::add_messages(const void* value, std::size_t size) {
  _internal_mutable_messages()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline void AcceptedMessagesFilter::add_messages(absl::string_view value) {
  _internal_mutable_messages()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcceptedMessagesFilter::messages() const {
  // @@protoc_insertion_point(field_list:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_messages();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AcceptedMessagesFilter::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:cosmwasm.wasm.v1.AcceptedMessagesFilter.messages)
  return _internal_mutable_messages();
}
inline const std::string& AcceptedMessagesFilter::_internal_messages(int index) const {
  return _internal_messages().Get(index);
}
inline std::string* AcceptedMessagesFilter::_internal_add_messages() {
  return _internal_mutable_messages()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcceptedMessagesFilter::_internal_messages() const {
  return _impl_.messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AcceptedMessagesFilter::_internal_mutable_messages() {
  return &_impl_.messages_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace wasm
}  // namespace cosmwasm


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_cosmwasm_2fwasm_2fv1_2fauthz_2eproto_2epb_2eh
