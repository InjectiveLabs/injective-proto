// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ibc/applications/fee/v1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "ibc/applications/fee/v1/fee.pb.h"
#include "ibc/core/channel/v1/channel.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
namespace ibc {
namespace applications {
namespace fee {
namespace v1 {
class MsgPayPacketFee;
struct MsgPayPacketFeeDefaultTypeInternal;
extern MsgPayPacketFeeDefaultTypeInternal _MsgPayPacketFee_default_instance_;
class MsgPayPacketFeeAsync;
struct MsgPayPacketFeeAsyncDefaultTypeInternal;
extern MsgPayPacketFeeAsyncDefaultTypeInternal _MsgPayPacketFeeAsync_default_instance_;
class MsgPayPacketFeeAsyncResponse;
struct MsgPayPacketFeeAsyncResponseDefaultTypeInternal;
extern MsgPayPacketFeeAsyncResponseDefaultTypeInternal _MsgPayPacketFeeAsyncResponse_default_instance_;
class MsgPayPacketFeeResponse;
struct MsgPayPacketFeeResponseDefaultTypeInternal;
extern MsgPayPacketFeeResponseDefaultTypeInternal _MsgPayPacketFeeResponse_default_instance_;
class MsgRegisterCounterpartyPayee;
struct MsgRegisterCounterpartyPayeeDefaultTypeInternal;
extern MsgRegisterCounterpartyPayeeDefaultTypeInternal _MsgRegisterCounterpartyPayee_default_instance_;
class MsgRegisterCounterpartyPayeeResponse;
struct MsgRegisterCounterpartyPayeeResponseDefaultTypeInternal;
extern MsgRegisterCounterpartyPayeeResponseDefaultTypeInternal _MsgRegisterCounterpartyPayeeResponse_default_instance_;
class MsgRegisterPayee;
struct MsgRegisterPayeeDefaultTypeInternal;
extern MsgRegisterPayeeDefaultTypeInternal _MsgRegisterPayee_default_instance_;
class MsgRegisterPayeeResponse;
struct MsgRegisterPayeeResponseDefaultTypeInternal;
extern MsgRegisterPayeeResponseDefaultTypeInternal _MsgRegisterPayeeResponse_default_instance_;
}  // namespace v1
}  // namespace fee
}  // namespace applications
}  // namespace ibc
PROTOBUF_NAMESPACE_OPEN
template <>
::ibc::applications::fee::v1::MsgPayPacketFee* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgPayPacketFee>(Arena*);
template <>
::ibc::applications::fee::v1::MsgPayPacketFeeAsync* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgPayPacketFeeAsync>(Arena*);
template <>
::ibc::applications::fee::v1::MsgPayPacketFeeAsyncResponse* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgPayPacketFeeAsyncResponse>(Arena*);
template <>
::ibc::applications::fee::v1::MsgPayPacketFeeResponse* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgPayPacketFeeResponse>(Arena*);
template <>
::ibc::applications::fee::v1::MsgRegisterCounterpartyPayee* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgRegisterCounterpartyPayee>(Arena*);
template <>
::ibc::applications::fee::v1::MsgRegisterCounterpartyPayeeResponse* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgRegisterCounterpartyPayeeResponse>(Arena*);
template <>
::ibc::applications::fee::v1::MsgRegisterPayee* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgRegisterPayee>(Arena*);
template <>
::ibc::applications::fee::v1::MsgRegisterPayeeResponse* Arena::CreateMaybeMessage<::ibc::applications::fee::v1::MsgRegisterPayeeResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ibc {
namespace applications {
namespace fee {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class MsgRegisterPayee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgRegisterPayee) */ {
 public:
  inline MsgRegisterPayee() : MsgRegisterPayee(nullptr) {}
  ~MsgRegisterPayee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterPayee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterPayee(const MsgRegisterPayee& from);
  MsgRegisterPayee(MsgRegisterPayee&& from) noexcept
    : MsgRegisterPayee() {
    *this = ::std::move(from);
  }

  inline MsgRegisterPayee& operator=(const MsgRegisterPayee& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterPayee& operator=(MsgRegisterPayee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterPayee& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterPayee* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterPayee*>(
               &_MsgRegisterPayee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgRegisterPayee& a, MsgRegisterPayee& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterPayee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterPayee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterPayee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterPayee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRegisterPayee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRegisterPayee& from) {
    MsgRegisterPayee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRegisterPayee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgRegisterPayee";
  }
  protected:
  explicit MsgRegisterPayee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kRelayerFieldNumber = 3,
    kPayeeFieldNumber = 4,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string relayer = 3 [json_name = "relayer"];
  void clear_relayer() ;
  const std::string& relayer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer(Arg_&& arg, Args_... args);
  std::string* mutable_relayer();
  PROTOBUF_NODISCARD std::string* release_relayer();
  void set_allocated_relayer(std::string* ptr);

  private:
  const std::string& _internal_relayer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer(
      const std::string& value);
  std::string* _internal_mutable_relayer();

  public:
  // string payee = 4 [json_name = "payee"];
  void clear_payee() ;
  const std::string& payee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payee(Arg_&& arg, Args_... args);
  std::string* mutable_payee();
  PROTOBUF_NODISCARD std::string* release_payee();
  void set_allocated_payee(std::string* ptr);

  private:
  const std::string& _internal_payee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payee(
      const std::string& value);
  std::string* _internal_mutable_payee();

  public:
  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgRegisterPayee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRegisterPayeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgRegisterPayeeResponse) */ {
 public:
  inline MsgRegisterPayeeResponse() : MsgRegisterPayeeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterPayeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterPayeeResponse(const MsgRegisterPayeeResponse& from);
  MsgRegisterPayeeResponse(MsgRegisterPayeeResponse&& from) noexcept
    : MsgRegisterPayeeResponse() {
    *this = ::std::move(from);
  }

  inline MsgRegisterPayeeResponse& operator=(const MsgRegisterPayeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterPayeeResponse& operator=(MsgRegisterPayeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterPayeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterPayeeResponse* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterPayeeResponse*>(
               &_MsgRegisterPayeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgRegisterPayeeResponse& a, MsgRegisterPayeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterPayeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterPayeeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterPayeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterPayeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgRegisterPayeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgRegisterPayeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgRegisterPayeeResponse";
  }
  protected:
  explicit MsgRegisterPayeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgRegisterPayeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRegisterCounterpartyPayee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee) */ {
 public:
  inline MsgRegisterCounterpartyPayee() : MsgRegisterCounterpartyPayee(nullptr) {}
  ~MsgRegisterCounterpartyPayee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterCounterpartyPayee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterCounterpartyPayee(const MsgRegisterCounterpartyPayee& from);
  MsgRegisterCounterpartyPayee(MsgRegisterCounterpartyPayee&& from) noexcept
    : MsgRegisterCounterpartyPayee() {
    *this = ::std::move(from);
  }

  inline MsgRegisterCounterpartyPayee& operator=(const MsgRegisterCounterpartyPayee& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterCounterpartyPayee& operator=(MsgRegisterCounterpartyPayee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterCounterpartyPayee& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterCounterpartyPayee* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterCounterpartyPayee*>(
               &_MsgRegisterCounterpartyPayee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgRegisterCounterpartyPayee& a, MsgRegisterCounterpartyPayee& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterCounterpartyPayee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterCounterpartyPayee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterCounterpartyPayee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterCounterpartyPayee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRegisterCounterpartyPayee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRegisterCounterpartyPayee& from) {
    MsgRegisterCounterpartyPayee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRegisterCounterpartyPayee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgRegisterCounterpartyPayee";
  }
  protected:
  explicit MsgRegisterCounterpartyPayee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kRelayerFieldNumber = 3,
    kCounterpartyPayeeFieldNumber = 4,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string relayer = 3 [json_name = "relayer"];
  void clear_relayer() ;
  const std::string& relayer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_relayer(Arg_&& arg, Args_... args);
  std::string* mutable_relayer();
  PROTOBUF_NODISCARD std::string* release_relayer();
  void set_allocated_relayer(std::string* ptr);

  private:
  const std::string& _internal_relayer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relayer(
      const std::string& value);
  std::string* _internal_mutable_relayer();

  public:
  // string counterparty_payee = 4 [json_name = "counterpartyPayee"];
  void clear_counterparty_payee() ;
  const std::string& counterparty_payee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_counterparty_payee(Arg_&& arg, Args_... args);
  std::string* mutable_counterparty_payee();
  PROTOBUF_NODISCARD std::string* release_counterparty_payee();
  void set_allocated_counterparty_payee(std::string* ptr);

  private:
  const std::string& _internal_counterparty_payee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_counterparty_payee(
      const std::string& value);
  std::string* _internal_mutable_counterparty_payee();

  public:
  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relayer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counterparty_payee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRegisterCounterpartyPayeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgRegisterCounterpartyPayeeResponse) */ {
 public:
  inline MsgRegisterCounterpartyPayeeResponse() : MsgRegisterCounterpartyPayeeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRegisterCounterpartyPayeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRegisterCounterpartyPayeeResponse(const MsgRegisterCounterpartyPayeeResponse& from);
  MsgRegisterCounterpartyPayeeResponse(MsgRegisterCounterpartyPayeeResponse&& from) noexcept
    : MsgRegisterCounterpartyPayeeResponse() {
    *this = ::std::move(from);
  }

  inline MsgRegisterCounterpartyPayeeResponse& operator=(const MsgRegisterCounterpartyPayeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRegisterCounterpartyPayeeResponse& operator=(MsgRegisterCounterpartyPayeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRegisterCounterpartyPayeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRegisterCounterpartyPayeeResponse* internal_default_instance() {
    return reinterpret_cast<const MsgRegisterCounterpartyPayeeResponse*>(
               &_MsgRegisterCounterpartyPayeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgRegisterCounterpartyPayeeResponse& a, MsgRegisterCounterpartyPayeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRegisterCounterpartyPayeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRegisterCounterpartyPayeeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRegisterCounterpartyPayeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRegisterCounterpartyPayeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgRegisterCounterpartyPayeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgRegisterCounterpartyPayeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgRegisterCounterpartyPayeeResponse";
  }
  protected:
  explicit MsgRegisterCounterpartyPayeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgRegisterCounterpartyPayeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPayPacketFee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgPayPacketFee) */ {
 public:
  inline MsgPayPacketFee() : MsgPayPacketFee(nullptr) {}
  ~MsgPayPacketFee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPayPacketFee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPayPacketFee(const MsgPayPacketFee& from);
  MsgPayPacketFee(MsgPayPacketFee&& from) noexcept
    : MsgPayPacketFee() {
    *this = ::std::move(from);
  }

  inline MsgPayPacketFee& operator=(const MsgPayPacketFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPayPacketFee& operator=(MsgPayPacketFee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPayPacketFee& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPayPacketFee* internal_default_instance() {
    return reinterpret_cast<const MsgPayPacketFee*>(
               &_MsgPayPacketFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgPayPacketFee& a, MsgPayPacketFee& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPayPacketFee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPayPacketFee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPayPacketFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPayPacketFee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPayPacketFee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPayPacketFee& from) {
    MsgPayPacketFee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPayPacketFee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgPayPacketFee";
  }
  protected:
  explicit MsgPayPacketFee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayersFieldNumber = 5,
    kSourcePortIdFieldNumber = 2,
    kSourceChannelIdFieldNumber = 3,
    kSignerFieldNumber = 4,
    kFeeFieldNumber = 1,
  };
  // repeated string relayers = 5 [json_name = "relayers"];
  int relayers_size() const;
  private:
  int _internal_relayers_size() const;

  public:
  void clear_relayers() ;
  const std::string& relayers(int index) const;
  std::string* mutable_relayers(int index);
  void set_relayers(int index, const std::string& value);
  void set_relayers(int index, std::string&& value);
  void set_relayers(int index, const char* value);
  void set_relayers(int index, const char* value, std::size_t size);
  void set_relayers(int index, absl::string_view value);
  std::string* add_relayers();
  void add_relayers(const std::string& value);
  void add_relayers(std::string&& value);
  void add_relayers(const char* value);
  void add_relayers(const char* value, std::size_t size);
  void add_relayers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_relayers();

  private:
  const std::string& _internal_relayers(int index) const;
  std::string* _internal_add_relayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_relayers();

  public:
  // string source_port_id = 2 [json_name = "sourcePortId"];
  void clear_source_port_id() ;
  const std::string& source_port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_port_id();
  PROTOBUF_NODISCARD std::string* release_source_port_id();
  void set_allocated_source_port_id(std::string* ptr);

  private:
  const std::string& _internal_source_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_port_id(
      const std::string& value);
  std::string* _internal_mutable_source_port_id();

  public:
  // string source_channel_id = 3 [json_name = "sourceChannelId"];
  void clear_source_channel_id() ;
  const std::string& source_channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_channel_id();
  PROTOBUF_NODISCARD std::string* release_source_channel_id();
  void set_allocated_source_channel_id(std::string* ptr);

  private:
  const std::string& _internal_source_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_channel_id(
      const std::string& value);
  std::string* _internal_mutable_source_channel_id();

  public:
  // string signer = 4 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.applications.fee.v1.Fee fee = 1 [json_name = "fee", (.gogoproto.nullable) = false];
  bool has_fee() const;
  void clear_fee() ;
  const ::ibc::applications::fee::v1::Fee& fee() const;
  PROTOBUF_NODISCARD ::ibc::applications::fee::v1::Fee* release_fee();
  ::ibc::applications::fee::v1::Fee* mutable_fee();
  void set_allocated_fee(::ibc::applications::fee::v1::Fee* fee);
  private:
  const ::ibc::applications::fee::v1::Fee& _internal_fee() const;
  ::ibc::applications::fee::v1::Fee* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::ibc::applications::fee::v1::Fee* fee);
  ::ibc::applications::fee::v1::Fee* unsafe_arena_release_fee();
  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgPayPacketFee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> relayers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::applications::fee::v1::Fee* fee_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPayPacketFeeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgPayPacketFeeResponse) */ {
 public:
  inline MsgPayPacketFeeResponse() : MsgPayPacketFeeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPayPacketFeeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPayPacketFeeResponse(const MsgPayPacketFeeResponse& from);
  MsgPayPacketFeeResponse(MsgPayPacketFeeResponse&& from) noexcept
    : MsgPayPacketFeeResponse() {
    *this = ::std::move(from);
  }

  inline MsgPayPacketFeeResponse& operator=(const MsgPayPacketFeeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPayPacketFeeResponse& operator=(MsgPayPacketFeeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPayPacketFeeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPayPacketFeeResponse* internal_default_instance() {
    return reinterpret_cast<const MsgPayPacketFeeResponse*>(
               &_MsgPayPacketFeeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgPayPacketFeeResponse& a, MsgPayPacketFeeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPayPacketFeeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPayPacketFeeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPayPacketFeeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPayPacketFeeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgPayPacketFeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgPayPacketFeeResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgPayPacketFeeResponse";
  }
  protected:
  explicit MsgPayPacketFeeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgPayPacketFeeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPayPacketFeeAsync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgPayPacketFeeAsync) */ {
 public:
  inline MsgPayPacketFeeAsync() : MsgPayPacketFeeAsync(nullptr) {}
  ~MsgPayPacketFeeAsync() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPayPacketFeeAsync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPayPacketFeeAsync(const MsgPayPacketFeeAsync& from);
  MsgPayPacketFeeAsync(MsgPayPacketFeeAsync&& from) noexcept
    : MsgPayPacketFeeAsync() {
    *this = ::std::move(from);
  }

  inline MsgPayPacketFeeAsync& operator=(const MsgPayPacketFeeAsync& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPayPacketFeeAsync& operator=(MsgPayPacketFeeAsync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPayPacketFeeAsync& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPayPacketFeeAsync* internal_default_instance() {
    return reinterpret_cast<const MsgPayPacketFeeAsync*>(
               &_MsgPayPacketFeeAsync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgPayPacketFeeAsync& a, MsgPayPacketFeeAsync& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPayPacketFeeAsync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPayPacketFeeAsync* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPayPacketFeeAsync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPayPacketFeeAsync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPayPacketFeeAsync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPayPacketFeeAsync& from) {
    MsgPayPacketFeeAsync::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPayPacketFeeAsync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgPayPacketFeeAsync";
  }
  protected:
  explicit MsgPayPacketFeeAsync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kPacketFeeFieldNumber = 2,
  };
  // .ibc.core.channel.v1.PacketId packet_id = 1 [json_name = "packetId", (.gogoproto.nullable) = false];
  bool has_packet_id() const;
  void clear_packet_id() ;
  const ::ibc::core::channel::v1::PacketId& packet_id() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::PacketId* release_packet_id();
  ::ibc::core::channel::v1::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ibc::core::channel::v1::PacketId* packet_id);
  private:
  const ::ibc::core::channel::v1::PacketId& _internal_packet_id() const;
  ::ibc::core::channel::v1::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ibc::core::channel::v1::PacketId* packet_id);
  ::ibc::core::channel::v1::PacketId* unsafe_arena_release_packet_id();
  // .ibc.applications.fee.v1.PacketFee packet_fee = 2 [json_name = "packetFee", (.gogoproto.nullable) = false];
  bool has_packet_fee() const;
  void clear_packet_fee() ;
  const ::ibc::applications::fee::v1::PacketFee& packet_fee() const;
  PROTOBUF_NODISCARD ::ibc::applications::fee::v1::PacketFee* release_packet_fee();
  ::ibc::applications::fee::v1::PacketFee* mutable_packet_fee();
  void set_allocated_packet_fee(::ibc::applications::fee::v1::PacketFee* packet_fee);
  private:
  const ::ibc::applications::fee::v1::PacketFee& _internal_packet_fee() const;
  ::ibc::applications::fee::v1::PacketFee* _internal_mutable_packet_fee();
  public:
  void unsafe_arena_set_allocated_packet_fee(
      ::ibc::applications::fee::v1::PacketFee* packet_fee);
  ::ibc::applications::fee::v1::PacketFee* unsafe_arena_release_packet_fee();
  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgPayPacketFeeAsync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ibc::core::channel::v1::PacketId* packet_id_;
    ::ibc::applications::fee::v1::PacketFee* packet_fee_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgPayPacketFeeAsyncResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse) */ {
 public:
  inline MsgPayPacketFeeAsyncResponse() : MsgPayPacketFeeAsyncResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgPayPacketFeeAsyncResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPayPacketFeeAsyncResponse(const MsgPayPacketFeeAsyncResponse& from);
  MsgPayPacketFeeAsyncResponse(MsgPayPacketFeeAsyncResponse&& from) noexcept
    : MsgPayPacketFeeAsyncResponse() {
    *this = ::std::move(from);
  }

  inline MsgPayPacketFeeAsyncResponse& operator=(const MsgPayPacketFeeAsyncResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPayPacketFeeAsyncResponse& operator=(MsgPayPacketFeeAsyncResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPayPacketFeeAsyncResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPayPacketFeeAsyncResponse* internal_default_instance() {
    return reinterpret_cast<const MsgPayPacketFeeAsyncResponse*>(
               &_MsgPayPacketFeeAsyncResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgPayPacketFeeAsyncResponse& a, MsgPayPacketFeeAsyncResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPayPacketFeeAsyncResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPayPacketFeeAsyncResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPayPacketFeeAsyncResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPayPacketFeeAsyncResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgPayPacketFeeAsyncResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgPayPacketFeeAsyncResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse";
  }
  protected:
  explicit MsgPayPacketFeeAsyncResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgRegisterPayee

// string port_id = 1 [json_name = "portId"];
inline void MsgRegisterPayee::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgRegisterPayee::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterPayee.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterPayee::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterPayee.port_id)
}
inline std::string* MsgRegisterPayee::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterPayee.port_id)
  return _s;
}
inline const std::string& MsgRegisterPayee::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgRegisterPayee::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterPayee.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgRegisterPayee::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterPayee.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgRegisterPayee::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgRegisterPayee::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterPayee.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterPayee::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterPayee.channel_id)
}
inline std::string* MsgRegisterPayee::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterPayee.channel_id)
  return _s;
}
inline const std::string& MsgRegisterPayee::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgRegisterPayee::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterPayee.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgRegisterPayee::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterPayee.channel_id)
}

// string relayer = 3 [json_name = "relayer"];
inline void MsgRegisterPayee::clear_relayer() {
  _impl_.relayer_.ClearToEmpty();
}
inline const std::string& MsgRegisterPayee::relayer() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterPayee.relayer)
  return _internal_relayer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterPayee::set_relayer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterPayee.relayer)
}
inline std::string* MsgRegisterPayee::mutable_relayer() {
  std::string* _s = _internal_mutable_relayer();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterPayee.relayer)
  return _s;
}
inline const std::string& MsgRegisterPayee::_internal_relayer() const {
  return _impl_.relayer_.Get();
}
inline void MsgRegisterPayee::_internal_set_relayer(const std::string& value) {
  ;


  _impl_.relayer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::_internal_mutable_relayer() {
  ;
  return _impl_.relayer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::release_relayer() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterPayee.relayer)
  return _impl_.relayer_.Release();
}
inline void MsgRegisterPayee::set_allocated_relayer(std::string* value) {
  _impl_.relayer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_.IsDefault()) {
          _impl_.relayer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterPayee.relayer)
}

// string payee = 4 [json_name = "payee"];
inline void MsgRegisterPayee::clear_payee() {
  _impl_.payee_.ClearToEmpty();
}
inline const std::string& MsgRegisterPayee::payee() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterPayee.payee)
  return _internal_payee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterPayee::set_payee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterPayee.payee)
}
inline std::string* MsgRegisterPayee::mutable_payee() {
  std::string* _s = _internal_mutable_payee();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterPayee.payee)
  return _s;
}
inline const std::string& MsgRegisterPayee::_internal_payee() const {
  return _impl_.payee_.Get();
}
inline void MsgRegisterPayee::_internal_set_payee(const std::string& value) {
  ;


  _impl_.payee_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::_internal_mutable_payee() {
  ;
  return _impl_.payee_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterPayee::release_payee() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterPayee.payee)
  return _impl_.payee_.Release();
}
inline void MsgRegisterPayee::set_allocated_payee(std::string* value) {
  _impl_.payee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payee_.IsDefault()) {
          _impl_.payee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterPayee.payee)
}

// -------------------------------------------------------------------

// MsgRegisterPayeeResponse

// -------------------------------------------------------------------

// MsgRegisterCounterpartyPayee

// string port_id = 1 [json_name = "portId"];
inline void MsgRegisterCounterpartyPayee::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgRegisterCounterpartyPayee::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterCounterpartyPayee::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.port_id)
}
inline std::string* MsgRegisterCounterpartyPayee::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.port_id)
  return _s;
}
inline const std::string& MsgRegisterCounterpartyPayee::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgRegisterCounterpartyPayee::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgRegisterCounterpartyPayee::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgRegisterCounterpartyPayee::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgRegisterCounterpartyPayee::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterCounterpartyPayee::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.channel_id)
}
inline std::string* MsgRegisterCounterpartyPayee::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.channel_id)
  return _s;
}
inline const std::string& MsgRegisterCounterpartyPayee::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgRegisterCounterpartyPayee::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgRegisterCounterpartyPayee::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.channel_id)
}

// string relayer = 3 [json_name = "relayer"];
inline void MsgRegisterCounterpartyPayee::clear_relayer() {
  _impl_.relayer_.ClearToEmpty();
}
inline const std::string& MsgRegisterCounterpartyPayee::relayer() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.relayer)
  return _internal_relayer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterCounterpartyPayee::set_relayer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.relayer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.relayer)
}
inline std::string* MsgRegisterCounterpartyPayee::mutable_relayer() {
  std::string* _s = _internal_mutable_relayer();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.relayer)
  return _s;
}
inline const std::string& MsgRegisterCounterpartyPayee::_internal_relayer() const {
  return _impl_.relayer_.Get();
}
inline void MsgRegisterCounterpartyPayee::_internal_set_relayer(const std::string& value) {
  ;


  _impl_.relayer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::_internal_mutable_relayer() {
  ;
  return _impl_.relayer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::release_relayer() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.relayer)
  return _impl_.relayer_.Release();
}
inline void MsgRegisterCounterpartyPayee::set_allocated_relayer(std::string* value) {
  _impl_.relayer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.relayer_.IsDefault()) {
          _impl_.relayer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.relayer)
}

// string counterparty_payee = 4 [json_name = "counterpartyPayee"];
inline void MsgRegisterCounterpartyPayee::clear_counterparty_payee() {
  _impl_.counterparty_payee_.ClearToEmpty();
}
inline const std::string& MsgRegisterCounterpartyPayee::counterparty_payee() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.counterparty_payee)
  return _internal_counterparty_payee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRegisterCounterpartyPayee::set_counterparty_payee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.counterparty_payee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.counterparty_payee)
}
inline std::string* MsgRegisterCounterpartyPayee::mutable_counterparty_payee() {
  std::string* _s = _internal_mutable_counterparty_payee();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.counterparty_payee)
  return _s;
}
inline const std::string& MsgRegisterCounterpartyPayee::_internal_counterparty_payee() const {
  return _impl_.counterparty_payee_.Get();
}
inline void MsgRegisterCounterpartyPayee::_internal_set_counterparty_payee(const std::string& value) {
  ;


  _impl_.counterparty_payee_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::_internal_mutable_counterparty_payee() {
  ;
  return _impl_.counterparty_payee_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRegisterCounterpartyPayee::release_counterparty_payee() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.counterparty_payee)
  return _impl_.counterparty_payee_.Release();
}
inline void MsgRegisterCounterpartyPayee::set_allocated_counterparty_payee(std::string* value) {
  _impl_.counterparty_payee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.counterparty_payee_.IsDefault()) {
          _impl_.counterparty_payee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgRegisterCounterpartyPayee.counterparty_payee)
}

// -------------------------------------------------------------------

// MsgRegisterCounterpartyPayeeResponse

// -------------------------------------------------------------------

// MsgPayPacketFee

// .ibc.applications.fee.v1.Fee fee = 1 [json_name = "fee", (.gogoproto.nullable) = false];
inline bool MsgPayPacketFee::has_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_ != nullptr);
  return value;
}
inline const ::ibc::applications::fee::v1::Fee& MsgPayPacketFee::_internal_fee() const {
  const ::ibc::applications::fee::v1::Fee* p = _impl_.fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::applications::fee::v1::Fee&>(
      ::ibc::applications::fee::v1::_Fee_default_instance_);
}
inline const ::ibc::applications::fee::v1::Fee& MsgPayPacketFee::fee() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFee.fee)
  return _internal_fee();
}
inline void MsgPayPacketFee::unsafe_arena_set_allocated_fee(
    ::ibc::applications::fee::v1::Fee* fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  _impl_.fee_ = fee;
  if (fee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.applications.fee.v1.MsgPayPacketFee.fee)
}
inline ::ibc::applications::fee::v1::Fee* MsgPayPacketFee::release_fee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::applications::fee::v1::Fee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::applications::fee::v1::Fee* MsgPayPacketFee::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFee.fee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::applications::fee::v1::Fee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
  return temp;
}
inline ::ibc::applications::fee::v1::Fee* MsgPayPacketFee::_internal_mutable_fee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::applications::fee::v1::Fee>(GetArenaForAllocation());
    _impl_.fee_ = p;
  }
  return _impl_.fee_;
}
inline ::ibc::applications::fee::v1::Fee* MsgPayPacketFee::mutable_fee() {
  ::ibc::applications::fee::v1::Fee* _msg = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFee.fee)
  return _msg;
}
inline void MsgPayPacketFee::set_allocated_fee(::ibc::applications::fee::v1::Fee* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fee));
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFee.fee)
}

// string source_port_id = 2 [json_name = "sourcePortId"];
inline void MsgPayPacketFee::clear_source_port_id() {
  _impl_.source_port_id_.ClearToEmpty();
}
inline const std::string& MsgPayPacketFee::source_port_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFee.source_port_id)
  return _internal_source_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPayPacketFee::set_source_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgPayPacketFee.source_port_id)
}
inline std::string* MsgPayPacketFee::mutable_source_port_id() {
  std::string* _s = _internal_mutable_source_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFee.source_port_id)
  return _s;
}
inline const std::string& MsgPayPacketFee::_internal_source_port_id() const {
  return _impl_.source_port_id_.Get();
}
inline void MsgPayPacketFee::_internal_set_source_port_id(const std::string& value) {
  ;


  _impl_.source_port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::_internal_mutable_source_port_id() {
  ;
  return _impl_.source_port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::release_source_port_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFee.source_port_id)
  return _impl_.source_port_id_.Release();
}
inline void MsgPayPacketFee::set_allocated_source_port_id(std::string* value) {
  _impl_.source_port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_port_id_.IsDefault()) {
          _impl_.source_port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFee.source_port_id)
}

// string source_channel_id = 3 [json_name = "sourceChannelId"];
inline void MsgPayPacketFee::clear_source_channel_id() {
  _impl_.source_channel_id_.ClearToEmpty();
}
inline const std::string& MsgPayPacketFee::source_channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFee.source_channel_id)
  return _internal_source_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPayPacketFee::set_source_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgPayPacketFee.source_channel_id)
}
inline std::string* MsgPayPacketFee::mutable_source_channel_id() {
  std::string* _s = _internal_mutable_source_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFee.source_channel_id)
  return _s;
}
inline const std::string& MsgPayPacketFee::_internal_source_channel_id() const {
  return _impl_.source_channel_id_.Get();
}
inline void MsgPayPacketFee::_internal_set_source_channel_id(const std::string& value) {
  ;


  _impl_.source_channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::_internal_mutable_source_channel_id() {
  ;
  return _impl_.source_channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::release_source_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFee.source_channel_id)
  return _impl_.source_channel_id_.Release();
}
inline void MsgPayPacketFee::set_allocated_source_channel_id(std::string* value) {
  _impl_.source_channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_channel_id_.IsDefault()) {
          _impl_.source_channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFee.source_channel_id)
}

// string signer = 4 [json_name = "signer"];
inline void MsgPayPacketFee::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgPayPacketFee::signer() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFee.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgPayPacketFee::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgPayPacketFee.signer)
}
inline std::string* MsgPayPacketFee::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFee.signer)
  return _s;
}
inline const std::string& MsgPayPacketFee::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgPayPacketFee::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgPayPacketFee::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFee.signer)
  return _impl_.signer_.Release();
}
inline void MsgPayPacketFee::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFee.signer)
}

// repeated string relayers = 5 [json_name = "relayers"];
inline int MsgPayPacketFee::_internal_relayers_size() const {
  return _impl_.relayers_.size();
}
inline int MsgPayPacketFee::relayers_size() const {
  return _internal_relayers_size();
}
inline void MsgPayPacketFee::clear_relayers() {
  _internal_mutable_relayers()->Clear();
}
inline std::string* MsgPayPacketFee::add_relayers() {
  std::string* _s = _internal_add_relayers();
  // @@protoc_insertion_point(field_add_mutable:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
  return _s;
}
inline const std::string& MsgPayPacketFee::relayers(int index) const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
  return _internal_relayers(index);
}
inline std::string* MsgPayPacketFee::mutable_relayers(int index) {
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
  return _internal_mutable_relayers()->Mutable(index);
}
inline void MsgPayPacketFee::set_relayers(int index, const std::string& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::set_relayers(int index, std::string&& value) {
  _internal_mutable_relayers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::set_relayers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::set_relayers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_relayers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::set_relayers(int index, absl::string_view value) {
  _internal_mutable_relayers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::add_relayers(const std::string& value) {
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::add_relayers(std::string&& value) {
  _internal_mutable_relayers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::add_relayers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_relayers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::add_relayers(const char* value, std::size_t size) {
  _internal_mutable_relayers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline void MsgPayPacketFee::add_relayers(absl::string_view value) {
  _internal_mutable_relayers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgPayPacketFee::relayers() const {
  // @@protoc_insertion_point(field_list:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
  return _internal_relayers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* MsgPayPacketFee::mutable_relayers() {
  // @@protoc_insertion_point(field_mutable_list:ibc.applications.fee.v1.MsgPayPacketFee.relayers)
  return _internal_mutable_relayers();
}
inline const std::string& MsgPayPacketFee::_internal_relayers(int index) const {
  return _internal_relayers().Get(index);
}
inline std::string* MsgPayPacketFee::_internal_add_relayers() {
  return _internal_mutable_relayers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MsgPayPacketFee::_internal_relayers() const {
  return _impl_.relayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MsgPayPacketFee::_internal_mutable_relayers() {
  return &_impl_.relayers_;
}

// -------------------------------------------------------------------

// MsgPayPacketFeeResponse

// -------------------------------------------------------------------

// MsgPayPacketFeeAsync

// .ibc.core.channel.v1.PacketId packet_id = 1 [json_name = "packetId", (.gogoproto.nullable) = false];
inline bool MsgPayPacketFeeAsync::has_packet_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_id_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::PacketId& MsgPayPacketFeeAsync::_internal_packet_id() const {
  const ::ibc::core::channel::v1::PacketId* p = _impl_.packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::PacketId&>(
      ::ibc::core::channel::v1::_PacketId_default_instance_);
}
inline const ::ibc::core::channel::v1::PacketId& MsgPayPacketFeeAsync::packet_id() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_id)
  return _internal_packet_id();
}
inline void MsgPayPacketFeeAsync::unsafe_arena_set_allocated_packet_id(
    ::ibc::core::channel::v1::PacketId* packet_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_id_);
  }
  _impl_.packet_id_ = packet_id;
  if (packet_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_id)
}
inline ::ibc::core::channel::v1::PacketId* MsgPayPacketFeeAsync::release_packet_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::PacketId* MsgPayPacketFeeAsync::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::PacketId* temp = _impl_.packet_id_;
  _impl_.packet_id_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::PacketId* MsgPayPacketFeeAsync::_internal_mutable_packet_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::PacketId>(GetArenaForAllocation());
    _impl_.packet_id_ = p;
  }
  return _impl_.packet_id_;
}
inline ::ibc::core::channel::v1::PacketId* MsgPayPacketFeeAsync::mutable_packet_id() {
  ::ibc::core::channel::v1::PacketId* _msg = _internal_mutable_packet_id();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_id)
  return _msg;
}
inline void MsgPayPacketFeeAsync::set_allocated_packet_id(::ibc::core::channel::v1::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_id_);
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_id));
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_id)
}

// .ibc.applications.fee.v1.PacketFee packet_fee = 2 [json_name = "packetFee", (.gogoproto.nullable) = false];
inline bool MsgPayPacketFeeAsync::has_packet_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_fee_ != nullptr);
  return value;
}
inline const ::ibc::applications::fee::v1::PacketFee& MsgPayPacketFeeAsync::_internal_packet_fee() const {
  const ::ibc::applications::fee::v1::PacketFee* p = _impl_.packet_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::applications::fee::v1::PacketFee&>(
      ::ibc::applications::fee::v1::_PacketFee_default_instance_);
}
inline const ::ibc::applications::fee::v1::PacketFee& MsgPayPacketFeeAsync::packet_fee() const {
  // @@protoc_insertion_point(field_get:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_fee)
  return _internal_packet_fee();
}
inline void MsgPayPacketFeeAsync::unsafe_arena_set_allocated_packet_fee(
    ::ibc::applications::fee::v1::PacketFee* packet_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_fee_);
  }
  _impl_.packet_fee_ = packet_fee;
  if (packet_fee) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_fee)
}
inline ::ibc::applications::fee::v1::PacketFee* MsgPayPacketFeeAsync::release_packet_fee() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::applications::fee::v1::PacketFee* temp = _impl_.packet_fee_;
  _impl_.packet_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::applications::fee::v1::PacketFee* MsgPayPacketFeeAsync::unsafe_arena_release_packet_fee() {
  // @@protoc_insertion_point(field_release:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_fee)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::applications::fee::v1::PacketFee* temp = _impl_.packet_fee_;
  _impl_.packet_fee_ = nullptr;
  return temp;
}
inline ::ibc::applications::fee::v1::PacketFee* MsgPayPacketFeeAsync::_internal_mutable_packet_fee() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.packet_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::applications::fee::v1::PacketFee>(GetArenaForAllocation());
    _impl_.packet_fee_ = p;
  }
  return _impl_.packet_fee_;
}
inline ::ibc::applications::fee::v1::PacketFee* MsgPayPacketFeeAsync::mutable_packet_fee() {
  ::ibc::applications::fee::v1::PacketFee* _msg = _internal_mutable_packet_fee();
  // @@protoc_insertion_point(field_mutable:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_fee)
  return _msg;
}
inline void MsgPayPacketFeeAsync::set_allocated_packet_fee(::ibc::applications::fee::v1::PacketFee* packet_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_fee_);
  }
  if (packet_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_fee));
    if (message_arena != submessage_arena) {
      packet_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.packet_fee_ = packet_fee;
  // @@protoc_insertion_point(field_set_allocated:ibc.applications.fee.v1.MsgPayPacketFeeAsync.packet_fee)
}

// -------------------------------------------------------------------

// MsgPayPacketFeeAsyncResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace fee
}  // namespace applications
}  // namespace ibc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ibc_2fapplications_2ffee_2fv1_2ftx_2eproto_2epb_2eh
