// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ibc/core/connection/v1/query.proto
#ifndef GRPC_ibc_2fcore_2fconnection_2fv1_2fquery_2eproto__INCLUDED
#define GRPC_ibc_2fcore_2fconnection_2fv1_2fquery_2eproto__INCLUDED

#include "ibc/core/connection/v1/query.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace ibc {
namespace core {
namespace connection {
namespace v1 {

// Query provides defines the gRPC querier service
class Query final {
 public:
  static constexpr char const* service_full_name() {
    return "ibc.core.connection.v1.Query";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Connection queries an IBC connection end.
    virtual ::grpc::Status Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::ibc::core::connection::v1::QueryConnectionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>> AsyncConnection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>>(AsyncConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>> PrepareAsyncConnection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>>(PrepareAsyncConnectionRaw(context, request, cq));
    }
    // Connections queries all the IBC connections of a chain.
    virtual ::grpc::Status Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::ibc::core::connection::v1::QueryConnectionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>> AsyncConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>>(AsyncConnectionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>> PrepareAsyncConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>>(PrepareAsyncConnectionsRaw(context, request, cq));
    }
    // ClientConnections queries the connection paths associated with a client
    // state.
    virtual ::grpc::Status ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>> AsyncClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>>(AsyncClientConnectionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>> PrepareAsyncClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>>(PrepareAsyncClientConnectionsRaw(context, request, cq));
    }
    // ConnectionClientState queries the client state associated with the
    // connection.
    virtual ::grpc::Status ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>> AsyncConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>>(AsyncConnectionClientStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>> PrepareAsyncConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>>(PrepareAsyncConnectionClientStateRaw(context, request, cq));
    }
    // ConnectionConsensusState queries the consensus state associated with the
    // connection.
    virtual ::grpc::Status ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>> AsyncConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>>(AsyncConnectionConsensusStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>> PrepareAsyncConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>>(PrepareAsyncConnectionConsensusStateRaw(context, request, cq));
    }
    // ConnectionParams queries all parameters of the ibc connection submodule.
    virtual ::grpc::Status ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>> AsyncConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>>(AsyncConnectionParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>> PrepareAsyncConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>>(PrepareAsyncConnectionParamsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Connection queries an IBC connection end.
      virtual void Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Connections queries all the IBC connections of a chain.
      virtual void Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ClientConnections queries the connection paths associated with a client
      // state.
      virtual void ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ConnectionClientState queries the client state associated with the
      // connection.
      virtual void ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ConnectionConsensusState queries the consensus state associated with the
      // connection.
      virtual void ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ConnectionParams queries all parameters of the ibc connection submodule.
      virtual void ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>* AsyncConnectionRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionResponse>* PrepareAsyncConnectionRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>* AsyncConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionsResponse>* PrepareAsyncConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>* AsyncClientConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryClientConnectionsResponse>* PrepareAsyncClientConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* AsyncConnectionClientStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* PrepareAsyncConnectionClientStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* AsyncConnectionConsensusStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* PrepareAsyncConnectionConsensusStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>* AsyncConnectionParamsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::connection::v1::QueryConnectionParamsResponse>* PrepareAsyncConnectionParamsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::ibc::core::connection::v1::QueryConnectionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>> AsyncConnection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>>(AsyncConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>> PrepareAsyncConnection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>>(PrepareAsyncConnectionRaw(context, request, cq));
    }
    ::grpc::Status Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::ibc::core::connection::v1::QueryConnectionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>> AsyncConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>>(AsyncConnectionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>> PrepareAsyncConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>>(PrepareAsyncConnectionsRaw(context, request, cq));
    }
    ::grpc::Status ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>> AsyncClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>>(AsyncClientConnectionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>> PrepareAsyncClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>>(PrepareAsyncClientConnectionsRaw(context, request, cq));
    }
    ::grpc::Status ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>> AsyncConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>>(AsyncConnectionClientStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>> PrepareAsyncConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>>(PrepareAsyncConnectionClientStateRaw(context, request, cq));
    }
    ::grpc::Status ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>> AsyncConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>>(AsyncConnectionConsensusStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>> PrepareAsyncConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>>(PrepareAsyncConnectionConsensusStateRaw(context, request, cq));
    }
    ::grpc::Status ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>> AsyncConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>>(AsyncConnectionParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>> PrepareAsyncConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>>(PrepareAsyncConnectionParamsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response, std::function<void(::grpc::Status)>) override;
      void Connection(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response, std::function<void(::grpc::Status)>) override;
      void Connections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ClientConnections(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response, std::function<void(::grpc::Status)>) override;
      void ConnectionClientState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response, std::function<void(::grpc::Status)>) override;
      void ConnectionConsensusState(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void ConnectionParams(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>* AsyncConnectionRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionResponse>* PrepareAsyncConnectionRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>* AsyncConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionsResponse>* PrepareAsyncConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>* AsyncClientConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryClientConnectionsResponse>* PrepareAsyncClientConnectionsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* AsyncConnectionClientStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* PrepareAsyncConnectionClientStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* AsyncConnectionConsensusStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* PrepareAsyncConnectionConsensusStateRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>* AsyncConnectionParamsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::connection::v1::QueryConnectionParamsResponse>* PrepareAsyncConnectionParamsRaw(::grpc::ClientContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Connection_;
    const ::grpc::internal::RpcMethod rpcmethod_Connections_;
    const ::grpc::internal::RpcMethod rpcmethod_ClientConnections_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectionClientState_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectionConsensusState_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectionParams_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Connection queries an IBC connection end.
    virtual ::grpc::Status Connection(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response);
    // Connections queries all the IBC connections of a chain.
    virtual ::grpc::Status Connections(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response);
    // ClientConnections queries the connection paths associated with a client
    // state.
    virtual ::grpc::Status ClientConnections(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response);
    // ConnectionClientState queries the client state associated with the
    // connection.
    virtual ::grpc::Status ConnectionClientState(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response);
    // ConnectionConsensusState queries the consensus state associated with the
    // connection.
    virtual ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response);
    // ConnectionParams queries all parameters of the ibc connection submodule.
    virtual ::grpc::Status ConnectionParams(::grpc::ServerContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Connection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnection(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryConnectionRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryConnectionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Connections() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnections(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryConnectionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClientConnections() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientConnections(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryClientConnectionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionClientState(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionConsensusState(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionParams(::grpc::ServerContext* context, ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::connection::v1::QueryConnectionParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Connection<WithAsyncMethod_Connections<WithAsyncMethod_ClientConnections<WithAsyncMethod_ConnectionClientState<WithAsyncMethod_ConnectionConsensusState<WithAsyncMethod_ConnectionParams<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Connection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionRequest, ::ibc::core::connection::v1::QueryConnectionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryConnectionRequest* request, ::ibc::core::connection::v1::QueryConnectionResponse* response) { return this->Connection(context, request, response); }));}
    void SetMessageAllocatorFor_Connection(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryConnectionRequest, ::ibc::core::connection::v1::QueryConnectionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionRequest, ::ibc::core::connection::v1::QueryConnectionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connection(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Connections() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionsRequest, ::ibc::core::connection::v1::QueryConnectionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryConnectionsRequest* request, ::ibc::core::connection::v1::QueryConnectionsResponse* response) { return this->Connections(context, request, response); }));}
    void SetMessageAllocatorFor_Connections(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryConnectionsRequest, ::ibc::core::connection::v1::QueryConnectionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionsRequest, ::ibc::core::connection::v1::QueryConnectionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connections(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClientConnections() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryClientConnectionsRequest, ::ibc::core::connection::v1::QueryClientConnectionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* request, ::ibc::core::connection::v1::QueryClientConnectionsResponse* response) { return this->ClientConnections(context, request, response); }));}
    void SetMessageAllocatorFor_ClientConnections(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryClientConnectionsRequest, ::ibc::core::connection::v1::QueryClientConnectionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryClientConnectionsRequest, ::ibc::core::connection::v1::QueryClientConnectionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientConnections(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionClientStateRequest, ::ibc::core::connection::v1::QueryConnectionClientStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* request, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* response) { return this->ConnectionClientState(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectionClientState(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryConnectionClientStateRequest, ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionClientStateRequest, ::ibc::core::connection::v1::QueryConnectionClientStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionClientState(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* request, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* response) { return this->ConnectionConsensusState(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectionConsensusState(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionConsensusState(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionParamsRequest, ::ibc::core::connection::v1::QueryConnectionParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* request, ::ibc::core::connection::v1::QueryConnectionParamsResponse* response) { return this->ConnectionParams(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectionParams(
        ::grpc::MessageAllocator< ::ibc::core::connection::v1::QueryConnectionParamsRequest, ::ibc::core::connection::v1::QueryConnectionParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::connection::v1::QueryConnectionParamsRequest, ::ibc::core::connection::v1::QueryConnectionParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionParams(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Connection<WithCallbackMethod_Connections<WithCallbackMethod_ClientConnections<WithCallbackMethod_ConnectionClientState<WithCallbackMethod_ConnectionConsensusState<WithCallbackMethod_ConnectionParams<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Connection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Connections() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClientConnections() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Connection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Connections() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnections(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClientConnections() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientConnections(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionClientState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionConsensusState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectionParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Connection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Connection(context, request, response); }));
    }
    ~WithRawCallbackMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Connections() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Connections(context, request, response); }));
    }
    ~WithRawCallbackMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Connections(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClientConnections() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClientConnections(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClientConnections(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectionClientState(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionClientState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectionConsensusState(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionConsensusState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectionParams(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectionParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Connection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Connection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryConnectionRequest, ::ibc::core::connection::v1::QueryConnectionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryConnectionRequest, ::ibc::core::connection::v1::QueryConnectionResponse>* streamer) {
                       return this->StreamedConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Connection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Connection(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryConnectionRequest,::ibc::core::connection::v1::QueryConnectionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Connections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Connections() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryConnectionsRequest, ::ibc::core::connection::v1::QueryConnectionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryConnectionsRequest, ::ibc::core::connection::v1::QueryConnectionsResponse>* streamer) {
                       return this->StreamedConnections(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Connections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Connections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnections(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryConnectionsRequest,::ibc::core::connection::v1::QueryConnectionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClientConnections : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClientConnections() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryClientConnectionsRequest, ::ibc::core::connection::v1::QueryClientConnectionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryClientConnectionsRequest, ::ibc::core::connection::v1::QueryClientConnectionsResponse>* streamer) {
                       return this->StreamedClientConnections(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClientConnections() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClientConnections(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryClientConnectionsRequest* /*request*/, ::ibc::core::connection::v1::QueryClientConnectionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClientConnections(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryClientConnectionsRequest,::ibc::core::connection::v1::QueryClientConnectionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectionClientState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectionClientState() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryConnectionClientStateRequest, ::ibc::core::connection::v1::QueryConnectionClientStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryConnectionClientStateRequest, ::ibc::core::connection::v1::QueryConnectionClientStateResponse>* streamer) {
                       return this->StreamedConnectionClientState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectionClientState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectionClientState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionClientStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionClientStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectionClientState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryConnectionClientStateRequest,::ibc::core::connection::v1::QueryConnectionClientStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectionConsensusState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectionConsensusState() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* streamer) {
                       return this->StreamedConnectionConsensusState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectionConsensusState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectionConsensusState(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionConsensusStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectionConsensusState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryConnectionConsensusStateRequest,::ibc::core::connection::v1::QueryConnectionConsensusStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectionParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectionParams() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::connection::v1::QueryConnectionParamsRequest, ::ibc::core::connection::v1::QueryConnectionParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::connection::v1::QueryConnectionParamsRequest, ::ibc::core::connection::v1::QueryConnectionParamsResponse>* streamer) {
                       return this->StreamedConnectionParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectionParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectionParams(::grpc::ServerContext* /*context*/, const ::ibc::core::connection::v1::QueryConnectionParamsRequest* /*request*/, ::ibc::core::connection::v1::QueryConnectionParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectionParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::connection::v1::QueryConnectionParamsRequest,::ibc::core::connection::v1::QueryConnectionParamsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Connection<WithStreamedUnaryMethod_Connections<WithStreamedUnaryMethod_ClientConnections<WithStreamedUnaryMethod_ConnectionClientState<WithStreamedUnaryMethod_ConnectionConsensusState<WithStreamedUnaryMethod_ConnectionParams<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Connection<WithStreamedUnaryMethod_Connections<WithStreamedUnaryMethod_ClientConnections<WithStreamedUnaryMethod_ConnectionClientState<WithStreamedUnaryMethod_ConnectionConsensusState<WithStreamedUnaryMethod_ConnectionParams<Service > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace connection
}  // namespace core
}  // namespace ibc


#endif  // GRPC_ibc_2fcore_2fconnection_2fv1_2fquery_2eproto__INCLUDED
