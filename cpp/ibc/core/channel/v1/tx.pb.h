// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ibc/core/channel/v1/tx.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "gogoproto/gogo.pb.h"
#include "ibc/core/client/v1/client.pb.h"
#include "ibc/core/channel/v1/channel.pb.h"
#include "cosmos/msg/v1/msg.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
namespace ibc {
namespace core {
namespace channel {
namespace v1 {
class MsgAcknowledgement;
struct MsgAcknowledgementDefaultTypeInternal;
extern MsgAcknowledgementDefaultTypeInternal _MsgAcknowledgement_default_instance_;
class MsgAcknowledgementResponse;
struct MsgAcknowledgementResponseDefaultTypeInternal;
extern MsgAcknowledgementResponseDefaultTypeInternal _MsgAcknowledgementResponse_default_instance_;
class MsgChannelCloseConfirm;
struct MsgChannelCloseConfirmDefaultTypeInternal;
extern MsgChannelCloseConfirmDefaultTypeInternal _MsgChannelCloseConfirm_default_instance_;
class MsgChannelCloseConfirmResponse;
struct MsgChannelCloseConfirmResponseDefaultTypeInternal;
extern MsgChannelCloseConfirmResponseDefaultTypeInternal _MsgChannelCloseConfirmResponse_default_instance_;
class MsgChannelCloseInit;
struct MsgChannelCloseInitDefaultTypeInternal;
extern MsgChannelCloseInitDefaultTypeInternal _MsgChannelCloseInit_default_instance_;
class MsgChannelCloseInitResponse;
struct MsgChannelCloseInitResponseDefaultTypeInternal;
extern MsgChannelCloseInitResponseDefaultTypeInternal _MsgChannelCloseInitResponse_default_instance_;
class MsgChannelOpenAck;
struct MsgChannelOpenAckDefaultTypeInternal;
extern MsgChannelOpenAckDefaultTypeInternal _MsgChannelOpenAck_default_instance_;
class MsgChannelOpenAckResponse;
struct MsgChannelOpenAckResponseDefaultTypeInternal;
extern MsgChannelOpenAckResponseDefaultTypeInternal _MsgChannelOpenAckResponse_default_instance_;
class MsgChannelOpenConfirm;
struct MsgChannelOpenConfirmDefaultTypeInternal;
extern MsgChannelOpenConfirmDefaultTypeInternal _MsgChannelOpenConfirm_default_instance_;
class MsgChannelOpenConfirmResponse;
struct MsgChannelOpenConfirmResponseDefaultTypeInternal;
extern MsgChannelOpenConfirmResponseDefaultTypeInternal _MsgChannelOpenConfirmResponse_default_instance_;
class MsgChannelOpenInit;
struct MsgChannelOpenInitDefaultTypeInternal;
extern MsgChannelOpenInitDefaultTypeInternal _MsgChannelOpenInit_default_instance_;
class MsgChannelOpenInitResponse;
struct MsgChannelOpenInitResponseDefaultTypeInternal;
extern MsgChannelOpenInitResponseDefaultTypeInternal _MsgChannelOpenInitResponse_default_instance_;
class MsgChannelOpenTry;
struct MsgChannelOpenTryDefaultTypeInternal;
extern MsgChannelOpenTryDefaultTypeInternal _MsgChannelOpenTry_default_instance_;
class MsgChannelOpenTryResponse;
struct MsgChannelOpenTryResponseDefaultTypeInternal;
extern MsgChannelOpenTryResponseDefaultTypeInternal _MsgChannelOpenTryResponse_default_instance_;
class MsgRecvPacket;
struct MsgRecvPacketDefaultTypeInternal;
extern MsgRecvPacketDefaultTypeInternal _MsgRecvPacket_default_instance_;
class MsgRecvPacketResponse;
struct MsgRecvPacketResponseDefaultTypeInternal;
extern MsgRecvPacketResponseDefaultTypeInternal _MsgRecvPacketResponse_default_instance_;
class MsgTimeout;
struct MsgTimeoutDefaultTypeInternal;
extern MsgTimeoutDefaultTypeInternal _MsgTimeout_default_instance_;
class MsgTimeoutOnClose;
struct MsgTimeoutOnCloseDefaultTypeInternal;
extern MsgTimeoutOnCloseDefaultTypeInternal _MsgTimeoutOnClose_default_instance_;
class MsgTimeoutOnCloseResponse;
struct MsgTimeoutOnCloseResponseDefaultTypeInternal;
extern MsgTimeoutOnCloseResponseDefaultTypeInternal _MsgTimeoutOnCloseResponse_default_instance_;
class MsgTimeoutResponse;
struct MsgTimeoutResponseDefaultTypeInternal;
extern MsgTimeoutResponseDefaultTypeInternal _MsgTimeoutResponse_default_instance_;
}  // namespace v1
}  // namespace channel
}  // namespace core
}  // namespace ibc
PROTOBUF_NAMESPACE_OPEN
template <>
::ibc::core::channel::v1::MsgAcknowledgement* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgAcknowledgement>(Arena*);
template <>
::ibc::core::channel::v1::MsgAcknowledgementResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgAcknowledgementResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelCloseConfirm* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelCloseConfirm>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelCloseInit* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelCloseInit>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelCloseInitResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelCloseInitResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenAck* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenAck>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenAckResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenAckResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenConfirm* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenConfirm>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenInit* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenInit>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenInitResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenInitResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenTry* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenTry>(Arena*);
template <>
::ibc::core::channel::v1::MsgChannelOpenTryResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgChannelOpenTryResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgRecvPacket* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgRecvPacket>(Arena*);
template <>
::ibc::core::channel::v1::MsgRecvPacketResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgRecvPacketResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgTimeout* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgTimeout>(Arena*);
template <>
::ibc::core::channel::v1::MsgTimeoutOnClose* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgTimeoutOnClose>(Arena*);
template <>
::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>(Arena*);
template <>
::ibc::core::channel::v1::MsgTimeoutResponse* Arena::CreateMaybeMessage<::ibc::core::channel::v1::MsgTimeoutResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ibc {
namespace core {
namespace channel {
namespace v1 {
enum ResponseResultType : int {
  RESPONSE_RESULT_TYPE_UNSPECIFIED = 0,
  RESPONSE_RESULT_TYPE_NOOP = 1,
  RESPONSE_RESULT_TYPE_SUCCESS = 2,
  ResponseResultType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResponseResultType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResponseResultType_IsValid(int value);
constexpr ResponseResultType ResponseResultType_MIN = static_cast<ResponseResultType>(0);
constexpr ResponseResultType ResponseResultType_MAX = static_cast<ResponseResultType>(2);
constexpr int ResponseResultType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResponseResultType_descriptor();
template <typename T>
const std::string& ResponseResultType_Name(T value) {
  static_assert(std::is_same<T, ResponseResultType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseResultType_Name().");
  return ResponseResultType_Name(static_cast<ResponseResultType>(value));
}
template <>
inline const std::string& ResponseResultType_Name(ResponseResultType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResponseResultType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ResponseResultType_Parse(absl::string_view name, ResponseResultType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseResultType>(
      ResponseResultType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MsgChannelOpenInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenInit) */ {
 public:
  inline MsgChannelOpenInit() : MsgChannelOpenInit(nullptr) {}
  ~MsgChannelOpenInit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenInit(const MsgChannelOpenInit& from);
  MsgChannelOpenInit(MsgChannelOpenInit&& from) noexcept
    : MsgChannelOpenInit() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenInit& operator=(const MsgChannelOpenInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenInit& operator=(MsgChannelOpenInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenInit* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenInit*>(
               &_MsgChannelOpenInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgChannelOpenInit& a, MsgChannelOpenInit& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenInit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenInit& from) {
    MsgChannelOpenInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenInit";
  }
  protected:
  explicit MsgChannelOpenInit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kSignerFieldNumber = 3,
    kChannelFieldNumber = 2,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string signer = 3 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Channel channel = 2 [json_name = "channel", (.gogoproto.nullable) = false];
  bool has_channel() const;
  void clear_channel() ;
  const ::ibc::core::channel::v1::Channel& channel() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Channel* release_channel();
  ::ibc::core::channel::v1::Channel* mutable_channel();
  void set_allocated_channel(::ibc::core::channel::v1::Channel* channel);
  private:
  const ::ibc::core::channel::v1::Channel& _internal_channel() const;
  ::ibc::core::channel::v1::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::ibc::core::channel::v1::Channel* channel);
  ::ibc::core::channel::v1::Channel* unsafe_arena_release_channel();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Channel* channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenInitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenInitResponse) */ {
 public:
  inline MsgChannelOpenInitResponse() : MsgChannelOpenInitResponse(nullptr) {}
  ~MsgChannelOpenInitResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenInitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenInitResponse(const MsgChannelOpenInitResponse& from);
  MsgChannelOpenInitResponse(MsgChannelOpenInitResponse&& from) noexcept
    : MsgChannelOpenInitResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenInitResponse& operator=(const MsgChannelOpenInitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenInitResponse& operator=(MsgChannelOpenInitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenInitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenInitResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenInitResponse*>(
               &_MsgChannelOpenInitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgChannelOpenInitResponse& a, MsgChannelOpenInitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenInitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenInitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenInitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenInitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenInitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenInitResponse& from) {
    MsgChannelOpenInitResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenInitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenInitResponse";
  }
  protected:
  explicit MsgChannelOpenInitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string channel_id = 1 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string version = 2 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenInitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenTry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenTry) */ {
 public:
  inline MsgChannelOpenTry() : MsgChannelOpenTry(nullptr) {}
  ~MsgChannelOpenTry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenTry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenTry(const MsgChannelOpenTry& from);
  MsgChannelOpenTry(MsgChannelOpenTry&& from) noexcept
    : MsgChannelOpenTry() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenTry& operator=(const MsgChannelOpenTry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenTry& operator=(MsgChannelOpenTry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenTry& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenTry* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenTry*>(
               &_MsgChannelOpenTry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgChannelOpenTry& a, MsgChannelOpenTry& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenTry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenTry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenTry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenTry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenTry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenTry& from) {
    MsgChannelOpenTry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenTry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenTry";
  }
  protected:
  explicit MsgChannelOpenTry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPreviousChannelIdFieldNumber = 2,
    kCounterpartyVersionFieldNumber = 4,
    kProofInitFieldNumber = 5,
    kSignerFieldNumber = 7,
    kChannelFieldNumber = 3,
    kProofHeightFieldNumber = 6,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string previous_channel_id = 2 [json_name = "previousChannelId", deprecated = true];
  [[deprecated]]  void clear_previous_channel_id() ;
  [[deprecated]] const std::string& previous_channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  [[deprecated]] void set_previous_channel_id(Arg_&& arg, Args_... args);
  [[deprecated]] std::string* mutable_previous_channel_id();
  [[deprecated]] PROTOBUF_NODISCARD std::string* release_previous_channel_id();
  [[deprecated]] void set_allocated_previous_channel_id(std::string* ptr);

  private:
  const std::string& _internal_previous_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_channel_id(
      const std::string& value);
  std::string* _internal_mutable_previous_channel_id();

  public:
  // string counterparty_version = 4 [json_name = "counterpartyVersion"];
  void clear_counterparty_version() ;
  const std::string& counterparty_version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_counterparty_version(Arg_&& arg, Args_... args);
  std::string* mutable_counterparty_version();
  PROTOBUF_NODISCARD std::string* release_counterparty_version();
  void set_allocated_counterparty_version(std::string* ptr);

  private:
  const std::string& _internal_counterparty_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_counterparty_version(
      const std::string& value);
  std::string* _internal_mutable_counterparty_version();

  public:
  // bytes proof_init = 5 [json_name = "proofInit"];
  void clear_proof_init() ;
  const std::string& proof_init() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_init(Arg_&& arg, Args_... args);
  std::string* mutable_proof_init();
  PROTOBUF_NODISCARD std::string* release_proof_init();
  void set_allocated_proof_init(std::string* ptr);

  private:
  const std::string& _internal_proof_init() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_init(
      const std::string& value);
  std::string* _internal_mutable_proof_init();

  public:
  // string signer = 7 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Channel channel = 3 [json_name = "channel", (.gogoproto.nullable) = false];
  bool has_channel() const;
  void clear_channel() ;
  const ::ibc::core::channel::v1::Channel& channel() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Channel* release_channel();
  ::ibc::core::channel::v1::Channel* mutable_channel();
  void set_allocated_channel(::ibc::core::channel::v1::Channel* channel);
  private:
  const ::ibc::core::channel::v1::Channel& _internal_channel() const;
  ::ibc::core::channel::v1::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::ibc::core::channel::v1::Channel* channel);
  ::ibc::core::channel::v1::Channel* unsafe_arena_release_channel();
  // .ibc.core.client.v1.Height proof_height = 6 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenTry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counterparty_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_init_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Channel* channel_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenTryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenTryResponse) */ {
 public:
  inline MsgChannelOpenTryResponse() : MsgChannelOpenTryResponse(nullptr) {}
  ~MsgChannelOpenTryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenTryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenTryResponse(const MsgChannelOpenTryResponse& from);
  MsgChannelOpenTryResponse(MsgChannelOpenTryResponse&& from) noexcept
    : MsgChannelOpenTryResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenTryResponse& operator=(const MsgChannelOpenTryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenTryResponse& operator=(MsgChannelOpenTryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenTryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenTryResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenTryResponse*>(
               &_MsgChannelOpenTryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgChannelOpenTryResponse& a, MsgChannelOpenTryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenTryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenTryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenTryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenTryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenTryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenTryResponse& from) {
    MsgChannelOpenTryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenTryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenTryResponse";
  }
  protected:
  explicit MsgChannelOpenTryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // string version = 1 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenTryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenAck) */ {
 public:
  inline MsgChannelOpenAck() : MsgChannelOpenAck(nullptr) {}
  ~MsgChannelOpenAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenAck(const MsgChannelOpenAck& from);
  MsgChannelOpenAck(MsgChannelOpenAck&& from) noexcept
    : MsgChannelOpenAck() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenAck& operator=(const MsgChannelOpenAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenAck& operator=(MsgChannelOpenAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenAck* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenAck*>(
               &_MsgChannelOpenAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgChannelOpenAck& a, MsgChannelOpenAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenAck& from) {
    MsgChannelOpenAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenAck";
  }
  protected:
  explicit MsgChannelOpenAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kCounterpartyChannelIdFieldNumber = 3,
    kCounterpartyVersionFieldNumber = 4,
    kProofTryFieldNumber = 5,
    kSignerFieldNumber = 7,
    kProofHeightFieldNumber = 6,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string counterparty_channel_id = 3 [json_name = "counterpartyChannelId"];
  void clear_counterparty_channel_id() ;
  const std::string& counterparty_channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_counterparty_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_counterparty_channel_id();
  PROTOBUF_NODISCARD std::string* release_counterparty_channel_id();
  void set_allocated_counterparty_channel_id(std::string* ptr);

  private:
  const std::string& _internal_counterparty_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_counterparty_channel_id(
      const std::string& value);
  std::string* _internal_mutable_counterparty_channel_id();

  public:
  // string counterparty_version = 4 [json_name = "counterpartyVersion"];
  void clear_counterparty_version() ;
  const std::string& counterparty_version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_counterparty_version(Arg_&& arg, Args_... args);
  std::string* mutable_counterparty_version();
  PROTOBUF_NODISCARD std::string* release_counterparty_version();
  void set_allocated_counterparty_version(std::string* ptr);

  private:
  const std::string& _internal_counterparty_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_counterparty_version(
      const std::string& value);
  std::string* _internal_mutable_counterparty_version();

  public:
  // bytes proof_try = 5 [json_name = "proofTry"];
  void clear_proof_try() ;
  const std::string& proof_try() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_try(Arg_&& arg, Args_... args);
  std::string* mutable_proof_try();
  PROTOBUF_NODISCARD std::string* release_proof_try();
  void set_allocated_proof_try(std::string* ptr);

  private:
  const std::string& _internal_proof_try() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_try(
      const std::string& value);
  std::string* _internal_mutable_proof_try();

  public:
  // string signer = 7 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.client.v1.Height proof_height = 6 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counterparty_channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counterparty_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_try_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenAckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenAckResponse) */ {
 public:
  inline MsgChannelOpenAckResponse() : MsgChannelOpenAckResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenAckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenAckResponse(const MsgChannelOpenAckResponse& from);
  MsgChannelOpenAckResponse(MsgChannelOpenAckResponse&& from) noexcept
    : MsgChannelOpenAckResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenAckResponse& operator=(const MsgChannelOpenAckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenAckResponse& operator=(MsgChannelOpenAckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenAckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenAckResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenAckResponse*>(
               &_MsgChannelOpenAckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgChannelOpenAckResponse& a, MsgChannelOpenAckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenAckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenAckResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenAckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenAckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgChannelOpenAckResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgChannelOpenAckResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenAckResponse";
  }
  protected:
  explicit MsgChannelOpenAckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenAckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenConfirm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenConfirm) */ {
 public:
  inline MsgChannelOpenConfirm() : MsgChannelOpenConfirm(nullptr) {}
  ~MsgChannelOpenConfirm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenConfirm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenConfirm(const MsgChannelOpenConfirm& from);
  MsgChannelOpenConfirm(MsgChannelOpenConfirm&& from) noexcept
    : MsgChannelOpenConfirm() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenConfirm& operator=(const MsgChannelOpenConfirm& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenConfirm& operator=(MsgChannelOpenConfirm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenConfirm& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenConfirm* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenConfirm*>(
               &_MsgChannelOpenConfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgChannelOpenConfirm& a, MsgChannelOpenConfirm& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenConfirm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenConfirm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenConfirm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenConfirm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelOpenConfirm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelOpenConfirm& from) {
    MsgChannelOpenConfirm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelOpenConfirm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenConfirm";
  }
  protected:
  explicit MsgChannelOpenConfirm(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kProofAckFieldNumber = 3,
    kSignerFieldNumber = 5,
    kProofHeightFieldNumber = 4,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // bytes proof_ack = 3 [json_name = "proofAck"];
  void clear_proof_ack() ;
  const std::string& proof_ack() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_ack(Arg_&& arg, Args_... args);
  std::string* mutable_proof_ack();
  PROTOBUF_NODISCARD std::string* release_proof_ack();
  void set_allocated_proof_ack(std::string* ptr);

  private:
  const std::string& _internal_proof_ack() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_ack(
      const std::string& value);
  std::string* _internal_mutable_proof_ack();

  public:
  // string signer = 5 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenConfirm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_ack_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelOpenConfirmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelOpenConfirmResponse) */ {
 public:
  inline MsgChannelOpenConfirmResponse() : MsgChannelOpenConfirmResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelOpenConfirmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelOpenConfirmResponse(const MsgChannelOpenConfirmResponse& from);
  MsgChannelOpenConfirmResponse(MsgChannelOpenConfirmResponse&& from) noexcept
    : MsgChannelOpenConfirmResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelOpenConfirmResponse& operator=(const MsgChannelOpenConfirmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelOpenConfirmResponse& operator=(MsgChannelOpenConfirmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelOpenConfirmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelOpenConfirmResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelOpenConfirmResponse*>(
               &_MsgChannelOpenConfirmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgChannelOpenConfirmResponse& a, MsgChannelOpenConfirmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelOpenConfirmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelOpenConfirmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelOpenConfirmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelOpenConfirmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgChannelOpenConfirmResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgChannelOpenConfirmResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelOpenConfirmResponse";
  }
  protected:
  explicit MsgChannelOpenConfirmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelOpenConfirmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelCloseInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelCloseInit) */ {
 public:
  inline MsgChannelCloseInit() : MsgChannelCloseInit(nullptr) {}
  ~MsgChannelCloseInit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelCloseInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelCloseInit(const MsgChannelCloseInit& from);
  MsgChannelCloseInit(MsgChannelCloseInit&& from) noexcept
    : MsgChannelCloseInit() {
    *this = ::std::move(from);
  }

  inline MsgChannelCloseInit& operator=(const MsgChannelCloseInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelCloseInit& operator=(MsgChannelCloseInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelCloseInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelCloseInit* internal_default_instance() {
    return reinterpret_cast<const MsgChannelCloseInit*>(
               &_MsgChannelCloseInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgChannelCloseInit& a, MsgChannelCloseInit& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelCloseInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelCloseInit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelCloseInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelCloseInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelCloseInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelCloseInit& from) {
    MsgChannelCloseInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelCloseInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelCloseInit";
  }
  protected:
  explicit MsgChannelCloseInit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kSignerFieldNumber = 3,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string signer = 3 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelCloseInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelCloseInitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelCloseInitResponse) */ {
 public:
  inline MsgChannelCloseInitResponse() : MsgChannelCloseInitResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelCloseInitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelCloseInitResponse(const MsgChannelCloseInitResponse& from);
  MsgChannelCloseInitResponse(MsgChannelCloseInitResponse&& from) noexcept
    : MsgChannelCloseInitResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelCloseInitResponse& operator=(const MsgChannelCloseInitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelCloseInitResponse& operator=(MsgChannelCloseInitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelCloseInitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelCloseInitResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelCloseInitResponse*>(
               &_MsgChannelCloseInitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgChannelCloseInitResponse& a, MsgChannelCloseInitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelCloseInitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelCloseInitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelCloseInitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelCloseInitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgChannelCloseInitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgChannelCloseInitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelCloseInitResponse";
  }
  protected:
  explicit MsgChannelCloseInitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelCloseInitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelCloseConfirm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelCloseConfirm) */ {
 public:
  inline MsgChannelCloseConfirm() : MsgChannelCloseConfirm(nullptr) {}
  ~MsgChannelCloseConfirm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelCloseConfirm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelCloseConfirm(const MsgChannelCloseConfirm& from);
  MsgChannelCloseConfirm(MsgChannelCloseConfirm&& from) noexcept
    : MsgChannelCloseConfirm() {
    *this = ::std::move(from);
  }

  inline MsgChannelCloseConfirm& operator=(const MsgChannelCloseConfirm& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelCloseConfirm& operator=(MsgChannelCloseConfirm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelCloseConfirm& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelCloseConfirm* internal_default_instance() {
    return reinterpret_cast<const MsgChannelCloseConfirm*>(
               &_MsgChannelCloseConfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MsgChannelCloseConfirm& a, MsgChannelCloseConfirm& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelCloseConfirm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelCloseConfirm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelCloseConfirm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelCloseConfirm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgChannelCloseConfirm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgChannelCloseConfirm& from) {
    MsgChannelCloseConfirm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgChannelCloseConfirm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelCloseConfirm";
  }
  protected:
  explicit MsgChannelCloseConfirm(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kProofInitFieldNumber = 3,
    kSignerFieldNumber = 5,
    kProofHeightFieldNumber = 4,
  };
  // string port_id = 1 [json_name = "portId"];
  void clear_port_id() ;
  const std::string& port_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port_id(Arg_&& arg, Args_... args);
  std::string* mutable_port_id();
  PROTOBUF_NODISCARD std::string* release_port_id();
  void set_allocated_port_id(std::string* ptr);

  private:
  const std::string& _internal_port_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_id(
      const std::string& value);
  std::string* _internal_mutable_port_id();

  public:
  // string channel_id = 2 [json_name = "channelId"];
  void clear_channel_id() ;
  const std::string& channel_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* ptr);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // bytes proof_init = 3 [json_name = "proofInit"];
  void clear_proof_init() ;
  const std::string& proof_init() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_init(Arg_&& arg, Args_... args);
  std::string* mutable_proof_init();
  PROTOBUF_NODISCARD std::string* release_proof_init();
  void set_allocated_proof_init(std::string* ptr);

  private:
  const std::string& _internal_proof_init() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_init(
      const std::string& value);
  std::string* _internal_mutable_proof_init();

  public:
  // string signer = 5 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelCloseConfirm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_init_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgChannelCloseConfirmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgChannelCloseConfirmResponse) */ {
 public:
  inline MsgChannelCloseConfirmResponse() : MsgChannelCloseConfirmResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgChannelCloseConfirmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgChannelCloseConfirmResponse(const MsgChannelCloseConfirmResponse& from);
  MsgChannelCloseConfirmResponse(MsgChannelCloseConfirmResponse&& from) noexcept
    : MsgChannelCloseConfirmResponse() {
    *this = ::std::move(from);
  }

  inline MsgChannelCloseConfirmResponse& operator=(const MsgChannelCloseConfirmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgChannelCloseConfirmResponse& operator=(MsgChannelCloseConfirmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgChannelCloseConfirmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgChannelCloseConfirmResponse* internal_default_instance() {
    return reinterpret_cast<const MsgChannelCloseConfirmResponse*>(
               &_MsgChannelCloseConfirmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MsgChannelCloseConfirmResponse& a, MsgChannelCloseConfirmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgChannelCloseConfirmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgChannelCloseConfirmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgChannelCloseConfirmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgChannelCloseConfirmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MsgChannelCloseConfirmResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MsgChannelCloseConfirmResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgChannelCloseConfirmResponse";
  }
  protected:
  explicit MsgChannelCloseConfirmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgChannelCloseConfirmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRecvPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgRecvPacket) */ {
 public:
  inline MsgRecvPacket() : MsgRecvPacket(nullptr) {}
  ~MsgRecvPacket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRecvPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRecvPacket(const MsgRecvPacket& from);
  MsgRecvPacket(MsgRecvPacket&& from) noexcept
    : MsgRecvPacket() {
    *this = ::std::move(from);
  }

  inline MsgRecvPacket& operator=(const MsgRecvPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRecvPacket& operator=(MsgRecvPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRecvPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRecvPacket* internal_default_instance() {
    return reinterpret_cast<const MsgRecvPacket*>(
               &_MsgRecvPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MsgRecvPacket& a, MsgRecvPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRecvPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRecvPacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRecvPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRecvPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRecvPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRecvPacket& from) {
    MsgRecvPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRecvPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgRecvPacket";
  }
  protected:
  explicit MsgRecvPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofCommitmentFieldNumber = 2,
    kSignerFieldNumber = 4,
    kPacketFieldNumber = 1,
    kProofHeightFieldNumber = 3,
  };
  // bytes proof_commitment = 2 [json_name = "proofCommitment"];
  void clear_proof_commitment() ;
  const std::string& proof_commitment() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_commitment(Arg_&& arg, Args_... args);
  std::string* mutable_proof_commitment();
  PROTOBUF_NODISCARD std::string* release_proof_commitment();
  void set_allocated_proof_commitment(std::string* ptr);

  private:
  const std::string& _internal_proof_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_commitment(
      const std::string& value);
  std::string* _internal_mutable_proof_commitment();

  public:
  // string signer = 4 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
  bool has_packet() const;
  void clear_packet() ;
  const ::ibc::core::channel::v1::Packet& packet() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Packet* release_packet();
  ::ibc::core::channel::v1::Packet* mutable_packet();
  void set_allocated_packet(::ibc::core::channel::v1::Packet* packet);
  private:
  const ::ibc::core::channel::v1::Packet& _internal_packet() const;
  ::ibc::core::channel::v1::Packet* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::ibc::core::channel::v1::Packet* packet);
  ::ibc::core::channel::v1::Packet* unsafe_arena_release_packet();
  // .ibc.core.client.v1.Height proof_height = 3 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgRecvPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_commitment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Packet* packet_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgRecvPacketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgRecvPacketResponse) */ {
 public:
  inline MsgRecvPacketResponse() : MsgRecvPacketResponse(nullptr) {}
  ~MsgRecvPacketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgRecvPacketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRecvPacketResponse(const MsgRecvPacketResponse& from);
  MsgRecvPacketResponse(MsgRecvPacketResponse&& from) noexcept
    : MsgRecvPacketResponse() {
    *this = ::std::move(from);
  }

  inline MsgRecvPacketResponse& operator=(const MsgRecvPacketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRecvPacketResponse& operator=(MsgRecvPacketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgRecvPacketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRecvPacketResponse* internal_default_instance() {
    return reinterpret_cast<const MsgRecvPacketResponse*>(
               &_MsgRecvPacketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MsgRecvPacketResponse& a, MsgRecvPacketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRecvPacketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRecvPacketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRecvPacketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRecvPacketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgRecvPacketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgRecvPacketResponse& from) {
    MsgRecvPacketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgRecvPacketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgRecvPacketResponse";
  }
  protected:
  explicit MsgRecvPacketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
  void clear_result() ;
  ::ibc::core::channel::v1::ResponseResultType result() const;
  void set_result(::ibc::core::channel::v1::ResponseResultType value);

  private:
  ::ibc::core::channel::v1::ResponseResultType _internal_result() const;
  void _internal_set_result(::ibc::core::channel::v1::ResponseResultType value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgRecvPacketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgTimeout) */ {
 public:
  inline MsgTimeout() : MsgTimeout(nullptr) {}
  ~MsgTimeout() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTimeout(const MsgTimeout& from);
  MsgTimeout(MsgTimeout&& from) noexcept
    : MsgTimeout() {
    *this = ::std::move(from);
  }

  inline MsgTimeout& operator=(const MsgTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTimeout& operator=(MsgTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTimeout* internal_default_instance() {
    return reinterpret_cast<const MsgTimeout*>(
               &_MsgTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MsgTimeout& a, MsgTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTimeout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTimeout* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTimeout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTimeout& from) {
    MsgTimeout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTimeout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgTimeout";
  }
  protected:
  explicit MsgTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofUnreceivedFieldNumber = 2,
    kSignerFieldNumber = 5,
    kPacketFieldNumber = 1,
    kProofHeightFieldNumber = 3,
    kNextSequenceRecvFieldNumber = 4,
  };
  // bytes proof_unreceived = 2 [json_name = "proofUnreceived"];
  void clear_proof_unreceived() ;
  const std::string& proof_unreceived() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_unreceived(Arg_&& arg, Args_... args);
  std::string* mutable_proof_unreceived();
  PROTOBUF_NODISCARD std::string* release_proof_unreceived();
  void set_allocated_proof_unreceived(std::string* ptr);

  private:
  const std::string& _internal_proof_unreceived() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_unreceived(
      const std::string& value);
  std::string* _internal_mutable_proof_unreceived();

  public:
  // string signer = 5 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
  bool has_packet() const;
  void clear_packet() ;
  const ::ibc::core::channel::v1::Packet& packet() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Packet* release_packet();
  ::ibc::core::channel::v1::Packet* mutable_packet();
  void set_allocated_packet(::ibc::core::channel::v1::Packet* packet);
  private:
  const ::ibc::core::channel::v1::Packet& _internal_packet() const;
  ::ibc::core::channel::v1::Packet* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::ibc::core::channel::v1::Packet* packet);
  ::ibc::core::channel::v1::Packet* unsafe_arena_release_packet();
  // .ibc.core.client.v1.Height proof_height = 3 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // uint64 next_sequence_recv = 4 [json_name = "nextSequenceRecv"];
  void clear_next_sequence_recv() ;
  ::uint64_t next_sequence_recv() const;
  void set_next_sequence_recv(::uint64_t value);

  private:
  ::uint64_t _internal_next_sequence_recv() const;
  void _internal_set_next_sequence_recv(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_unreceived_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Packet* packet_;
    ::ibc::core::client::v1::Height* proof_height_;
    ::uint64_t next_sequence_recv_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTimeoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgTimeoutResponse) */ {
 public:
  inline MsgTimeoutResponse() : MsgTimeoutResponse(nullptr) {}
  ~MsgTimeoutResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTimeoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTimeoutResponse(const MsgTimeoutResponse& from);
  MsgTimeoutResponse(MsgTimeoutResponse&& from) noexcept
    : MsgTimeoutResponse() {
    *this = ::std::move(from);
  }

  inline MsgTimeoutResponse& operator=(const MsgTimeoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTimeoutResponse& operator=(MsgTimeoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTimeoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTimeoutResponse* internal_default_instance() {
    return reinterpret_cast<const MsgTimeoutResponse*>(
               &_MsgTimeoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MsgTimeoutResponse& a, MsgTimeoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTimeoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTimeoutResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTimeoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTimeoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTimeoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTimeoutResponse& from) {
    MsgTimeoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTimeoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgTimeoutResponse";
  }
  protected:
  explicit MsgTimeoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
  void clear_result() ;
  ::ibc::core::channel::v1::ResponseResultType result() const;
  void set_result(::ibc::core::channel::v1::ResponseResultType value);

  private:
  ::ibc::core::channel::v1::ResponseResultType _internal_result() const;
  void _internal_set_result(::ibc::core::channel::v1::ResponseResultType value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgTimeoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTimeoutOnClose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgTimeoutOnClose) */ {
 public:
  inline MsgTimeoutOnClose() : MsgTimeoutOnClose(nullptr) {}
  ~MsgTimeoutOnClose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTimeoutOnClose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTimeoutOnClose(const MsgTimeoutOnClose& from);
  MsgTimeoutOnClose(MsgTimeoutOnClose&& from) noexcept
    : MsgTimeoutOnClose() {
    *this = ::std::move(from);
  }

  inline MsgTimeoutOnClose& operator=(const MsgTimeoutOnClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTimeoutOnClose& operator=(MsgTimeoutOnClose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTimeoutOnClose& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTimeoutOnClose* internal_default_instance() {
    return reinterpret_cast<const MsgTimeoutOnClose*>(
               &_MsgTimeoutOnClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MsgTimeoutOnClose& a, MsgTimeoutOnClose& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTimeoutOnClose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTimeoutOnClose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTimeoutOnClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTimeoutOnClose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTimeoutOnClose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTimeoutOnClose& from) {
    MsgTimeoutOnClose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTimeoutOnClose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgTimeoutOnClose";
  }
  protected:
  explicit MsgTimeoutOnClose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofUnreceivedFieldNumber = 2,
    kProofCloseFieldNumber = 3,
    kSignerFieldNumber = 6,
    kPacketFieldNumber = 1,
    kProofHeightFieldNumber = 4,
    kNextSequenceRecvFieldNumber = 5,
  };
  // bytes proof_unreceived = 2 [json_name = "proofUnreceived"];
  void clear_proof_unreceived() ;
  const std::string& proof_unreceived() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_unreceived(Arg_&& arg, Args_... args);
  std::string* mutable_proof_unreceived();
  PROTOBUF_NODISCARD std::string* release_proof_unreceived();
  void set_allocated_proof_unreceived(std::string* ptr);

  private:
  const std::string& _internal_proof_unreceived() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_unreceived(
      const std::string& value);
  std::string* _internal_mutable_proof_unreceived();

  public:
  // bytes proof_close = 3 [json_name = "proofClose"];
  void clear_proof_close() ;
  const std::string& proof_close() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_close(Arg_&& arg, Args_... args);
  std::string* mutable_proof_close();
  PROTOBUF_NODISCARD std::string* release_proof_close();
  void set_allocated_proof_close(std::string* ptr);

  private:
  const std::string& _internal_proof_close() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_close(
      const std::string& value);
  std::string* _internal_mutable_proof_close();

  public:
  // string signer = 6 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
  bool has_packet() const;
  void clear_packet() ;
  const ::ibc::core::channel::v1::Packet& packet() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Packet* release_packet();
  ::ibc::core::channel::v1::Packet* mutable_packet();
  void set_allocated_packet(::ibc::core::channel::v1::Packet* packet);
  private:
  const ::ibc::core::channel::v1::Packet& _internal_packet() const;
  ::ibc::core::channel::v1::Packet* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::ibc::core::channel::v1::Packet* packet);
  ::ibc::core::channel::v1::Packet* unsafe_arena_release_packet();
  // .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // uint64 next_sequence_recv = 5 [json_name = "nextSequenceRecv"];
  void clear_next_sequence_recv() ;
  ::uint64_t next_sequence_recv() const;
  void set_next_sequence_recv(::uint64_t value);

  private:
  ::uint64_t _internal_next_sequence_recv() const;
  void _internal_set_next_sequence_recv(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgTimeoutOnClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_unreceived_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_close_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Packet* packet_;
    ::ibc::core::client::v1::Height* proof_height_;
    ::uint64_t next_sequence_recv_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgTimeoutOnCloseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgTimeoutOnCloseResponse) */ {
 public:
  inline MsgTimeoutOnCloseResponse() : MsgTimeoutOnCloseResponse(nullptr) {}
  ~MsgTimeoutOnCloseResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgTimeoutOnCloseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgTimeoutOnCloseResponse(const MsgTimeoutOnCloseResponse& from);
  MsgTimeoutOnCloseResponse(MsgTimeoutOnCloseResponse&& from) noexcept
    : MsgTimeoutOnCloseResponse() {
    *this = ::std::move(from);
  }

  inline MsgTimeoutOnCloseResponse& operator=(const MsgTimeoutOnCloseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgTimeoutOnCloseResponse& operator=(MsgTimeoutOnCloseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgTimeoutOnCloseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgTimeoutOnCloseResponse* internal_default_instance() {
    return reinterpret_cast<const MsgTimeoutOnCloseResponse*>(
               &_MsgTimeoutOnCloseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MsgTimeoutOnCloseResponse& a, MsgTimeoutOnCloseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgTimeoutOnCloseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgTimeoutOnCloseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgTimeoutOnCloseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgTimeoutOnCloseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgTimeoutOnCloseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgTimeoutOnCloseResponse& from) {
    MsgTimeoutOnCloseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgTimeoutOnCloseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgTimeoutOnCloseResponse";
  }
  protected:
  explicit MsgTimeoutOnCloseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
  void clear_result() ;
  ::ibc::core::channel::v1::ResponseResultType result() const;
  void set_result(::ibc::core::channel::v1::ResponseResultType value);

  private:
  ::ibc::core::channel::v1::ResponseResultType _internal_result() const;
  void _internal_set_result(::ibc::core::channel::v1::ResponseResultType value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgTimeoutOnCloseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAcknowledgement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgAcknowledgement) */ {
 public:
  inline MsgAcknowledgement() : MsgAcknowledgement(nullptr) {}
  ~MsgAcknowledgement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAcknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAcknowledgement(const MsgAcknowledgement& from);
  MsgAcknowledgement(MsgAcknowledgement&& from) noexcept
    : MsgAcknowledgement() {
    *this = ::std::move(from);
  }

  inline MsgAcknowledgement& operator=(const MsgAcknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAcknowledgement& operator=(MsgAcknowledgement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAcknowledgement& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAcknowledgement* internal_default_instance() {
    return reinterpret_cast<const MsgAcknowledgement*>(
               &_MsgAcknowledgement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MsgAcknowledgement& a, MsgAcknowledgement& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAcknowledgement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAcknowledgement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAcknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAcknowledgement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgAcknowledgement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgAcknowledgement& from) {
    MsgAcknowledgement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgAcknowledgement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgAcknowledgement";
  }
  protected:
  explicit MsgAcknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcknowledgementFieldNumber = 2,
    kProofAckedFieldNumber = 3,
    kSignerFieldNumber = 5,
    kPacketFieldNumber = 1,
    kProofHeightFieldNumber = 4,
  };
  // bytes acknowledgement = 2 [json_name = "acknowledgement"];
  void clear_acknowledgement() ;
  const std::string& acknowledgement() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acknowledgement(Arg_&& arg, Args_... args);
  std::string* mutable_acknowledgement();
  PROTOBUF_NODISCARD std::string* release_acknowledgement();
  void set_allocated_acknowledgement(std::string* ptr);

  private:
  const std::string& _internal_acknowledgement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acknowledgement(
      const std::string& value);
  std::string* _internal_mutable_acknowledgement();

  public:
  // bytes proof_acked = 3 [json_name = "proofAcked"];
  void clear_proof_acked() ;
  const std::string& proof_acked() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proof_acked(Arg_&& arg, Args_... args);
  std::string* mutable_proof_acked();
  PROTOBUF_NODISCARD std::string* release_proof_acked();
  void set_allocated_proof_acked(std::string* ptr);

  private:
  const std::string& _internal_proof_acked() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proof_acked(
      const std::string& value);
  std::string* _internal_mutable_proof_acked();

  public:
  // string signer = 5 [json_name = "signer"];
  void clear_signer() ;
  const std::string& signer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer(Arg_&& arg, Args_... args);
  std::string* mutable_signer();
  PROTOBUF_NODISCARD std::string* release_signer();
  void set_allocated_signer(std::string* ptr);

  private:
  const std::string& _internal_signer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer(
      const std::string& value);
  std::string* _internal_mutable_signer();

  public:
  // .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
  bool has_packet() const;
  void clear_packet() ;
  const ::ibc::core::channel::v1::Packet& packet() const;
  PROTOBUF_NODISCARD ::ibc::core::channel::v1::Packet* release_packet();
  ::ibc::core::channel::v1::Packet* mutable_packet();
  void set_allocated_packet(::ibc::core::channel::v1::Packet* packet);
  private:
  const ::ibc::core::channel::v1::Packet& _internal_packet() const;
  ::ibc::core::channel::v1::Packet* _internal_mutable_packet();
  public:
  void unsafe_arena_set_allocated_packet(
      ::ibc::core::channel::v1::Packet* packet);
  ::ibc::core::channel::v1::Packet* unsafe_arena_release_packet();
  // .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
  bool has_proof_height() const;
  void clear_proof_height() ;
  const ::ibc::core::client::v1::Height& proof_height() const;
  PROTOBUF_NODISCARD ::ibc::core::client::v1::Height* release_proof_height();
  ::ibc::core::client::v1::Height* mutable_proof_height();
  void set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height);
  private:
  const ::ibc::core::client::v1::Height& _internal_proof_height() const;
  ::ibc::core::client::v1::Height* _internal_mutable_proof_height();
  public:
  void unsafe_arena_set_allocated_proof_height(
      ::ibc::core::client::v1::Height* proof_height);
  ::ibc::core::client::v1::Height* unsafe_arena_release_proof_height();
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgAcknowledgement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr acknowledgement_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_acked_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_;
    ::ibc::core::channel::v1::Packet* packet_;
    ::ibc::core::client::v1::Height* proof_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};// -------------------------------------------------------------------

class MsgAcknowledgementResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibc.core.channel.v1.MsgAcknowledgementResponse) */ {
 public:
  inline MsgAcknowledgementResponse() : MsgAcknowledgementResponse(nullptr) {}
  ~MsgAcknowledgementResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MsgAcknowledgementResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgAcknowledgementResponse(const MsgAcknowledgementResponse& from);
  MsgAcknowledgementResponse(MsgAcknowledgementResponse&& from) noexcept
    : MsgAcknowledgementResponse() {
    *this = ::std::move(from);
  }

  inline MsgAcknowledgementResponse& operator=(const MsgAcknowledgementResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgAcknowledgementResponse& operator=(MsgAcknowledgementResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgAcknowledgementResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgAcknowledgementResponse* internal_default_instance() {
    return reinterpret_cast<const MsgAcknowledgementResponse*>(
               &_MsgAcknowledgementResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MsgAcknowledgementResponse& a, MsgAcknowledgementResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgAcknowledgementResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgAcknowledgementResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgAcknowledgementResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgAcknowledgementResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgAcknowledgementResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgAcknowledgementResponse& from) {
    MsgAcknowledgementResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgAcknowledgementResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ibc.core.channel.v1.MsgAcknowledgementResponse";
  }
  protected:
  explicit MsgAcknowledgementResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
  void clear_result() ;
  ::ibc::core::channel::v1::ResponseResultType result() const;
  void set_result(::ibc::core::channel::v1::ResponseResultType value);

  private:
  ::ibc::core::channel::v1::ResponseResultType _internal_result() const;
  void _internal_set_result(::ibc::core::channel::v1::ResponseResultType value);

  public:
  // @@protoc_insertion_point(class_scope:ibc.core.channel.v1.MsgAcknowledgementResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MsgChannelOpenInit

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelOpenInit::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenInit::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenInit::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
}
inline std::string* MsgChannelOpenInit::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
  return _s;
}
inline const std::string& MsgChannelOpenInit::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelOpenInit::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInit::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInit::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelOpenInit::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenInit.port_id)
}

// .ibc.core.channel.v1.Channel channel = 2 [json_name = "channel", (.gogoproto.nullable) = false];
inline bool MsgChannelOpenInit::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Channel& MsgChannelOpenInit::_internal_channel() const {
  const ::ibc::core::channel::v1::Channel* p = _impl_.channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Channel&>(
      ::ibc::core::channel::v1::_Channel_default_instance_);
}
inline const ::ibc::core::channel::v1::Channel& MsgChannelOpenInit::channel() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenInit.channel)
  return _internal_channel();
}
inline void MsgChannelOpenInit::unsafe_arena_set_allocated_channel(
    ::ibc::core::channel::v1::Channel* channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channel_);
  }
  _impl_.channel_ = channel;
  if (channel) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelOpenInit.channel)
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenInit::release_channel() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Channel* temp = _impl_.channel_;
  _impl_.channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenInit::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenInit.channel)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Channel* temp = _impl_.channel_;
  _impl_.channel_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenInit::_internal_mutable_channel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Channel>(GetArenaForAllocation());
    _impl_.channel_ = p;
  }
  return _impl_.channel_;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenInit::mutable_channel() {
  ::ibc::core::channel::v1::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenInit.channel)
  return _msg;
}
inline void MsgChannelOpenInit::set_allocated_channel(::ibc::core::channel::v1::Channel* channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channel_);
  }
  if (channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel));
    if (message_arena != submessage_arena) {
      channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenInit.channel)
}

// string signer = 3 [json_name = "signer"];
inline void MsgChannelOpenInit::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenInit::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenInit.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenInit::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenInit.signer)
}
inline std::string* MsgChannelOpenInit::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenInit.signer)
  return _s;
}
inline const std::string& MsgChannelOpenInit::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelOpenInit::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInit::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInit::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenInit.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelOpenInit::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenInit.signer)
}

// -------------------------------------------------------------------

// MsgChannelOpenInitResponse

// string channel_id = 1 [json_name = "channelId"];
inline void MsgChannelOpenInitResponse::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenInitResponse::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenInitResponse::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
}
inline std::string* MsgChannelOpenInitResponse::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenInitResponse::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelOpenInitResponse::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInitResponse::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInitResponse::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelOpenInitResponse::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenInitResponse.channel_id)
}

// string version = 2 [json_name = "version"];
inline void MsgChannelOpenInitResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenInitResponse::version() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenInitResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenInitResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenInitResponse.version)
}
inline std::string* MsgChannelOpenInitResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenInitResponse.version)
  return _s;
}
inline const std::string& MsgChannelOpenInitResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MsgChannelOpenInitResponse::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInitResponse::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenInitResponse::release_version() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenInitResponse.version)
  return _impl_.version_.Release();
}
inline void MsgChannelOpenInitResponse::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenInitResponse.version)
}

// -------------------------------------------------------------------

// MsgChannelOpenTry

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelOpenTry::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTry::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTry::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
}
inline std::string* MsgChannelOpenTry::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
  return _s;
}
inline const std::string& MsgChannelOpenTry::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelOpenTry::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelOpenTry::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.port_id)
}

// string previous_channel_id = 2 [json_name = "previousChannelId", deprecated = true];
inline void MsgChannelOpenTry::clear_previous_channel_id() {
  _impl_.previous_channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTry::previous_channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
  return _internal_previous_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTry::set_previous_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.previous_channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
}
inline std::string* MsgChannelOpenTry::mutable_previous_channel_id() {
  std::string* _s = _internal_mutable_previous_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenTry::_internal_previous_channel_id() const {
  return _impl_.previous_channel_id_.Get();
}
inline void MsgChannelOpenTry::_internal_set_previous_channel_id(const std::string& value) {
  ;


  _impl_.previous_channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::_internal_mutable_previous_channel_id() {
  ;
  return _impl_.previous_channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::release_previous_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
  return _impl_.previous_channel_id_.Release();
}
inline void MsgChannelOpenTry::set_allocated_previous_channel_id(std::string* value) {
  _impl_.previous_channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.previous_channel_id_.IsDefault()) {
          _impl_.previous_channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.previous_channel_id)
}

// .ibc.core.channel.v1.Channel channel = 3 [json_name = "channel", (.gogoproto.nullable) = false];
inline bool MsgChannelOpenTry::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Channel& MsgChannelOpenTry::_internal_channel() const {
  const ::ibc::core::channel::v1::Channel* p = _impl_.channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Channel&>(
      ::ibc::core::channel::v1::_Channel_default_instance_);
}
inline const ::ibc::core::channel::v1::Channel& MsgChannelOpenTry::channel() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.channel)
  return _internal_channel();
}
inline void MsgChannelOpenTry::unsafe_arena_set_allocated_channel(
    ::ibc::core::channel::v1::Channel* channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channel_);
  }
  _impl_.channel_ = channel;
  if (channel) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.channel)
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenTry::release_channel() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Channel* temp = _impl_.channel_;
  _impl_.channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenTry::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.channel)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Channel* temp = _impl_.channel_;
  _impl_.channel_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenTry::_internal_mutable_channel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Channel>(GetArenaForAllocation());
    _impl_.channel_ = p;
  }
  return _impl_.channel_;
}
inline ::ibc::core::channel::v1::Channel* MsgChannelOpenTry::mutable_channel() {
  ::ibc::core::channel::v1::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.channel)
  return _msg;
}
inline void MsgChannelOpenTry::set_allocated_channel(::ibc::core::channel::v1::Channel* channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.channel_);
  }
  if (channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel));
    if (message_arena != submessage_arena) {
      channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.channel)
}

// string counterparty_version = 4 [json_name = "counterpartyVersion"];
inline void MsgChannelOpenTry::clear_counterparty_version() {
  _impl_.counterparty_version_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTry::counterparty_version() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
  return _internal_counterparty_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTry::set_counterparty_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.counterparty_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
}
inline std::string* MsgChannelOpenTry::mutable_counterparty_version() {
  std::string* _s = _internal_mutable_counterparty_version();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
  return _s;
}
inline const std::string& MsgChannelOpenTry::_internal_counterparty_version() const {
  return _impl_.counterparty_version_.Get();
}
inline void MsgChannelOpenTry::_internal_set_counterparty_version(const std::string& value) {
  ;


  _impl_.counterparty_version_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::_internal_mutable_counterparty_version() {
  ;
  return _impl_.counterparty_version_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::release_counterparty_version() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
  return _impl_.counterparty_version_.Release();
}
inline void MsgChannelOpenTry::set_allocated_counterparty_version(std::string* value) {
  _impl_.counterparty_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.counterparty_version_.IsDefault()) {
          _impl_.counterparty_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.counterparty_version)
}

// bytes proof_init = 5 [json_name = "proofInit"];
inline void MsgChannelOpenTry::clear_proof_init() {
  _impl_.proof_init_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTry::proof_init() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
  return _internal_proof_init();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTry::set_proof_init(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_init_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
}
inline std::string* MsgChannelOpenTry::mutable_proof_init() {
  std::string* _s = _internal_mutable_proof_init();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
  return _s;
}
inline const std::string& MsgChannelOpenTry::_internal_proof_init() const {
  return _impl_.proof_init_.Get();
}
inline void MsgChannelOpenTry::_internal_set_proof_init(const std::string& value) {
  ;


  _impl_.proof_init_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::_internal_mutable_proof_init() {
  ;
  return _impl_.proof_init_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::release_proof_init() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
  return _impl_.proof_init_.Release();
}
inline void MsgChannelOpenTry::set_allocated_proof_init(std::string* value) {
  _impl_.proof_init_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_init_.IsDefault()) {
          _impl_.proof_init_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.proof_init)
}

// .ibc.core.client.v1.Height proof_height = 6 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgChannelOpenTry::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenTry::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenTry::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
  return _internal_proof_height();
}
inline void MsgChannelOpenTry::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenTry::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenTry::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenTry::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenTry::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
  return _msg;
}
inline void MsgChannelOpenTry::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.proof_height)
}

// string signer = 7 [json_name = "signer"];
inline void MsgChannelOpenTry::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTry::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTry.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTry::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTry.signer)
}
inline std::string* MsgChannelOpenTry::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTry.signer)
  return _s;
}
inline const std::string& MsgChannelOpenTry::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelOpenTry::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTry::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTry.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelOpenTry::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTry.signer)
}

// -------------------------------------------------------------------

// MsgChannelOpenTryResponse

// string version = 1 [json_name = "version"];
inline void MsgChannelOpenTryResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTryResponse::version() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTryResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTryResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTryResponse.version)
}
inline std::string* MsgChannelOpenTryResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTryResponse.version)
  return _s;
}
inline const std::string& MsgChannelOpenTryResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MsgChannelOpenTryResponse::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTryResponse::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTryResponse::release_version() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTryResponse.version)
  return _impl_.version_.Release();
}
inline void MsgChannelOpenTryResponse::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTryResponse.version)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgChannelOpenTryResponse::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenTryResponse::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenTryResponse.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenTryResponse::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenTryResponse.channel_id)
}
inline std::string* MsgChannelOpenTryResponse::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenTryResponse.channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenTryResponse::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelOpenTryResponse::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTryResponse::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenTryResponse::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenTryResponse.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelOpenTryResponse::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenTryResponse.channel_id)
}

// -------------------------------------------------------------------

// MsgChannelOpenAck

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelOpenAck::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
}
inline std::string* MsgChannelOpenAck::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelOpenAck::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelOpenAck::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgChannelOpenAck::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
}
inline std::string* MsgChannelOpenAck::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelOpenAck::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelOpenAck::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.channel_id)
}

// string counterparty_channel_id = 3 [json_name = "counterpartyChannelId"];
inline void MsgChannelOpenAck::clear_counterparty_channel_id() {
  _impl_.counterparty_channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::counterparty_channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
  return _internal_counterparty_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_counterparty_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.counterparty_channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
}
inline std::string* MsgChannelOpenAck::mutable_counterparty_channel_id() {
  std::string* _s = _internal_mutable_counterparty_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_counterparty_channel_id() const {
  return _impl_.counterparty_channel_id_.Get();
}
inline void MsgChannelOpenAck::_internal_set_counterparty_channel_id(const std::string& value) {
  ;


  _impl_.counterparty_channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_counterparty_channel_id() {
  ;
  return _impl_.counterparty_channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_counterparty_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
  return _impl_.counterparty_channel_id_.Release();
}
inline void MsgChannelOpenAck::set_allocated_counterparty_channel_id(std::string* value) {
  _impl_.counterparty_channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.counterparty_channel_id_.IsDefault()) {
          _impl_.counterparty_channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_channel_id)
}

// string counterparty_version = 4 [json_name = "counterpartyVersion"];
inline void MsgChannelOpenAck::clear_counterparty_version() {
  _impl_.counterparty_version_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::counterparty_version() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
  return _internal_counterparty_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_counterparty_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.counterparty_version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
}
inline std::string* MsgChannelOpenAck::mutable_counterparty_version() {
  std::string* _s = _internal_mutable_counterparty_version();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_counterparty_version() const {
  return _impl_.counterparty_version_.Get();
}
inline void MsgChannelOpenAck::_internal_set_counterparty_version(const std::string& value) {
  ;


  _impl_.counterparty_version_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_counterparty_version() {
  ;
  return _impl_.counterparty_version_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_counterparty_version() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
  return _impl_.counterparty_version_.Release();
}
inline void MsgChannelOpenAck::set_allocated_counterparty_version(std::string* value) {
  _impl_.counterparty_version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.counterparty_version_.IsDefault()) {
          _impl_.counterparty_version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.counterparty_version)
}

// bytes proof_try = 5 [json_name = "proofTry"];
inline void MsgChannelOpenAck::clear_proof_try() {
  _impl_.proof_try_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::proof_try() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
  return _internal_proof_try();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_proof_try(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_try_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
}
inline std::string* MsgChannelOpenAck::mutable_proof_try() {
  std::string* _s = _internal_mutable_proof_try();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_proof_try() const {
  return _impl_.proof_try_.Get();
}
inline void MsgChannelOpenAck::_internal_set_proof_try(const std::string& value) {
  ;


  _impl_.proof_try_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_proof_try() {
  ;
  return _impl_.proof_try_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_proof_try() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
  return _impl_.proof_try_.Release();
}
inline void MsgChannelOpenAck::set_allocated_proof_try(std::string* value) {
  _impl_.proof_try_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_try_.IsDefault()) {
          _impl_.proof_try_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.proof_try)
}

// .ibc.core.client.v1.Height proof_height = 6 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgChannelOpenAck::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenAck::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenAck::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
  return _internal_proof_height();
}
inline void MsgChannelOpenAck::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenAck::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenAck::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenAck::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenAck::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
  return _msg;
}
inline void MsgChannelOpenAck::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.proof_height)
}

// string signer = 7 [json_name = "signer"];
inline void MsgChannelOpenAck::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenAck::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenAck.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenAck::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenAck.signer)
}
inline std::string* MsgChannelOpenAck::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenAck.signer)
  return _s;
}
inline const std::string& MsgChannelOpenAck::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelOpenAck::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenAck::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenAck.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelOpenAck::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenAck.signer)
}

// -------------------------------------------------------------------

// MsgChannelOpenAckResponse

// -------------------------------------------------------------------

// MsgChannelOpenConfirm

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelOpenConfirm::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenConfirm::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenConfirm::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
}
inline std::string* MsgChannelOpenConfirm::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
  return _s;
}
inline const std::string& MsgChannelOpenConfirm::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelOpenConfirm::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelOpenConfirm::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgChannelOpenConfirm::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenConfirm::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenConfirm::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
}
inline std::string* MsgChannelOpenConfirm::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
  return _s;
}
inline const std::string& MsgChannelOpenConfirm::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelOpenConfirm::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelOpenConfirm::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.channel_id)
}

// bytes proof_ack = 3 [json_name = "proofAck"];
inline void MsgChannelOpenConfirm::clear_proof_ack() {
  _impl_.proof_ack_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenConfirm::proof_ack() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
  return _internal_proof_ack();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenConfirm::set_proof_ack(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_ack_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
}
inline std::string* MsgChannelOpenConfirm::mutable_proof_ack() {
  std::string* _s = _internal_mutable_proof_ack();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
  return _s;
}
inline const std::string& MsgChannelOpenConfirm::_internal_proof_ack() const {
  return _impl_.proof_ack_.Get();
}
inline void MsgChannelOpenConfirm::_internal_set_proof_ack(const std::string& value) {
  ;


  _impl_.proof_ack_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::_internal_mutable_proof_ack() {
  ;
  return _impl_.proof_ack_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::release_proof_ack() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
  return _impl_.proof_ack_.Release();
}
inline void MsgChannelOpenConfirm::set_allocated_proof_ack(std::string* value) {
  _impl_.proof_ack_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_ack_.IsDefault()) {
          _impl_.proof_ack_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_ack)
}

// .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgChannelOpenConfirm::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenConfirm::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgChannelOpenConfirm::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
  return _internal_proof_height();
}
inline void MsgChannelOpenConfirm::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenConfirm::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenConfirm::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenConfirm::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgChannelOpenConfirm::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
  return _msg;
}
inline void MsgChannelOpenConfirm::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.proof_height)
}

// string signer = 5 [json_name = "signer"];
inline void MsgChannelOpenConfirm::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelOpenConfirm::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelOpenConfirm::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
}
inline std::string* MsgChannelOpenConfirm::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
  return _s;
}
inline const std::string& MsgChannelOpenConfirm::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelOpenConfirm::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelOpenConfirm::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelOpenConfirm::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelOpenConfirm.signer)
}

// -------------------------------------------------------------------

// MsgChannelOpenConfirmResponse

// -------------------------------------------------------------------

// MsgChannelCloseInit

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelCloseInit::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseInit::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseInit::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
}
inline std::string* MsgChannelCloseInit::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
  return _s;
}
inline const std::string& MsgChannelCloseInit::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelCloseInit::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelCloseInit::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseInit.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgChannelCloseInit::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseInit::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseInit::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
}
inline std::string* MsgChannelCloseInit::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
  return _s;
}
inline const std::string& MsgChannelCloseInit::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelCloseInit::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelCloseInit::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseInit.channel_id)
}

// string signer = 3 [json_name = "signer"];
inline void MsgChannelCloseInit::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseInit::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseInit.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseInit::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseInit.signer)
}
inline std::string* MsgChannelCloseInit::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseInit.signer)
  return _s;
}
inline const std::string& MsgChannelCloseInit::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelCloseInit::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseInit::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseInit.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelCloseInit::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseInit.signer)
}

// -------------------------------------------------------------------

// MsgChannelCloseInitResponse

// -------------------------------------------------------------------

// MsgChannelCloseConfirm

// string port_id = 1 [json_name = "portId"];
inline void MsgChannelCloseConfirm::clear_port_id() {
  _impl_.port_id_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseConfirm::port_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
  return _internal_port_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseConfirm::set_port_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
}
inline std::string* MsgChannelCloseConfirm::mutable_port_id() {
  std::string* _s = _internal_mutable_port_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
  return _s;
}
inline const std::string& MsgChannelCloseConfirm::_internal_port_id() const {
  return _impl_.port_id_.Get();
}
inline void MsgChannelCloseConfirm::_internal_set_port_id(const std::string& value) {
  ;


  _impl_.port_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::_internal_mutable_port_id() {
  ;
  return _impl_.port_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::release_port_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
  return _impl_.port_id_.Release();
}
inline void MsgChannelCloseConfirm::set_allocated_port_id(std::string* value) {
  _impl_.port_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_id_.IsDefault()) {
          _impl_.port_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.port_id)
}

// string channel_id = 2 [json_name = "channelId"];
inline void MsgChannelCloseConfirm::clear_channel_id() {
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseConfirm::channel_id() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseConfirm::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
}
inline std::string* MsgChannelCloseConfirm::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
  return _s;
}
inline const std::string& MsgChannelCloseConfirm::_internal_channel_id() const {
  return _impl_.channel_id_.Get();
}
inline void MsgChannelCloseConfirm::_internal_set_channel_id(const std::string& value) {
  ;


  _impl_.channel_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::_internal_mutable_channel_id() {
  ;
  return _impl_.channel_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::release_channel_id() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
  return _impl_.channel_id_.Release();
}
inline void MsgChannelCloseConfirm::set_allocated_channel_id(std::string* value) {
  _impl_.channel_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.channel_id)
}

// bytes proof_init = 3 [json_name = "proofInit"];
inline void MsgChannelCloseConfirm::clear_proof_init() {
  _impl_.proof_init_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseConfirm::proof_init() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
  return _internal_proof_init();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseConfirm::set_proof_init(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_init_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
}
inline std::string* MsgChannelCloseConfirm::mutable_proof_init() {
  std::string* _s = _internal_mutable_proof_init();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
  return _s;
}
inline const std::string& MsgChannelCloseConfirm::_internal_proof_init() const {
  return _impl_.proof_init_.Get();
}
inline void MsgChannelCloseConfirm::_internal_set_proof_init(const std::string& value) {
  ;


  _impl_.proof_init_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::_internal_mutable_proof_init() {
  ;
  return _impl_.proof_init_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::release_proof_init() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
  return _impl_.proof_init_.Release();
}
inline void MsgChannelCloseConfirm::set_allocated_proof_init(std::string* value) {
  _impl_.proof_init_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_init_.IsDefault()) {
          _impl_.proof_init_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_init)
}

// .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgChannelCloseConfirm::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgChannelCloseConfirm::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgChannelCloseConfirm::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
  return _internal_proof_height();
}
inline void MsgChannelCloseConfirm::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgChannelCloseConfirm::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelCloseConfirm::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgChannelCloseConfirm::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgChannelCloseConfirm::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
  return _msg;
}
inline void MsgChannelCloseConfirm::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.proof_height)
}

// string signer = 5 [json_name = "signer"];
inline void MsgChannelCloseConfirm::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgChannelCloseConfirm::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgChannelCloseConfirm::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
}
inline std::string* MsgChannelCloseConfirm::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
  return _s;
}
inline const std::string& MsgChannelCloseConfirm::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgChannelCloseConfirm::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgChannelCloseConfirm::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
  return _impl_.signer_.Release();
}
inline void MsgChannelCloseConfirm::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgChannelCloseConfirm.signer)
}

// -------------------------------------------------------------------

// MsgChannelCloseConfirmResponse

// -------------------------------------------------------------------

// MsgRecvPacket

// .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
inline bool MsgRecvPacket::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Packet& MsgRecvPacket::_internal_packet() const {
  const ::ibc::core::channel::v1::Packet* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Packet&>(
      ::ibc::core::channel::v1::_Packet_default_instance_);
}
inline const ::ibc::core::channel::v1::Packet& MsgRecvPacket::packet() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgRecvPacket.packet)
  return _internal_packet();
}
inline void MsgRecvPacket::unsafe_arena_set_allocated_packet(
    ::ibc::core::channel::v1::Packet* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgRecvPacket.packet)
}
inline ::ibc::core::channel::v1::Packet* MsgRecvPacket::release_packet() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgRecvPacket::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgRecvPacket.packet)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgRecvPacket::_internal_mutable_packet() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Packet>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::ibc::core::channel::v1::Packet* MsgRecvPacket::mutable_packet() {
  ::ibc::core::channel::v1::Packet* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgRecvPacket.packet)
  return _msg;
}
inline void MsgRecvPacket::set_allocated_packet(::ibc::core::channel::v1::Packet* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet));
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgRecvPacket.packet)
}

// bytes proof_commitment = 2 [json_name = "proofCommitment"];
inline void MsgRecvPacket::clear_proof_commitment() {
  _impl_.proof_commitment_.ClearToEmpty();
}
inline const std::string& MsgRecvPacket::proof_commitment() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
  return _internal_proof_commitment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRecvPacket::set_proof_commitment(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_commitment_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
}
inline std::string* MsgRecvPacket::mutable_proof_commitment() {
  std::string* _s = _internal_mutable_proof_commitment();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
  return _s;
}
inline const std::string& MsgRecvPacket::_internal_proof_commitment() const {
  return _impl_.proof_commitment_.Get();
}
inline void MsgRecvPacket::_internal_set_proof_commitment(const std::string& value) {
  ;


  _impl_.proof_commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRecvPacket::_internal_mutable_proof_commitment() {
  ;
  return _impl_.proof_commitment_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRecvPacket::release_proof_commitment() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
  return _impl_.proof_commitment_.Release();
}
inline void MsgRecvPacket::set_allocated_proof_commitment(std::string* value) {
  _impl_.proof_commitment_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_commitment_.IsDefault()) {
          _impl_.proof_commitment_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgRecvPacket.proof_commitment)
}

// .ibc.core.client.v1.Height proof_height = 3 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgRecvPacket::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgRecvPacket::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgRecvPacket::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgRecvPacket.proof_height)
  return _internal_proof_height();
}
inline void MsgRecvPacket::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgRecvPacket.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgRecvPacket::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgRecvPacket::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgRecvPacket.proof_height)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgRecvPacket::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgRecvPacket::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgRecvPacket.proof_height)
  return _msg;
}
inline void MsgRecvPacket::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgRecvPacket.proof_height)
}

// string signer = 4 [json_name = "signer"];
inline void MsgRecvPacket::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgRecvPacket::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgRecvPacket.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgRecvPacket::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgRecvPacket.signer)
}
inline std::string* MsgRecvPacket::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgRecvPacket.signer)
  return _s;
}
inline const std::string& MsgRecvPacket::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgRecvPacket::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRecvPacket::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgRecvPacket::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgRecvPacket.signer)
  return _impl_.signer_.Release();
}
inline void MsgRecvPacket::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgRecvPacket.signer)
}

// -------------------------------------------------------------------

// MsgRecvPacketResponse

// .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
inline void MsgRecvPacketResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::ibc::core::channel::v1::ResponseResultType MsgRecvPacketResponse::result() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgRecvPacketResponse.result)
  return _internal_result();
}
inline void MsgRecvPacketResponse::set_result(::ibc::core::channel::v1::ResponseResultType value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgRecvPacketResponse.result)
}
inline ::ibc::core::channel::v1::ResponseResultType MsgRecvPacketResponse::_internal_result() const {
  return static_cast<::ibc::core::channel::v1::ResponseResultType>(_impl_.result_);
}
inline void MsgRecvPacketResponse::_internal_set_result(::ibc::core::channel::v1::ResponseResultType value) {
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// MsgTimeout

// .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
inline bool MsgTimeout::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Packet& MsgTimeout::_internal_packet() const {
  const ::ibc::core::channel::v1::Packet* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Packet&>(
      ::ibc::core::channel::v1::_Packet_default_instance_);
}
inline const ::ibc::core::channel::v1::Packet& MsgTimeout::packet() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeout.packet)
  return _internal_packet();
}
inline void MsgTimeout::unsafe_arena_set_allocated_packet(
    ::ibc::core::channel::v1::Packet* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgTimeout.packet)
}
inline ::ibc::core::channel::v1::Packet* MsgTimeout::release_packet() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeout::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeout.packet)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeout::_internal_mutable_packet() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Packet>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeout::mutable_packet() {
  ::ibc::core::channel::v1::Packet* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeout.packet)
  return _msg;
}
inline void MsgTimeout::set_allocated_packet(::ibc::core::channel::v1::Packet* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet));
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeout.packet)
}

// bytes proof_unreceived = 2 [json_name = "proofUnreceived"];
inline void MsgTimeout::clear_proof_unreceived() {
  _impl_.proof_unreceived_.ClearToEmpty();
}
inline const std::string& MsgTimeout::proof_unreceived() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
  return _internal_proof_unreceived();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTimeout::set_proof_unreceived(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_unreceived_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
}
inline std::string* MsgTimeout::mutable_proof_unreceived() {
  std::string* _s = _internal_mutable_proof_unreceived();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
  return _s;
}
inline const std::string& MsgTimeout::_internal_proof_unreceived() const {
  return _impl_.proof_unreceived_.Get();
}
inline void MsgTimeout::_internal_set_proof_unreceived(const std::string& value) {
  ;


  _impl_.proof_unreceived_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTimeout::_internal_mutable_proof_unreceived() {
  ;
  return _impl_.proof_unreceived_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTimeout::release_proof_unreceived() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
  return _impl_.proof_unreceived_.Release();
}
inline void MsgTimeout::set_allocated_proof_unreceived(std::string* value) {
  _impl_.proof_unreceived_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_unreceived_.IsDefault()) {
          _impl_.proof_unreceived_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeout.proof_unreceived)
}

// .ibc.core.client.v1.Height proof_height = 3 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgTimeout::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgTimeout::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgTimeout::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeout.proof_height)
  return _internal_proof_height();
}
inline void MsgTimeout::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgTimeout.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgTimeout::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgTimeout::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeout.proof_height)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgTimeout::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgTimeout::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeout.proof_height)
  return _msg;
}
inline void MsgTimeout::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeout.proof_height)
}

// uint64 next_sequence_recv = 4 [json_name = "nextSequenceRecv"];
inline void MsgTimeout::clear_next_sequence_recv() {
  _impl_.next_sequence_recv_ = ::uint64_t{0u};
}
inline ::uint64_t MsgTimeout::next_sequence_recv() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeout.next_sequence_recv)
  return _internal_next_sequence_recv();
}
inline void MsgTimeout::set_next_sequence_recv(::uint64_t value) {
  _internal_set_next_sequence_recv(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeout.next_sequence_recv)
}
inline ::uint64_t MsgTimeout::_internal_next_sequence_recv() const {
  return _impl_.next_sequence_recv_;
}
inline void MsgTimeout::_internal_set_next_sequence_recv(::uint64_t value) {
  ;
  _impl_.next_sequence_recv_ = value;
}

// string signer = 5 [json_name = "signer"];
inline void MsgTimeout::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgTimeout::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeout.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTimeout::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeout.signer)
}
inline std::string* MsgTimeout::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeout.signer)
  return _s;
}
inline const std::string& MsgTimeout::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgTimeout::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTimeout::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTimeout::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeout.signer)
  return _impl_.signer_.Release();
}
inline void MsgTimeout::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeout.signer)
}

// -------------------------------------------------------------------

// MsgTimeoutResponse

// .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
inline void MsgTimeoutResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::ibc::core::channel::v1::ResponseResultType MsgTimeoutResponse::result() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutResponse.result)
  return _internal_result();
}
inline void MsgTimeoutResponse::set_result(::ibc::core::channel::v1::ResponseResultType value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutResponse.result)
}
inline ::ibc::core::channel::v1::ResponseResultType MsgTimeoutResponse::_internal_result() const {
  return static_cast<::ibc::core::channel::v1::ResponseResultType>(_impl_.result_);
}
inline void MsgTimeoutResponse::_internal_set_result(::ibc::core::channel::v1::ResponseResultType value) {
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// MsgTimeoutOnClose

// .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
inline bool MsgTimeoutOnClose::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Packet& MsgTimeoutOnClose::_internal_packet() const {
  const ::ibc::core::channel::v1::Packet* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Packet&>(
      ::ibc::core::channel::v1::_Packet_default_instance_);
}
inline const ::ibc::core::channel::v1::Packet& MsgTimeoutOnClose::packet() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
  return _internal_packet();
}
inline void MsgTimeoutOnClose::unsafe_arena_set_allocated_packet(
    ::ibc::core::channel::v1::Packet* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
}
inline ::ibc::core::channel::v1::Packet* MsgTimeoutOnClose::release_packet() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeoutOnClose::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeoutOnClose::_internal_mutable_packet() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Packet>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::ibc::core::channel::v1::Packet* MsgTimeoutOnClose::mutable_packet() {
  ::ibc::core::channel::v1::Packet* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
  return _msg;
}
inline void MsgTimeoutOnClose::set_allocated_packet(::ibc::core::channel::v1::Packet* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet));
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.packet)
}

// bytes proof_unreceived = 2 [json_name = "proofUnreceived"];
inline void MsgTimeoutOnClose::clear_proof_unreceived() {
  _impl_.proof_unreceived_.ClearToEmpty();
}
inline const std::string& MsgTimeoutOnClose::proof_unreceived() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
  return _internal_proof_unreceived();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTimeoutOnClose::set_proof_unreceived(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_unreceived_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
}
inline std::string* MsgTimeoutOnClose::mutable_proof_unreceived() {
  std::string* _s = _internal_mutable_proof_unreceived();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
  return _s;
}
inline const std::string& MsgTimeoutOnClose::_internal_proof_unreceived() const {
  return _impl_.proof_unreceived_.Get();
}
inline void MsgTimeoutOnClose::_internal_set_proof_unreceived(const std::string& value) {
  ;


  _impl_.proof_unreceived_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::_internal_mutable_proof_unreceived() {
  ;
  return _impl_.proof_unreceived_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::release_proof_unreceived() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
  return _impl_.proof_unreceived_.Release();
}
inline void MsgTimeoutOnClose::set_allocated_proof_unreceived(std::string* value) {
  _impl_.proof_unreceived_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_unreceived_.IsDefault()) {
          _impl_.proof_unreceived_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.proof_unreceived)
}

// bytes proof_close = 3 [json_name = "proofClose"];
inline void MsgTimeoutOnClose::clear_proof_close() {
  _impl_.proof_close_.ClearToEmpty();
}
inline const std::string& MsgTimeoutOnClose::proof_close() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
  return _internal_proof_close();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTimeoutOnClose::set_proof_close(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_close_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
}
inline std::string* MsgTimeoutOnClose::mutable_proof_close() {
  std::string* _s = _internal_mutable_proof_close();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
  return _s;
}
inline const std::string& MsgTimeoutOnClose::_internal_proof_close() const {
  return _impl_.proof_close_.Get();
}
inline void MsgTimeoutOnClose::_internal_set_proof_close(const std::string& value) {
  ;


  _impl_.proof_close_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::_internal_mutable_proof_close() {
  ;
  return _impl_.proof_close_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::release_proof_close() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
  return _impl_.proof_close_.Release();
}
inline void MsgTimeoutOnClose::set_allocated_proof_close(std::string* value) {
  _impl_.proof_close_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_close_.IsDefault()) {
          _impl_.proof_close_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.proof_close)
}

// .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgTimeoutOnClose::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgTimeoutOnClose::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgTimeoutOnClose::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
  return _internal_proof_height();
}
inline void MsgTimeoutOnClose::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgTimeoutOnClose::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgTimeoutOnClose::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgTimeoutOnClose::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgTimeoutOnClose::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
  return _msg;
}
inline void MsgTimeoutOnClose::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.proof_height)
}

// uint64 next_sequence_recv = 5 [json_name = "nextSequenceRecv"];
inline void MsgTimeoutOnClose::clear_next_sequence_recv() {
  _impl_.next_sequence_recv_ = ::uint64_t{0u};
}
inline ::uint64_t MsgTimeoutOnClose::next_sequence_recv() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.next_sequence_recv)
  return _internal_next_sequence_recv();
}
inline void MsgTimeoutOnClose::set_next_sequence_recv(::uint64_t value) {
  _internal_set_next_sequence_recv(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutOnClose.next_sequence_recv)
}
inline ::uint64_t MsgTimeoutOnClose::_internal_next_sequence_recv() const {
  return _impl_.next_sequence_recv_;
}
inline void MsgTimeoutOnClose::_internal_set_next_sequence_recv(::uint64_t value) {
  ;
  _impl_.next_sequence_recv_ = value;
}

// string signer = 6 [json_name = "signer"];
inline void MsgTimeoutOnClose::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgTimeoutOnClose::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgTimeoutOnClose::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
}
inline std::string* MsgTimeoutOnClose::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
  return _s;
}
inline const std::string& MsgTimeoutOnClose::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgTimeoutOnClose::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgTimeoutOnClose::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
  return _impl_.signer_.Release();
}
inline void MsgTimeoutOnClose::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgTimeoutOnClose.signer)
}

// -------------------------------------------------------------------

// MsgTimeoutOnCloseResponse

// .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
inline void MsgTimeoutOnCloseResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::ibc::core::channel::v1::ResponseResultType MsgTimeoutOnCloseResponse::result() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgTimeoutOnCloseResponse.result)
  return _internal_result();
}
inline void MsgTimeoutOnCloseResponse::set_result(::ibc::core::channel::v1::ResponseResultType value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgTimeoutOnCloseResponse.result)
}
inline ::ibc::core::channel::v1::ResponseResultType MsgTimeoutOnCloseResponse::_internal_result() const {
  return static_cast<::ibc::core::channel::v1::ResponseResultType>(_impl_.result_);
}
inline void MsgTimeoutOnCloseResponse::_internal_set_result(::ibc::core::channel::v1::ResponseResultType value) {
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// MsgAcknowledgement

// .ibc.core.channel.v1.Packet packet = 1 [json_name = "packet", (.gogoproto.nullable) = false];
inline bool MsgAcknowledgement::has_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.packet_ != nullptr);
  return value;
}
inline const ::ibc::core::channel::v1::Packet& MsgAcknowledgement::_internal_packet() const {
  const ::ibc::core::channel::v1::Packet* p = _impl_.packet_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::channel::v1::Packet&>(
      ::ibc::core::channel::v1::_Packet_default_instance_);
}
inline const ::ibc::core::channel::v1::Packet& MsgAcknowledgement::packet() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgement.packet)
  return _internal_packet();
}
inline void MsgAcknowledgement::unsafe_arena_set_allocated_packet(
    ::ibc::core::channel::v1::Packet* packet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  _impl_.packet_ = packet;
  if (packet) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.packet)
}
inline ::ibc::core::channel::v1::Packet* MsgAcknowledgement::release_packet() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgAcknowledgement::unsafe_arena_release_packet() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgAcknowledgement.packet)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ibc::core::channel::v1::Packet* temp = _impl_.packet_;
  _impl_.packet_ = nullptr;
  return temp;
}
inline ::ibc::core::channel::v1::Packet* MsgAcknowledgement::_internal_mutable_packet() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.packet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::channel::v1::Packet>(GetArenaForAllocation());
    _impl_.packet_ = p;
  }
  return _impl_.packet_;
}
inline ::ibc::core::channel::v1::Packet* MsgAcknowledgement::mutable_packet() {
  ::ibc::core::channel::v1::Packet* _msg = _internal_mutable_packet();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgAcknowledgement.packet)
  return _msg;
}
inline void MsgAcknowledgement::set_allocated_packet(::ibc::core::channel::v1::Packet* packet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_);
  }
  if (packet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet));
    if (message_arena != submessage_arena) {
      packet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.packet_ = packet;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.packet)
}

// bytes acknowledgement = 2 [json_name = "acknowledgement"];
inline void MsgAcknowledgement::clear_acknowledgement() {
  _impl_.acknowledgement_.ClearToEmpty();
}
inline const std::string& MsgAcknowledgement::acknowledgement() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
  return _internal_acknowledgement();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcknowledgement::set_acknowledgement(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.acknowledgement_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
}
inline std::string* MsgAcknowledgement::mutable_acknowledgement() {
  std::string* _s = _internal_mutable_acknowledgement();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
  return _s;
}
inline const std::string& MsgAcknowledgement::_internal_acknowledgement() const {
  return _impl_.acknowledgement_.Get();
}
inline void MsgAcknowledgement::_internal_set_acknowledgement(const std::string& value) {
  ;


  _impl_.acknowledgement_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::_internal_mutable_acknowledgement() {
  ;
  return _impl_.acknowledgement_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::release_acknowledgement() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
  return _impl_.acknowledgement_.Release();
}
inline void MsgAcknowledgement::set_allocated_acknowledgement(std::string* value) {
  _impl_.acknowledgement_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acknowledgement_.IsDefault()) {
          _impl_.acknowledgement_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.acknowledgement)
}

// bytes proof_acked = 3 [json_name = "proofAcked"];
inline void MsgAcknowledgement::clear_proof_acked() {
  _impl_.proof_acked_.ClearToEmpty();
}
inline const std::string& MsgAcknowledgement::proof_acked() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
  return _internal_proof_acked();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcknowledgement::set_proof_acked(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proof_acked_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
}
inline std::string* MsgAcknowledgement::mutable_proof_acked() {
  std::string* _s = _internal_mutable_proof_acked();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
  return _s;
}
inline const std::string& MsgAcknowledgement::_internal_proof_acked() const {
  return _impl_.proof_acked_.Get();
}
inline void MsgAcknowledgement::_internal_set_proof_acked(const std::string& value) {
  ;


  _impl_.proof_acked_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::_internal_mutable_proof_acked() {
  ;
  return _impl_.proof_acked_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::release_proof_acked() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
  return _impl_.proof_acked_.Release();
}
inline void MsgAcknowledgement::set_allocated_proof_acked(std::string* value) {
  _impl_.proof_acked_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proof_acked_.IsDefault()) {
          _impl_.proof_acked_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.proof_acked)
}

// .ibc.core.client.v1.Height proof_height = 4 [json_name = "proofHeight", (.gogoproto.nullable) = false];
inline bool MsgAcknowledgement::has_proof_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_height_ != nullptr);
  return value;
}
inline const ::ibc::core::client::v1::Height& MsgAcknowledgement::_internal_proof_height() const {
  const ::ibc::core::client::v1::Height* p = _impl_.proof_height_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibc::core::client::v1::Height&>(
      ::ibc::core::client::v1::_Height_default_instance_);
}
inline const ::ibc::core::client::v1::Height& MsgAcknowledgement::proof_height() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
  return _internal_proof_height();
}
inline void MsgAcknowledgement::unsafe_arena_set_allocated_proof_height(
    ::ibc::core::client::v1::Height* proof_height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  _impl_.proof_height_ = proof_height;
  if (proof_height) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
}
inline ::ibc::core::client::v1::Height* MsgAcknowledgement::release_proof_height() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgAcknowledgement::unsafe_arena_release_proof_height() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ibc::core::client::v1::Height* temp = _impl_.proof_height_;
  _impl_.proof_height_ = nullptr;
  return temp;
}
inline ::ibc::core::client::v1::Height* MsgAcknowledgement::_internal_mutable_proof_height() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.proof_height_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibc::core::client::v1::Height>(GetArenaForAllocation());
    _impl_.proof_height_ = p;
  }
  return _impl_.proof_height_;
}
inline ::ibc::core::client::v1::Height* MsgAcknowledgement::mutable_proof_height() {
  ::ibc::core::client::v1::Height* _msg = _internal_mutable_proof_height();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
  return _msg;
}
inline void MsgAcknowledgement::set_allocated_proof_height(::ibc::core::client::v1::Height* proof_height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_height_);
  }
  if (proof_height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_height));
    if (message_arena != submessage_arena) {
      proof_height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_height, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.proof_height_ = proof_height;
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.proof_height)
}

// string signer = 5 [json_name = "signer"];
inline void MsgAcknowledgement::clear_signer() {
  _impl_.signer_.ClearToEmpty();
}
inline const std::string& MsgAcknowledgement::signer() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgement.signer)
  return _internal_signer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MsgAcknowledgement::set_signer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgAcknowledgement.signer)
}
inline std::string* MsgAcknowledgement::mutable_signer() {
  std::string* _s = _internal_mutable_signer();
  // @@protoc_insertion_point(field_mutable:ibc.core.channel.v1.MsgAcknowledgement.signer)
  return _s;
}
inline const std::string& MsgAcknowledgement::_internal_signer() const {
  return _impl_.signer_.Get();
}
inline void MsgAcknowledgement::_internal_set_signer(const std::string& value) {
  ;


  _impl_.signer_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::_internal_mutable_signer() {
  ;
  return _impl_.signer_.Mutable( GetArenaForAllocation());
}
inline std::string* MsgAcknowledgement::release_signer() {
  // @@protoc_insertion_point(field_release:ibc.core.channel.v1.MsgAcknowledgement.signer)
  return _impl_.signer_.Release();
}
inline void MsgAcknowledgement::set_allocated_signer(std::string* value) {
  _impl_.signer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_.IsDefault()) {
          _impl_.signer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ibc.core.channel.v1.MsgAcknowledgement.signer)
}

// -------------------------------------------------------------------

// MsgAcknowledgementResponse

// .ibc.core.channel.v1.ResponseResultType result = 1 [json_name = "result"];
inline void MsgAcknowledgementResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::ibc::core::channel::v1::ResponseResultType MsgAcknowledgementResponse::result() const {
  // @@protoc_insertion_point(field_get:ibc.core.channel.v1.MsgAcknowledgementResponse.result)
  return _internal_result();
}
inline void MsgAcknowledgementResponse::set_result(::ibc::core::channel::v1::ResponseResultType value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:ibc.core.channel.v1.MsgAcknowledgementResponse.result)
}
inline ::ibc::core::channel::v1::ResponseResultType MsgAcknowledgementResponse::_internal_result() const {
  return static_cast<::ibc::core::channel::v1::ResponseResultType>(_impl_.result_);
}
inline void MsgAcknowledgementResponse::_internal_set_result(::ibc::core::channel::v1::ResponseResultType value) {
  ;
  _impl_.result_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace channel
}  // namespace core
}  // namespace ibc


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::ibc::core::channel::v1::ResponseResultType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ibc::core::channel::v1::ResponseResultType>() {
  return ::ibc::core::channel::v1::ResponseResultType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto_2epb_2eh
