// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: ibc/core/channel/v1/tx.proto
#ifndef GRPC_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto__INCLUDED
#define GRPC_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto__INCLUDED

#include "ibc/core/channel/v1/tx.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace ibc {
namespace core {
namespace channel {
namespace v1 {

// Msg defines the ibc/channel Msg service.
class Msg final {
 public:
  static constexpr char const* service_full_name() {
    return "ibc.core.channel.v1.Msg";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit.
    virtual ::grpc::Status ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>> AsyncChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>>(AsyncChannelOpenInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>> PrepareAsyncChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>>(PrepareAsyncChannelOpenInitRaw(context, request, cq));
    }
    // ChannelOpenTry defines a rpc handler method for MsgChannelOpenTry.
    virtual ::grpc::Status ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>> AsyncChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>>(AsyncChannelOpenTryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>> PrepareAsyncChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>>(PrepareAsyncChannelOpenTryRaw(context, request, cq));
    }
    // ChannelOpenAck defines a rpc handler method for MsgChannelOpenAck.
    virtual ::grpc::Status ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>> AsyncChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>>(AsyncChannelOpenAckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>> PrepareAsyncChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>>(PrepareAsyncChannelOpenAckRaw(context, request, cq));
    }
    // ChannelOpenConfirm defines a rpc handler method for MsgChannelOpenConfirm.
    virtual ::grpc::Status ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>> AsyncChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>>(AsyncChannelOpenConfirmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>> PrepareAsyncChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>>(PrepareAsyncChannelOpenConfirmRaw(context, request, cq));
    }
    // ChannelCloseInit defines a rpc handler method for MsgChannelCloseInit.
    virtual ::grpc::Status ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>> AsyncChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>>(AsyncChannelCloseInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>> PrepareAsyncChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>>(PrepareAsyncChannelCloseInitRaw(context, request, cq));
    }
    // ChannelCloseConfirm defines a rpc handler method for
    // MsgChannelCloseConfirm.
    virtual ::grpc::Status ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>> AsyncChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>>(AsyncChannelCloseConfirmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>> PrepareAsyncChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>>(PrepareAsyncChannelCloseConfirmRaw(context, request, cq));
    }
    // RecvPacket defines a rpc handler method for MsgRecvPacket.
    virtual ::grpc::Status RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>> AsyncRecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>>(AsyncRecvPacketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>> PrepareAsyncRecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>>(PrepareAsyncRecvPacketRaw(context, request, cq));
    }
    // Timeout defines a rpc handler method for MsgTimeout.
    virtual ::grpc::Status Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::ibc::core::channel::v1::MsgTimeoutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>> AsyncTimeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>>(AsyncTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>> PrepareAsyncTimeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>>(PrepareAsyncTimeoutRaw(context, request, cq));
    }
    // TimeoutOnClose defines a rpc handler method for MsgTimeoutOnClose.
    virtual ::grpc::Status TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>> AsyncTimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>>(AsyncTimeoutOnCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>> PrepareAsyncTimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>>(PrepareAsyncTimeoutOnCloseRaw(context, request, cq));
    }
    // Acknowledgement defines a rpc handler method for MsgAcknowledgement.
    virtual ::grpc::Status Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>> AsyncAcknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>>(AsyncAcknowledgementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>> PrepareAsyncAcknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>>(PrepareAsyncAcknowledgementRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit.
      virtual void ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ChannelOpenTry defines a rpc handler method for MsgChannelOpenTry.
      virtual void ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ChannelOpenAck defines a rpc handler method for MsgChannelOpenAck.
      virtual void ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ChannelOpenConfirm defines a rpc handler method for MsgChannelOpenConfirm.
      virtual void ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ChannelCloseInit defines a rpc handler method for MsgChannelCloseInit.
      virtual void ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // ChannelCloseConfirm defines a rpc handler method for
      // MsgChannelCloseConfirm.
      virtual void ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // RecvPacket defines a rpc handler method for MsgRecvPacket.
      virtual void RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Timeout defines a rpc handler method for MsgTimeout.
      virtual void Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // TimeoutOnClose defines a rpc handler method for MsgTimeoutOnClose.
      virtual void TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Acknowledgement defines a rpc handler method for MsgAcknowledgement.
      virtual void Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* AsyncChannelOpenInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* PrepareAsyncChannelOpenInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* AsyncChannelOpenTryRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* PrepareAsyncChannelOpenTryRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* AsyncChannelOpenAckRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* PrepareAsyncChannelOpenAckRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* AsyncChannelOpenConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* PrepareAsyncChannelOpenConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* AsyncChannelCloseInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* PrepareAsyncChannelCloseInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* AsyncChannelCloseConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* PrepareAsyncChannelCloseConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>* AsyncRecvPacketRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgRecvPacketResponse>* PrepareAsyncRecvPacketRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>* AsyncTimeoutRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutResponse>* PrepareAsyncTimeoutRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* AsyncTimeoutOnCloseRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* PrepareAsyncTimeoutOnCloseRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>* AsyncAcknowledgementRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ibc::core::channel::v1::MsgAcknowledgementResponse>* PrepareAsyncAcknowledgementRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>> AsyncChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>>(AsyncChannelOpenInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>> PrepareAsyncChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>>(PrepareAsyncChannelOpenInitRaw(context, request, cq));
    }
    ::grpc::Status ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>> AsyncChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>>(AsyncChannelOpenTryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>> PrepareAsyncChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>>(PrepareAsyncChannelOpenTryRaw(context, request, cq));
    }
    ::grpc::Status ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>> AsyncChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>>(AsyncChannelOpenAckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>> PrepareAsyncChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>>(PrepareAsyncChannelOpenAckRaw(context, request, cq));
    }
    ::grpc::Status ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>> AsyncChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>>(AsyncChannelOpenConfirmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>> PrepareAsyncChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>>(PrepareAsyncChannelOpenConfirmRaw(context, request, cq));
    }
    ::grpc::Status ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>> AsyncChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>>(AsyncChannelCloseInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>> PrepareAsyncChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>>(PrepareAsyncChannelCloseInitRaw(context, request, cq));
    }
    ::grpc::Status ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>> AsyncChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>>(AsyncChannelCloseConfirmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>> PrepareAsyncChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>>(PrepareAsyncChannelCloseConfirmRaw(context, request, cq));
    }
    ::grpc::Status RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>> AsyncRecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>>(AsyncRecvPacketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>> PrepareAsyncRecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>>(PrepareAsyncRecvPacketRaw(context, request, cq));
    }
    ::grpc::Status Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::ibc::core::channel::v1::MsgTimeoutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>> AsyncTimeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>>(AsyncTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>> PrepareAsyncTimeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>>(PrepareAsyncTimeoutRaw(context, request, cq));
    }
    ::grpc::Status TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>> AsyncTimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>>(AsyncTimeoutOnCloseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>> PrepareAsyncTimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>>(PrepareAsyncTimeoutOnCloseRaw(context, request, cq));
    }
    ::grpc::Status Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>> AsyncAcknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>>(AsyncAcknowledgementRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>> PrepareAsyncAcknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>>(PrepareAsyncAcknowledgementRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelOpenInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelOpenTry(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelOpenAck(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelOpenConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelCloseInit(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response, std::function<void(::grpc::Status)>) override;
      void ChannelCloseConfirm(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response, std::function<void(::grpc::Status)>) override;
      void RecvPacket(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response, std::function<void(::grpc::Status)>) override;
      void Timeout(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response, std::function<void(::grpc::Status)>) override;
      void TimeoutOnClose(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response, std::function<void(::grpc::Status)>) override;
      void Acknowledgement(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* AsyncChannelOpenInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* PrepareAsyncChannelOpenInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* AsyncChannelOpenTryRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* PrepareAsyncChannelOpenTryRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* AsyncChannelOpenAckRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* PrepareAsyncChannelOpenAckRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* AsyncChannelOpenConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* PrepareAsyncChannelOpenConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* AsyncChannelCloseInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* PrepareAsyncChannelCloseInitRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* AsyncChannelCloseConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* PrepareAsyncChannelCloseConfirmRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>* AsyncRecvPacketRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgRecvPacketResponse>* PrepareAsyncRecvPacketRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgRecvPacket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>* AsyncTimeoutRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutResponse>* PrepareAsyncTimeoutRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeout& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* AsyncTimeoutOnCloseRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* PrepareAsyncTimeoutOnCloseRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>* AsyncAcknowledgementRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ibc::core::channel::v1::MsgAcknowledgementResponse>* PrepareAsyncAcknowledgementRaw(::grpc::ClientContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelOpenInit_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelOpenTry_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelOpenAck_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelOpenConfirm_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelCloseInit_;
    const ::grpc::internal::RpcMethod rpcmethod_ChannelCloseConfirm_;
    const ::grpc::internal::RpcMethod rpcmethod_RecvPacket_;
    const ::grpc::internal::RpcMethod rpcmethod_Timeout_;
    const ::grpc::internal::RpcMethod rpcmethod_TimeoutOnClose_;
    const ::grpc::internal::RpcMethod rpcmethod_Acknowledgement_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit.
    virtual ::grpc::Status ChannelOpenInit(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response);
    // ChannelOpenTry defines a rpc handler method for MsgChannelOpenTry.
    virtual ::grpc::Status ChannelOpenTry(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response);
    // ChannelOpenAck defines a rpc handler method for MsgChannelOpenAck.
    virtual ::grpc::Status ChannelOpenAck(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response);
    // ChannelOpenConfirm defines a rpc handler method for MsgChannelOpenConfirm.
    virtual ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response);
    // ChannelCloseInit defines a rpc handler method for MsgChannelCloseInit.
    virtual ::grpc::Status ChannelCloseInit(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response);
    // ChannelCloseConfirm defines a rpc handler method for
    // MsgChannelCloseConfirm.
    virtual ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response);
    // RecvPacket defines a rpc handler method for MsgRecvPacket.
    virtual ::grpc::Status RecvPacket(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response);
    // Timeout defines a rpc handler method for MsgTimeout.
    virtual ::grpc::Status Timeout(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response);
    // TimeoutOnClose defines a rpc handler method for MsgTimeoutOnClose.
    virtual ::grpc::Status TimeoutOnClose(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response);
    // Acknowledgement defines a rpc handler method for MsgAcknowledgement.
    virtual ::grpc::Status Acknowledgement(::grpc::ServerContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenInit(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenTry(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenAck(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenConfirm(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelCloseInit(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelCloseConfirm(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RecvPacket() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecvPacket(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgRecvPacket* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgRecvPacketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Timeout() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeout(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgTimeout* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgTimeoutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeoutOnClose(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcknowledgement(::grpc::ServerContext* context, ::ibc::core::channel::v1::MsgAcknowledgement* request, ::grpc::ServerAsyncResponseWriter< ::ibc::core::channel::v1::MsgAcknowledgementResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ChannelOpenInit<WithAsyncMethod_ChannelOpenTry<WithAsyncMethod_ChannelOpenAck<WithAsyncMethod_ChannelOpenConfirm<WithAsyncMethod_ChannelCloseInit<WithAsyncMethod_ChannelCloseConfirm<WithAsyncMethod_RecvPacket<WithAsyncMethod_Timeout<WithAsyncMethod_TimeoutOnClose<WithAsyncMethod_Acknowledgement<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenInit, ::ibc::core::channel::v1::MsgChannelOpenInitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenInit* request, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* response) { return this->ChannelOpenInit(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelOpenInit(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelOpenInit, ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenInit, ::ibc::core::channel::v1::MsgChannelOpenInitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenInit(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenTry, ::ibc::core::channel::v1::MsgChannelOpenTryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenTry* request, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* response) { return this->ChannelOpenTry(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelOpenTry(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelOpenTry, ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenTry, ::ibc::core::channel::v1::MsgChannelOpenTryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenTry(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenAck, ::ibc::core::channel::v1::MsgChannelOpenAckResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenAck* request, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* response) { return this->ChannelOpenAck(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelOpenAck(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelOpenAck, ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenAck, ::ibc::core::channel::v1::MsgChannelOpenAckResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenAck(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenConfirm, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* request, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* response) { return this->ChannelOpenConfirm(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelOpenConfirm(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelOpenConfirm, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelOpenConfirm, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenConfirm(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelCloseInit, ::ibc::core::channel::v1::MsgChannelCloseInitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelCloseInit* request, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* response) { return this->ChannelCloseInit(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelCloseInit(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelCloseInit, ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelCloseInit, ::ibc::core::channel::v1::MsgChannelCloseInitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelCloseInit(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelCloseConfirm, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* request, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* response) { return this->ChannelCloseConfirm(context, request, response); }));}
    void SetMessageAllocatorFor_ChannelCloseConfirm(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgChannelCloseConfirm, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgChannelCloseConfirm, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelCloseConfirm(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RecvPacket() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgRecvPacket, ::ibc::core::channel::v1::MsgRecvPacketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgRecvPacket* request, ::ibc::core::channel::v1::MsgRecvPacketResponse* response) { return this->RecvPacket(context, request, response); }));}
    void SetMessageAllocatorFor_RecvPacket(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgRecvPacket, ::ibc::core::channel::v1::MsgRecvPacketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgRecvPacket, ::ibc::core::channel::v1::MsgRecvPacketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RecvPacket(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Timeout() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgTimeout, ::ibc::core::channel::v1::MsgTimeoutResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgTimeout* request, ::ibc::core::channel::v1::MsgTimeoutResponse* response) { return this->Timeout(context, request, response); }));}
    void SetMessageAllocatorFor_Timeout(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgTimeout, ::ibc::core::channel::v1::MsgTimeoutResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgTimeout, ::ibc::core::channel::v1::MsgTimeoutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Timeout(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgTimeoutOnClose, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgTimeoutOnClose* request, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* response) { return this->TimeoutOnClose(context, request, response); }));}
    void SetMessageAllocatorFor_TimeoutOnClose(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgTimeoutOnClose, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgTimeoutOnClose, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TimeoutOnClose(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgAcknowledgement, ::ibc::core::channel::v1::MsgAcknowledgementResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ibc::core::channel::v1::MsgAcknowledgement* request, ::ibc::core::channel::v1::MsgAcknowledgementResponse* response) { return this->Acknowledgement(context, request, response); }));}
    void SetMessageAllocatorFor_Acknowledgement(
        ::grpc::MessageAllocator< ::ibc::core::channel::v1::MsgAcknowledgement, ::ibc::core::channel::v1::MsgAcknowledgementResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ibc::core::channel::v1::MsgAcknowledgement, ::ibc::core::channel::v1::MsgAcknowledgementResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Acknowledgement(
      ::grpc::CallbackServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ChannelOpenInit<WithCallbackMethod_ChannelOpenTry<WithCallbackMethod_ChannelOpenAck<WithCallbackMethod_ChannelOpenConfirm<WithCallbackMethod_ChannelCloseInit<WithCallbackMethod_ChannelCloseConfirm<WithCallbackMethod_RecvPacket<WithCallbackMethod_Timeout<WithCallbackMethod_TimeoutOnClose<WithCallbackMethod_Acknowledgement<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RecvPacket() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Timeout() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenTry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenAck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelOpenConfirm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelCloseInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChannelCloseConfirm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RecvPacket() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecvPacket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Timeout() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeoutOnClose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcknowledgement(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelOpenInit(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelOpenTry(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenTry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelOpenAck(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenAck(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelOpenConfirm(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelOpenConfirm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelCloseInit(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelCloseInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChannelCloseConfirm(context, request, response); }));
    }
    ~WithRawCallbackMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ChannelCloseConfirm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RecvPacket() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RecvPacket(context, request, response); }));
    }
    ~WithRawCallbackMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RecvPacket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Timeout() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Timeout(context, request, response); }));
    }
    ~WithRawCallbackMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Timeout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TimeoutOnClose(context, request, response); }));
    }
    ~WithRawCallbackMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TimeoutOnClose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Acknowledgement(context, request, response); }));
    }
    ~WithRawCallbackMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Acknowledgement(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelOpenInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelOpenInit() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelOpenInit, ::ibc::core::channel::v1::MsgChannelOpenInitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelOpenInit, ::ibc::core::channel::v1::MsgChannelOpenInitResponse>* streamer) {
                       return this->StreamedChannelOpenInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelOpenInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelOpenInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenInit* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelOpenInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelOpenInit,::ibc::core::channel::v1::MsgChannelOpenInitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelOpenTry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelOpenTry() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelOpenTry, ::ibc::core::channel::v1::MsgChannelOpenTryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelOpenTry, ::ibc::core::channel::v1::MsgChannelOpenTryResponse>* streamer) {
                       return this->StreamedChannelOpenTry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelOpenTry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelOpenTry(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenTry* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenTryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelOpenTry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelOpenTry,::ibc::core::channel::v1::MsgChannelOpenTryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelOpenAck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelOpenAck() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelOpenAck, ::ibc::core::channel::v1::MsgChannelOpenAckResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelOpenAck, ::ibc::core::channel::v1::MsgChannelOpenAckResponse>* streamer) {
                       return this->StreamedChannelOpenAck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelOpenAck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelOpenAck(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenAck* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenAckResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelOpenAck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelOpenAck,::ibc::core::channel::v1::MsgChannelOpenAckResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelOpenConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelOpenConfirm() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelOpenConfirm, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelOpenConfirm, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* streamer) {
                       return this->StreamedChannelOpenConfirm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelOpenConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelOpenConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelOpenConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelOpenConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelOpenConfirm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelOpenConfirm,::ibc::core::channel::v1::MsgChannelOpenConfirmResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelCloseInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelCloseInit() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelCloseInit, ::ibc::core::channel::v1::MsgChannelCloseInitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelCloseInit, ::ibc::core::channel::v1::MsgChannelCloseInitResponse>* streamer) {
                       return this->StreamedChannelCloseInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelCloseInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelCloseInit(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseInit* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseInitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelCloseInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelCloseInit,::ibc::core::channel::v1::MsgChannelCloseInitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChannelCloseConfirm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChannelCloseConfirm() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgChannelCloseConfirm, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgChannelCloseConfirm, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* streamer) {
                       return this->StreamedChannelCloseConfirm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChannelCloseConfirm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChannelCloseConfirm(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgChannelCloseConfirm* /*request*/, ::ibc::core::channel::v1::MsgChannelCloseConfirmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChannelCloseConfirm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgChannelCloseConfirm,::ibc::core::channel::v1::MsgChannelCloseConfirmResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RecvPacket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RecvPacket() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgRecvPacket, ::ibc::core::channel::v1::MsgRecvPacketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgRecvPacket, ::ibc::core::channel::v1::MsgRecvPacketResponse>* streamer) {
                       return this->StreamedRecvPacket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RecvPacket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RecvPacket(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgRecvPacket* /*request*/, ::ibc::core::channel::v1::MsgRecvPacketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecvPacket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgRecvPacket,::ibc::core::channel::v1::MsgRecvPacketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Timeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Timeout() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgTimeout, ::ibc::core::channel::v1::MsgTimeoutResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgTimeout, ::ibc::core::channel::v1::MsgTimeoutResponse>* streamer) {
                       return this->StreamedTimeout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Timeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Timeout(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeout* /*request*/, ::ibc::core::channel::v1::MsgTimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTimeout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgTimeout,::ibc::core::channel::v1::MsgTimeoutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TimeoutOnClose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TimeoutOnClose() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgTimeoutOnClose, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgTimeoutOnClose, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* streamer) {
                       return this->StreamedTimeoutOnClose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TimeoutOnClose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TimeoutOnClose(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgTimeoutOnClose* /*request*/, ::ibc::core::channel::v1::MsgTimeoutOnCloseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTimeoutOnClose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgTimeoutOnClose,::ibc::core::channel::v1::MsgTimeoutOnCloseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Acknowledgement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Acknowledgement() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ibc::core::channel::v1::MsgAcknowledgement, ::ibc::core::channel::v1::MsgAcknowledgementResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ibc::core::channel::v1::MsgAcknowledgement, ::ibc::core::channel::v1::MsgAcknowledgementResponse>* streamer) {
                       return this->StreamedAcknowledgement(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Acknowledgement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Acknowledgement(::grpc::ServerContext* /*context*/, const ::ibc::core::channel::v1::MsgAcknowledgement* /*request*/, ::ibc::core::channel::v1::MsgAcknowledgementResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAcknowledgement(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ibc::core::channel::v1::MsgAcknowledgement,::ibc::core::channel::v1::MsgAcknowledgementResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ChannelOpenInit<WithStreamedUnaryMethod_ChannelOpenTry<WithStreamedUnaryMethod_ChannelOpenAck<WithStreamedUnaryMethod_ChannelOpenConfirm<WithStreamedUnaryMethod_ChannelCloseInit<WithStreamedUnaryMethod_ChannelCloseConfirm<WithStreamedUnaryMethod_RecvPacket<WithStreamedUnaryMethod_Timeout<WithStreamedUnaryMethod_TimeoutOnClose<WithStreamedUnaryMethod_Acknowledgement<Service > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ChannelOpenInit<WithStreamedUnaryMethod_ChannelOpenTry<WithStreamedUnaryMethod_ChannelOpenAck<WithStreamedUnaryMethod_ChannelOpenConfirm<WithStreamedUnaryMethod_ChannelCloseInit<WithStreamedUnaryMethod_ChannelCloseConfirm<WithStreamedUnaryMethod_RecvPacket<WithStreamedUnaryMethod_Timeout<WithStreamedUnaryMethod_TimeoutOnClose<WithStreamedUnaryMethod_Acknowledgement<Service > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace channel
}  // namespace core
}  // namespace ibc


#endif  // GRPC_ibc_2fcore_2fchannel_2fv1_2ftx_2eproto__INCLUDED
