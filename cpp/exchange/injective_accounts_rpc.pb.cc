// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_accounts_rpc.proto

#include "exchange/injective_accounts_rpc.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace injective_accounts_rpc {
template <typename>
PROTOBUF_CONSTEXPR PortfolioRequest::PortfolioRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PortfolioRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortfolioRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortfolioRequestDefaultTypeInternal() {}
  union {
    PortfolioRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortfolioRequestDefaultTypeInternal _PortfolioRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PortfolioResponse::PortfolioResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.portfolio_)*/nullptr} {}
struct PortfolioResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortfolioResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortfolioResponseDefaultTypeInternal() {}
  union {
    PortfolioResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortfolioResponseDefaultTypeInternal _PortfolioResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR AccountPortfolio::AccountPortfolio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccounts_)*/{}
  , /*decltype(_impl_.portfolio_value_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.available_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.locked_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.unrealized_pnl_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AccountPortfolioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AccountPortfolioDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AccountPortfolioDefaultTypeInternal() {}
  union {
    AccountPortfolio _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AccountPortfolioDefaultTypeInternal _AccountPortfolio_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountPortfolio::SubaccountPortfolio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.available_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.locked_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.unrealized_pnl_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountPortfolioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountPortfolioDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountPortfolioDefaultTypeInternal() {}
  union {
    SubaccountPortfolio _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountPortfolioDefaultTypeInternal _SubaccountPortfolio_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderStatesRequest::OrderStatesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spot_order_hashes_)*/{}
  , /*decltype(_impl_.derivative_order_hashes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderStatesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderStatesRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderStatesRequestDefaultTypeInternal() {}
  union {
    OrderStatesRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderStatesRequestDefaultTypeInternal _OrderStatesRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderStatesResponse::OrderStatesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spot_order_states_)*/{}
  , /*decltype(_impl_.derivative_order_states_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderStatesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderStatesResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderStatesResponseDefaultTypeInternal() {}
  union {
    OrderStatesResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderStatesResponseDefaultTypeInternal _OrderStatesResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR OrderStateRecord::OrderStateRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.order_hash_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_side_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.state_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_filled_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.quantity_remaining_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.created_at_)*/ ::int64_t{0}

  , /*decltype(_impl_.updated_at_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OrderStateRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OrderStateRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OrderStateRecordDefaultTypeInternal() {}
  union {
    OrderStateRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OrderStateRecordDefaultTypeInternal _OrderStateRecord_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountsListRequest::SubaccountsListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountsListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountsListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountsListRequestDefaultTypeInternal() {}
  union {
    SubaccountsListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountsListRequestDefaultTypeInternal _SubaccountsListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountsListResponse::SubaccountsListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccounts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountsListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountsListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountsListResponseDefaultTypeInternal() {}
  union {
    SubaccountsListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountsListResponseDefaultTypeInternal _SubaccountsListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalancesListRequest::SubaccountBalancesListRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denoms_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountBalancesListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalancesListRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalancesListRequestDefaultTypeInternal() {}
  union {
    SubaccountBalancesListRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalancesListRequestDefaultTypeInternal _SubaccountBalancesListRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalancesListResponse::SubaccountBalancesListResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.balances_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountBalancesListResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalancesListResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalancesListResponseDefaultTypeInternal() {}
  union {
    SubaccountBalancesListResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalancesListResponseDefaultTypeInternal _SubaccountBalancesListResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalance::SubaccountBalance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.deposit_)*/nullptr} {}
struct SubaccountBalanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalanceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalanceDefaultTypeInternal() {}
  union {
    SubaccountBalance _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalanceDefaultTypeInternal _SubaccountBalance_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountDeposit::SubaccountDeposit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.total_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.available_balance_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountDepositDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountDepositDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountDepositDefaultTypeInternal() {}
  union {
    SubaccountDeposit _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountDepositDefaultTypeInternal _SubaccountDeposit_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalanceRequest::SubaccountBalanceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountBalanceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalanceRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalanceRequestDefaultTypeInternal() {}
  union {
    SubaccountBalanceRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalanceRequestDefaultTypeInternal _SubaccountBalanceRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalanceResponse::SubaccountBalanceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.balance_)*/nullptr} {}
struct SubaccountBalanceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalanceResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalanceResponseDefaultTypeInternal() {}
  union {
    SubaccountBalanceResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalanceResponseDefaultTypeInternal _SubaccountBalanceResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamSubaccountBalanceRequest::StreamSubaccountBalanceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denoms_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamSubaccountBalanceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamSubaccountBalanceRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamSubaccountBalanceRequestDefaultTypeInternal() {}
  union {
    StreamSubaccountBalanceRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamSubaccountBalanceRequestDefaultTypeInternal _StreamSubaccountBalanceRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StreamSubaccountBalanceResponse::StreamSubaccountBalanceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.balance_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::int64_t{0}
} {}
struct StreamSubaccountBalanceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamSubaccountBalanceResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamSubaccountBalanceResponseDefaultTypeInternal() {}
  union {
    StreamSubaccountBalanceResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamSubaccountBalanceResponseDefaultTypeInternal _StreamSubaccountBalanceResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountHistoryRequest::SubaccountHistoryRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transfer_types_)*/{}
  , /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.skip_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.limit_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountHistoryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountHistoryRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountHistoryRequestDefaultTypeInternal() {}
  union {
    SubaccountHistoryRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountHistoryRequestDefaultTypeInternal _SubaccountHistoryRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountHistoryResponse::SubaccountHistoryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transfers_)*/{}
  , /*decltype(_impl_.paging_)*/nullptr} {}
struct SubaccountHistoryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountHistoryResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountHistoryResponseDefaultTypeInternal() {}
  union {
    SubaccountHistoryResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountHistoryResponseDefaultTypeInternal _SubaccountHistoryResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountBalanceTransfer::SubaccountBalanceTransfer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.transfer_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.src_subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.src_account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.dst_account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/nullptr
  , /*decltype(_impl_.executed_at_)*/ ::int64_t{0}
} {}
struct SubaccountBalanceTransferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountBalanceTransferDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountBalanceTransferDefaultTypeInternal() {}
  union {
    SubaccountBalanceTransfer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountBalanceTransferDefaultTypeInternal _SubaccountBalanceTransfer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR CosmosCoin::CosmosCoin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CosmosCoinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CosmosCoinDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CosmosCoinDefaultTypeInternal() {}
  union {
    CosmosCoin _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CosmosCoinDefaultTypeInternal _CosmosCoin_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Paging::Paging(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.total_)*/ ::int64_t{0}

  , /*decltype(_impl_.from_)*/ 0

  , /*decltype(_impl_.to_)*/ 0

  , /*decltype(_impl_.count_by_subaccount_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PagingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PagingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PagingDefaultTypeInternal() {}
  union {
    Paging _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PagingDefaultTypeInternal _Paging_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrderSummaryRequest::SubaccountOrderSummaryRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subaccount_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.market_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.order_direction_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountOrderSummaryRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrderSummaryRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrderSummaryRequestDefaultTypeInternal() {}
  union {
    SubaccountOrderSummaryRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrderSummaryRequestDefaultTypeInternal _SubaccountOrderSummaryRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SubaccountOrderSummaryResponse::SubaccountOrderSummaryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spot_orders_total_)*/ ::int64_t{0}

  , /*decltype(_impl_.derivative_orders_total_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubaccountOrderSummaryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubaccountOrderSummaryResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubaccountOrderSummaryResponseDefaultTypeInternal() {}
  union {
    SubaccountOrderSummaryResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubaccountOrderSummaryResponseDefaultTypeInternal _SubaccountOrderSummaryResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RewardsRequest::RewardsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.epoch_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RewardsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RewardsRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RewardsRequestDefaultTypeInternal() {}
  union {
    RewardsRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RewardsRequestDefaultTypeInternal _RewardsRequest_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR RewardsResponse::RewardsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rewards_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RewardsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RewardsResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RewardsResponseDefaultTypeInternal() {}
  union {
    RewardsResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RewardsResponseDefaultTypeInternal _RewardsResponse_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Reward::Reward(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rewards_)*/{}
  , /*decltype(_impl_.account_address_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.distributed_at_)*/ ::int64_t{0}

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RewardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RewardDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RewardDefaultTypeInternal() {}
  union {
    Reward _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RewardDefaultTypeInternal _Reward_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Coin::Coin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.denom_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.amount_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CoinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoinDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoinDefaultTypeInternal() {}
  union {
    Coin _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoinDefaultTypeInternal _Coin_default_instance_;
}  // namespace injective_accounts_rpc
static ::_pb::Metadata file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[28];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_exchange_2finjective_5faccounts_5frpc_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_exchange_2finjective_5faccounts_5frpc_2eproto = nullptr;
const ::uint32_t TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::PortfolioRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::PortfolioRequest, _impl_.account_address_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::PortfolioResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::PortfolioResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::PortfolioResponse, _impl_.portfolio_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _impl_.portfolio_value_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _impl_.available_balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _impl_.locked_balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _impl_.unrealized_pnl_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::AccountPortfolio, _impl_.subaccounts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountPortfolio, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountPortfolio, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountPortfolio, _impl_.available_balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountPortfolio, _impl_.locked_balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountPortfolio, _impl_.unrealized_pnl_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesRequest, _impl_.spot_order_hashes_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesRequest, _impl_.derivative_order_hashes_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesResponse, _impl_.spot_order_states_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStatesResponse, _impl_.derivative_order_states_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.order_hash_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.order_type_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.order_side_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.quantity_filled_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.quantity_remaining_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.created_at_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::OrderStateRecord, _impl_.updated_at_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountsListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountsListRequest, _impl_.account_address_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountsListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountsListResponse, _impl_.subaccounts_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalancesListRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalancesListRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalancesListRequest, _impl_.denoms_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalancesListResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalancesListResponse, _impl_.balances_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _impl_.account_address_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalance, _impl_.deposit_),
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountDeposit, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountDeposit, _impl_.total_balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountDeposit, _impl_.available_balance_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceRequest, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceResponse, _impl_.balance_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceRequest, _impl_.denoms_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceResponse, _impl_.balance_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::StreamSubaccountBalanceResponse, _impl_.timestamp_),
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.transfer_types_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.limit_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryRequest, _impl_.end_time_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryResponse, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryResponse, _impl_.transfers_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountHistoryResponse, _impl_.paging_),
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.transfer_type_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.src_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.src_account_address_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.dst_subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.dst_account_address_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.amount_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountBalanceTransfer, _impl_.executed_at_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::CosmosCoin, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::CosmosCoin, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::CosmosCoin, _impl_.amount_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Paging, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Paging, _impl_.total_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Paging, _impl_.from_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Paging, _impl_.to_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Paging, _impl_.count_by_subaccount_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryRequest, _impl_.subaccount_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryRequest, _impl_.market_id_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryRequest, _impl_.order_direction_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryResponse, _impl_.spot_orders_total_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::SubaccountOrderSummaryResponse, _impl_.derivative_orders_total_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::RewardsRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::RewardsRequest, _impl_.epoch_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::RewardsRequest, _impl_.account_address_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::RewardsResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::RewardsResponse, _impl_.rewards_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Reward, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Reward, _impl_.account_address_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Reward, _impl_.rewards_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Reward, _impl_.distributed_at_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Coin, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Coin, _impl_.denom_),
    PROTOBUF_FIELD_OFFSET(::injective_accounts_rpc::Coin, _impl_.amount_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::injective_accounts_rpc::PortfolioRequest)},
        { 9, 18, -1, sizeof(::injective_accounts_rpc::PortfolioResponse)},
        { 19, -1, -1, sizeof(::injective_accounts_rpc::AccountPortfolio)},
        { 32, -1, -1, sizeof(::injective_accounts_rpc::SubaccountPortfolio)},
        { 44, -1, -1, sizeof(::injective_accounts_rpc::OrderStatesRequest)},
        { 54, -1, -1, sizeof(::injective_accounts_rpc::OrderStatesResponse)},
        { 64, -1, -1, sizeof(::injective_accounts_rpc::OrderStateRecord)},
        { 82, -1, -1, sizeof(::injective_accounts_rpc::SubaccountsListRequest)},
        { 91, -1, -1, sizeof(::injective_accounts_rpc::SubaccountsListResponse)},
        { 100, -1, -1, sizeof(::injective_accounts_rpc::SubaccountBalancesListRequest)},
        { 110, -1, -1, sizeof(::injective_accounts_rpc::SubaccountBalancesListResponse)},
        { 119, 131, -1, sizeof(::injective_accounts_rpc::SubaccountBalance)},
        { 135, -1, -1, sizeof(::injective_accounts_rpc::SubaccountDeposit)},
        { 145, -1, -1, sizeof(::injective_accounts_rpc::SubaccountBalanceRequest)},
        { 155, 164, -1, sizeof(::injective_accounts_rpc::SubaccountBalanceResponse)},
        { 165, -1, -1, sizeof(::injective_accounts_rpc::StreamSubaccountBalanceRequest)},
        { 175, 185, -1, sizeof(::injective_accounts_rpc::StreamSubaccountBalanceResponse)},
        { 187, -1, -1, sizeof(::injective_accounts_rpc::SubaccountHistoryRequest)},
        { 201, 211, -1, sizeof(::injective_accounts_rpc::SubaccountHistoryResponse)},
        { 213, 228, -1, sizeof(::injective_accounts_rpc::SubaccountBalanceTransfer)},
        { 235, -1, -1, sizeof(::injective_accounts_rpc::CosmosCoin)},
        { 245, -1, -1, sizeof(::injective_accounts_rpc::Paging)},
        { 257, -1, -1, sizeof(::injective_accounts_rpc::SubaccountOrderSummaryRequest)},
        { 268, -1, -1, sizeof(::injective_accounts_rpc::SubaccountOrderSummaryResponse)},
        { 278, -1, -1, sizeof(::injective_accounts_rpc::RewardsRequest)},
        { 288, -1, -1, sizeof(::injective_accounts_rpc::RewardsResponse)},
        { 297, -1, -1, sizeof(::injective_accounts_rpc::Reward)},
        { 308, -1, -1, sizeof(::injective_accounts_rpc::Coin)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::injective_accounts_rpc::_PortfolioRequest_default_instance_._instance,
    &::injective_accounts_rpc::_PortfolioResponse_default_instance_._instance,
    &::injective_accounts_rpc::_AccountPortfolio_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountPortfolio_default_instance_._instance,
    &::injective_accounts_rpc::_OrderStatesRequest_default_instance_._instance,
    &::injective_accounts_rpc::_OrderStatesResponse_default_instance_._instance,
    &::injective_accounts_rpc::_OrderStateRecord_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountsListRequest_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountsListResponse_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalancesListRequest_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalancesListResponse_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalance_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountDeposit_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalanceRequest_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalanceResponse_default_instance_._instance,
    &::injective_accounts_rpc::_StreamSubaccountBalanceRequest_default_instance_._instance,
    &::injective_accounts_rpc::_StreamSubaccountBalanceResponse_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountHistoryRequest_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountHistoryResponse_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountBalanceTransfer_default_instance_._instance,
    &::injective_accounts_rpc::_CosmosCoin_default_instance_._instance,
    &::injective_accounts_rpc::_Paging_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountOrderSummaryRequest_default_instance_._instance,
    &::injective_accounts_rpc::_SubaccountOrderSummaryResponse_default_instance_._instance,
    &::injective_accounts_rpc::_RewardsRequest_default_instance_._instance,
    &::injective_accounts_rpc::_RewardsResponse_default_instance_._instance,
    &::injective_accounts_rpc::_Reward_default_instance_._instance,
    &::injective_accounts_rpc::_Coin_default_instance_._instance,
};
const char descriptor_table_protodef_exchange_2finjective_5faccounts_5frpc_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n%exchange/injective_accounts_rpc.proto\022"
    "\026injective_accounts_rpc\";\n\020PortfolioRequ"
    "est\022\'\n\017account_address\030\001 \001(\tR\016accountAdd"
    "ress\"[\n\021PortfolioResponse\022F\n\tportfolio\030\001"
    " \001(\0132(.injective_accounts_rpc.AccountPor"
    "tfolioR\tportfolio\"\205\002\n\020AccountPortfolio\022\'"
    "\n\017portfolio_value\030\001 \001(\tR\016portfolioValue\022"
    "+\n\021available_balance\030\002 \001(\tR\020availableBal"
    "ance\022%\n\016locked_balance\030\003 \001(\tR\rlockedBala"
    "nce\022%\n\016unrealized_pnl\030\004 \001(\tR\runrealizedP"
    "nl\022M\n\013subaccounts\030\005 \003(\0132+.injective_acco"
    "unts_rpc.SubaccountPortfolioR\013subaccount"
    "s\"\265\001\n\023SubaccountPortfolio\022#\n\rsubaccount_"
    "id\030\001 \001(\tR\014subaccountId\022+\n\021available_bala"
    "nce\030\002 \001(\tR\020availableBalance\022%\n\016locked_ba"
    "lance\030\003 \001(\tR\rlockedBalance\022%\n\016unrealized"
    "_pnl\030\004 \001(\tR\runrealizedPnl\"x\n\022OrderStates"
    "Request\022*\n\021spot_order_hashes\030\001 \003(\tR\017spot"
    "OrderHashes\0226\n\027derivative_order_hashes\030\002"
    " \003(\tR\025derivativeOrderHashes\"\315\001\n\023OrderSta"
    "tesResponse\022T\n\021spot_order_states\030\001 \003(\0132("
    ".injective_accounts_rpc.OrderStateRecord"
    "R\017spotOrderStates\022`\n\027derivative_order_st"
    "ates\030\002 \003(\0132(.injective_accounts_rpc.Orde"
    "rStateRecordR\025derivativeOrderStates\"\335\002\n\020"
    "OrderStateRecord\022\035\n\norder_hash\030\001 \001(\tR\tor"
    "derHash\022#\n\rsubaccount_id\030\002 \001(\tR\014subaccou"
    "ntId\022\033\n\tmarket_id\030\003 \001(\tR\010marketId\022\035\n\nord"
    "er_type\030\004 \001(\tR\torderType\022\035\n\norder_side\030\005"
    " \001(\tR\torderSide\022\024\n\005state\030\006 \001(\tR\005state\022\'\n"
    "\017quantity_filled\030\007 \001(\tR\016quantityFilled\022-"
    "\n\022quantity_remaining\030\010 \001(\tR\021quantityRema"
    "ining\022\035\n\ncreated_at\030\t \001(\022R\tcreatedAt\022\035\n\n"
    "updated_at\030\n \001(\022R\tupdatedAt\"A\n\026Subaccoun"
    "tsListRequest\022\'\n\017account_address\030\001 \001(\tR\016"
    "accountAddress\";\n\027SubaccountsListRespons"
    "e\022 \n\013subaccounts\030\001 \003(\tR\013subaccounts\"\\\n\035S"
    "ubaccountBalancesListRequest\022#\n\rsubaccou"
    "nt_id\030\001 \001(\tR\014subaccountId\022\026\n\006denoms\030\002 \003("
    "\tR\006denoms\"g\n\036SubaccountBalancesListRespo"
    "nse\022E\n\010balances\030\001 \003(\0132).injective_accoun"
    "ts_rpc.SubaccountBalanceR\010balances\"\274\001\n\021S"
    "ubaccountBalance\022#\n\rsubaccount_id\030\001 \001(\tR"
    "\014subaccountId\022\'\n\017account_address\030\002 \001(\tR\016"
    "accountAddress\022\024\n\005denom\030\003 \001(\tR\005denom\022C\n\007"
    "deposit\030\004 \001(\0132).injective_accounts_rpc.S"
    "ubaccountDepositR\007deposit\"e\n\021SubaccountD"
    "eposit\022#\n\rtotal_balance\030\001 \001(\tR\014totalBala"
    "nce\022+\n\021available_balance\030\002 \001(\tR\020availabl"
    "eBalance\"U\n\030SubaccountBalanceRequest\022#\n\r"
    "subaccount_id\030\001 \001(\tR\014subaccountId\022\024\n\005den"
    "om\030\002 \001(\tR\005denom\"`\n\031SubaccountBalanceResp"
    "onse\022C\n\007balance\030\001 \001(\0132).injective_accoun"
    "ts_rpc.SubaccountBalanceR\007balance\"]\n\036Str"
    "eamSubaccountBalanceRequest\022#\n\rsubaccoun"
    "t_id\030\001 \001(\tR\014subaccountId\022\026\n\006denoms\030\002 \003(\t"
    "R\006denoms\"\204\001\n\037StreamSubaccountBalanceResp"
    "onse\022C\n\007balance\030\001 \001(\0132).injective_accoun"
    "ts_rpc.SubaccountBalanceR\007balance\022\034\n\ttim"
    "estamp\030\002 \001(\022R\ttimestamp\"\301\001\n\030SubaccountHi"
    "storyRequest\022#\n\rsubaccount_id\030\001 \001(\tR\014sub"
    "accountId\022\024\n\005denom\030\002 \001(\tR\005denom\022%\n\016trans"
    "fer_types\030\003 \003(\tR\rtransferTypes\022\022\n\004skip\030\004"
    " \001(\004R\004skip\022\024\n\005limit\030\005 \001(\021R\005limit\022\031\n\010end_"
    "time\030\006 \001(\022R\007endTime\"\244\001\n\031SubaccountHistor"
    "yResponse\022O\n\ttransfers\030\001 \003(\01321.injective"
    "_accounts_rpc.SubaccountBalanceTransferR"
    "\ttransfers\0226\n\006paging\030\002 \001(\0132\036.injective_a"
    "ccounts_rpc.PagingR\006paging\"\325\002\n\031Subaccoun"
    "tBalanceTransfer\022#\n\rtransfer_type\030\001 \001(\tR"
    "\014transferType\022*\n\021src_subaccount_id\030\002 \001(\t"
    "R\017srcSubaccountId\022.\n\023src_account_address"
    "\030\003 \001(\tR\021srcAccountAddress\022*\n\021dst_subacco"
    "unt_id\030\004 \001(\tR\017dstSubaccountId\022.\n\023dst_acc"
    "ount_address\030\005 \001(\tR\021dstAccountAddress\022:\n"
    "\006amount\030\006 \001(\0132\".injective_accounts_rpc.C"
    "osmosCoinR\006amount\022\037\n\013executed_at\030\007 \001(\022R\n"
    "executedAt\":\n\nCosmosCoin\022\024\n\005denom\030\001 \001(\tR"
    "\005denom\022\026\n\006amount\030\002 \001(\tR\006amount\"r\n\006Paging"
    "\022\024\n\005total\030\001 \001(\022R\005total\022\022\n\004from\030\002 \001(\021R\004fr"
    "om\022\016\n\002to\030\003 \001(\021R\002to\022.\n\023count_by_subaccoun"
    "t\030\004 \001(\022R\021countBySubaccount\"\212\001\n\035Subaccoun"
    "tOrderSummaryRequest\022#\n\rsubaccount_id\030\001 "
    "\001(\tR\014subaccountId\022\033\n\tmarket_id\030\002 \001(\tR\010ma"
    "rketId\022\'\n\017order_direction\030\003 \001(\tR\016orderDi"
    "rection\"\204\001\n\036SubaccountOrderSummaryRespon"
    "se\022*\n\021spot_orders_total\030\001 \001(\022R\017spotOrder"
    "sTotal\0226\n\027derivative_orders_total\030\002 \001(\022R"
    "\025derivativeOrdersTotal\"O\n\016RewardsRequest"
    "\022\024\n\005epoch\030\001 \001(\022R\005epoch\022\'\n\017account_addres"
    "s\030\002 \001(\tR\016accountAddress\"K\n\017RewardsRespon"
    "se\0228\n\007rewards\030\001 \003(\0132\036.injective_accounts"
    "_rpc.RewardR\007rewards\"\220\001\n\006Reward\022\'\n\017accou"
    "nt_address\030\001 \001(\tR\016accountAddress\0226\n\007rewa"
    "rds\030\002 \003(\0132\034.injective_accounts_rpc.CoinR"
    "\007rewards\022%\n\016distributed_at\030\003 \001(\022R\rdistri"
    "butedAt\"4\n\004Coin\022\024\n\005denom\030\001 \001(\tR\005denom\022\026\n"
    "\006amount\030\002 \001(\tR\006amount2\320\010\n\024InjectiveAccou"
    "ntsRPC\022`\n\tPortfolio\022(.injective_accounts"
    "_rpc.PortfolioRequest\032).injective_accoun"
    "ts_rpc.PortfolioResponse\022f\n\013OrderStates\022"
    "*.injective_accounts_rpc.OrderStatesRequ"
    "est\032+.injective_accounts_rpc.OrderStates"
    "Response\022r\n\017SubaccountsList\022..injective_"
    "accounts_rpc.SubaccountsListRequest\032/.in"
    "jective_accounts_rpc.SubaccountsListResp"
    "onse\022\207\001\n\026SubaccountBalancesList\0225.inject"
    "ive_accounts_rpc.SubaccountBalancesListR"
    "equest\0326.injective_accounts_rpc.Subaccou"
    "ntBalancesListResponse\022\200\001\n\031SubaccountBal"
    "anceEndpoint\0220.injective_accounts_rpc.Su"
    "baccountBalanceRequest\0321.injective_accou"
    "nts_rpc.SubaccountBalanceResponse\022\214\001\n\027St"
    "reamSubaccountBalance\0226.injective_accoun"
    "ts_rpc.StreamSubaccountBalanceRequest\0327."
    "injective_accounts_rpc.StreamSubaccountB"
    "alanceResponse0\001\022x\n\021SubaccountHistory\0220."
    "injective_accounts_rpc.SubaccountHistory"
    "Request\0321.injective_accounts_rpc.Subacco"
    "untHistoryResponse\022\207\001\n\026SubaccountOrderSu"
    "mmary\0225.injective_accounts_rpc.Subaccoun"
    "tOrderSummaryRequest\0326.injective_account"
    "s_rpc.SubaccountOrderSummaryResponse\022Z\n\007"
    "Rewards\022&.injective_accounts_rpc.Rewards"
    "Request\032\'.injective_accounts_rpc.Rewards"
    "ResponseB\302\001\n\032com.injective_accounts_rpcB"
    "\031InjectiveAccountsRpcProtoP\001Z\031/injective"
    "_accounts_rpcpb\242\002\003IXX\252\002\024InjectiveAccount"
    "sRpc\312\002\024InjectiveAccountsRpc\342\002 InjectiveA"
    "ccountsRpc\\GPBMetadata\352\002\024InjectiveAccoun"
    "tsRpcb\006proto3"
};
static ::absl::once_flag descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto = {
    false,
    false,
    5213,
    descriptor_table_protodef_exchange_2finjective_5faccounts_5frpc_2eproto,
    "exchange/injective_accounts_rpc.proto",
    &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
    nullptr,
    0,
    28,
    schemas,
    file_default_instances,
    TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto::offsets,
    file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto,
    file_level_enum_descriptors_exchange_2finjective_5faccounts_5frpc_2eproto,
    file_level_service_descriptors_exchange_2finjective_5faccounts_5frpc_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter() {
  return &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_exchange_2finjective_5faccounts_5frpc_2eproto(&descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto);
namespace injective_accounts_rpc {
// ===================================================================

class PortfolioRequest::_Internal {
 public:
};

PortfolioRequest::PortfolioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.PortfolioRequest)
}
PortfolioRequest::PortfolioRequest(const PortfolioRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortfolioRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_address().empty()) {
    _this->_impl_.account_address_.Set(from._internal_account_address(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.PortfolioRequest)
}

inline void PortfolioRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PortfolioRequest::~PortfolioRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.PortfolioRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortfolioRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_address_.Destroy();
}

void PortfolioRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortfolioRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.PortfolioRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortfolioRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_address = 1 [json_name = "accountAddress"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.PortfolioRequest.account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PortfolioRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.PortfolioRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    const std::string& _s = this->_internal_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.PortfolioRequest.account_address");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.PortfolioRequest)
  return target;
}

::size_t PortfolioRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.PortfolioRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortfolioRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortfolioRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortfolioRequest::GetClassData() const { return &_class_data_; }


void PortfolioRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortfolioRequest*>(&to_msg);
  auto& from = static_cast<const PortfolioRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.PortfolioRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_address().empty()) {
    _this->_internal_set_account_address(from._internal_account_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortfolioRequest::CopyFrom(const PortfolioRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.PortfolioRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortfolioRequest::IsInitialized() const {
  return true;
}

void PortfolioRequest::InternalSwap(PortfolioRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_address_, lhs_arena,
                                       &other->_impl_.account_address_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortfolioRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[0]);
}
// ===================================================================

class PortfolioResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PortfolioResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PortfolioResponse, _impl_._has_bits_);
  static const ::injective_accounts_rpc::AccountPortfolio& portfolio(const PortfolioResponse* msg);
  static void set_has_portfolio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::AccountPortfolio&
PortfolioResponse::_Internal::portfolio(const PortfolioResponse* msg) {
  return *msg->_impl_.portfolio_;
}
PortfolioResponse::PortfolioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.PortfolioResponse)
}
PortfolioResponse::PortfolioResponse(const PortfolioResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PortfolioResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portfolio_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.portfolio_ = new ::injective_accounts_rpc::AccountPortfolio(*from._impl_.portfolio_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.PortfolioResponse)
}

inline void PortfolioResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.portfolio_){nullptr}
  };
}

PortfolioResponse::~PortfolioResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.PortfolioResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortfolioResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.portfolio_;
}

void PortfolioResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortfolioResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.PortfolioResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.portfolio_ != nullptr);
    _impl_.portfolio_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortfolioResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_accounts_rpc.AccountPortfolio portfolio = 1 [json_name = "portfolio"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_portfolio(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PortfolioResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.PortfolioResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.AccountPortfolio portfolio = 1 [json_name = "portfolio"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::portfolio(this),
        _Internal::portfolio(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.PortfolioResponse)
  return target;
}

::size_t PortfolioResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.PortfolioResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_accounts_rpc.AccountPortfolio portfolio = 1 [json_name = "portfolio"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.portfolio_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortfolioResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortfolioResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortfolioResponse::GetClassData() const { return &_class_data_; }


void PortfolioResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortfolioResponse*>(&to_msg);
  auto& from = static_cast<const PortfolioResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.PortfolioResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_portfolio()->::injective_accounts_rpc::AccountPortfolio::MergeFrom(
        from._internal_portfolio());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortfolioResponse::CopyFrom(const PortfolioResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.PortfolioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortfolioResponse::IsInitialized() const {
  return true;
}

void PortfolioResponse::InternalSwap(PortfolioResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.portfolio_, other->_impl_.portfolio_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortfolioResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[1]);
}
// ===================================================================

class AccountPortfolio::_Internal {
 public:
};

AccountPortfolio::AccountPortfolio(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.AccountPortfolio)
}
AccountPortfolio::AccountPortfolio(const AccountPortfolio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AccountPortfolio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccounts_){from._impl_.subaccounts_}
    , decltype(_impl_.portfolio_value_) {}

    , decltype(_impl_.available_balance_) {}

    , decltype(_impl_.locked_balance_) {}

    , decltype(_impl_.unrealized_pnl_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.portfolio_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.portfolio_value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_portfolio_value().empty()) {
    _this->_impl_.portfolio_value_.Set(from._internal_portfolio_value(), _this->GetArenaForAllocation());
  }
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_available_balance().empty()) {
    _this->_impl_.available_balance_.Set(from._internal_available_balance(), _this->GetArenaForAllocation());
  }
  _impl_.locked_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.locked_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_locked_balance().empty()) {
    _this->_impl_.locked_balance_.Set(from._internal_locked_balance(), _this->GetArenaForAllocation());
  }
  _impl_.unrealized_pnl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unrealized_pnl().empty()) {
    _this->_impl_.unrealized_pnl_.Set(from._internal_unrealized_pnl(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.AccountPortfolio)
}

inline void AccountPortfolio::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccounts_){arena}
    , decltype(_impl_.portfolio_value_) {}

    , decltype(_impl_.available_balance_) {}

    , decltype(_impl_.locked_balance_) {}

    , decltype(_impl_.unrealized_pnl_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.portfolio_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.portfolio_value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locked_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.locked_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unrealized_pnl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AccountPortfolio::~AccountPortfolio() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.AccountPortfolio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AccountPortfolio::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_subaccounts()->~RepeatedPtrField();
  _impl_.portfolio_value_.Destroy();
  _impl_.available_balance_.Destroy();
  _impl_.locked_balance_.Destroy();
  _impl_.unrealized_pnl_.Destroy();
}

void AccountPortfolio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AccountPortfolio::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.AccountPortfolio)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_subaccounts()->Clear();
  _impl_.portfolio_value_.ClearToEmpty();
  _impl_.available_balance_.ClearToEmpty();
  _impl_.locked_balance_.ClearToEmpty();
  _impl_.unrealized_pnl_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AccountPortfolio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string portfolio_value = 1 [json_name = "portfolioValue"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_portfolio_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.AccountPortfolio.portfolio_value"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string available_balance = 2 [json_name = "availableBalance"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_available_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.AccountPortfolio.available_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string locked_balance = 3 [json_name = "lockedBalance"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_locked_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.AccountPortfolio.locked_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_unrealized_pnl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.AccountPortfolio.unrealized_pnl"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5 [json_name = "subaccounts"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subaccounts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* AccountPortfolio::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.AccountPortfolio)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string portfolio_value = 1 [json_name = "portfolioValue"];
  if (!this->_internal_portfolio_value().empty()) {
    const std::string& _s = this->_internal_portfolio_value();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.AccountPortfolio.portfolio_value");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    const std::string& _s = this->_internal_available_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.AccountPortfolio.available_balance");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string locked_balance = 3 [json_name = "lockedBalance"];
  if (!this->_internal_locked_balance().empty()) {
    const std::string& _s = this->_internal_locked_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.AccountPortfolio.locked_balance");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  if (!this->_internal_unrealized_pnl().empty()) {
    const std::string& _s = this->_internal_unrealized_pnl();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.AccountPortfolio.unrealized_pnl");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5 [json_name = "subaccounts"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subaccounts_size()); i < n; i++) {
    const auto& repfield = this->_internal_subaccounts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.AccountPortfolio)
  return target;
}

::size_t AccountPortfolio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.AccountPortfolio)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5 [json_name = "subaccounts"];
  total_size += 1UL * this->_internal_subaccounts_size();
  for (const auto& msg : this->_internal_subaccounts()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string portfolio_value = 1 [json_name = "portfolioValue"];
  if (!this->_internal_portfolio_value().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_portfolio_value());
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_available_balance());
  }

  // string locked_balance = 3 [json_name = "lockedBalance"];
  if (!this->_internal_locked_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_locked_balance());
  }

  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  if (!this->_internal_unrealized_pnl().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_unrealized_pnl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AccountPortfolio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AccountPortfolio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AccountPortfolio::GetClassData() const { return &_class_data_; }


void AccountPortfolio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AccountPortfolio*>(&to_msg);
  auto& from = static_cast<const AccountPortfolio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.AccountPortfolio)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_subaccounts()->MergeFrom(from._internal_subaccounts());
  if (!from._internal_portfolio_value().empty()) {
    _this->_internal_set_portfolio_value(from._internal_portfolio_value());
  }
  if (!from._internal_available_balance().empty()) {
    _this->_internal_set_available_balance(from._internal_available_balance());
  }
  if (!from._internal_locked_balance().empty()) {
    _this->_internal_set_locked_balance(from._internal_locked_balance());
  }
  if (!from._internal_unrealized_pnl().empty()) {
    _this->_internal_set_unrealized_pnl(from._internal_unrealized_pnl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AccountPortfolio::CopyFrom(const AccountPortfolio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.AccountPortfolio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountPortfolio::IsInitialized() const {
  return true;
}

void AccountPortfolio::InternalSwap(AccountPortfolio* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_subaccounts()->InternalSwap(other->_internal_mutable_subaccounts());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.portfolio_value_, lhs_arena,
                                       &other->_impl_.portfolio_value_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.available_balance_, lhs_arena,
                                       &other->_impl_.available_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.locked_balance_, lhs_arena,
                                       &other->_impl_.locked_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.unrealized_pnl_, lhs_arena,
                                       &other->_impl_.unrealized_pnl_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata AccountPortfolio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[2]);
}
// ===================================================================

class SubaccountPortfolio::_Internal {
 public:
};

SubaccountPortfolio::SubaccountPortfolio(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountPortfolio)
}
SubaccountPortfolio::SubaccountPortfolio(const SubaccountPortfolio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountPortfolio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.available_balance_) {}

    , decltype(_impl_.locked_balance_) {}

    , decltype(_impl_.unrealized_pnl_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_available_balance().empty()) {
    _this->_impl_.available_balance_.Set(from._internal_available_balance(), _this->GetArenaForAllocation());
  }
  _impl_.locked_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.locked_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_locked_balance().empty()) {
    _this->_impl_.locked_balance_.Set(from._internal_locked_balance(), _this->GetArenaForAllocation());
  }
  _impl_.unrealized_pnl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unrealized_pnl().empty()) {
    _this->_impl_.unrealized_pnl_.Set(from._internal_unrealized_pnl(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountPortfolio)
}

inline void SubaccountPortfolio::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.available_balance_) {}

    , decltype(_impl_.locked_balance_) {}

    , decltype(_impl_.unrealized_pnl_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.locked_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.locked_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unrealized_pnl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountPortfolio::~SubaccountPortfolio() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountPortfolio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountPortfolio::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.available_balance_.Destroy();
  _impl_.locked_balance_.Destroy();
  _impl_.unrealized_pnl_.Destroy();
}

void SubaccountPortfolio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountPortfolio::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountPortfolio)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.available_balance_.ClearToEmpty();
  _impl_.locked_balance_.ClearToEmpty();
  _impl_.unrealized_pnl_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountPortfolio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountPortfolio.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string available_balance = 2 [json_name = "availableBalance"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_available_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountPortfolio.available_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string locked_balance = 3 [json_name = "lockedBalance"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_locked_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountPortfolio.locked_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_unrealized_pnl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountPortfolio::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountPortfolio)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountPortfolio.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    const std::string& _s = this->_internal_available_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountPortfolio.available_balance");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string locked_balance = 3 [json_name = "lockedBalance"];
  if (!this->_internal_locked_balance().empty()) {
    const std::string& _s = this->_internal_locked_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountPortfolio.locked_balance");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  if (!this->_internal_unrealized_pnl().empty()) {
    const std::string& _s = this->_internal_unrealized_pnl();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountPortfolio)
  return target;
}

::size_t SubaccountPortfolio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountPortfolio)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_available_balance());
  }

  // string locked_balance = 3 [json_name = "lockedBalance"];
  if (!this->_internal_locked_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_locked_balance());
  }

  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  if (!this->_internal_unrealized_pnl().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_unrealized_pnl());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountPortfolio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountPortfolio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountPortfolio::GetClassData() const { return &_class_data_; }


void SubaccountPortfolio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountPortfolio*>(&to_msg);
  auto& from = static_cast<const SubaccountPortfolio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountPortfolio)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_available_balance().empty()) {
    _this->_internal_set_available_balance(from._internal_available_balance());
  }
  if (!from._internal_locked_balance().empty()) {
    _this->_internal_set_locked_balance(from._internal_locked_balance());
  }
  if (!from._internal_unrealized_pnl().empty()) {
    _this->_internal_set_unrealized_pnl(from._internal_unrealized_pnl());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountPortfolio::CopyFrom(const SubaccountPortfolio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountPortfolio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountPortfolio::IsInitialized() const {
  return true;
}

void SubaccountPortfolio::InternalSwap(SubaccountPortfolio* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.available_balance_, lhs_arena,
                                       &other->_impl_.available_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.locked_balance_, lhs_arena,
                                       &other->_impl_.locked_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.unrealized_pnl_, lhs_arena,
                                       &other->_impl_.unrealized_pnl_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountPortfolio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[3]);
}
// ===================================================================

class OrderStatesRequest::_Internal {
 public:
};

OrderStatesRequest::OrderStatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.OrderStatesRequest)
}
OrderStatesRequest::OrderStatesRequest(const OrderStatesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderStatesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_order_hashes_){from._impl_.spot_order_hashes_}
    , decltype(_impl_.derivative_order_hashes_){from._impl_.derivative_order_hashes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.OrderStatesRequest)
}

inline void OrderStatesRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_order_hashes_){arena}
    , decltype(_impl_.derivative_order_hashes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderStatesRequest::~OrderStatesRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.OrderStatesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderStatesRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_spot_order_hashes()->~RepeatedPtrField();
  _internal_mutable_derivative_order_hashes()->~RepeatedPtrField();
}

void OrderStatesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderStatesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.OrderStatesRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_spot_order_hashes()->Clear();
  _internal_mutable_derivative_order_hashes()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderStatesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string spot_order_hashes = 1 [json_name = "spotOrderHashes"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_spot_order_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStatesRequest.spot_order_hashes"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string derivative_order_hashes = 2 [json_name = "derivativeOrderHashes"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_derivative_order_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderStatesRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.OrderStatesRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string spot_order_hashes = 1 [json_name = "spotOrderHashes"];
  for (int i = 0, n = this->_internal_spot_order_hashes_size(); i < n; ++i) {
    const auto& s = this->_internal_spot_order_hashes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStatesRequest.spot_order_hashes");
    target = stream->WriteString(1, s, target);
  }

  // repeated string derivative_order_hashes = 2 [json_name = "derivativeOrderHashes"];
  for (int i = 0, n = this->_internal_derivative_order_hashes_size(); i < n; ++i) {
    const auto& s = this->_internal_derivative_order_hashes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.OrderStatesRequest)
  return target;
}

::size_t OrderStatesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.OrderStatesRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string spot_order_hashes = 1 [json_name = "spotOrderHashes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_spot_order_hashes().size());
  for (int i = 0, n = _internal_spot_order_hashes().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_spot_order_hashes().Get(i));
  }

  // repeated string derivative_order_hashes = 2 [json_name = "derivativeOrderHashes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_derivative_order_hashes().size());
  for (int i = 0, n = _internal_derivative_order_hashes().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_derivative_order_hashes().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderStatesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderStatesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderStatesRequest::GetClassData() const { return &_class_data_; }


void OrderStatesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderStatesRequest*>(&to_msg);
  auto& from = static_cast<const OrderStatesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.OrderStatesRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_spot_order_hashes()->MergeFrom(from._internal_spot_order_hashes());
  _this->_internal_mutable_derivative_order_hashes()->MergeFrom(from._internal_derivative_order_hashes());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderStatesRequest::CopyFrom(const OrderStatesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.OrderStatesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderStatesRequest::IsInitialized() const {
  return true;
}

void OrderStatesRequest::InternalSwap(OrderStatesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_spot_order_hashes()->InternalSwap(
      other->_internal_mutable_spot_order_hashes());
  _internal_mutable_derivative_order_hashes()->InternalSwap(
      other->_internal_mutable_derivative_order_hashes());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderStatesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[4]);
}
// ===================================================================

class OrderStatesResponse::_Internal {
 public:
};

OrderStatesResponse::OrderStatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.OrderStatesResponse)
}
OrderStatesResponse::OrderStatesResponse(const OrderStatesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderStatesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_order_states_){from._impl_.spot_order_states_}
    , decltype(_impl_.derivative_order_states_){from._impl_.derivative_order_states_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.OrderStatesResponse)
}

inline void OrderStatesResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_order_states_){arena}
    , decltype(_impl_.derivative_order_states_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OrderStatesResponse::~OrderStatesResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.OrderStatesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderStatesResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_spot_order_states()->~RepeatedPtrField();
  _internal_mutable_derivative_order_states()->~RepeatedPtrField();
}

void OrderStatesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderStatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.OrderStatesResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_spot_order_states()->Clear();
  _internal_mutable_derivative_order_states()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderStatesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1 [json_name = "spotOrderStates"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spot_order_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2 [json_name = "derivativeOrderStates"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derivative_order_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderStatesResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.OrderStatesResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1 [json_name = "spotOrderStates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_spot_order_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_spot_order_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2 [json_name = "derivativeOrderStates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_derivative_order_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_derivative_order_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.OrderStatesResponse)
  return target;
}

::size_t OrderStatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.OrderStatesResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1 [json_name = "spotOrderStates"];
  total_size += 1UL * this->_internal_spot_order_states_size();
  for (const auto& msg : this->_internal_spot_order_states()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2 [json_name = "derivativeOrderStates"];
  total_size += 1UL * this->_internal_derivative_order_states_size();
  for (const auto& msg : this->_internal_derivative_order_states()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderStatesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderStatesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderStatesResponse::GetClassData() const { return &_class_data_; }


void OrderStatesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderStatesResponse*>(&to_msg);
  auto& from = static_cast<const OrderStatesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.OrderStatesResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_spot_order_states()->MergeFrom(from._internal_spot_order_states());
  _this->_internal_mutable_derivative_order_states()->MergeFrom(from._internal_derivative_order_states());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderStatesResponse::CopyFrom(const OrderStatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.OrderStatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderStatesResponse::IsInitialized() const {
  return true;
}

void OrderStatesResponse::InternalSwap(OrderStatesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_spot_order_states()->InternalSwap(other->_internal_mutable_spot_order_states());
  _internal_mutable_derivative_order_states()->InternalSwap(other->_internal_mutable_derivative_order_states());
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderStatesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[5]);
}
// ===================================================================

class OrderStateRecord::_Internal {
 public:
};

OrderStateRecord::OrderStateRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.OrderStateRecord)
}
OrderStateRecord::OrderStateRecord(const OrderStateRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OrderStateRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_type_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.quantity_filled_) {}

    , decltype(_impl_.quantity_remaining_) {}

    , decltype(_impl_.created_at_) {}

    , decltype(_impl_.updated_at_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_hash().empty()) {
    _this->_impl_.order_hash_.Set(from._internal_order_hash(), _this->GetArenaForAllocation());
  }
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.order_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_type().empty()) {
    _this->_impl_.order_type_.Set(from._internal_order_type(), _this->GetArenaForAllocation());
  }
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_side().empty()) {
    _this->_impl_.order_side_.Set(from._internal_order_side(), _this->GetArenaForAllocation());
  }
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_state().empty()) {
    _this->_impl_.state_.Set(from._internal_state(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_filled_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_filled_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity_filled().empty()) {
    _this->_impl_.quantity_filled_.Set(from._internal_quantity_filled(), _this->GetArenaForAllocation());
  }
  _impl_.quantity_remaining_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_remaining_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity_remaining().empty()) {
    _this->_impl_.quantity_remaining_.Set(from._internal_quantity_remaining(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.created_at_, &from._impl_.created_at_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.updated_at_) -
    reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.updated_at_));
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.OrderStateRecord)
}

inline void OrderStateRecord::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.order_hash_) {}

    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_type_) {}

    , decltype(_impl_.order_side_) {}

    , decltype(_impl_.state_) {}

    , decltype(_impl_.quantity_filled_) {}

    , decltype(_impl_.quantity_remaining_) {}

    , decltype(_impl_.created_at_) { ::int64_t{0} }

    , decltype(_impl_.updated_at_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.order_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_hash_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_side_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_side_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_filled_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_filled_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quantity_remaining_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.quantity_remaining_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OrderStateRecord::~OrderStateRecord() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.OrderStateRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OrderStateRecord::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.order_hash_.Destroy();
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.order_type_.Destroy();
  _impl_.order_side_.Destroy();
  _impl_.state_.Destroy();
  _impl_.quantity_filled_.Destroy();
  _impl_.quantity_remaining_.Destroy();
}

void OrderStateRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OrderStateRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.OrderStateRecord)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.order_hash_.ClearToEmpty();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.order_type_.ClearToEmpty();
  _impl_.order_side_.ClearToEmpty();
  _impl_.state_.ClearToEmpty();
  _impl_.quantity_filled_.ClearToEmpty();
  _impl_.quantity_remaining_.ClearToEmpty();
  ::memset(&_impl_.created_at_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.updated_at_) -
      reinterpret_cast<char*>(&_impl_.created_at_)) + sizeof(_impl_.updated_at_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OrderStateRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string order_hash = 1 [json_name = "orderHash"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_order_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.order_hash"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string subaccount_id = 2 [json_name = "subaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 3 [json_name = "marketId"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_type = 4 [json_name = "orderType"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_order_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.order_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_side = 5 [json_name = "orderSide"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_order_side();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.order_side"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string state = 6 [json_name = "state"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.state"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity_filled = 7 [json_name = "quantityFilled"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_quantity_filled();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.quantity_filled"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string quantity_remaining = 8 [json_name = "quantityRemaining"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_quantity_remaining();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.OrderStateRecord.quantity_remaining"));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 created_at = 9 [json_name = "createdAt"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          _impl_.created_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 updated_at = 10 [json_name = "updatedAt"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* OrderStateRecord::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.OrderStateRecord)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    const std::string& _s = this->_internal_order_hash();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.order_hash");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.subaccount_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.market_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string order_type = 4 [json_name = "orderType"];
  if (!this->_internal_order_type().empty()) {
    const std::string& _s = this->_internal_order_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.order_type");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string order_side = 5 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    const std::string& _s = this->_internal_order_side();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.order_side");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // string state = 6 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    const std::string& _s = this->_internal_state();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.state");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // string quantity_filled = 7 [json_name = "quantityFilled"];
  if (!this->_internal_quantity_filled().empty()) {
    const std::string& _s = this->_internal_quantity_filled();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.quantity_filled");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // string quantity_remaining = 8 [json_name = "quantityRemaining"];
  if (!this->_internal_quantity_remaining().empty()) {
    const std::string& _s = this->_internal_quantity_remaining();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.OrderStateRecord.quantity_remaining");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // sint64 created_at = 9 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        9, this->_internal_created_at(), target);
  }

  // sint64 updated_at = 10 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        10, this->_internal_updated_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.OrderStateRecord)
  return target;
}

::size_t OrderStateRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.OrderStateRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string order_hash = 1 [json_name = "orderHash"];
  if (!this->_internal_order_hash().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_hash());
  }

  // string subaccount_id = 2 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 3 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string order_type = 4 [json_name = "orderType"];
  if (!this->_internal_order_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_type());
  }

  // string order_side = 5 [json_name = "orderSide"];
  if (!this->_internal_order_side().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_side());
  }

  // string state = 6 [json_name = "state"];
  if (!this->_internal_state().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_state());
  }

  // string quantity_filled = 7 [json_name = "quantityFilled"];
  if (!this->_internal_quantity_filled().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity_filled());
  }

  // string quantity_remaining = 8 [json_name = "quantityRemaining"];
  if (!this->_internal_quantity_remaining().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_quantity_remaining());
  }

  // sint64 created_at = 9 [json_name = "createdAt"];
  if (this->_internal_created_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_created_at());
  }

  // sint64 updated_at = 10 [json_name = "updatedAt"];
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_updated_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OrderStateRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OrderStateRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OrderStateRecord::GetClassData() const { return &_class_data_; }


void OrderStateRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OrderStateRecord*>(&to_msg);
  auto& from = static_cast<const OrderStateRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.OrderStateRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_order_hash().empty()) {
    _this->_internal_set_order_hash(from._internal_order_hash());
  }
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_order_type().empty()) {
    _this->_internal_set_order_type(from._internal_order_type());
  }
  if (!from._internal_order_side().empty()) {
    _this->_internal_set_order_side(from._internal_order_side());
  }
  if (!from._internal_state().empty()) {
    _this->_internal_set_state(from._internal_state());
  }
  if (!from._internal_quantity_filled().empty()) {
    _this->_internal_set_quantity_filled(from._internal_quantity_filled());
  }
  if (!from._internal_quantity_remaining().empty()) {
    _this->_internal_set_quantity_remaining(from._internal_quantity_remaining());
  }
  if (from._internal_created_at() != 0) {
    _this->_internal_set_created_at(from._internal_created_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OrderStateRecord::CopyFrom(const OrderStateRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.OrderStateRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderStateRecord::IsInitialized() const {
  return true;
}

void OrderStateRecord::InternalSwap(OrderStateRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_hash_, lhs_arena,
                                       &other->_impl_.order_hash_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_type_, lhs_arena,
                                       &other->_impl_.order_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_side_, lhs_arena,
                                       &other->_impl_.order_side_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.state_, lhs_arena,
                                       &other->_impl_.state_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_filled_, lhs_arena,
                                       &other->_impl_.quantity_filled_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quantity_remaining_, lhs_arena,
                                       &other->_impl_.quantity_remaining_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OrderStateRecord, _impl_.updated_at_)
      + sizeof(OrderStateRecord::_impl_.updated_at_)
      - PROTOBUF_FIELD_OFFSET(OrderStateRecord, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OrderStateRecord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[6]);
}
// ===================================================================

class SubaccountsListRequest::_Internal {
 public:
};

SubaccountsListRequest::SubaccountsListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountsListRequest)
}
SubaccountsListRequest::SubaccountsListRequest(const SubaccountsListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountsListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_address().empty()) {
    _this->_impl_.account_address_.Set(from._internal_account_address(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountsListRequest)
}

inline void SubaccountsListRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountsListRequest::~SubaccountsListRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountsListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountsListRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_address_.Destroy();
}

void SubaccountsListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountsListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountsListRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_address_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountsListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_address = 1 [json_name = "accountAddress"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountsListRequest.account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountsListRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountsListRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    const std::string& _s = this->_internal_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountsListRequest.account_address");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountsListRequest)
  return target;
}

::size_t SubaccountsListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountsListRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountsListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountsListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountsListRequest::GetClassData() const { return &_class_data_; }


void SubaccountsListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountsListRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountsListRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountsListRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_address().empty()) {
    _this->_internal_set_account_address(from._internal_account_address());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountsListRequest::CopyFrom(const SubaccountsListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountsListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountsListRequest::IsInitialized() const {
  return true;
}

void SubaccountsListRequest::InternalSwap(SubaccountsListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_address_, lhs_arena,
                                       &other->_impl_.account_address_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountsListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[7]);
}
// ===================================================================

class SubaccountsListResponse::_Internal {
 public:
};

SubaccountsListResponse::SubaccountsListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountsListResponse)
}
SubaccountsListResponse::SubaccountsListResponse(const SubaccountsListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountsListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccounts_){from._impl_.subaccounts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountsListResponse)
}

inline void SubaccountsListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccounts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountsListResponse::~SubaccountsListResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountsListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountsListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_subaccounts()->~RepeatedPtrField();
}

void SubaccountsListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountsListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountsListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_subaccounts()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountsListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string subaccounts = 1 [json_name = "subaccounts"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_subaccounts();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountsListResponse.subaccounts"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountsListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountsListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string subaccounts = 1 [json_name = "subaccounts"];
  for (int i = 0, n = this->_internal_subaccounts_size(); i < n; ++i) {
    const auto& s = this->_internal_subaccounts(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountsListResponse.subaccounts");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountsListResponse)
  return target;
}

::size_t SubaccountsListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountsListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string subaccounts = 1 [json_name = "subaccounts"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_subaccounts().size());
  for (int i = 0, n = _internal_subaccounts().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_subaccounts().Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountsListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountsListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountsListResponse::GetClassData() const { return &_class_data_; }


void SubaccountsListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountsListResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountsListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountsListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_subaccounts()->MergeFrom(from._internal_subaccounts());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountsListResponse::CopyFrom(const SubaccountsListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountsListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountsListResponse::IsInitialized() const {
  return true;
}

void SubaccountsListResponse::InternalSwap(SubaccountsListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_subaccounts()->InternalSwap(
      other->_internal_mutable_subaccounts());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountsListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[8]);
}
// ===================================================================

class SubaccountBalancesListRequest::_Internal {
 public:
};

SubaccountBalancesListRequest::SubaccountBalancesListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalancesListRequest)
}
SubaccountBalancesListRequest::SubaccountBalancesListRequest(const SubaccountBalancesListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalancesListRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denoms_){from._impl_.denoms_}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalancesListRequest)
}

inline void SubaccountBalancesListRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denoms_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountBalancesListRequest::~SubaccountBalancesListRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalancesListRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalancesListRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_denoms()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
}

void SubaccountBalancesListRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalancesListRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalancesListRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_denoms()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalancesListRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string denoms = 2 [json_name = "denoms"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_denoms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalancesListRequest.denoms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalancesListRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalancesListRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated string denoms = 2 [json_name = "denoms"];
  for (int i = 0, n = this->_internal_denoms_size(); i < n; ++i) {
    const auto& s = this->_internal_denoms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalancesListRequest.denoms");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalancesListRequest)
  return target;
}

::size_t SubaccountBalancesListRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalancesListRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string denoms = 2 [json_name = "denoms"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_denoms().size());
  for (int i = 0, n = _internal_denoms().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_denoms().Get(i));
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalancesListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalancesListRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalancesListRequest::GetClassData() const { return &_class_data_; }


void SubaccountBalancesListRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalancesListRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountBalancesListRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalancesListRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_denoms()->MergeFrom(from._internal_denoms());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalancesListRequest::CopyFrom(const SubaccountBalancesListRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalancesListRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalancesListRequest::IsInitialized() const {
  return true;
}

void SubaccountBalancesListRequest::InternalSwap(SubaccountBalancesListRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_denoms()->InternalSwap(
      other->_internal_mutable_denoms());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalancesListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[9]);
}
// ===================================================================

class SubaccountBalancesListResponse::_Internal {
 public:
};

SubaccountBalancesListResponse::SubaccountBalancesListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalancesListResponse)
}
SubaccountBalancesListResponse::SubaccountBalancesListResponse(const SubaccountBalancesListResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalancesListResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.balances_){from._impl_.balances_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalancesListResponse)
}

inline void SubaccountBalancesListResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.balances_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountBalancesListResponse::~SubaccountBalancesListResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalancesListResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalancesListResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_balances()->~RepeatedPtrField();
}

void SubaccountBalancesListResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalancesListResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalancesListResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_balances()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalancesListResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_accounts_rpc.SubaccountBalance balances = 1 [json_name = "balances"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_balances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalancesListResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalancesListResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.SubaccountBalance balances = 1 [json_name = "balances"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_balances_size()); i < n; i++) {
    const auto& repfield = this->_internal_balances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalancesListResponse)
  return target;
}

::size_t SubaccountBalancesListResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalancesListResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.SubaccountBalance balances = 1 [json_name = "balances"];
  total_size += 1UL * this->_internal_balances_size();
  for (const auto& msg : this->_internal_balances()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalancesListResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalancesListResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalancesListResponse::GetClassData() const { return &_class_data_; }


void SubaccountBalancesListResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalancesListResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountBalancesListResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalancesListResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_balances()->MergeFrom(from._internal_balances());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalancesListResponse::CopyFrom(const SubaccountBalancesListResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalancesListResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalancesListResponse::IsInitialized() const {
  return true;
}

void SubaccountBalancesListResponse::InternalSwap(SubaccountBalancesListResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_balances()->InternalSwap(other->_internal_mutable_balances());
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalancesListResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[10]);
}
// ===================================================================

class SubaccountBalance::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountBalance>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountBalance, _impl_._has_bits_);
  static const ::injective_accounts_rpc::SubaccountDeposit& deposit(const SubaccountBalance* msg);
  static void set_has_deposit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::SubaccountDeposit&
SubaccountBalance::_Internal::deposit(const SubaccountBalance* msg) {
  return *msg->_impl_.deposit_;
}
SubaccountBalance::SubaccountBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalance)
}
SubaccountBalance::SubaccountBalance(const SubaccountBalance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.account_address_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.deposit_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_address().empty()) {
    _this->_impl_.account_address_.Set(from._internal_account_address(), _this->GetArenaForAllocation());
  }
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.deposit_ = new ::injective_accounts_rpc::SubaccountDeposit(*from._impl_.deposit_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalance)
}

inline void SubaccountBalance::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.account_address_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.deposit_){nullptr}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountBalance::~SubaccountBalance() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalance::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.account_address_.Destroy();
  _impl_.denom_.Destroy();
  if (this != internal_default_instance()) delete _impl_.deposit_;
}

void SubaccountBalance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalance::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalance)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.account_address_.ClearToEmpty();
  _impl_.denom_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.deposit_ != nullptr);
    _impl_.deposit_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalance.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string account_address = 2 [json_name = "accountAddress"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalance.account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string denom = 3 [json_name = "denom"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalance.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_accounts_rpc.SubaccountDeposit deposit = 4 [json_name = "deposit"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_deposit(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalance::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalance)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalance.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string account_address = 2 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    const std::string& _s = this->_internal_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalance.account_address");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string denom = 3 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalance.denom");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.SubaccountDeposit deposit = 4 [json_name = "deposit"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::deposit(this),
        _Internal::deposit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalance)
  return target;
}

::size_t SubaccountBalance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalance)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string account_address = 2 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_address());
  }

  // string denom = 3 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // .injective_accounts_rpc.SubaccountDeposit deposit = 4 [json_name = "deposit"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deposit_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalance::GetClassData() const { return &_class_data_; }


void SubaccountBalance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalance*>(&to_msg);
  auto& from = static_cast<const SubaccountBalance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalance)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_account_address().empty()) {
    _this->_internal_set_account_address(from._internal_account_address());
  }
  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_deposit()->::injective_accounts_rpc::SubaccountDeposit::MergeFrom(
        from._internal_deposit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalance::CopyFrom(const SubaccountBalance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalance::IsInitialized() const {
  return true;
}

void SubaccountBalance::InternalSwap(SubaccountBalance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_address_, lhs_arena,
                                       &other->_impl_.account_address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
  swap(_impl_.deposit_, other->_impl_.deposit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[11]);
}
// ===================================================================

class SubaccountDeposit::_Internal {
 public:
};

SubaccountDeposit::SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountDeposit)
}
SubaccountDeposit::SubaccountDeposit(const SubaccountDeposit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountDeposit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.total_balance_) {}

    , decltype(_impl_.available_balance_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.total_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_total_balance().empty()) {
    _this->_impl_.total_balance_.Set(from._internal_total_balance(), _this->GetArenaForAllocation());
  }
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_available_balance().empty()) {
    _this->_impl_.available_balance_.Set(from._internal_available_balance(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountDeposit)
}

inline void SubaccountDeposit::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.total_balance_) {}

    , decltype(_impl_.available_balance_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.total_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.total_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.available_balance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.available_balance_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountDeposit::~SubaccountDeposit() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountDeposit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountDeposit::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.total_balance_.Destroy();
  _impl_.available_balance_.Destroy();
}

void SubaccountDeposit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountDeposit::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.total_balance_.ClearToEmpty();
  _impl_.available_balance_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountDeposit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string total_balance = 1 [json_name = "totalBalance"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_total_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountDeposit.total_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string available_balance = 2 [json_name = "availableBalance"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_available_balance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountDeposit.available_balance"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountDeposit::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountDeposit)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string total_balance = 1 [json_name = "totalBalance"];
  if (!this->_internal_total_balance().empty()) {
    const std::string& _s = this->_internal_total_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountDeposit.total_balance");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    const std::string& _s = this->_internal_available_balance();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountDeposit.available_balance");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountDeposit)
  return target;
}

::size_t SubaccountDeposit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountDeposit)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string total_balance = 1 [json_name = "totalBalance"];
  if (!this->_internal_total_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_total_balance());
  }

  // string available_balance = 2 [json_name = "availableBalance"];
  if (!this->_internal_available_balance().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_available_balance());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountDeposit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountDeposit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountDeposit::GetClassData() const { return &_class_data_; }


void SubaccountDeposit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountDeposit*>(&to_msg);
  auto& from = static_cast<const SubaccountDeposit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountDeposit)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_total_balance().empty()) {
    _this->_internal_set_total_balance(from._internal_total_balance());
  }
  if (!from._internal_available_balance().empty()) {
    _this->_internal_set_available_balance(from._internal_available_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountDeposit::CopyFrom(const SubaccountDeposit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountDeposit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountDeposit::IsInitialized() const {
  return true;
}

void SubaccountDeposit::InternalSwap(SubaccountDeposit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.total_balance_, lhs_arena,
                                       &other->_impl_.total_balance_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.available_balance_, lhs_arena,
                                       &other->_impl_.available_balance_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountDeposit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[12]);
}
// ===================================================================

class SubaccountBalanceRequest::_Internal {
 public:
};

SubaccountBalanceRequest::SubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalanceRequest)
}
SubaccountBalanceRequest::SubaccountBalanceRequest(const SubaccountBalanceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalanceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalanceRequest)
}

inline void SubaccountBalanceRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountBalanceRequest::~SubaccountBalanceRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalanceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalanceRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.denom_.Destroy();
}

void SubaccountBalanceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalanceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalanceRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.denom_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalanceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string denom = 2 [json_name = "denom"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceRequest.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalanceRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalanceRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceRequest.denom");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalanceRequest)
  return target;
}

::size_t SubaccountBalanceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalanceRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalanceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalanceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalanceRequest::GetClassData() const { return &_class_data_; }


void SubaccountBalanceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalanceRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountBalanceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalanceRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalanceRequest::CopyFrom(const SubaccountBalanceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalanceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalanceRequest::IsInitialized() const {
  return true;
}

void SubaccountBalanceRequest::InternalSwap(SubaccountBalanceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalanceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[13]);
}
// ===================================================================

class SubaccountBalanceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountBalanceResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountBalanceResponse, _impl_._has_bits_);
  static const ::injective_accounts_rpc::SubaccountBalance& balance(const SubaccountBalanceResponse* msg);
  static void set_has_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::SubaccountBalance&
SubaccountBalanceResponse::_Internal::balance(const SubaccountBalanceResponse* msg) {
  return *msg->_impl_.balance_;
}
SubaccountBalanceResponse::SubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalanceResponse)
}
SubaccountBalanceResponse::SubaccountBalanceResponse(const SubaccountBalanceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalanceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.balance_ = new ::injective_accounts_rpc::SubaccountBalance(*from._impl_.balance_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalanceResponse)
}

inline void SubaccountBalanceResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_){nullptr}
  };
}

SubaccountBalanceResponse::~SubaccountBalanceResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalanceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalanceResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.balance_;
}

void SubaccountBalanceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalanceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalanceResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.balance_ != nullptr);
    _impl_.balance_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalanceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_balance(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalanceResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalanceResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::balance(this),
        _Internal::balance(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalanceResponse)
  return target;
}

::size_t SubaccountBalanceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalanceResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.balance_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalanceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalanceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalanceResponse::GetClassData() const { return &_class_data_; }


void SubaccountBalanceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalanceResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountBalanceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalanceResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_balance()->::injective_accounts_rpc::SubaccountBalance::MergeFrom(
        from._internal_balance());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalanceResponse::CopyFrom(const SubaccountBalanceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalanceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalanceResponse::IsInitialized() const {
  return true;
}

void SubaccountBalanceResponse::InternalSwap(SubaccountBalanceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.balance_, other->_impl_.balance_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalanceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[14]);
}
// ===================================================================

class StreamSubaccountBalanceRequest::_Internal {
 public:
};

StreamSubaccountBalanceRequest::StreamSubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.StreamSubaccountBalanceRequest)
}
StreamSubaccountBalanceRequest::StreamSubaccountBalanceRequest(const StreamSubaccountBalanceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamSubaccountBalanceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denoms_){from._impl_.denoms_}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.StreamSubaccountBalanceRequest)
}

inline void StreamSubaccountBalanceRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denoms_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamSubaccountBalanceRequest::~StreamSubaccountBalanceRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamSubaccountBalanceRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_denoms()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
}

void StreamSubaccountBalanceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamSubaccountBalanceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_denoms()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamSubaccountBalanceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string denoms = 2 [json_name = "denoms"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_denoms();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamSubaccountBalanceRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated string denoms = 2 [json_name = "denoms"];
  for (int i = 0, n = this->_internal_denoms_size(); i < n; ++i) {
    const auto& s = this->_internal_denoms(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  return target;
}

::size_t StreamSubaccountBalanceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string denoms = 2 [json_name = "denoms"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_denoms().size());
  for (int i = 0, n = _internal_denoms().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_denoms().Get(i));
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamSubaccountBalanceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamSubaccountBalanceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamSubaccountBalanceRequest::GetClassData() const { return &_class_data_; }


void StreamSubaccountBalanceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamSubaccountBalanceRequest*>(&to_msg);
  auto& from = static_cast<const StreamSubaccountBalanceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_denoms()->MergeFrom(from._internal_denoms());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamSubaccountBalanceRequest::CopyFrom(const StreamSubaccountBalanceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.StreamSubaccountBalanceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamSubaccountBalanceRequest::IsInitialized() const {
  return true;
}

void StreamSubaccountBalanceRequest::InternalSwap(StreamSubaccountBalanceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_denoms()->InternalSwap(
      other->_internal_mutable_denoms());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamSubaccountBalanceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[15]);
}
// ===================================================================

class StreamSubaccountBalanceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<StreamSubaccountBalanceResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StreamSubaccountBalanceResponse, _impl_._has_bits_);
  static const ::injective_accounts_rpc::SubaccountBalance& balance(const StreamSubaccountBalanceResponse* msg);
  static void set_has_balance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::SubaccountBalance&
StreamSubaccountBalanceResponse::_Internal::balance(const StreamSubaccountBalanceResponse* msg) {
  return *msg->_impl_.balance_;
}
StreamSubaccountBalanceResponse::StreamSubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.StreamSubaccountBalanceResponse)
}
StreamSubaccountBalanceResponse::StreamSubaccountBalanceResponse(const StreamSubaccountBalanceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamSubaccountBalanceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_){nullptr}
    , decltype(_impl_.timestamp_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.balance_ = new ::injective_accounts_rpc::SubaccountBalance(*from._impl_.balance_);
  }
  _this->_impl_.timestamp_ = from._impl_.timestamp_;
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.StreamSubaccountBalanceResponse)
}

inline void StreamSubaccountBalanceResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.balance_){nullptr}
    , decltype(_impl_.timestamp_) { ::int64_t{0} }

  };
}

StreamSubaccountBalanceResponse::~StreamSubaccountBalanceResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamSubaccountBalanceResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.balance_;
}

void StreamSubaccountBalanceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamSubaccountBalanceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.balance_ != nullptr);
    _impl_.balance_->Clear();
  }
  _impl_.timestamp_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamSubaccountBalanceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_balance(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 timestamp = 2 [json_name = "timestamp"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StreamSubaccountBalanceResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::balance(this),
        _Internal::balance(this).GetCachedSize(), target, stream);
  }

  // sint64 timestamp = 2 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  return target;
}

::size_t StreamSubaccountBalanceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.balance_);
  }

  // sint64 timestamp = 2 [json_name = "timestamp"];
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_timestamp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamSubaccountBalanceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamSubaccountBalanceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamSubaccountBalanceResponse::GetClassData() const { return &_class_data_; }


void StreamSubaccountBalanceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamSubaccountBalanceResponse*>(&to_msg);
  auto& from = static_cast<const StreamSubaccountBalanceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_balance()->::injective_accounts_rpc::SubaccountBalance::MergeFrom(
        from._internal_balance());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamSubaccountBalanceResponse::CopyFrom(const StreamSubaccountBalanceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.StreamSubaccountBalanceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamSubaccountBalanceResponse::IsInitialized() const {
  return true;
}

void StreamSubaccountBalanceResponse::InternalSwap(StreamSubaccountBalanceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamSubaccountBalanceResponse, _impl_.timestamp_)
      + sizeof(StreamSubaccountBalanceResponse::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(StreamSubaccountBalanceResponse, _impl_.balance_)>(
          reinterpret_cast<char*>(&_impl_.balance_),
          reinterpret_cast<char*>(&other->_impl_.balance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamSubaccountBalanceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[16]);
}
// ===================================================================

class SubaccountHistoryRequest::_Internal {
 public:
};

SubaccountHistoryRequest::SubaccountHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountHistoryRequest)
}
SubaccountHistoryRequest::SubaccountHistoryRequest(const SubaccountHistoryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountHistoryRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transfer_types_){from._impl_.transfer_types_}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.skip_) {}

    , decltype(_impl_.end_time_) {}

    , decltype(_impl_.limit_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.skip_, &from._impl_.skip_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.limit_) -
    reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountHistoryRequest)
}

inline void SubaccountHistoryRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.transfer_types_){arena}
    , decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.denom_) {}

    , decltype(_impl_.skip_) { ::uint64_t{0u} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

    , decltype(_impl_.limit_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountHistoryRequest::~SubaccountHistoryRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountHistoryRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountHistoryRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_transfer_types()->~RepeatedPtrField();
  _impl_.subaccount_id_.Destroy();
  _impl_.denom_.Destroy();
}

void SubaccountHistoryRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountHistoryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_transfer_types()->Clear();
  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.denom_.ClearToEmpty();
  ::memset(&_impl_.skip_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.limit_) -
      reinterpret_cast<char*>(&_impl_.skip_)) + sizeof(_impl_.limit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountHistoryRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string denom = 2 [json_name = "denom"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountHistoryRequest.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string transfer_types = 3 [json_name = "transferTypes"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transfer_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountHistoryRequest.transfer_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint64 skip = 4 [json_name = "skip"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.skip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 limit = 5 [json_name = "limit"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 end_time = 6 [json_name = "endTime"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountHistoryRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountHistoryRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountHistoryRequest.denom");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string transfer_types = 3 [json_name = "transferTypes"];
  for (int i = 0, n = this->_internal_transfer_types_size(); i < n; ++i) {
    const auto& s = this->_internal_transfer_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountHistoryRequest.transfer_types");
    target = stream->WriteString(3, s, target);
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_skip(), target);
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        5, this->_internal_limit(), target);
  }

  // sint64 end_time = 6 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        6, this->_internal_end_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountHistoryRequest)
  return target;
}

::size_t SubaccountHistoryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountHistoryRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string transfer_types = 3 [json_name = "transferTypes"];
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_transfer_types().size());
  for (int i = 0, n = _internal_transfer_types().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_transfer_types().Get(i));
  }

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string denom = 2 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // uint64 skip = 4 [json_name = "skip"];
  if (this->_internal_skip() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_skip());
  }

  // sint64 end_time = 6 [json_name = "endTime"];
  if (this->_internal_end_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_end_time());
  }

  // sint32 limit = 5 [json_name = "limit"];
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_limit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountHistoryRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountHistoryRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountHistoryRequest::GetClassData() const { return &_class_data_; }


void SubaccountHistoryRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountHistoryRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountHistoryRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountHistoryRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transfer_types()->MergeFrom(from._internal_transfer_types());
  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if (from._internal_skip() != 0) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (from._internal_end_time() != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountHistoryRequest::CopyFrom(const SubaccountHistoryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountHistoryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountHistoryRequest::IsInitialized() const {
  return true;
}

void SubaccountHistoryRequest::InternalSwap(SubaccountHistoryRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_transfer_types()->InternalSwap(
      other->_internal_mutable_transfer_types());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountHistoryRequest, _impl_.limit_)
      + sizeof(SubaccountHistoryRequest::_impl_.limit_)
      - PROTOBUF_FIELD_OFFSET(SubaccountHistoryRequest, _impl_.skip_)>(
          reinterpret_cast<char*>(&_impl_.skip_),
          reinterpret_cast<char*>(&other->_impl_.skip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountHistoryRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[17]);
}
// ===================================================================

class SubaccountHistoryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountHistoryResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountHistoryResponse, _impl_._has_bits_);
  static const ::injective_accounts_rpc::Paging& paging(const SubaccountHistoryResponse* msg);
  static void set_has_paging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::Paging&
SubaccountHistoryResponse::_Internal::paging(const SubaccountHistoryResponse* msg) {
  return *msg->_impl_.paging_;
}
SubaccountHistoryResponse::SubaccountHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountHistoryResponse)
}
SubaccountHistoryResponse::SubaccountHistoryResponse(const SubaccountHistoryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountHistoryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transfers_){from._impl_.transfers_}
    , decltype(_impl_.paging_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.paging_ = new ::injective_accounts_rpc::Paging(*from._impl_.paging_);
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountHistoryResponse)
}

inline void SubaccountHistoryResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transfers_){arena}
    , decltype(_impl_.paging_){nullptr}
  };
}

SubaccountHistoryResponse::~SubaccountHistoryResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountHistoryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountHistoryResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_transfers()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.paging_;
}

void SubaccountHistoryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountHistoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_transfers()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.paging_ != nullptr);
    _impl_.paging_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountHistoryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1 [json_name = "transfers"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transfers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_accounts_rpc.Paging paging = 2 [json_name = "paging"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paging(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountHistoryResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountHistoryResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1 [json_name = "transfers"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transfers_size()); i < n; i++) {
    const auto& repfield = this->_internal_transfers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.Paging paging = 2 [json_name = "paging"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paging(this),
        _Internal::paging(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountHistoryResponse)
  return target;
}

::size_t SubaccountHistoryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountHistoryResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1 [json_name = "transfers"];
  total_size += 1UL * this->_internal_transfers_size();
  for (const auto& msg : this->_internal_transfers()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .injective_accounts_rpc.Paging paging = 2 [json_name = "paging"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.paging_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountHistoryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountHistoryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountHistoryResponse::GetClassData() const { return &_class_data_; }


void SubaccountHistoryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountHistoryResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountHistoryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountHistoryResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_transfers()->MergeFrom(from._internal_transfers());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_paging()->::injective_accounts_rpc::Paging::MergeFrom(
        from._internal_paging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountHistoryResponse::CopyFrom(const SubaccountHistoryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountHistoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountHistoryResponse::IsInitialized() const {
  return true;
}

void SubaccountHistoryResponse::InternalSwap(SubaccountHistoryResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_transfers()->InternalSwap(other->_internal_mutable_transfers());
  swap(_impl_.paging_, other->_impl_.paging_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountHistoryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[18]);
}
// ===================================================================

class SubaccountBalanceTransfer::_Internal {
 public:
  using HasBits = decltype(std::declval<SubaccountBalanceTransfer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SubaccountBalanceTransfer, _impl_._has_bits_);
  static const ::injective_accounts_rpc::CosmosCoin& amount(const SubaccountBalanceTransfer* msg);
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::injective_accounts_rpc::CosmosCoin&
SubaccountBalanceTransfer::_Internal::amount(const SubaccountBalanceTransfer* msg) {
  return *msg->_impl_.amount_;
}
SubaccountBalanceTransfer::SubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountBalanceTransfer)
}
SubaccountBalanceTransfer::SubaccountBalanceTransfer(const SubaccountBalanceTransfer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountBalanceTransfer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transfer_type_) {}

    , decltype(_impl_.src_subaccount_id_) {}

    , decltype(_impl_.src_account_address_) {}

    , decltype(_impl_.dst_subaccount_id_) {}

    , decltype(_impl_.dst_account_address_) {}

    , decltype(_impl_.amount_){nullptr}
    , decltype(_impl_.executed_at_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transfer_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transfer_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transfer_type().empty()) {
    _this->_impl_.transfer_type_.Set(from._internal_transfer_type(), _this->GetArenaForAllocation());
  }
  _impl_.src_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_subaccount_id().empty()) {
    _this->_impl_.src_subaccount_id_.Set(from._internal_src_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.src_account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src_account_address().empty()) {
    _this->_impl_.src_account_address_.Set(from._internal_src_account_address(), _this->GetArenaForAllocation());
  }
  _impl_.dst_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst_subaccount_id().empty()) {
    _this->_impl_.dst_subaccount_id_.Set(from._internal_dst_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.dst_account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst_account_address().empty()) {
    _this->_impl_.dst_account_address_.Set(from._internal_dst_account_address(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.amount_ = new ::injective_accounts_rpc::CosmosCoin(*from._impl_.amount_);
  }
  _this->_impl_.executed_at_ = from._impl_.executed_at_;
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountBalanceTransfer)
}

inline void SubaccountBalanceTransfer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.transfer_type_) {}

    , decltype(_impl_.src_subaccount_id_) {}

    , decltype(_impl_.src_account_address_) {}

    , decltype(_impl_.dst_subaccount_id_) {}

    , decltype(_impl_.dst_account_address_) {}

    , decltype(_impl_.amount_){nullptr}
    , decltype(_impl_.executed_at_) { ::int64_t{0} }

  };
  _impl_.transfer_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.transfer_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.src_account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dst_account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.dst_account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountBalanceTransfer::~SubaccountBalanceTransfer() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountBalanceTransfer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountBalanceTransfer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transfer_type_.Destroy();
  _impl_.src_subaccount_id_.Destroy();
  _impl_.src_account_address_.Destroy();
  _impl_.dst_subaccount_id_.Destroy();
  _impl_.dst_account_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.amount_;
}

void SubaccountBalanceTransfer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountBalanceTransfer::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountBalanceTransfer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transfer_type_.ClearToEmpty();
  _impl_.src_subaccount_id_.ClearToEmpty();
  _impl_.src_account_address_.ClearToEmpty();
  _impl_.dst_subaccount_id_.ClearToEmpty();
  _impl_.dst_account_address_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.amount_ != nullptr);
    _impl_.amount_->Clear();
  }
  _impl_.executed_at_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountBalanceTransfer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string transfer_type = 1 [json_name = "transferType"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_transfer_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string src_subaccount_id = 2 [json_name = "srcSubaccountId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_src_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string src_account_address = 3 [json_name = "srcAccountAddress"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_src_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_subaccount_id = 4 [json_name = "dstSubaccountId"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_dst_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string dst_account_address = 5 [json_name = "dstAccountAddress"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_dst_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // .injective_accounts_rpc.CosmosCoin amount = 6 [json_name = "amount"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_amount(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 executed_at = 7 [json_name = "executedAt"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.executed_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountBalanceTransfer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountBalanceTransfer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string transfer_type = 1 [json_name = "transferType"];
  if (!this->_internal_transfer_type().empty()) {
    const std::string& _s = this->_internal_transfer_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string src_subaccount_id = 2 [json_name = "srcSubaccountId"];
  if (!this->_internal_src_subaccount_id().empty()) {
    const std::string& _s = this->_internal_src_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string src_account_address = 3 [json_name = "srcAccountAddress"];
  if (!this->_internal_src_account_address().empty()) {
    const std::string& _s = this->_internal_src_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string dst_subaccount_id = 4 [json_name = "dstSubaccountId"];
  if (!this->_internal_dst_subaccount_id().empty()) {
    const std::string& _s = this->_internal_dst_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string dst_account_address = 5 [json_name = "dstAccountAddress"];
  if (!this->_internal_dst_account_address().empty()) {
    const std::string& _s = this->_internal_dst_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .injective_accounts_rpc.CosmosCoin amount = 6 [json_name = "amount"];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::amount(this),
        _Internal::amount(this).GetCachedSize(), target, stream);
  }

  // sint64 executed_at = 7 [json_name = "executedAt"];
  if (this->_internal_executed_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        7, this->_internal_executed_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountBalanceTransfer)
  return target;
}

::size_t SubaccountBalanceTransfer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountBalanceTransfer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string transfer_type = 1 [json_name = "transferType"];
  if (!this->_internal_transfer_type().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_transfer_type());
  }

  // string src_subaccount_id = 2 [json_name = "srcSubaccountId"];
  if (!this->_internal_src_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_src_subaccount_id());
  }

  // string src_account_address = 3 [json_name = "srcAccountAddress"];
  if (!this->_internal_src_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_src_account_address());
  }

  // string dst_subaccount_id = 4 [json_name = "dstSubaccountId"];
  if (!this->_internal_dst_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dst_subaccount_id());
  }

  // string dst_account_address = 5 [json_name = "dstAccountAddress"];
  if (!this->_internal_dst_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_dst_account_address());
  }

  // .injective_accounts_rpc.CosmosCoin amount = 6 [json_name = "amount"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.amount_);
  }

  // sint64 executed_at = 7 [json_name = "executedAt"];
  if (this->_internal_executed_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_executed_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountBalanceTransfer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountBalanceTransfer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountBalanceTransfer::GetClassData() const { return &_class_data_; }


void SubaccountBalanceTransfer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountBalanceTransfer*>(&to_msg);
  auto& from = static_cast<const SubaccountBalanceTransfer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountBalanceTransfer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transfer_type().empty()) {
    _this->_internal_set_transfer_type(from._internal_transfer_type());
  }
  if (!from._internal_src_subaccount_id().empty()) {
    _this->_internal_set_src_subaccount_id(from._internal_src_subaccount_id());
  }
  if (!from._internal_src_account_address().empty()) {
    _this->_internal_set_src_account_address(from._internal_src_account_address());
  }
  if (!from._internal_dst_subaccount_id().empty()) {
    _this->_internal_set_dst_subaccount_id(from._internal_dst_subaccount_id());
  }
  if (!from._internal_dst_account_address().empty()) {
    _this->_internal_set_dst_account_address(from._internal_dst_account_address());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_amount()->::injective_accounts_rpc::CosmosCoin::MergeFrom(
        from._internal_amount());
  }
  if (from._internal_executed_at() != 0) {
    _this->_internal_set_executed_at(from._internal_executed_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountBalanceTransfer::CopyFrom(const SubaccountBalanceTransfer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountBalanceTransfer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountBalanceTransfer::IsInitialized() const {
  return true;
}

void SubaccountBalanceTransfer::InternalSwap(SubaccountBalanceTransfer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transfer_type_, lhs_arena,
                                       &other->_impl_.transfer_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_subaccount_id_, lhs_arena,
                                       &other->_impl_.src_subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.src_account_address_, lhs_arena,
                                       &other->_impl_.src_account_address_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_subaccount_id_, lhs_arena,
                                       &other->_impl_.dst_subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dst_account_address_, lhs_arena,
                                       &other->_impl_.dst_account_address_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountBalanceTransfer, _impl_.executed_at_)
      + sizeof(SubaccountBalanceTransfer::_impl_.executed_at_)
      - PROTOBUF_FIELD_OFFSET(SubaccountBalanceTransfer, _impl_.amount_)>(
          reinterpret_cast<char*>(&_impl_.amount_),
          reinterpret_cast<char*>(&other->_impl_.amount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountBalanceTransfer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[19]);
}
// ===================================================================

class CosmosCoin::_Internal {
 public:
};

CosmosCoin::CosmosCoin(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.CosmosCoin)
}
CosmosCoin::CosmosCoin(const CosmosCoin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CosmosCoin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.amount_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.CosmosCoin)
}

inline void CosmosCoin::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.amount_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CosmosCoin::~CosmosCoin() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.CosmosCoin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CosmosCoin::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denom_.Destroy();
  _impl_.amount_.Destroy();
}

void CosmosCoin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CosmosCoin::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.CosmosCoin)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denom_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosmosCoin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denom = 1 [json_name = "denom"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.CosmosCoin.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string amount = 2 [json_name = "amount"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.CosmosCoin.amount"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CosmosCoin::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.CosmosCoin)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.CosmosCoin.denom");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string amount = 2 [json_name = "amount"];
  if (!this->_internal_amount().empty()) {
    const std::string& _s = this->_internal_amount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.CosmosCoin.amount");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.CosmosCoin)
  return target;
}

::size_t CosmosCoin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.CosmosCoin)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // string amount = 2 [json_name = "amount"];
  if (!this->_internal_amount().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CosmosCoin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CosmosCoin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CosmosCoin::GetClassData() const { return &_class_data_; }


void CosmosCoin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CosmosCoin*>(&to_msg);
  auto& from = static_cast<const CosmosCoin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.CosmosCoin)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CosmosCoin::CopyFrom(const CosmosCoin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.CosmosCoin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosmosCoin::IsInitialized() const {
  return true;
}

void CosmosCoin::InternalSwap(CosmosCoin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.amount_, lhs_arena,
                                       &other->_impl_.amount_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata CosmosCoin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[20]);
}
// ===================================================================

class Paging::_Internal {
 public:
};

Paging::Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.Paging)
}
Paging::Paging(const Paging& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.Paging)
}

inline void Paging::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.total_) { ::int64_t{0} }

    , decltype(_impl_.from_) { 0 }

    , decltype(_impl_.to_) { 0 }

    , decltype(_impl_.count_by_subaccount_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Paging::~Paging() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.Paging)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Paging::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void Paging::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Paging::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.Paging)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.total_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.count_by_subaccount_) -
      reinterpret_cast<char*>(&_impl_.total_)) + sizeof(_impl_.count_by_subaccount_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Paging::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // sint64 total = 1 [json_name = "total"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 from = 2 [json_name = "from"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 to = 3 [json_name = "to"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.count_by_subaccount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Paging::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.Paging)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // sint64 total = 1 [json_name = "total"];
  if (this->_internal_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_total(), target);
  }

  // sint32 from = 2 [json_name = "from"];
  if (this->_internal_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        2, this->_internal_from(), target);
  }

  // sint32 to = 3 [json_name = "to"];
  if (this->_internal_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        3, this->_internal_to(), target);
  }

  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  if (this->_internal_count_by_subaccount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        4, this->_internal_count_by_subaccount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.Paging)
  return target;
}

::size_t Paging::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.Paging)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // sint64 total = 1 [json_name = "total"];
  if (this->_internal_total() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_total());
  }

  // sint32 from = 2 [json_name = "from"];
  if (this->_internal_from() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_from());
  }

  // sint32 to = 3 [json_name = "to"];
  if (this->_internal_to() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_to());
  }

  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  if (this->_internal_count_by_subaccount() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_count_by_subaccount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Paging::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Paging::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Paging::GetClassData() const { return &_class_data_; }


void Paging::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Paging*>(&to_msg);
  auto& from = static_cast<const Paging&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.Paging)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_total() != 0) {
    _this->_internal_set_total(from._internal_total());
  }
  if (from._internal_from() != 0) {
    _this->_internal_set_from(from._internal_from());
  }
  if (from._internal_to() != 0) {
    _this->_internal_set_to(from._internal_to());
  }
  if (from._internal_count_by_subaccount() != 0) {
    _this->_internal_set_count_by_subaccount(from._internal_count_by_subaccount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Paging::CopyFrom(const Paging& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.Paging)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Paging::IsInitialized() const {
  return true;
}

void Paging::InternalSwap(Paging* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Paging, _impl_.count_by_subaccount_)
      + sizeof(Paging::_impl_.count_by_subaccount_)
      - PROTOBUF_FIELD_OFFSET(Paging, _impl_.total_)>(
          reinterpret_cast<char*>(&_impl_.total_),
          reinterpret_cast<char*>(&other->_impl_.total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Paging::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[21]);
}
// ===================================================================

class SubaccountOrderSummaryRequest::_Internal {
 public:
};

SubaccountOrderSummaryRequest::SubaccountOrderSummaryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountOrderSummaryRequest)
}
SubaccountOrderSummaryRequest::SubaccountOrderSummaryRequest(const SubaccountOrderSummaryRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubaccountOrderSummaryRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_direction_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subaccount_id().empty()) {
    _this->_impl_.subaccount_id_.Set(from._internal_subaccount_id(), _this->GetArenaForAllocation());
  }
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_market_id().empty()) {
    _this->_impl_.market_id_.Set(from._internal_market_id(), _this->GetArenaForAllocation());
  }
  _impl_.order_direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_order_direction().empty()) {
    _this->_impl_.order_direction_.Set(from._internal_order_direction(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountOrderSummaryRequest)
}

inline void SubaccountOrderSummaryRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.subaccount_id_) {}

    , decltype(_impl_.market_id_) {}

    , decltype(_impl_.order_direction_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subaccount_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.subaccount_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.market_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.market_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.order_direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.order_direction_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubaccountOrderSummaryRequest::~SubaccountOrderSummaryRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrderSummaryRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subaccount_id_.Destroy();
  _impl_.market_id_.Destroy();
  _impl_.order_direction_.Destroy();
}

void SubaccountOrderSummaryRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrderSummaryRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subaccount_id_.ClearToEmpty();
  _impl_.market_id_.ClearToEmpty();
  _impl_.order_direction_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrderSummaryRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string subaccount_id = 1 [json_name = "subaccountId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_subaccount_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string market_id = 2 [json_name = "marketId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_market_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string order_direction = 3 [json_name = "orderDirection"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_order_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrderSummaryRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    const std::string& _s = this->_internal_subaccount_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    const std::string& _s = this->_internal_market_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string order_direction = 3 [json_name = "orderDirection"];
  if (!this->_internal_order_direction().empty()) {
    const std::string& _s = this->_internal_order_direction();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  return target;
}

::size_t SubaccountOrderSummaryRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subaccount_id = 1 [json_name = "subaccountId"];
  if (!this->_internal_subaccount_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_subaccount_id());
  }

  // string market_id = 2 [json_name = "marketId"];
  if (!this->_internal_market_id().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_market_id());
  }

  // string order_direction = 3 [json_name = "orderDirection"];
  if (!this->_internal_order_direction().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_order_direction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrderSummaryRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrderSummaryRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrderSummaryRequest::GetClassData() const { return &_class_data_; }


void SubaccountOrderSummaryRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrderSummaryRequest*>(&to_msg);
  auto& from = static_cast<const SubaccountOrderSummaryRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subaccount_id().empty()) {
    _this->_internal_set_subaccount_id(from._internal_subaccount_id());
  }
  if (!from._internal_market_id().empty()) {
    _this->_internal_set_market_id(from._internal_market_id());
  }
  if (!from._internal_order_direction().empty()) {
    _this->_internal_set_order_direction(from._internal_order_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrderSummaryRequest::CopyFrom(const SubaccountOrderSummaryRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountOrderSummaryRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrderSummaryRequest::IsInitialized() const {
  return true;
}

void SubaccountOrderSummaryRequest::InternalSwap(SubaccountOrderSummaryRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subaccount_id_, lhs_arena,
                                       &other->_impl_.subaccount_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.market_id_, lhs_arena,
                                       &other->_impl_.market_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.order_direction_, lhs_arena,
                                       &other->_impl_.order_direction_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrderSummaryRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[22]);
}
// ===================================================================

class SubaccountOrderSummaryResponse::_Internal {
 public:
};

SubaccountOrderSummaryResponse::SubaccountOrderSummaryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.SubaccountOrderSummaryResponse)
}
SubaccountOrderSummaryResponse::SubaccountOrderSummaryResponse(const SubaccountOrderSummaryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.SubaccountOrderSummaryResponse)
}

inline void SubaccountOrderSummaryResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.spot_orders_total_) { ::int64_t{0} }

    , decltype(_impl_.derivative_orders_total_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SubaccountOrderSummaryResponse::~SubaccountOrderSummaryResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubaccountOrderSummaryResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SubaccountOrderSummaryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubaccountOrderSummaryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.spot_orders_total_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.derivative_orders_total_) -
      reinterpret_cast<char*>(&_impl_.spot_orders_total_)) + sizeof(_impl_.derivative_orders_total_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubaccountOrderSummaryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // sint64 spot_orders_total = 1 [json_name = "spotOrdersTotal"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.spot_orders_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 derivative_orders_total = 2 [json_name = "derivativeOrdersTotal"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.derivative_orders_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SubaccountOrderSummaryResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // sint64 spot_orders_total = 1 [json_name = "spotOrdersTotal"];
  if (this->_internal_spot_orders_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_spot_orders_total(), target);
  }

  // sint64 derivative_orders_total = 2 [json_name = "derivativeOrdersTotal"];
  if (this->_internal_derivative_orders_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        2, this->_internal_derivative_orders_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  return target;
}

::size_t SubaccountOrderSummaryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // sint64 spot_orders_total = 1 [json_name = "spotOrdersTotal"];
  if (this->_internal_spot_orders_total() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_spot_orders_total());
  }

  // sint64 derivative_orders_total = 2 [json_name = "derivativeOrdersTotal"];
  if (this->_internal_derivative_orders_total() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_derivative_orders_total());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubaccountOrderSummaryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubaccountOrderSummaryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubaccountOrderSummaryResponse::GetClassData() const { return &_class_data_; }


void SubaccountOrderSummaryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubaccountOrderSummaryResponse*>(&to_msg);
  auto& from = static_cast<const SubaccountOrderSummaryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_spot_orders_total() != 0) {
    _this->_internal_set_spot_orders_total(from._internal_spot_orders_total());
  }
  if (from._internal_derivative_orders_total() != 0) {
    _this->_internal_set_derivative_orders_total(from._internal_derivative_orders_total());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubaccountOrderSummaryResponse::CopyFrom(const SubaccountOrderSummaryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.SubaccountOrderSummaryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubaccountOrderSummaryResponse::IsInitialized() const {
  return true;
}

void SubaccountOrderSummaryResponse::InternalSwap(SubaccountOrderSummaryResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubaccountOrderSummaryResponse, _impl_.derivative_orders_total_)
      + sizeof(SubaccountOrderSummaryResponse::_impl_.derivative_orders_total_)
      - PROTOBUF_FIELD_OFFSET(SubaccountOrderSummaryResponse, _impl_.spot_orders_total_)>(
          reinterpret_cast<char*>(&_impl_.spot_orders_total_),
          reinterpret_cast<char*>(&other->_impl_.spot_orders_total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubaccountOrderSummaryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[23]);
}
// ===================================================================

class RewardsRequest::_Internal {
 public:
};

RewardsRequest::RewardsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.RewardsRequest)
}
RewardsRequest::RewardsRequest(const RewardsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RewardsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , decltype(_impl_.epoch_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_address().empty()) {
    _this->_impl_.account_address_.Set(from._internal_account_address(), _this->GetArenaForAllocation());
  }
  _this->_impl_.epoch_ = from._impl_.epoch_;
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.RewardsRequest)
}

inline void RewardsRequest::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.account_address_) {}

    , decltype(_impl_.epoch_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RewardsRequest::~RewardsRequest() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.RewardsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RewardsRequest::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.account_address_.Destroy();
}

void RewardsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RewardsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.RewardsRequest)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.account_address_.ClearToEmpty();
  _impl_.epoch_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RewardsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // sint64 epoch = 1 [json_name = "epoch"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // string account_address = 2 [json_name = "accountAddress"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.RewardsRequest.account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RewardsRequest::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.RewardsRequest)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // sint64 epoch = 1 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_epoch(), target);
  }

  // string account_address = 2 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    const std::string& _s = this->_internal_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.RewardsRequest.account_address");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.RewardsRequest)
  return target;
}

::size_t RewardsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.RewardsRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string account_address = 2 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_address());
  }

  // sint64 epoch = 1 [json_name = "epoch"];
  if (this->_internal_epoch() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_epoch());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RewardsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RewardsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RewardsRequest::GetClassData() const { return &_class_data_; }


void RewardsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RewardsRequest*>(&to_msg);
  auto& from = static_cast<const RewardsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.RewardsRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_account_address().empty()) {
    _this->_internal_set_account_address(from._internal_account_address());
  }
  if (from._internal_epoch() != 0) {
    _this->_internal_set_epoch(from._internal_epoch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RewardsRequest::CopyFrom(const RewardsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.RewardsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardsRequest::IsInitialized() const {
  return true;
}

void RewardsRequest::InternalSwap(RewardsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_address_, lhs_arena,
                                       &other->_impl_.account_address_, rhs_arena);

  swap(_impl_.epoch_, other->_impl_.epoch_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RewardsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[24]);
}
// ===================================================================

class RewardsResponse::_Internal {
 public:
};

RewardsResponse::RewardsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.RewardsResponse)
}
RewardsResponse::RewardsResponse(const RewardsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RewardsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){from._impl_.rewards_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.RewardsResponse)
}

inline void RewardsResponse::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RewardsResponse::~RewardsResponse() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.RewardsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RewardsResponse::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_rewards()->~RepeatedPtrField();
}

void RewardsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RewardsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.RewardsResponse)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_rewards()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RewardsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .injective_accounts_rpc.Reward rewards = 1 [json_name = "rewards"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* RewardsResponse::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.RewardsResponse)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.Reward rewards = 1 [json_name = "rewards"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.RewardsResponse)
  return target;
}

::size_t RewardsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.RewardsResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.Reward rewards = 1 [json_name = "rewards"];
  total_size += 1UL * this->_internal_rewards_size();
  for (const auto& msg : this->_internal_rewards()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RewardsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RewardsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RewardsResponse::GetClassData() const { return &_class_data_; }


void RewardsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RewardsResponse*>(&to_msg);
  auto& from = static_cast<const RewardsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.RewardsResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_rewards()->MergeFrom(from._internal_rewards());
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RewardsResponse::CopyFrom(const RewardsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.RewardsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RewardsResponse::IsInitialized() const {
  return true;
}

void RewardsResponse::InternalSwap(RewardsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_rewards()->InternalSwap(other->_internal_mutable_rewards());
}

::PROTOBUF_NAMESPACE_ID::Metadata RewardsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[25]);
}
// ===================================================================

class Reward::_Internal {
 public:
};

Reward::Reward(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.Reward)
}
Reward::Reward(const Reward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Reward* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){from._impl_.rewards_}
    , decltype(_impl_.account_address_) {}

    , decltype(_impl_.distributed_at_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_account_address().empty()) {
    _this->_impl_.account_address_.Set(from._internal_account_address(), _this->GetArenaForAllocation());
  }
  _this->_impl_.distributed_at_ = from._impl_.distributed_at_;
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.Reward)
}

inline void Reward::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.rewards_){arena}
    , decltype(_impl_.account_address_) {}

    , decltype(_impl_.distributed_at_) { ::int64_t{0} }

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.account_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.account_address_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Reward::~Reward() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.Reward)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Reward::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_rewards()->~RepeatedPtrField();
  _impl_.account_address_.Destroy();
}

void Reward::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Reward::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.Reward)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_rewards()->Clear();
  _impl_.account_address_.ClearToEmpty();
  _impl_.distributed_at_ = ::int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reward::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string account_address = 1 [json_name = "accountAddress"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.Reward.account_address"));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .injective_accounts_rpc.Coin rewards = 2 [json_name = "rewards"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rewards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint64 distributed_at = 3 [json_name = "distributedAt"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.distributed_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Reward::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.Reward)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    const std::string& _s = this->_internal_account_address();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.Reward.account_address");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .injective_accounts_rpc.Coin rewards = 2 [json_name = "rewards"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_rewards(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // sint64 distributed_at = 3 [json_name = "distributedAt"];
  if (this->_internal_distributed_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        3, this->_internal_distributed_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.Reward)
  return target;
}

::size_t Reward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.Reward)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .injective_accounts_rpc.Coin rewards = 2 [json_name = "rewards"];
  total_size += 1UL * this->_internal_rewards_size();
  for (const auto& msg : this->_internal_rewards()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string account_address = 1 [json_name = "accountAddress"];
  if (!this->_internal_account_address().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_account_address());
  }

  // sint64 distributed_at = 3 [json_name = "distributedAt"];
  if (this->_internal_distributed_at() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_distributed_at());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Reward::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Reward::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Reward::GetClassData() const { return &_class_data_; }


void Reward::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Reward*>(&to_msg);
  auto& from = static_cast<const Reward&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.Reward)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_rewards()->MergeFrom(from._internal_rewards());
  if (!from._internal_account_address().empty()) {
    _this->_internal_set_account_address(from._internal_account_address());
  }
  if (from._internal_distributed_at() != 0) {
    _this->_internal_set_distributed_at(from._internal_distributed_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Reward::CopyFrom(const Reward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.Reward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reward::IsInitialized() const {
  return true;
}

void Reward::InternalSwap(Reward* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_rewards()->InternalSwap(other->_internal_mutable_rewards());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.account_address_, lhs_arena,
                                       &other->_impl_.account_address_, rhs_arena);

  swap(_impl_.distributed_at_, other->_impl_.distributed_at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Reward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[26]);
}
// ===================================================================

class Coin::_Internal {
 public:
};

Coin::Coin(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:injective_accounts_rpc.Coin)
}
Coin::Coin(const Coin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Coin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.amount_) {}

    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_denom().empty()) {
    _this->_impl_.denom_.Set(from._internal_denom(), _this->GetArenaForAllocation());
  }
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_amount().empty()) {
    _this->_impl_.amount_.Set(from._internal_amount(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:injective_accounts_rpc.Coin)
}

inline void Coin::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.denom_) {}

    , decltype(_impl_.amount_) {}

    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.denom_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.denom_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.amount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.amount_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Coin::~Coin() {
  // @@protoc_insertion_point(destructor:injective_accounts_rpc.Coin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Coin::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.denom_.Destroy();
  _impl_.amount_.Destroy();
}

void Coin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Coin::Clear() {
// @@protoc_insertion_point(message_clear_start:injective_accounts_rpc.Coin)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.denom_.ClearToEmpty();
  _impl_.amount_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Coin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string denom = 1 [json_name = "denom"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_denom();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.Coin.denom"));
        } else {
          goto handle_unusual;
        }
        continue;
      // string amount = 2 [json_name = "amount"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_amount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "injective_accounts_rpc.Coin.amount"));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Coin::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:injective_accounts_rpc.Coin)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    const std::string& _s = this->_internal_denom();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.Coin.denom");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string amount = 2 [json_name = "amount"];
  if (!this->_internal_amount().empty()) {
    const std::string& _s = this->_internal_amount();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "injective_accounts_rpc.Coin.amount");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:injective_accounts_rpc.Coin)
  return target;
}

::size_t Coin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:injective_accounts_rpc.Coin)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string denom = 1 [json_name = "denom"];
  if (!this->_internal_denom().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_denom());
  }

  // string amount = 2 [json_name = "amount"];
  if (!this->_internal_amount().empty()) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Coin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Coin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Coin::GetClassData() const { return &_class_data_; }


void Coin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Coin*>(&to_msg);
  auto& from = static_cast<const Coin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:injective_accounts_rpc.Coin)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_denom().empty()) {
    _this->_internal_set_denom(from._internal_denom());
  }
  if (!from._internal_amount().empty()) {
    _this->_internal_set_amount(from._internal_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Coin::CopyFrom(const Coin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:injective_accounts_rpc.Coin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coin::IsInitialized() const {
  return true;
}

void Coin::InternalSwap(Coin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.denom_, lhs_arena,
                                       &other->_impl_.denom_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.amount_, lhs_arena,
                                       &other->_impl_.amount_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Coin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_getter, &descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto_once,
      file_level_metadata_exchange_2finjective_5faccounts_5frpc_2eproto[27]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_accounts_rpc
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::PortfolioRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::PortfolioRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::PortfolioRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::PortfolioResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::PortfolioResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::PortfolioResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::AccountPortfolio*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::AccountPortfolio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::AccountPortfolio >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountPortfolio*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountPortfolio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountPortfolio >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::OrderStatesRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::OrderStatesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::OrderStatesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::OrderStatesResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::OrderStatesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::OrderStatesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::OrderStateRecord*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::OrderStateRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::OrderStateRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountsListRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountsListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountsListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountsListResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountsListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountsListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalancesListRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalancesListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalancesListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalancesListResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalancesListResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalancesListResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalance*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalance >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountDeposit*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountDeposit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountDeposit >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalanceRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalanceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalanceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalanceResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalanceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalanceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::StreamSubaccountBalanceRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::StreamSubaccountBalanceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::StreamSubaccountBalanceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::StreamSubaccountBalanceResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::StreamSubaccountBalanceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::StreamSubaccountBalanceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountHistoryRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountHistoryRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountHistoryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountHistoryResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountHistoryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountHistoryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountBalanceTransfer*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountBalanceTransfer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountBalanceTransfer >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::CosmosCoin*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::CosmosCoin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::CosmosCoin >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::Paging*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::Paging >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::Paging >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountOrderSummaryRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountOrderSummaryRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountOrderSummaryRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::SubaccountOrderSummaryResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::SubaccountOrderSummaryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::SubaccountOrderSummaryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::RewardsRequest*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::RewardsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::RewardsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::RewardsResponse*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::RewardsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::RewardsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::Reward*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::Reward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::Reward >(arena);
}
template<> PROTOBUF_NOINLINE ::injective_accounts_rpc::Coin*
Arena::CreateMaybeMessage< ::injective_accounts_rpc::Coin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::injective_accounts_rpc::Coin >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
