// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_auction_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fauction_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fauction_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5fauction_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5fauction_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5fauction_5frpc_2eproto;
namespace injective_auction_rpc {
class Auction;
struct AuctionDefaultTypeInternal;
extern AuctionDefaultTypeInternal _Auction_default_instance_;
class AuctionRequest;
struct AuctionRequestDefaultTypeInternal;
extern AuctionRequestDefaultTypeInternal _AuctionRequest_default_instance_;
class AuctionResponse;
struct AuctionResponseDefaultTypeInternal;
extern AuctionResponseDefaultTypeInternal _AuctionResponse_default_instance_;
class AuctionsRequest;
struct AuctionsRequestDefaultTypeInternal;
extern AuctionsRequestDefaultTypeInternal _AuctionsRequest_default_instance_;
class AuctionsResponse;
struct AuctionsResponseDefaultTypeInternal;
extern AuctionsResponseDefaultTypeInternal _AuctionsResponse_default_instance_;
class Bid;
struct BidDefaultTypeInternal;
extern BidDefaultTypeInternal _Bid_default_instance_;
class Coin;
struct CoinDefaultTypeInternal;
extern CoinDefaultTypeInternal _Coin_default_instance_;
class StreamBidsRequest;
struct StreamBidsRequestDefaultTypeInternal;
extern StreamBidsRequestDefaultTypeInternal _StreamBidsRequest_default_instance_;
class StreamBidsResponse;
struct StreamBidsResponseDefaultTypeInternal;
extern StreamBidsResponseDefaultTypeInternal _StreamBidsResponse_default_instance_;
}  // namespace injective_auction_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_auction_rpc::Auction* Arena::CreateMaybeMessage<::injective_auction_rpc::Auction>(Arena*);
template <>
::injective_auction_rpc::AuctionRequest* Arena::CreateMaybeMessage<::injective_auction_rpc::AuctionRequest>(Arena*);
template <>
::injective_auction_rpc::AuctionResponse* Arena::CreateMaybeMessage<::injective_auction_rpc::AuctionResponse>(Arena*);
template <>
::injective_auction_rpc::AuctionsRequest* Arena::CreateMaybeMessage<::injective_auction_rpc::AuctionsRequest>(Arena*);
template <>
::injective_auction_rpc::AuctionsResponse* Arena::CreateMaybeMessage<::injective_auction_rpc::AuctionsResponse>(Arena*);
template <>
::injective_auction_rpc::Bid* Arena::CreateMaybeMessage<::injective_auction_rpc::Bid>(Arena*);
template <>
::injective_auction_rpc::Coin* Arena::CreateMaybeMessage<::injective_auction_rpc::Coin>(Arena*);
template <>
::injective_auction_rpc::StreamBidsRequest* Arena::CreateMaybeMessage<::injective_auction_rpc::StreamBidsRequest>(Arena*);
template <>
::injective_auction_rpc::StreamBidsResponse* Arena::CreateMaybeMessage<::injective_auction_rpc::StreamBidsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_auction_rpc {

// ===================================================================


// -------------------------------------------------------------------

class AuctionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.AuctionRequest) */ {
 public:
  inline AuctionRequest() : AuctionRequest(nullptr) {}
  ~AuctionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuctionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuctionRequest(const AuctionRequest& from);
  AuctionRequest(AuctionRequest&& from) noexcept
    : AuctionRequest() {
    *this = ::std::move(from);
  }

  inline AuctionRequest& operator=(const AuctionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionRequest& operator=(AuctionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuctionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuctionRequest* internal_default_instance() {
    return reinterpret_cast<const AuctionRequest*>(
               &_AuctionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AuctionRequest& a, AuctionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuctionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuctionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuctionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuctionRequest& from) {
    AuctionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.AuctionRequest";
  }
  protected:
  explicit AuctionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundFieldNumber = 1,
  };
  // sint64 round = 1 [json_name = "round"];
  void clear_round() ;
  ::int64_t round() const;
  void set_round(::int64_t value);

  private:
  ::int64_t _internal_round() const;
  void _internal_set_round(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.AuctionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t round_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class AuctionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.AuctionResponse) */ {
 public:
  inline AuctionResponse() : AuctionResponse(nullptr) {}
  ~AuctionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuctionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuctionResponse(const AuctionResponse& from);
  AuctionResponse(AuctionResponse&& from) noexcept
    : AuctionResponse() {
    *this = ::std::move(from);
  }

  inline AuctionResponse& operator=(const AuctionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionResponse& operator=(AuctionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuctionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuctionResponse* internal_default_instance() {
    return reinterpret_cast<const AuctionResponse*>(
               &_AuctionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AuctionResponse& a, AuctionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuctionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuctionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuctionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuctionResponse& from) {
    AuctionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.AuctionResponse";
  }
  protected:
  explicit AuctionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBidsFieldNumber = 2,
    kAuctionFieldNumber = 1,
  };
  // repeated .injective_auction_rpc.Bid bids = 2 [json_name = "bids"];
  int bids_size() const;
  private:
  int _internal_bids_size() const;

  public:
  void clear_bids() ;
  ::injective_auction_rpc::Bid* mutable_bids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Bid >*
      mutable_bids();
  private:
  const ::injective_auction_rpc::Bid& _internal_bids(int index) const;
  ::injective_auction_rpc::Bid* _internal_add_bids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Bid>& _internal_bids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Bid>* _internal_mutable_bids();
  public:
  const ::injective_auction_rpc::Bid& bids(int index) const;
  ::injective_auction_rpc::Bid* add_bids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Bid >&
      bids() const;
  // .injective_auction_rpc.Auction auction = 1 [json_name = "auction"];
  bool has_auction() const;
  void clear_auction() ;
  const ::injective_auction_rpc::Auction& auction() const;
  PROTOBUF_NODISCARD ::injective_auction_rpc::Auction* release_auction();
  ::injective_auction_rpc::Auction* mutable_auction();
  void set_allocated_auction(::injective_auction_rpc::Auction* auction);
  private:
  const ::injective_auction_rpc::Auction& _internal_auction() const;
  ::injective_auction_rpc::Auction* _internal_mutable_auction();
  public:
  void unsafe_arena_set_allocated_auction(
      ::injective_auction_rpc::Auction* auction);
  ::injective_auction_rpc::Auction* unsafe_arena_release_auction();
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.AuctionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Bid > bids_;
    ::injective_auction_rpc::Auction* auction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class Auction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.Auction) */ {
 public:
  inline Auction() : Auction(nullptr) {}
  ~Auction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Auction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Auction(const Auction& from);
  Auction(Auction&& from) noexcept
    : Auction() {
    *this = ::std::move(from);
  }

  inline Auction& operator=(const Auction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Auction& operator=(Auction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Auction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Auction* internal_default_instance() {
    return reinterpret_cast<const Auction*>(
               &_Auction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Auction& a, Auction& b) {
    a.Swap(&b);
  }
  inline void Swap(Auction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Auction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Auction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Auction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Auction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Auction& from) {
    Auction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Auction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.Auction";
  }
  protected:
  explicit Auction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasketFieldNumber = 2,
    kWinnerFieldNumber = 1,
    kWinningBidAmountFieldNumber = 3,
    kRoundFieldNumber = 4,
    kEndTimestampFieldNumber = 5,
    kUpdatedAtFieldNumber = 6,
  };
  // repeated .injective_auction_rpc.Coin basket = 2 [json_name = "basket"];
  int basket_size() const;
  private:
  int _internal_basket_size() const;

  public:
  void clear_basket() ;
  ::injective_auction_rpc::Coin* mutable_basket(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Coin >*
      mutable_basket();
  private:
  const ::injective_auction_rpc::Coin& _internal_basket(int index) const;
  ::injective_auction_rpc::Coin* _internal_add_basket();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Coin>& _internal_basket() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Coin>* _internal_mutable_basket();
  public:
  const ::injective_auction_rpc::Coin& basket(int index) const;
  ::injective_auction_rpc::Coin* add_basket();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Coin >&
      basket() const;
  // string winner = 1 [json_name = "winner"];
  void clear_winner() ;
  const std::string& winner() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_winner(Arg_&& arg, Args_... args);
  std::string* mutable_winner();
  PROTOBUF_NODISCARD std::string* release_winner();
  void set_allocated_winner(std::string* ptr);

  private:
  const std::string& _internal_winner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winner(
      const std::string& value);
  std::string* _internal_mutable_winner();

  public:
  // string winning_bid_amount = 3 [json_name = "winningBidAmount"];
  void clear_winning_bid_amount() ;
  const std::string& winning_bid_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_winning_bid_amount(Arg_&& arg, Args_... args);
  std::string* mutable_winning_bid_amount();
  PROTOBUF_NODISCARD std::string* release_winning_bid_amount();
  void set_allocated_winning_bid_amount(std::string* ptr);

  private:
  const std::string& _internal_winning_bid_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winning_bid_amount(
      const std::string& value);
  std::string* _internal_mutable_winning_bid_amount();

  public:
  // uint64 round = 4 [json_name = "round"];
  void clear_round() ;
  ::uint64_t round() const;
  void set_round(::uint64_t value);

  private:
  ::uint64_t _internal_round() const;
  void _internal_set_round(::uint64_t value);

  public:
  // sint64 end_timestamp = 5 [json_name = "endTimestamp"];
  void clear_end_timestamp() ;
  ::int64_t end_timestamp() const;
  void set_end_timestamp(::int64_t value);

  private:
  ::int64_t _internal_end_timestamp() const;
  void _internal_set_end_timestamp(::int64_t value);

  public:
  // sint64 updated_at = 6 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.Auction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Coin > basket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr winner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr winning_bid_amount_;
    ::uint64_t round_;
    ::int64_t end_timestamp_;
    ::int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class Coin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.Coin) */ {
 public:
  inline Coin() : Coin(nullptr) {}
  ~Coin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Coin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Coin(const Coin& from);
  Coin(Coin&& from) noexcept
    : Coin() {
    *this = ::std::move(from);
  }

  inline Coin& operator=(const Coin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coin& operator=(Coin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coin* internal_default_instance() {
    return reinterpret_cast<const Coin*>(
               &_Coin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Coin& a, Coin& b) {
    a.Swap(&b);
  }
  inline void Swap(Coin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Coin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Coin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Coin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Coin& from) {
    Coin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.Coin";
  }
  protected:
  explicit Coin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.Coin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class Bid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.Bid) */ {
 public:
  inline Bid() : Bid(nullptr) {}
  ~Bid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Bid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bid(const Bid& from);
  Bid(Bid&& from) noexcept
    : Bid() {
    *this = ::std::move(from);
  }

  inline Bid& operator=(const Bid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bid& operator=(Bid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bid* internal_default_instance() {
    return reinterpret_cast<const Bid*>(
               &_Bid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Bid& a, Bid& b) {
    a.Swap(&b);
  }
  inline void Swap(Bid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bid& from) {
    Bid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.Bid";
  }
  protected:
  explicit Bid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBidderFieldNumber = 1,
    kAmountFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string bidder = 1 [json_name = "bidder"];
  void clear_bidder() ;
  const std::string& bidder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bidder(Arg_&& arg, Args_... args);
  std::string* mutable_bidder();
  PROTOBUF_NODISCARD std::string* release_bidder();
  void set_allocated_bidder(std::string* ptr);

  private:
  const std::string& _internal_bidder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bidder(
      const std::string& value);
  std::string* _internal_mutable_bidder();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.Bid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bidder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class AuctionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_auction_rpc.AuctionsRequest) */ {
 public:
  inline AuctionsRequest() : AuctionsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuctionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuctionsRequest(const AuctionsRequest& from);
  AuctionsRequest(AuctionsRequest&& from) noexcept
    : AuctionsRequest() {
    *this = ::std::move(from);
  }

  inline AuctionsRequest& operator=(const AuctionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionsRequest& operator=(AuctionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuctionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuctionsRequest* internal_default_instance() {
    return reinterpret_cast<const AuctionsRequest*>(
               &_AuctionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AuctionsRequest& a, AuctionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuctionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuctionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AuctionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AuctionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.AuctionsRequest";
  }
  protected:
  explicit AuctionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_auction_rpc.AuctionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class AuctionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.AuctionsResponse) */ {
 public:
  inline AuctionsResponse() : AuctionsResponse(nullptr) {}
  ~AuctionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuctionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuctionsResponse(const AuctionsResponse& from);
  AuctionsResponse(AuctionsResponse&& from) noexcept
    : AuctionsResponse() {
    *this = ::std::move(from);
  }

  inline AuctionsResponse& operator=(const AuctionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionsResponse& operator=(AuctionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuctionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuctionsResponse* internal_default_instance() {
    return reinterpret_cast<const AuctionsResponse*>(
               &_AuctionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuctionsResponse& a, AuctionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuctionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuctionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuctionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuctionsResponse& from) {
    AuctionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.AuctionsResponse";
  }
  protected:
  explicit AuctionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuctionsFieldNumber = 1,
  };
  // repeated .injective_auction_rpc.Auction auctions = 1 [json_name = "auctions"];
  int auctions_size() const;
  private:
  int _internal_auctions_size() const;

  public:
  void clear_auctions() ;
  ::injective_auction_rpc::Auction* mutable_auctions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Auction >*
      mutable_auctions();
  private:
  const ::injective_auction_rpc::Auction& _internal_auctions(int index) const;
  ::injective_auction_rpc::Auction* _internal_add_auctions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Auction>& _internal_auctions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Auction>* _internal_mutable_auctions();
  public:
  const ::injective_auction_rpc::Auction& auctions(int index) const;
  ::injective_auction_rpc::Auction* add_auctions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Auction >&
      auctions() const;
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.AuctionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Auction > auctions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamBidsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_auction_rpc.StreamBidsRequest) */ {
 public:
  inline StreamBidsRequest() : StreamBidsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBidsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamBidsRequest(const StreamBidsRequest& from);
  StreamBidsRequest(StreamBidsRequest&& from) noexcept
    : StreamBidsRequest() {
    *this = ::std::move(from);
  }

  inline StreamBidsRequest& operator=(const StreamBidsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBidsRequest& operator=(StreamBidsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBidsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBidsRequest* internal_default_instance() {
    return reinterpret_cast<const StreamBidsRequest*>(
               &_StreamBidsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamBidsRequest& a, StreamBidsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBidsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBidsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBidsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBidsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StreamBidsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StreamBidsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.StreamBidsRequest";
  }
  protected:
  explicit StreamBidsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_auction_rpc.StreamBidsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamBidsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_auction_rpc.StreamBidsResponse) */ {
 public:
  inline StreamBidsResponse() : StreamBidsResponse(nullptr) {}
  ~StreamBidsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBidsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamBidsResponse(const StreamBidsResponse& from);
  StreamBidsResponse(StreamBidsResponse&& from) noexcept
    : StreamBidsResponse() {
    *this = ::std::move(from);
  }

  inline StreamBidsResponse& operator=(const StreamBidsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBidsResponse& operator=(StreamBidsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBidsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBidsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamBidsResponse*>(
               &_StreamBidsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamBidsResponse& a, StreamBidsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBidsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBidsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBidsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBidsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamBidsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamBidsResponse& from) {
    StreamBidsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamBidsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_auction_rpc.StreamBidsResponse";
  }
  protected:
  explicit StreamBidsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBidderFieldNumber = 1,
    kBidAmountFieldNumber = 2,
    kRoundFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // string bidder = 1 [json_name = "bidder"];
  void clear_bidder() ;
  const std::string& bidder() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bidder(Arg_&& arg, Args_... args);
  std::string* mutable_bidder();
  PROTOBUF_NODISCARD std::string* release_bidder();
  void set_allocated_bidder(std::string* ptr);

  private:
  const std::string& _internal_bidder() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bidder(
      const std::string& value);
  std::string* _internal_mutable_bidder();

  public:
  // string bid_amount = 2 [json_name = "bidAmount"];
  void clear_bid_amount() ;
  const std::string& bid_amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bid_amount(Arg_&& arg, Args_... args);
  std::string* mutable_bid_amount();
  PROTOBUF_NODISCARD std::string* release_bid_amount();
  void set_allocated_bid_amount(std::string* ptr);

  private:
  const std::string& _internal_bid_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bid_amount(
      const std::string& value);
  std::string* _internal_mutable_bid_amount();

  public:
  // uint64 round = 3 [json_name = "round"];
  void clear_round() ;
  ::uint64_t round() const;
  void set_round(::uint64_t value);

  private:
  ::uint64_t _internal_round() const;
  void _internal_set_round(::uint64_t value);

  public:
  // sint64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_auction_rpc.StreamBidsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bidder_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bid_amount_;
    ::uint64_t round_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fauction_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AuctionRequest

// sint64 round = 1 [json_name = "round"];
inline void AuctionRequest::clear_round() {
  _impl_.round_ = ::int64_t{0};
}
inline ::int64_t AuctionRequest::round() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.AuctionRequest.round)
  return _internal_round();
}
inline void AuctionRequest::set_round(::int64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.AuctionRequest.round)
}
inline ::int64_t AuctionRequest::_internal_round() const {
  return _impl_.round_;
}
inline void AuctionRequest::_internal_set_round(::int64_t value) {
  ;
  _impl_.round_ = value;
}

// -------------------------------------------------------------------

// AuctionResponse

// .injective_auction_rpc.Auction auction = 1 [json_name = "auction"];
inline bool AuctionResponse::has_auction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.auction_ != nullptr);
  return value;
}
inline void AuctionResponse::clear_auction() {
  if (_impl_.auction_ != nullptr) _impl_.auction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_auction_rpc::Auction& AuctionResponse::_internal_auction() const {
  const ::injective_auction_rpc::Auction* p = _impl_.auction_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_auction_rpc::Auction&>(
      ::injective_auction_rpc::_Auction_default_instance_);
}
inline const ::injective_auction_rpc::Auction& AuctionResponse::auction() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.AuctionResponse.auction)
  return _internal_auction();
}
inline void AuctionResponse::unsafe_arena_set_allocated_auction(
    ::injective_auction_rpc::Auction* auction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auction_);
  }
  _impl_.auction_ = auction;
  if (auction) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_auction_rpc.AuctionResponse.auction)
}
inline ::injective_auction_rpc::Auction* AuctionResponse::release_auction() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_auction_rpc::Auction* temp = _impl_.auction_;
  _impl_.auction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_auction_rpc::Auction* AuctionResponse::unsafe_arena_release_auction() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.AuctionResponse.auction)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_auction_rpc::Auction* temp = _impl_.auction_;
  _impl_.auction_ = nullptr;
  return temp;
}
inline ::injective_auction_rpc::Auction* AuctionResponse::_internal_mutable_auction() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.auction_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_auction_rpc::Auction>(GetArenaForAllocation());
    _impl_.auction_ = p;
  }
  return _impl_.auction_;
}
inline ::injective_auction_rpc::Auction* AuctionResponse::mutable_auction() {
  ::injective_auction_rpc::Auction* _msg = _internal_mutable_auction();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.AuctionResponse.auction)
  return _msg;
}
inline void AuctionResponse::set_allocated_auction(::injective_auction_rpc::Auction* auction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.auction_;
  }
  if (auction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auction);
    if (message_arena != submessage_arena) {
      auction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auction_ = auction;
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.AuctionResponse.auction)
}

// repeated .injective_auction_rpc.Bid bids = 2 [json_name = "bids"];
inline int AuctionResponse::_internal_bids_size() const {
  return _impl_.bids_.size();
}
inline int AuctionResponse::bids_size() const {
  return _internal_bids_size();
}
inline void AuctionResponse::clear_bids() {
  _internal_mutable_bids()->Clear();
}
inline ::injective_auction_rpc::Bid* AuctionResponse::mutable_bids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.AuctionResponse.bids)
  return _internal_mutable_bids()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Bid >*
AuctionResponse::mutable_bids() {
  // @@protoc_insertion_point(field_mutable_list:injective_auction_rpc.AuctionResponse.bids)
  return _internal_mutable_bids();
}
inline const ::injective_auction_rpc::Bid& AuctionResponse::_internal_bids(int index) const {
  return _internal_bids().Get(index);
}
inline const ::injective_auction_rpc::Bid& AuctionResponse::bids(int index) const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.AuctionResponse.bids)
  return _internal_bids(index);
}
inline ::injective_auction_rpc::Bid* AuctionResponse::_internal_add_bids() {
  return _internal_mutable_bids()->Add();
}
inline ::injective_auction_rpc::Bid* AuctionResponse::add_bids() {
  ::injective_auction_rpc::Bid* _add = _internal_add_bids();
  // @@protoc_insertion_point(field_add:injective_auction_rpc.AuctionResponse.bids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Bid >&
AuctionResponse::bids() const {
  // @@protoc_insertion_point(field_list:injective_auction_rpc.AuctionResponse.bids)
  return _internal_bids();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Bid>&
AuctionResponse::_internal_bids() const {
  return _impl_.bids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Bid>*
AuctionResponse::_internal_mutable_bids() {
  return &_impl_.bids_;
}

// -------------------------------------------------------------------

// Auction

// string winner = 1 [json_name = "winner"];
inline void Auction::clear_winner() {
  _impl_.winner_.ClearToEmpty();
}
inline const std::string& Auction::winner() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.winner)
  return _internal_winner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Auction::set_winner(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.winner_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Auction.winner)
}
inline std::string* Auction::mutable_winner() {
  std::string* _s = _internal_mutable_winner();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Auction.winner)
  return _s;
}
inline const std::string& Auction::_internal_winner() const {
  return _impl_.winner_.Get();
}
inline void Auction::_internal_set_winner(const std::string& value) {
  ;


  _impl_.winner_.Set(value, GetArenaForAllocation());
}
inline std::string* Auction::_internal_mutable_winner() {
  ;
  return _impl_.winner_.Mutable( GetArenaForAllocation());
}
inline std::string* Auction::release_winner() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Auction.winner)
  return _impl_.winner_.Release();
}
inline void Auction::set_allocated_winner(std::string* value) {
  _impl_.winner_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.winner_.IsDefault()) {
          _impl_.winner_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Auction.winner)
}

// repeated .injective_auction_rpc.Coin basket = 2 [json_name = "basket"];
inline int Auction::_internal_basket_size() const {
  return _impl_.basket_.size();
}
inline int Auction::basket_size() const {
  return _internal_basket_size();
}
inline void Auction::clear_basket() {
  _internal_mutable_basket()->Clear();
}
inline ::injective_auction_rpc::Coin* Auction::mutable_basket(int index) {
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Auction.basket)
  return _internal_mutable_basket()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Coin >*
Auction::mutable_basket() {
  // @@protoc_insertion_point(field_mutable_list:injective_auction_rpc.Auction.basket)
  return _internal_mutable_basket();
}
inline const ::injective_auction_rpc::Coin& Auction::_internal_basket(int index) const {
  return _internal_basket().Get(index);
}
inline const ::injective_auction_rpc::Coin& Auction::basket(int index) const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.basket)
  return _internal_basket(index);
}
inline ::injective_auction_rpc::Coin* Auction::_internal_add_basket() {
  return _internal_mutable_basket()->Add();
}
inline ::injective_auction_rpc::Coin* Auction::add_basket() {
  ::injective_auction_rpc::Coin* _add = _internal_add_basket();
  // @@protoc_insertion_point(field_add:injective_auction_rpc.Auction.basket)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Coin >&
Auction::basket() const {
  // @@protoc_insertion_point(field_list:injective_auction_rpc.Auction.basket)
  return _internal_basket();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Coin>&
Auction::_internal_basket() const {
  return _impl_.basket_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Coin>*
Auction::_internal_mutable_basket() {
  return &_impl_.basket_;
}

// string winning_bid_amount = 3 [json_name = "winningBidAmount"];
inline void Auction::clear_winning_bid_amount() {
  _impl_.winning_bid_amount_.ClearToEmpty();
}
inline const std::string& Auction::winning_bid_amount() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.winning_bid_amount)
  return _internal_winning_bid_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Auction::set_winning_bid_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.winning_bid_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Auction.winning_bid_amount)
}
inline std::string* Auction::mutable_winning_bid_amount() {
  std::string* _s = _internal_mutable_winning_bid_amount();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Auction.winning_bid_amount)
  return _s;
}
inline const std::string& Auction::_internal_winning_bid_amount() const {
  return _impl_.winning_bid_amount_.Get();
}
inline void Auction::_internal_set_winning_bid_amount(const std::string& value) {
  ;


  _impl_.winning_bid_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Auction::_internal_mutable_winning_bid_amount() {
  ;
  return _impl_.winning_bid_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* Auction::release_winning_bid_amount() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Auction.winning_bid_amount)
  return _impl_.winning_bid_amount_.Release();
}
inline void Auction::set_allocated_winning_bid_amount(std::string* value) {
  _impl_.winning_bid_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.winning_bid_amount_.IsDefault()) {
          _impl_.winning_bid_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Auction.winning_bid_amount)
}

// uint64 round = 4 [json_name = "round"];
inline void Auction::clear_round() {
  _impl_.round_ = ::uint64_t{0u};
}
inline ::uint64_t Auction::round() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.round)
  return _internal_round();
}
inline void Auction::set_round(::uint64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Auction.round)
}
inline ::uint64_t Auction::_internal_round() const {
  return _impl_.round_;
}
inline void Auction::_internal_set_round(::uint64_t value) {
  ;
  _impl_.round_ = value;
}

// sint64 end_timestamp = 5 [json_name = "endTimestamp"];
inline void Auction::clear_end_timestamp() {
  _impl_.end_timestamp_ = ::int64_t{0};
}
inline ::int64_t Auction::end_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.end_timestamp)
  return _internal_end_timestamp();
}
inline void Auction::set_end_timestamp(::int64_t value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Auction.end_timestamp)
}
inline ::int64_t Auction::_internal_end_timestamp() const {
  return _impl_.end_timestamp_;
}
inline void Auction::_internal_set_end_timestamp(::int64_t value) {
  ;
  _impl_.end_timestamp_ = value;
}

// sint64 updated_at = 6 [json_name = "updatedAt"];
inline void Auction::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t Auction::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Auction.updated_at)
  return _internal_updated_at();
}
inline void Auction::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Auction.updated_at)
}
inline ::int64_t Auction::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void Auction::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// Coin

// string denom = 1 [json_name = "denom"];
inline void Coin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& Coin::denom() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Coin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Coin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Coin.denom)
}
inline std::string* Coin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Coin.denom)
  return _s;
}
inline const std::string& Coin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void Coin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* Coin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* Coin::release_denom() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Coin.denom)
  return _impl_.denom_.Release();
}
inline void Coin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Coin.denom)
}

// string amount = 2 [json_name = "amount"];
inline void Coin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Coin::amount() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Coin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Coin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Coin.amount)
}
inline std::string* Coin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Coin.amount)
  return _s;
}
inline const std::string& Coin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Coin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Coin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* Coin::release_amount() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Coin.amount)
  return _impl_.amount_.Release();
}
inline void Coin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Coin.amount)
}

// -------------------------------------------------------------------

// Bid

// string bidder = 1 [json_name = "bidder"];
inline void Bid::clear_bidder() {
  _impl_.bidder_.ClearToEmpty();
}
inline const std::string& Bid::bidder() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Bid.bidder)
  return _internal_bidder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Bid::set_bidder(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bidder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Bid.bidder)
}
inline std::string* Bid::mutable_bidder() {
  std::string* _s = _internal_mutable_bidder();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Bid.bidder)
  return _s;
}
inline const std::string& Bid::_internal_bidder() const {
  return _impl_.bidder_.Get();
}
inline void Bid::_internal_set_bidder(const std::string& value) {
  ;


  _impl_.bidder_.Set(value, GetArenaForAllocation());
}
inline std::string* Bid::_internal_mutable_bidder() {
  ;
  return _impl_.bidder_.Mutable( GetArenaForAllocation());
}
inline std::string* Bid::release_bidder() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Bid.bidder)
  return _impl_.bidder_.Release();
}
inline void Bid::set_allocated_bidder(std::string* value) {
  _impl_.bidder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bidder_.IsDefault()) {
          _impl_.bidder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Bid.bidder)
}

// string amount = 2 [json_name = "amount"];
inline void Bid::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Bid::amount() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Bid.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Bid::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Bid.amount)
}
inline std::string* Bid::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.Bid.amount)
  return _s;
}
inline const std::string& Bid::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Bid::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Bid::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* Bid::release_amount() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.Bid.amount)
  return _impl_.amount_.Release();
}
inline void Bid::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.Bid.amount)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void Bid::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t Bid::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.Bid.timestamp)
  return _internal_timestamp();
}
inline void Bid::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.Bid.timestamp)
}
inline ::int64_t Bid::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void Bid::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// AuctionsRequest

// -------------------------------------------------------------------

// AuctionsResponse

// repeated .injective_auction_rpc.Auction auctions = 1 [json_name = "auctions"];
inline int AuctionsResponse::_internal_auctions_size() const {
  return _impl_.auctions_.size();
}
inline int AuctionsResponse::auctions_size() const {
  return _internal_auctions_size();
}
inline void AuctionsResponse::clear_auctions() {
  _internal_mutable_auctions()->Clear();
}
inline ::injective_auction_rpc::Auction* AuctionsResponse::mutable_auctions(int index) {
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.AuctionsResponse.auctions)
  return _internal_mutable_auctions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Auction >*
AuctionsResponse::mutable_auctions() {
  // @@protoc_insertion_point(field_mutable_list:injective_auction_rpc.AuctionsResponse.auctions)
  return _internal_mutable_auctions();
}
inline const ::injective_auction_rpc::Auction& AuctionsResponse::_internal_auctions(int index) const {
  return _internal_auctions().Get(index);
}
inline const ::injective_auction_rpc::Auction& AuctionsResponse::auctions(int index) const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.AuctionsResponse.auctions)
  return _internal_auctions(index);
}
inline ::injective_auction_rpc::Auction* AuctionsResponse::_internal_add_auctions() {
  return _internal_mutable_auctions()->Add();
}
inline ::injective_auction_rpc::Auction* AuctionsResponse::add_auctions() {
  ::injective_auction_rpc::Auction* _add = _internal_add_auctions();
  // @@protoc_insertion_point(field_add:injective_auction_rpc.AuctionsResponse.auctions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_auction_rpc::Auction >&
AuctionsResponse::auctions() const {
  // @@protoc_insertion_point(field_list:injective_auction_rpc.AuctionsResponse.auctions)
  return _internal_auctions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Auction>&
AuctionsResponse::_internal_auctions() const {
  return _impl_.auctions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_auction_rpc::Auction>*
AuctionsResponse::_internal_mutable_auctions() {
  return &_impl_.auctions_;
}

// -------------------------------------------------------------------

// StreamBidsRequest

// -------------------------------------------------------------------

// StreamBidsResponse

// string bidder = 1 [json_name = "bidder"];
inline void StreamBidsResponse::clear_bidder() {
  _impl_.bidder_.ClearToEmpty();
}
inline const std::string& StreamBidsResponse::bidder() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.StreamBidsResponse.bidder)
  return _internal_bidder();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBidsResponse::set_bidder(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bidder_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.StreamBidsResponse.bidder)
}
inline std::string* StreamBidsResponse::mutable_bidder() {
  std::string* _s = _internal_mutable_bidder();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.StreamBidsResponse.bidder)
  return _s;
}
inline const std::string& StreamBidsResponse::_internal_bidder() const {
  return _impl_.bidder_.Get();
}
inline void StreamBidsResponse::_internal_set_bidder(const std::string& value) {
  ;


  _impl_.bidder_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBidsResponse::_internal_mutable_bidder() {
  ;
  return _impl_.bidder_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBidsResponse::release_bidder() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.StreamBidsResponse.bidder)
  return _impl_.bidder_.Release();
}
inline void StreamBidsResponse::set_allocated_bidder(std::string* value) {
  _impl_.bidder_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bidder_.IsDefault()) {
          _impl_.bidder_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.StreamBidsResponse.bidder)
}

// string bid_amount = 2 [json_name = "bidAmount"];
inline void StreamBidsResponse::clear_bid_amount() {
  _impl_.bid_amount_.ClearToEmpty();
}
inline const std::string& StreamBidsResponse::bid_amount() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.StreamBidsResponse.bid_amount)
  return _internal_bid_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBidsResponse::set_bid_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bid_amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_auction_rpc.StreamBidsResponse.bid_amount)
}
inline std::string* StreamBidsResponse::mutable_bid_amount() {
  std::string* _s = _internal_mutable_bid_amount();
  // @@protoc_insertion_point(field_mutable:injective_auction_rpc.StreamBidsResponse.bid_amount)
  return _s;
}
inline const std::string& StreamBidsResponse::_internal_bid_amount() const {
  return _impl_.bid_amount_.Get();
}
inline void StreamBidsResponse::_internal_set_bid_amount(const std::string& value) {
  ;


  _impl_.bid_amount_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBidsResponse::_internal_mutable_bid_amount() {
  ;
  return _impl_.bid_amount_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBidsResponse::release_bid_amount() {
  // @@protoc_insertion_point(field_release:injective_auction_rpc.StreamBidsResponse.bid_amount)
  return _impl_.bid_amount_.Release();
}
inline void StreamBidsResponse::set_allocated_bid_amount(std::string* value) {
  _impl_.bid_amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bid_amount_.IsDefault()) {
          _impl_.bid_amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_auction_rpc.StreamBidsResponse.bid_amount)
}

// uint64 round = 3 [json_name = "round"];
inline void StreamBidsResponse::clear_round() {
  _impl_.round_ = ::uint64_t{0u};
}
inline ::uint64_t StreamBidsResponse::round() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.StreamBidsResponse.round)
  return _internal_round();
}
inline void StreamBidsResponse::set_round(::uint64_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.StreamBidsResponse.round)
}
inline ::uint64_t StreamBidsResponse::_internal_round() const {
  return _impl_.round_;
}
inline void StreamBidsResponse::_internal_set_round(::uint64_t value) {
  ;
  _impl_.round_ = value;
}

// sint64 timestamp = 4 [json_name = "timestamp"];
inline void StreamBidsResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamBidsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_auction_rpc.StreamBidsResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamBidsResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_auction_rpc.StreamBidsResponse.timestamp)
}
inline ::int64_t StreamBidsResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamBidsResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_auction_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fauction_5frpc_2eproto_2epb_2eh
