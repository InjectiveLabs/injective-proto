// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_derivative_exchange_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
namespace injective_derivative_exchange_rpc {
class BinaryOptionsMarketInfo;
struct BinaryOptionsMarketInfoDefaultTypeInternal;
extern BinaryOptionsMarketInfoDefaultTypeInternal _BinaryOptionsMarketInfo_default_instance_;
class BinaryOptionsMarketRequest;
struct BinaryOptionsMarketRequestDefaultTypeInternal;
extern BinaryOptionsMarketRequestDefaultTypeInternal _BinaryOptionsMarketRequest_default_instance_;
class BinaryOptionsMarketResponse;
struct BinaryOptionsMarketResponseDefaultTypeInternal;
extern BinaryOptionsMarketResponseDefaultTypeInternal _BinaryOptionsMarketResponse_default_instance_;
class BinaryOptionsMarketsRequest;
struct BinaryOptionsMarketsRequestDefaultTypeInternal;
extern BinaryOptionsMarketsRequestDefaultTypeInternal _BinaryOptionsMarketsRequest_default_instance_;
class BinaryOptionsMarketsResponse;
struct BinaryOptionsMarketsResponseDefaultTypeInternal;
extern BinaryOptionsMarketsResponseDefaultTypeInternal _BinaryOptionsMarketsResponse_default_instance_;
class DerivativeLimitOrder;
struct DerivativeLimitOrderDefaultTypeInternal;
extern DerivativeLimitOrderDefaultTypeInternal _DerivativeLimitOrder_default_instance_;
class DerivativeLimitOrderbook;
struct DerivativeLimitOrderbookDefaultTypeInternal;
extern DerivativeLimitOrderbookDefaultTypeInternal _DerivativeLimitOrderbook_default_instance_;
class DerivativeLimitOrderbookV2;
struct DerivativeLimitOrderbookV2DefaultTypeInternal;
extern DerivativeLimitOrderbookV2DefaultTypeInternal _DerivativeLimitOrderbookV2_default_instance_;
class DerivativeMarketInfo;
struct DerivativeMarketInfoDefaultTypeInternal;
extern DerivativeMarketInfoDefaultTypeInternal _DerivativeMarketInfo_default_instance_;
class DerivativeOrderHistory;
struct DerivativeOrderHistoryDefaultTypeInternal;
extern DerivativeOrderHistoryDefaultTypeInternal _DerivativeOrderHistory_default_instance_;
class DerivativePosition;
struct DerivativePositionDefaultTypeInternal;
extern DerivativePositionDefaultTypeInternal _DerivativePosition_default_instance_;
class DerivativeTrade;
struct DerivativeTradeDefaultTypeInternal;
extern DerivativeTradeDefaultTypeInternal _DerivativeTrade_default_instance_;
class ExpiryFuturesMarketInfo;
struct ExpiryFuturesMarketInfoDefaultTypeInternal;
extern ExpiryFuturesMarketInfoDefaultTypeInternal _ExpiryFuturesMarketInfo_default_instance_;
class FundingPayment;
struct FundingPaymentDefaultTypeInternal;
extern FundingPaymentDefaultTypeInternal _FundingPayment_default_instance_;
class FundingPaymentsRequest;
struct FundingPaymentsRequestDefaultTypeInternal;
extern FundingPaymentsRequestDefaultTypeInternal _FundingPaymentsRequest_default_instance_;
class FundingPaymentsResponse;
struct FundingPaymentsResponseDefaultTypeInternal;
extern FundingPaymentsResponseDefaultTypeInternal _FundingPaymentsResponse_default_instance_;
class FundingRate;
struct FundingRateDefaultTypeInternal;
extern FundingRateDefaultTypeInternal _FundingRate_default_instance_;
class FundingRatesRequest;
struct FundingRatesRequestDefaultTypeInternal;
extern FundingRatesRequestDefaultTypeInternal _FundingRatesRequest_default_instance_;
class FundingRatesResponse;
struct FundingRatesResponseDefaultTypeInternal;
extern FundingRatesResponseDefaultTypeInternal _FundingRatesResponse_default_instance_;
class LiquidablePositionsRequest;
struct LiquidablePositionsRequestDefaultTypeInternal;
extern LiquidablePositionsRequestDefaultTypeInternal _LiquidablePositionsRequest_default_instance_;
class LiquidablePositionsResponse;
struct LiquidablePositionsResponseDefaultTypeInternal;
extern LiquidablePositionsResponseDefaultTypeInternal _LiquidablePositionsResponse_default_instance_;
class MarketRequest;
struct MarketRequestDefaultTypeInternal;
extern MarketRequestDefaultTypeInternal _MarketRequest_default_instance_;
class MarketResponse;
struct MarketResponseDefaultTypeInternal;
extern MarketResponseDefaultTypeInternal _MarketResponse_default_instance_;
class MarketsRequest;
struct MarketsRequestDefaultTypeInternal;
extern MarketsRequestDefaultTypeInternal _MarketsRequest_default_instance_;
class MarketsResponse;
struct MarketsResponseDefaultTypeInternal;
extern MarketsResponseDefaultTypeInternal _MarketsResponse_default_instance_;
class OrderbookLevelUpdates;
struct OrderbookLevelUpdatesDefaultTypeInternal;
extern OrderbookLevelUpdatesDefaultTypeInternal _OrderbookLevelUpdates_default_instance_;
class OrderbookRequest;
struct OrderbookRequestDefaultTypeInternal;
extern OrderbookRequestDefaultTypeInternal _OrderbookRequest_default_instance_;
class OrderbookResponse;
struct OrderbookResponseDefaultTypeInternal;
extern OrderbookResponseDefaultTypeInternal _OrderbookResponse_default_instance_;
class OrderbookV2Request;
struct OrderbookV2RequestDefaultTypeInternal;
extern OrderbookV2RequestDefaultTypeInternal _OrderbookV2Request_default_instance_;
class OrderbookV2Response;
struct OrderbookV2ResponseDefaultTypeInternal;
extern OrderbookV2ResponseDefaultTypeInternal _OrderbookV2Response_default_instance_;
class OrderbooksRequest;
struct OrderbooksRequestDefaultTypeInternal;
extern OrderbooksRequestDefaultTypeInternal _OrderbooksRequest_default_instance_;
class OrderbooksResponse;
struct OrderbooksResponseDefaultTypeInternal;
extern OrderbooksResponseDefaultTypeInternal _OrderbooksResponse_default_instance_;
class OrderbooksV2Request;
struct OrderbooksV2RequestDefaultTypeInternal;
extern OrderbooksV2RequestDefaultTypeInternal _OrderbooksV2Request_default_instance_;
class OrderbooksV2Response;
struct OrderbooksV2ResponseDefaultTypeInternal;
extern OrderbooksV2ResponseDefaultTypeInternal _OrderbooksV2Response_default_instance_;
class OrdersHistoryRequest;
struct OrdersHistoryRequestDefaultTypeInternal;
extern OrdersHistoryRequestDefaultTypeInternal _OrdersHistoryRequest_default_instance_;
class OrdersHistoryResponse;
struct OrdersHistoryResponseDefaultTypeInternal;
extern OrdersHistoryResponseDefaultTypeInternal _OrdersHistoryResponse_default_instance_;
class OrdersRequest;
struct OrdersRequestDefaultTypeInternal;
extern OrdersRequestDefaultTypeInternal _OrdersRequest_default_instance_;
class OrdersResponse;
struct OrdersResponseDefaultTypeInternal;
extern OrdersResponseDefaultTypeInternal _OrdersResponse_default_instance_;
class Paging;
struct PagingDefaultTypeInternal;
extern PagingDefaultTypeInternal _Paging_default_instance_;
class PerpetualMarketFunding;
struct PerpetualMarketFundingDefaultTypeInternal;
extern PerpetualMarketFundingDefaultTypeInternal _PerpetualMarketFunding_default_instance_;
class PerpetualMarketInfo;
struct PerpetualMarketInfoDefaultTypeInternal;
extern PerpetualMarketInfoDefaultTypeInternal _PerpetualMarketInfo_default_instance_;
class PositionDelta;
struct PositionDeltaDefaultTypeInternal;
extern PositionDeltaDefaultTypeInternal _PositionDelta_default_instance_;
class PositionsRequest;
struct PositionsRequestDefaultTypeInternal;
extern PositionsRequestDefaultTypeInternal _PositionsRequest_default_instance_;
class PositionsResponse;
struct PositionsResponseDefaultTypeInternal;
extern PositionsResponseDefaultTypeInternal _PositionsResponse_default_instance_;
class PriceLevel;
struct PriceLevelDefaultTypeInternal;
extern PriceLevelDefaultTypeInternal _PriceLevel_default_instance_;
class PriceLevelUpdate;
struct PriceLevelUpdateDefaultTypeInternal;
extern PriceLevelUpdateDefaultTypeInternal _PriceLevelUpdate_default_instance_;
class SingleDerivativeLimitOrderbook;
struct SingleDerivativeLimitOrderbookDefaultTypeInternal;
extern SingleDerivativeLimitOrderbookDefaultTypeInternal _SingleDerivativeLimitOrderbook_default_instance_;
class SingleDerivativeLimitOrderbookV2;
struct SingleDerivativeLimitOrderbookV2DefaultTypeInternal;
extern SingleDerivativeLimitOrderbookV2DefaultTypeInternal _SingleDerivativeLimitOrderbookV2_default_instance_;
class StreamMarketRequest;
struct StreamMarketRequestDefaultTypeInternal;
extern StreamMarketRequestDefaultTypeInternal _StreamMarketRequest_default_instance_;
class StreamMarketResponse;
struct StreamMarketResponseDefaultTypeInternal;
extern StreamMarketResponseDefaultTypeInternal _StreamMarketResponse_default_instance_;
class StreamOrderbookRequest;
struct StreamOrderbookRequestDefaultTypeInternal;
extern StreamOrderbookRequestDefaultTypeInternal _StreamOrderbookRequest_default_instance_;
class StreamOrderbookResponse;
struct StreamOrderbookResponseDefaultTypeInternal;
extern StreamOrderbookResponseDefaultTypeInternal _StreamOrderbookResponse_default_instance_;
class StreamOrderbookUpdateRequest;
struct StreamOrderbookUpdateRequestDefaultTypeInternal;
extern StreamOrderbookUpdateRequestDefaultTypeInternal _StreamOrderbookUpdateRequest_default_instance_;
class StreamOrderbookUpdateResponse;
struct StreamOrderbookUpdateResponseDefaultTypeInternal;
extern StreamOrderbookUpdateResponseDefaultTypeInternal _StreamOrderbookUpdateResponse_default_instance_;
class StreamOrderbookV2Request;
struct StreamOrderbookV2RequestDefaultTypeInternal;
extern StreamOrderbookV2RequestDefaultTypeInternal _StreamOrderbookV2Request_default_instance_;
class StreamOrderbookV2Response;
struct StreamOrderbookV2ResponseDefaultTypeInternal;
extern StreamOrderbookV2ResponseDefaultTypeInternal _StreamOrderbookV2Response_default_instance_;
class StreamOrdersHistoryRequest;
struct StreamOrdersHistoryRequestDefaultTypeInternal;
extern StreamOrdersHistoryRequestDefaultTypeInternal _StreamOrdersHistoryRequest_default_instance_;
class StreamOrdersHistoryResponse;
struct StreamOrdersHistoryResponseDefaultTypeInternal;
extern StreamOrdersHistoryResponseDefaultTypeInternal _StreamOrdersHistoryResponse_default_instance_;
class StreamOrdersRequest;
struct StreamOrdersRequestDefaultTypeInternal;
extern StreamOrdersRequestDefaultTypeInternal _StreamOrdersRequest_default_instance_;
class StreamOrdersResponse;
struct StreamOrdersResponseDefaultTypeInternal;
extern StreamOrdersResponseDefaultTypeInternal _StreamOrdersResponse_default_instance_;
class StreamPositionsRequest;
struct StreamPositionsRequestDefaultTypeInternal;
extern StreamPositionsRequestDefaultTypeInternal _StreamPositionsRequest_default_instance_;
class StreamPositionsResponse;
struct StreamPositionsResponseDefaultTypeInternal;
extern StreamPositionsResponseDefaultTypeInternal _StreamPositionsResponse_default_instance_;
class StreamTradesRequest;
struct StreamTradesRequestDefaultTypeInternal;
extern StreamTradesRequestDefaultTypeInternal _StreamTradesRequest_default_instance_;
class StreamTradesResponse;
struct StreamTradesResponseDefaultTypeInternal;
extern StreamTradesResponseDefaultTypeInternal _StreamTradesResponse_default_instance_;
class SubaccountOrdersListRequest;
struct SubaccountOrdersListRequestDefaultTypeInternal;
extern SubaccountOrdersListRequestDefaultTypeInternal _SubaccountOrdersListRequest_default_instance_;
class SubaccountOrdersListResponse;
struct SubaccountOrdersListResponseDefaultTypeInternal;
extern SubaccountOrdersListResponseDefaultTypeInternal _SubaccountOrdersListResponse_default_instance_;
class SubaccountTradesListRequest;
struct SubaccountTradesListRequestDefaultTypeInternal;
extern SubaccountTradesListRequestDefaultTypeInternal _SubaccountTradesListRequest_default_instance_;
class SubaccountTradesListResponse;
struct SubaccountTradesListResponseDefaultTypeInternal;
extern SubaccountTradesListResponseDefaultTypeInternal _SubaccountTradesListResponse_default_instance_;
class TokenMeta;
struct TokenMetaDefaultTypeInternal;
extern TokenMetaDefaultTypeInternal _TokenMeta_default_instance_;
class TradesRequest;
struct TradesRequestDefaultTypeInternal;
extern TradesRequestDefaultTypeInternal _TradesRequest_default_instance_;
class TradesResponse;
struct TradesResponseDefaultTypeInternal;
extern TradesResponseDefaultTypeInternal _TradesResponse_default_instance_;
}  // namespace injective_derivative_exchange_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>(Arena*);
template <>
::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeLimitOrder* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrder>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbook>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeMarketInfo* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeMarketInfo>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeOrderHistory* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeOrderHistory>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativePosition* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativePosition>(Arena*);
template <>
::injective_derivative_exchange_rpc::DerivativeTrade* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeTrade>(Arena*);
template <>
::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingPayment* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingPayment>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingPaymentsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingPaymentsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingPaymentsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingPaymentsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingRate* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingRate>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingRatesRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingRatesRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::FundingRatesResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::FundingRatesResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::LiquidablePositionsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::LiquidablePositionsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::LiquidablePositionsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::LiquidablePositionsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::MarketRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::MarketRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::MarketResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::MarketResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::MarketsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::MarketsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::MarketsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::MarketsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbookLevelUpdates* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookLevelUpdates>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbookRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbookResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbookV2Request* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookV2Request>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbookV2Response* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookV2Response>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbooksRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbooksRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbooksResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbooksResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbooksV2Request* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbooksV2Request>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrderbooksV2Response* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbooksV2Response>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrdersHistoryRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrdersHistoryRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrdersHistoryResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrdersHistoryResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrdersRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrdersRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::OrdersResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::OrdersResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::Paging* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(Arena*);
template <>
::injective_derivative_exchange_rpc::PerpetualMarketFunding* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PerpetualMarketFunding>(Arena*);
template <>
::injective_derivative_exchange_rpc::PerpetualMarketInfo* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PerpetualMarketInfo>(Arena*);
template <>
::injective_derivative_exchange_rpc::PositionDelta* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PositionDelta>(Arena*);
template <>
::injective_derivative_exchange_rpc::PositionsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PositionsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::PositionsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PositionsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::PriceLevel* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PriceLevel>(Arena*);
template <>
::injective_derivative_exchange_rpc::PriceLevelUpdate* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::PriceLevelUpdate>(Arena*);
template <>
::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook>(Arena*);
template <>
::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamMarketRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamMarketRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamMarketResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamMarketResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookV2Request* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookV2Request>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrderbookV2Response* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrderbookV2Response>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrdersRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrdersRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamOrdersResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamOrdersResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamPositionsRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamPositionsRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamPositionsResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamPositionsResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamTradesRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamTradesRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::StreamTradesResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::StreamTradesResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SubaccountOrdersListRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::SubaccountTradesListRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SubaccountTradesListRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::SubaccountTradesListResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::SubaccountTradesListResponse>(Arena*);
template <>
::injective_derivative_exchange_rpc::TokenMeta* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::TokenMeta>(Arena*);
template <>
::injective_derivative_exchange_rpc::TradesRequest* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::TradesRequest>(Arena*);
template <>
::injective_derivative_exchange_rpc::TradesResponse* Arena::CreateMaybeMessage<::injective_derivative_exchange_rpc::TradesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_derivative_exchange_rpc {

// ===================================================================


// -------------------------------------------------------------------

class MarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.MarketsRequest) */ {
 public:
  inline MarketsRequest() : MarketsRequest(nullptr) {}
  ~MarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketsRequest(const MarketsRequest& from);
  MarketsRequest(MarketsRequest&& from) noexcept
    : MarketsRequest() {
    *this = ::std::move(from);
  }

  inline MarketsRequest& operator=(const MarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketsRequest& operator=(MarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketsRequest* internal_default_instance() {
    return reinterpret_cast<const MarketsRequest*>(
               &_MarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MarketsRequest& a, MarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketsRequest& from) {
    MarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.MarketsRequest";
  }
  protected:
  explicit MarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketStatusFieldNumber = 1,
    kQuoteDenomFieldNumber = 2,
  };
  // string market_status = 1 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string quote_denom = 2 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.MarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.MarketsResponse) */ {
 public:
  inline MarketsResponse() : MarketsResponse(nullptr) {}
  ~MarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketsResponse(const MarketsResponse& from);
  MarketsResponse(MarketsResponse&& from) noexcept
    : MarketsResponse() {
    *this = ::std::move(from);
  }

  inline MarketsResponse& operator=(const MarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketsResponse& operator=(MarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketsResponse* internal_default_instance() {
    return reinterpret_cast<const MarketsResponse*>(
               &_MarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MarketsResponse& a, MarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketsResponse& from) {
    MarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.MarketsResponse";
  }
  protected:
  explicit MarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeMarketInfo >*
      mutable_markets();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& _internal_markets(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeMarketInfo>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeMarketInfo>* _internal_mutable_markets();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& markets(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeMarketInfo >&
      markets() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.MarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeMarketInfo > markets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeMarketInfo) */ {
 public:
  inline DerivativeMarketInfo() : DerivativeMarketInfo(nullptr) {}
  ~DerivativeMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeMarketInfo(const DerivativeMarketInfo& from);
  DerivativeMarketInfo(DerivativeMarketInfo&& from) noexcept
    : DerivativeMarketInfo() {
    *this = ::std::move(from);
  }

  inline DerivativeMarketInfo& operator=(const DerivativeMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeMarketInfo& operator=(DerivativeMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeMarketInfo* internal_default_instance() {
    return reinterpret_cast<const DerivativeMarketInfo*>(
               &_DerivativeMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DerivativeMarketInfo& a, DerivativeMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeMarketInfo& from) {
    DerivativeMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeMarketInfo";
  }
  protected:
  explicit DerivativeMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kMarketStatusFieldNumber = 2,
    kTickerFieldNumber = 3,
    kOracleBaseFieldNumber = 4,
    kOracleQuoteFieldNumber = 5,
    kOracleTypeFieldNumber = 6,
    kInitialMarginRatioFieldNumber = 8,
    kMaintenanceMarginRatioFieldNumber = 9,
    kQuoteDenomFieldNumber = 10,
    kMakerFeeRateFieldNumber = 12,
    kTakerFeeRateFieldNumber = 13,
    kServiceProviderFeeFieldNumber = 14,
    kMinPriceTickSizeFieldNumber = 16,
    kMinQuantityTickSizeFieldNumber = 17,
    kQuoteTokenMetaFieldNumber = 11,
    kPerpetualMarketInfoFieldNumber = 18,
    kPerpetualMarketFundingFieldNumber = 19,
    kExpiryFuturesMarketInfoFieldNumber = 20,
    kOracleScaleFactorFieldNumber = 7,
    kIsPerpetualFieldNumber = 15,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string market_status = 2 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_base = 4 [json_name = "oracleBase"];
  void clear_oracle_base() ;
  const std::string& oracle_base() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_base(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_base();
  PROTOBUF_NODISCARD std::string* release_oracle_base();
  void set_allocated_oracle_base(std::string* ptr);

  private:
  const std::string& _internal_oracle_base() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_base(
      const std::string& value);
  std::string* _internal_mutable_oracle_base();

  public:
  // string oracle_quote = 5 [json_name = "oracleQuote"];
  void clear_oracle_quote() ;
  const std::string& oracle_quote() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_quote(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_quote();
  PROTOBUF_NODISCARD std::string* release_oracle_quote();
  void set_allocated_oracle_quote(std::string* ptr);

  private:
  const std::string& _internal_oracle_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_quote(
      const std::string& value);
  std::string* _internal_mutable_oracle_quote();

  public:
  // string oracle_type = 6 [json_name = "oracleType"];
  void clear_oracle_type() ;
  const std::string& oracle_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_type(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_type();
  PROTOBUF_NODISCARD std::string* release_oracle_type();
  void set_allocated_oracle_type(std::string* ptr);

  private:
  const std::string& _internal_oracle_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_type(
      const std::string& value);
  std::string* _internal_mutable_oracle_type();

  public:
  // string initial_margin_ratio = 8 [json_name = "initialMarginRatio"];
  void clear_initial_margin_ratio() ;
  const std::string& initial_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_initial_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_initial_margin_ratio();
  void set_allocated_initial_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_initial_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_initial_margin_ratio();

  public:
  // string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio"];
  void clear_maintenance_margin_ratio() ;
  const std::string& maintenance_margin_ratio() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maintenance_margin_ratio(Arg_&& arg, Args_... args);
  std::string* mutable_maintenance_margin_ratio();
  PROTOBUF_NODISCARD std::string* release_maintenance_margin_ratio();
  void set_allocated_maintenance_margin_ratio(std::string* ptr);

  private:
  const std::string& _internal_maintenance_margin_ratio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maintenance_margin_ratio(
      const std::string& value);
  std::string* _internal_mutable_maintenance_margin_ratio();

  public:
  // string quote_denom = 10 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string maker_fee_rate = 12 [json_name = "makerFeeRate"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 13 [json_name = "takerFeeRate"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string service_provider_fee = 14 [json_name = "serviceProviderFee"];
  void clear_service_provider_fee() ;
  const std::string& service_provider_fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_provider_fee(Arg_&& arg, Args_... args);
  std::string* mutable_service_provider_fee();
  PROTOBUF_NODISCARD std::string* release_service_provider_fee();
  void set_allocated_service_provider_fee(std::string* ptr);

  private:
  const std::string& _internal_service_provider_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_provider_fee(
      const std::string& value);
  std::string* _internal_mutable_service_provider_fee();

  public:
  // string min_price_tick_size = 16 [json_name = "minPriceTickSize"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 17 [json_name = "minQuantityTickSize"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11 [json_name = "quoteTokenMeta"];
  bool has_quote_token_meta() const;
  void clear_quote_token_meta() ;
  const ::injective_derivative_exchange_rpc::TokenMeta& quote_token_meta() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::TokenMeta* release_quote_token_meta();
  ::injective_derivative_exchange_rpc::TokenMeta* mutable_quote_token_meta();
  void set_allocated_quote_token_meta(::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta);
  private:
  const ::injective_derivative_exchange_rpc::TokenMeta& _internal_quote_token_meta() const;
  ::injective_derivative_exchange_rpc::TokenMeta* _internal_mutable_quote_token_meta();
  public:
  void unsafe_arena_set_allocated_quote_token_meta(
      ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta);
  ::injective_derivative_exchange_rpc::TokenMeta* unsafe_arena_release_quote_token_meta();
  // .injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18 [json_name = "perpetualMarketInfo"];
  bool has_perpetual_market_info() const;
  void clear_perpetual_market_info() ;
  const ::injective_derivative_exchange_rpc::PerpetualMarketInfo& perpetual_market_info() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::PerpetualMarketInfo* release_perpetual_market_info();
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* mutable_perpetual_market_info();
  void set_allocated_perpetual_market_info(::injective_derivative_exchange_rpc::PerpetualMarketInfo* perpetual_market_info);
  private:
  const ::injective_derivative_exchange_rpc::PerpetualMarketInfo& _internal_perpetual_market_info() const;
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* _internal_mutable_perpetual_market_info();
  public:
  void unsafe_arena_set_allocated_perpetual_market_info(
      ::injective_derivative_exchange_rpc::PerpetualMarketInfo* perpetual_market_info);
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* unsafe_arena_release_perpetual_market_info();
  // .injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19 [json_name = "perpetualMarketFunding"];
  bool has_perpetual_market_funding() const;
  void clear_perpetual_market_funding() ;
  const ::injective_derivative_exchange_rpc::PerpetualMarketFunding& perpetual_market_funding() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::PerpetualMarketFunding* release_perpetual_market_funding();
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* mutable_perpetual_market_funding();
  void set_allocated_perpetual_market_funding(::injective_derivative_exchange_rpc::PerpetualMarketFunding* perpetual_market_funding);
  private:
  const ::injective_derivative_exchange_rpc::PerpetualMarketFunding& _internal_perpetual_market_funding() const;
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* _internal_mutable_perpetual_market_funding();
  public:
  void unsafe_arena_set_allocated_perpetual_market_funding(
      ::injective_derivative_exchange_rpc::PerpetualMarketFunding* perpetual_market_funding);
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* unsafe_arena_release_perpetual_market_funding();
  // .injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20 [json_name = "expiryFuturesMarketInfo"];
  bool has_expiry_futures_market_info() const;
  void clear_expiry_futures_market_info() ;
  const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo& expiry_futures_market_info() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* release_expiry_futures_market_info();
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* mutable_expiry_futures_market_info();
  void set_allocated_expiry_futures_market_info(::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* expiry_futures_market_info);
  private:
  const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo& _internal_expiry_futures_market_info() const;
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* _internal_mutable_expiry_futures_market_info();
  public:
  void unsafe_arena_set_allocated_expiry_futures_market_info(
      ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* expiry_futures_market_info);
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* unsafe_arena_release_expiry_futures_market_info();
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // bool is_perpetual = 15 [json_name = "isPerpetual"];
  void clear_is_perpetual() ;
  bool is_perpetual() const;
  void set_is_perpetual(bool value);

  private:
  bool _internal_is_perpetual() const;
  void _internal_set_is_perpetual(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_base_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maintenance_margin_ratio_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_provider_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta_;
    ::injective_derivative_exchange_rpc::PerpetualMarketInfo* perpetual_market_info_;
    ::injective_derivative_exchange_rpc::PerpetualMarketFunding* perpetual_market_funding_;
    ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* expiry_futures_market_info_;
    ::uint32_t oracle_scale_factor_;
    bool is_perpetual_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TokenMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.TokenMeta) */ {
 public:
  inline TokenMeta() : TokenMeta(nullptr) {}
  ~TokenMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TokenMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenMeta(const TokenMeta& from);
  TokenMeta(TokenMeta&& from) noexcept
    : TokenMeta() {
    *this = ::std::move(from);
  }

  inline TokenMeta& operator=(const TokenMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenMeta& operator=(TokenMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenMeta* internal_default_instance() {
    return reinterpret_cast<const TokenMeta*>(
               &_TokenMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TokenMeta& a, TokenMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenMeta& from) {
    TokenMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.TokenMeta";
  }
  protected:
  explicit TokenMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kSymbolFieldNumber = 3,
    kLogoFieldNumber = 4,
    kUpdatedAtFieldNumber = 6,
    kDecimalsFieldNumber = 5,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string symbol = 3 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string logo = 4 [json_name = "logo"];
  void clear_logo() ;
  const std::string& logo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logo(Arg_&& arg, Args_... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* ptr);

  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(
      const std::string& value);
  std::string* _internal_mutable_logo();

  public:
  // sint64 updated_at = 6 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // sint32 decimals = 5 [json_name = "decimals"];
  void clear_decimals() ;
  ::int32_t decimals() const;
  void set_decimals(::int32_t value);

  private:
  ::int32_t _internal_decimals() const;
  void _internal_set_decimals(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.TokenMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::int64_t updated_at_;
    ::int32_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PerpetualMarketInfo) */ {
 public:
  inline PerpetualMarketInfo() : PerpetualMarketInfo(nullptr) {}
  ~PerpetualMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketInfo(const PerpetualMarketInfo& from);
  PerpetualMarketInfo(PerpetualMarketInfo&& from) noexcept
    : PerpetualMarketInfo() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketInfo& operator=(const PerpetualMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketInfo& operator=(PerpetualMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketInfo* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketInfo*>(
               &_PerpetualMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PerpetualMarketInfo& a, PerpetualMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketInfo& from) {
    PerpetualMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PerpetualMarketInfo";
  }
  protected:
  explicit PerpetualMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHourlyFundingRateCapFieldNumber = 1,
    kHourlyInterestRateFieldNumber = 2,
    kNextFundingTimestampFieldNumber = 3,
    kFundingIntervalFieldNumber = 4,
  };
  // string hourly_funding_rate_cap = 1 [json_name = "hourlyFundingRateCap"];
  void clear_hourly_funding_rate_cap() ;
  const std::string& hourly_funding_rate_cap() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourly_funding_rate_cap(Arg_&& arg, Args_... args);
  std::string* mutable_hourly_funding_rate_cap();
  PROTOBUF_NODISCARD std::string* release_hourly_funding_rate_cap();
  void set_allocated_hourly_funding_rate_cap(std::string* ptr);

  private:
  const std::string& _internal_hourly_funding_rate_cap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourly_funding_rate_cap(
      const std::string& value);
  std::string* _internal_mutable_hourly_funding_rate_cap();

  public:
  // string hourly_interest_rate = 2 [json_name = "hourlyInterestRate"];
  void clear_hourly_interest_rate() ;
  const std::string& hourly_interest_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hourly_interest_rate(Arg_&& arg, Args_... args);
  std::string* mutable_hourly_interest_rate();
  PROTOBUF_NODISCARD std::string* release_hourly_interest_rate();
  void set_allocated_hourly_interest_rate(std::string* ptr);

  private:
  const std::string& _internal_hourly_interest_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hourly_interest_rate(
      const std::string& value);
  std::string* _internal_mutable_hourly_interest_rate();

  public:
  // sint64 next_funding_timestamp = 3 [json_name = "nextFundingTimestamp"];
  void clear_next_funding_timestamp() ;
  ::int64_t next_funding_timestamp() const;
  void set_next_funding_timestamp(::int64_t value);

  private:
  ::int64_t _internal_next_funding_timestamp() const;
  void _internal_set_next_funding_timestamp(::int64_t value);

  public:
  // sint64 funding_interval = 4 [json_name = "fundingInterval"];
  void clear_funding_interval() ;
  ::int64_t funding_interval() const;
  void set_funding_interval(::int64_t value);

  private:
  ::int64_t _internal_funding_interval() const;
  void _internal_set_funding_interval(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PerpetualMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourly_funding_rate_cap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hourly_interest_rate_;
    ::int64_t next_funding_timestamp_;
    ::int64_t funding_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PerpetualMarketFunding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PerpetualMarketFunding) */ {
 public:
  inline PerpetualMarketFunding() : PerpetualMarketFunding(nullptr) {}
  ~PerpetualMarketFunding() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PerpetualMarketFunding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerpetualMarketFunding(const PerpetualMarketFunding& from);
  PerpetualMarketFunding(PerpetualMarketFunding&& from) noexcept
    : PerpetualMarketFunding() {
    *this = ::std::move(from);
  }

  inline PerpetualMarketFunding& operator=(const PerpetualMarketFunding& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerpetualMarketFunding& operator=(PerpetualMarketFunding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerpetualMarketFunding& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerpetualMarketFunding* internal_default_instance() {
    return reinterpret_cast<const PerpetualMarketFunding*>(
               &_PerpetualMarketFunding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PerpetualMarketFunding& a, PerpetualMarketFunding& b) {
    a.Swap(&b);
  }
  inline void Swap(PerpetualMarketFunding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerpetualMarketFunding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerpetualMarketFunding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerpetualMarketFunding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerpetualMarketFunding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerpetualMarketFunding& from) {
    PerpetualMarketFunding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerpetualMarketFunding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PerpetualMarketFunding";
  }
  protected:
  explicit PerpetualMarketFunding(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCumulativeFundingFieldNumber = 1,
    kCumulativePriceFieldNumber = 2,
    kLastTimestampFieldNumber = 3,
  };
  // string cumulative_funding = 1 [json_name = "cumulativeFunding"];
  void clear_cumulative_funding() ;
  const std::string& cumulative_funding() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_funding(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_funding();
  PROTOBUF_NODISCARD std::string* release_cumulative_funding();
  void set_allocated_cumulative_funding(std::string* ptr);

  private:
  const std::string& _internal_cumulative_funding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_funding(
      const std::string& value);
  std::string* _internal_mutable_cumulative_funding();

  public:
  // string cumulative_price = 2 [json_name = "cumulativePrice"];
  void clear_cumulative_price() ;
  const std::string& cumulative_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cumulative_price(Arg_&& arg, Args_... args);
  std::string* mutable_cumulative_price();
  PROTOBUF_NODISCARD std::string* release_cumulative_price();
  void set_allocated_cumulative_price(std::string* ptr);

  private:
  const std::string& _internal_cumulative_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cumulative_price(
      const std::string& value);
  std::string* _internal_mutable_cumulative_price();

  public:
  // sint64 last_timestamp = 3 [json_name = "lastTimestamp"];
  void clear_last_timestamp() ;
  ::int64_t last_timestamp() const;
  void set_last_timestamp(::int64_t value);

  private:
  ::int64_t _internal_last_timestamp() const;
  void _internal_set_last_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PerpetualMarketFunding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_funding_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cumulative_price_;
    ::int64_t last_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class ExpiryFuturesMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo) */ {
 public:
  inline ExpiryFuturesMarketInfo() : ExpiryFuturesMarketInfo(nullptr) {}
  ~ExpiryFuturesMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExpiryFuturesMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpiryFuturesMarketInfo(const ExpiryFuturesMarketInfo& from);
  ExpiryFuturesMarketInfo(ExpiryFuturesMarketInfo&& from) noexcept
    : ExpiryFuturesMarketInfo() {
    *this = ::std::move(from);
  }

  inline ExpiryFuturesMarketInfo& operator=(const ExpiryFuturesMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpiryFuturesMarketInfo& operator=(ExpiryFuturesMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpiryFuturesMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpiryFuturesMarketInfo* internal_default_instance() {
    return reinterpret_cast<const ExpiryFuturesMarketInfo*>(
               &_ExpiryFuturesMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExpiryFuturesMarketInfo& a, ExpiryFuturesMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpiryFuturesMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpiryFuturesMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpiryFuturesMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpiryFuturesMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpiryFuturesMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpiryFuturesMarketInfo& from) {
    ExpiryFuturesMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpiryFuturesMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo";
  }
  protected:
  explicit ExpiryFuturesMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettlementPriceFieldNumber = 2,
    kExpirationTimestampFieldNumber = 1,
  };
  // string settlement_price = 2 [json_name = "settlementPrice"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // sint64 expiration_timestamp = 1 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    ::int64_t expiration_timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.MarketRequest) */ {
 public:
  inline MarketRequest() : MarketRequest(nullptr) {}
  ~MarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketRequest(const MarketRequest& from);
  MarketRequest(MarketRequest&& from) noexcept
    : MarketRequest() {
    *this = ::std::move(from);
  }

  inline MarketRequest& operator=(const MarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketRequest& operator=(MarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketRequest* internal_default_instance() {
    return reinterpret_cast<const MarketRequest*>(
               &_MarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MarketRequest& a, MarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketRequest& from) {
    MarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.MarketRequest";
  }
  protected:
  explicit MarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.MarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class MarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.MarketResponse) */ {
 public:
  inline MarketResponse() : MarketResponse(nullptr) {}
  ~MarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketResponse(const MarketResponse& from);
  MarketResponse(MarketResponse&& from) noexcept
    : MarketResponse() {
    *this = ::std::move(from);
  }

  inline MarketResponse& operator=(const MarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketResponse& operator=(MarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketResponse* internal_default_instance() {
    return reinterpret_cast<const MarketResponse*>(
               &_MarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MarketResponse& a, MarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketResponse& from) {
    MarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.MarketResponse";
  }
  protected:
  explicit MarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& market() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeMarketInfo* release_market();
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* mutable_market();
  void set_allocated_market(::injective_derivative_exchange_rpc::DerivativeMarketInfo* market);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& _internal_market() const;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market);
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.MarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamMarketRequest) */ {
 public:
  inline StreamMarketRequest() : StreamMarketRequest(nullptr) {}
  ~StreamMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMarketRequest(const StreamMarketRequest& from);
  StreamMarketRequest(StreamMarketRequest&& from) noexcept
    : StreamMarketRequest() {
    *this = ::std::move(from);
  }

  inline StreamMarketRequest& operator=(const StreamMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMarketRequest& operator=(StreamMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamMarketRequest* internal_default_instance() {
    return reinterpret_cast<const StreamMarketRequest*>(
               &_StreamMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StreamMarketRequest& a, StreamMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamMarketRequest& from) {
    StreamMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamMarketRequest";
  }
  protected:
  explicit StreamMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamMarketResponse) */ {
 public:
  inline StreamMarketResponse() : StreamMarketResponse(nullptr) {}
  ~StreamMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamMarketResponse(const StreamMarketResponse& from);
  StreamMarketResponse(StreamMarketResponse&& from) noexcept
    : StreamMarketResponse() {
    *this = ::std::move(from);
  }

  inline StreamMarketResponse& operator=(const StreamMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMarketResponse& operator=(StreamMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamMarketResponse* internal_default_instance() {
    return reinterpret_cast<const StreamMarketResponse*>(
               &_StreamMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StreamMarketResponse& a, StreamMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamMarketResponse& from) {
    StreamMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamMarketResponse";
  }
  protected:
  explicit StreamMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& market() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeMarketInfo* release_market();
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* mutable_market();
  void set_allocated_market(::injective_derivative_exchange_rpc::DerivativeMarketInfo* market);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& _internal_market() const;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market);
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* unsafe_arena_release_market();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest) */ {
 public:
  inline BinaryOptionsMarketsRequest() : BinaryOptionsMarketsRequest(nullptr) {}
  ~BinaryOptionsMarketsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketsRequest(const BinaryOptionsMarketsRequest& from);
  BinaryOptionsMarketsRequest(BinaryOptionsMarketsRequest&& from) noexcept
    : BinaryOptionsMarketsRequest() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketsRequest& operator=(const BinaryOptionsMarketsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketsRequest& operator=(BinaryOptionsMarketsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketsRequest* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketsRequest*>(
               &_BinaryOptionsMarketsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BinaryOptionsMarketsRequest& a, BinaryOptionsMarketsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketsRequest& from) {
    BinaryOptionsMarketsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest";
  }
  protected:
  explicit BinaryOptionsMarketsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketStatusFieldNumber = 1,
    kQuoteDenomFieldNumber = 2,
    kSkipFieldNumber = 3,
    kLimitFieldNumber = 4,
  };
  // string market_status = 1 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string quote_denom = 2 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse) */ {
 public:
  inline BinaryOptionsMarketsResponse() : BinaryOptionsMarketsResponse(nullptr) {}
  ~BinaryOptionsMarketsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketsResponse(const BinaryOptionsMarketsResponse& from);
  BinaryOptionsMarketsResponse(BinaryOptionsMarketsResponse&& from) noexcept
    : BinaryOptionsMarketsResponse() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketsResponse& operator=(const BinaryOptionsMarketsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketsResponse& operator=(BinaryOptionsMarketsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketsResponse* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketsResponse*>(
               &_BinaryOptionsMarketsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BinaryOptionsMarketsResponse& a, BinaryOptionsMarketsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketsResponse& from) {
    BinaryOptionsMarketsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse";
  }
  protected:
  explicit BinaryOptionsMarketsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketsFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1 [json_name = "markets"];
  int markets_size() const;
  private:
  int _internal_markets_size() const;

  public:
  void clear_markets() ;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* mutable_markets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo >*
      mutable_markets();
  private:
  const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& _internal_markets(int index) const;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* _internal_add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>& _internal_markets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>* _internal_mutable_markets();
  public:
  const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& markets(int index) const;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* add_markets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo >&
      markets() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo > markets_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo) */ {
 public:
  inline BinaryOptionsMarketInfo() : BinaryOptionsMarketInfo(nullptr) {}
  ~BinaryOptionsMarketInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketInfo(const BinaryOptionsMarketInfo& from);
  BinaryOptionsMarketInfo(BinaryOptionsMarketInfo&& from) noexcept
    : BinaryOptionsMarketInfo() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketInfo& operator=(const BinaryOptionsMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketInfo& operator=(BinaryOptionsMarketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketInfo* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketInfo*>(
               &_BinaryOptionsMarketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BinaryOptionsMarketInfo& a, BinaryOptionsMarketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketInfo& from) {
    BinaryOptionsMarketInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.BinaryOptionsMarketInfo";
  }
  protected:
  explicit BinaryOptionsMarketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kMarketStatusFieldNumber = 2,
    kTickerFieldNumber = 3,
    kOracleSymbolFieldNumber = 4,
    kOracleProviderFieldNumber = 5,
    kOracleTypeFieldNumber = 6,
    kQuoteDenomFieldNumber = 10,
    kMakerFeeRateFieldNumber = 12,
    kTakerFeeRateFieldNumber = 13,
    kServiceProviderFeeFieldNumber = 14,
    kMinPriceTickSizeFieldNumber = 15,
    kMinQuantityTickSizeFieldNumber = 16,
    kSettlementPriceFieldNumber = 17,
    kQuoteTokenMetaFieldNumber = 11,
    kExpirationTimestampFieldNumber = 8,
    kSettlementTimestampFieldNumber = 9,
    kOracleScaleFactorFieldNumber = 7,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string market_status = 2 [json_name = "marketStatus"];
  void clear_market_status() ;
  const std::string& market_status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_status(Arg_&& arg, Args_... args);
  std::string* mutable_market_status();
  PROTOBUF_NODISCARD std::string* release_market_status();
  void set_allocated_market_status(std::string* ptr);

  private:
  const std::string& _internal_market_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_status(
      const std::string& value);
  std::string* _internal_mutable_market_status();

  public:
  // string ticker = 3 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string oracle_symbol = 4 [json_name = "oracleSymbol"];
  void clear_oracle_symbol() ;
  const std::string& oracle_symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_symbol();
  PROTOBUF_NODISCARD std::string* release_oracle_symbol();
  void set_allocated_oracle_symbol(std::string* ptr);

  private:
  const std::string& _internal_oracle_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_symbol(
      const std::string& value);
  std::string* _internal_mutable_oracle_symbol();

  public:
  // string oracle_provider = 5 [json_name = "oracleProvider"];
  void clear_oracle_provider() ;
  const std::string& oracle_provider() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_provider(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_provider();
  PROTOBUF_NODISCARD std::string* release_oracle_provider();
  void set_allocated_oracle_provider(std::string* ptr);

  private:
  const std::string& _internal_oracle_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_provider(
      const std::string& value);
  std::string* _internal_mutable_oracle_provider();

  public:
  // string oracle_type = 6 [json_name = "oracleType"];
  void clear_oracle_type() ;
  const std::string& oracle_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oracle_type(Arg_&& arg, Args_... args);
  std::string* mutable_oracle_type();
  PROTOBUF_NODISCARD std::string* release_oracle_type();
  void set_allocated_oracle_type(std::string* ptr);

  private:
  const std::string& _internal_oracle_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oracle_type(
      const std::string& value);
  std::string* _internal_mutable_oracle_type();

  public:
  // string quote_denom = 10 [json_name = "quoteDenom"];
  void clear_quote_denom() ;
  const std::string& quote_denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quote_denom(Arg_&& arg, Args_... args);
  std::string* mutable_quote_denom();
  PROTOBUF_NODISCARD std::string* release_quote_denom();
  void set_allocated_quote_denom(std::string* ptr);

  private:
  const std::string& _internal_quote_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote_denom(
      const std::string& value);
  std::string* _internal_mutable_quote_denom();

  public:
  // string maker_fee_rate = 12 [json_name = "makerFeeRate"];
  void clear_maker_fee_rate() ;
  const std::string& maker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_maker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_maker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_maker_fee_rate();
  void set_allocated_maker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_maker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_maker_fee_rate();

  public:
  // string taker_fee_rate = 13 [json_name = "takerFeeRate"];
  void clear_taker_fee_rate() ;
  const std::string& taker_fee_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taker_fee_rate(Arg_&& arg, Args_... args);
  std::string* mutable_taker_fee_rate();
  PROTOBUF_NODISCARD std::string* release_taker_fee_rate();
  void set_allocated_taker_fee_rate(std::string* ptr);

  private:
  const std::string& _internal_taker_fee_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taker_fee_rate(
      const std::string& value);
  std::string* _internal_mutable_taker_fee_rate();

  public:
  // string service_provider_fee = 14 [json_name = "serviceProviderFee"];
  void clear_service_provider_fee() ;
  const std::string& service_provider_fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_provider_fee(Arg_&& arg, Args_... args);
  std::string* mutable_service_provider_fee();
  PROTOBUF_NODISCARD std::string* release_service_provider_fee();
  void set_allocated_service_provider_fee(std::string* ptr);

  private:
  const std::string& _internal_service_provider_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_provider_fee(
      const std::string& value);
  std::string* _internal_mutable_service_provider_fee();

  public:
  // string min_price_tick_size = 15 [json_name = "minPriceTickSize"];
  void clear_min_price_tick_size() ;
  const std::string& min_price_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_price_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_price_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_price_tick_size();
  void set_allocated_min_price_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_price_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_price_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_price_tick_size();

  public:
  // string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize"];
  void clear_min_quantity_tick_size() ;
  const std::string& min_quantity_tick_size() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_min_quantity_tick_size(Arg_&& arg, Args_... args);
  std::string* mutable_min_quantity_tick_size();
  PROTOBUF_NODISCARD std::string* release_min_quantity_tick_size();
  void set_allocated_min_quantity_tick_size(std::string* ptr);

  private:
  const std::string& _internal_min_quantity_tick_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_quantity_tick_size(
      const std::string& value);
  std::string* _internal_mutable_min_quantity_tick_size();

  public:
  // string settlement_price = 17 [json_name = "settlementPrice"];
  void clear_settlement_price() ;
  const std::string& settlement_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_settlement_price(Arg_&& arg, Args_... args);
  std::string* mutable_settlement_price();
  PROTOBUF_NODISCARD std::string* release_settlement_price();
  void set_allocated_settlement_price(std::string* ptr);

  private:
  const std::string& _internal_settlement_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_settlement_price(
      const std::string& value);
  std::string* _internal_mutable_settlement_price();

  public:
  // .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11 [json_name = "quoteTokenMeta"];
  bool has_quote_token_meta() const;
  void clear_quote_token_meta() ;
  const ::injective_derivative_exchange_rpc::TokenMeta& quote_token_meta() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::TokenMeta* release_quote_token_meta();
  ::injective_derivative_exchange_rpc::TokenMeta* mutable_quote_token_meta();
  void set_allocated_quote_token_meta(::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta);
  private:
  const ::injective_derivative_exchange_rpc::TokenMeta& _internal_quote_token_meta() const;
  ::injective_derivative_exchange_rpc::TokenMeta* _internal_mutable_quote_token_meta();
  public:
  void unsafe_arena_set_allocated_quote_token_meta(
      ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta);
  ::injective_derivative_exchange_rpc::TokenMeta* unsafe_arena_release_quote_token_meta();
  // sint64 expiration_timestamp = 8 [json_name = "expirationTimestamp"];
  void clear_expiration_timestamp() ;
  ::int64_t expiration_timestamp() const;
  void set_expiration_timestamp(::int64_t value);

  private:
  ::int64_t _internal_expiration_timestamp() const;
  void _internal_set_expiration_timestamp(::int64_t value);

  public:
  // sint64 settlement_timestamp = 9 [json_name = "settlementTimestamp"];
  void clear_settlement_timestamp() ;
  ::int64_t settlement_timestamp() const;
  void set_settlement_timestamp(::int64_t value);

  private:
  ::int64_t _internal_settlement_timestamp() const;
  void _internal_set_settlement_timestamp(::int64_t value);

  public:
  // uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
  void clear_oracle_scale_factor() ;
  ::uint32_t oracle_scale_factor() const;
  void set_oracle_scale_factor(::uint32_t value);

  private:
  ::uint32_t _internal_oracle_scale_factor() const;
  void _internal_set_oracle_scale_factor(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oracle_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taker_fee_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_provider_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_price_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_quantity_tick_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_;
    ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta_;
    ::int64_t expiration_timestamp_;
    ::int64_t settlement_timestamp_;
    ::uint32_t oracle_scale_factor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class Paging final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.Paging) */ {
 public:
  inline Paging() : Paging(nullptr) {}
  ~Paging() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Paging(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paging(const Paging& from);
  Paging(Paging&& from) noexcept
    : Paging() {
    *this = ::std::move(from);
  }

  inline Paging& operator=(const Paging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paging& operator=(Paging&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paging& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paging* internal_default_instance() {
    return reinterpret_cast<const Paging*>(
               &_Paging_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Paging& a, Paging& b) {
    a.Swap(&b);
  }
  inline void Swap(Paging* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paging* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Paging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Paging>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paging& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Paging& from) {
    Paging::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paging* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.Paging";
  }
  protected:
  explicit Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kCountBySubaccountFieldNumber = 4,
  };
  // sint64 total = 1 [json_name = "total"];
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // sint32 from = 2 [json_name = "from"];
  void clear_from() ;
  ::int32_t from() const;
  void set_from(::int32_t value);

  private:
  ::int32_t _internal_from() const;
  void _internal_set_from(::int32_t value);

  public:
  // sint32 to = 3 [json_name = "to"];
  void clear_to() ;
  ::int32_t to() const;
  void set_to(::int32_t value);

  private:
  ::int32_t _internal_to() const;
  void _internal_set_to(::int32_t value);

  public:
  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  void clear_count_by_subaccount() ;
  ::int64_t count_by_subaccount() const;
  void set_count_by_subaccount(::int64_t value);

  private:
  ::int64_t _internal_count_by_subaccount() const;
  void _internal_set_count_by_subaccount(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.Paging)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t total_;
    ::int32_t from_;
    ::int32_t to_;
    ::int64_t count_by_subaccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest) */ {
 public:
  inline BinaryOptionsMarketRequest() : BinaryOptionsMarketRequest(nullptr) {}
  ~BinaryOptionsMarketRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketRequest(const BinaryOptionsMarketRequest& from);
  BinaryOptionsMarketRequest(BinaryOptionsMarketRequest&& from) noexcept
    : BinaryOptionsMarketRequest() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketRequest& operator=(const BinaryOptionsMarketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketRequest& operator=(BinaryOptionsMarketRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketRequest* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketRequest*>(
               &_BinaryOptionsMarketRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BinaryOptionsMarketRequest& a, BinaryOptionsMarketRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketRequest& from) {
    BinaryOptionsMarketRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.BinaryOptionsMarketRequest";
  }
  protected:
  explicit BinaryOptionsMarketRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BinaryOptionsMarketResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse) */ {
 public:
  inline BinaryOptionsMarketResponse() : BinaryOptionsMarketResponse(nullptr) {}
  ~BinaryOptionsMarketResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryOptionsMarketResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryOptionsMarketResponse(const BinaryOptionsMarketResponse& from);
  BinaryOptionsMarketResponse(BinaryOptionsMarketResponse&& from) noexcept
    : BinaryOptionsMarketResponse() {
    *this = ::std::move(from);
  }

  inline BinaryOptionsMarketResponse& operator=(const BinaryOptionsMarketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryOptionsMarketResponse& operator=(BinaryOptionsMarketResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryOptionsMarketResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryOptionsMarketResponse* internal_default_instance() {
    return reinterpret_cast<const BinaryOptionsMarketResponse*>(
               &_BinaryOptionsMarketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BinaryOptionsMarketResponse& a, BinaryOptionsMarketResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryOptionsMarketResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryOptionsMarketResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryOptionsMarketResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryOptionsMarketResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryOptionsMarketResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryOptionsMarketResponse& from) {
    BinaryOptionsMarketResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryOptionsMarketResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.BinaryOptionsMarketResponse";
  }
  protected:
  explicit BinaryOptionsMarketResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketFieldNumber = 1,
  };
  // .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1 [json_name = "market"];
  bool has_market() const;
  void clear_market() ;
  const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& market() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* release_market();
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* mutable_market();
  void set_allocated_market(::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* market);
  private:
  const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& _internal_market() const;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* _internal_mutable_market();
  public:
  void unsafe_arena_set_allocated_market(
      ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* market);
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* unsafe_arena_release_market();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* market_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbookRequest) */ {
 public:
  inline OrderbookRequest() : OrderbookRequest(nullptr) {}
  ~OrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookRequest(const OrderbookRequest& from);
  OrderbookRequest(OrderbookRequest&& from) noexcept
    : OrderbookRequest() {
    *this = ::std::move(from);
  }

  inline OrderbookRequest& operator=(const OrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookRequest& operator=(OrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const OrderbookRequest*>(
               &_OrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OrderbookRequest& a, OrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookRequest& from) {
    OrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbookRequest";
  }
  protected:
  explicit OrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbookResponse) */ {
 public:
  inline OrderbookResponse() : OrderbookResponse(nullptr) {}
  ~OrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookResponse(const OrderbookResponse& from);
  OrderbookResponse(OrderbookResponse&& from) noexcept
    : OrderbookResponse() {
    *this = ::std::move(from);
  }

  inline OrderbookResponse& operator=(const OrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookResponse& operator=(OrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const OrderbookResponse*>(
               &_OrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OrderbookResponse& a, OrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookResponse& from) {
    OrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbookResponse";
  }
  protected:
  explicit OrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbookFieldNumber = 1,
  };
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeLimitOrderbook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeLimitOrderbook) */ {
 public:
  inline DerivativeLimitOrderbook() : DerivativeLimitOrderbook(nullptr) {}
  ~DerivativeLimitOrderbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeLimitOrderbook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeLimitOrderbook(const DerivativeLimitOrderbook& from);
  DerivativeLimitOrderbook(DerivativeLimitOrderbook&& from) noexcept
    : DerivativeLimitOrderbook() {
    *this = ::std::move(from);
  }

  inline DerivativeLimitOrderbook& operator=(const DerivativeLimitOrderbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeLimitOrderbook& operator=(DerivativeLimitOrderbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeLimitOrderbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeLimitOrderbook* internal_default_instance() {
    return reinterpret_cast<const DerivativeLimitOrderbook*>(
               &_DerivativeLimitOrderbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DerivativeLimitOrderbook& a, DerivativeLimitOrderbook& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeLimitOrderbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeLimitOrderbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeLimitOrderbook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeLimitOrderbook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeLimitOrderbook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeLimitOrderbook& from) {
    DerivativeLimitOrderbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeLimitOrderbook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeLimitOrderbook";
  }
  protected:
  explicit DerivativeLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 1,
    kSellsFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_derivative_exchange_rpc::PriceLevel* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
      mutable_buys();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevel& _internal_buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>* _internal_mutable_buys();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevel& buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
      buys() const;
  // repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_derivative_exchange_rpc::PriceLevel* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
      mutable_sells();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevel& _internal_sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>* _internal_mutable_sells();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevel& sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
      sells() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeLimitOrderbook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel > sells_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PriceLevel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PriceLevel) */ {
 public:
  inline PriceLevel() : PriceLevel(nullptr) {}
  ~PriceLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceLevel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceLevel(const PriceLevel& from);
  PriceLevel(PriceLevel&& from) noexcept
    : PriceLevel() {
    *this = ::std::move(from);
  }

  inline PriceLevel& operator=(const PriceLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceLevel& operator=(PriceLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceLevel* internal_default_instance() {
    return reinterpret_cast<const PriceLevel*>(
               &_PriceLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PriceLevel& a, PriceLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceLevel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceLevel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceLevel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceLevel& from) {
    PriceLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceLevel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PriceLevel";
  }
  protected:
  explicit PriceLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string price = 1 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PriceLevel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbookV2Request) */ {
 public:
  inline OrderbookV2Request() : OrderbookV2Request(nullptr) {}
  ~OrderbookV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookV2Request(const OrderbookV2Request& from);
  OrderbookV2Request(OrderbookV2Request&& from) noexcept
    : OrderbookV2Request() {
    *this = ::std::move(from);
  }

  inline OrderbookV2Request& operator=(const OrderbookV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookV2Request& operator=(OrderbookV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookV2Request* internal_default_instance() {
    return reinterpret_cast<const OrderbookV2Request*>(
               &_OrderbookV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(OrderbookV2Request& a, OrderbookV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookV2Request& from) {
    OrderbookV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbookV2Request";
  }
  protected:
  explicit OrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbookV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbookV2Response) */ {
 public:
  inline OrderbookV2Response() : OrderbookV2Response(nullptr) {}
  ~OrderbookV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookV2Response(const OrderbookV2Response& from);
  OrderbookV2Response(OrderbookV2Response&& from) noexcept
    : OrderbookV2Response() {
    *this = ::std::move(from);
  }

  inline OrderbookV2Response& operator=(const OrderbookV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookV2Response& operator=(OrderbookV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookV2Response* internal_default_instance() {
    return reinterpret_cast<const OrderbookV2Response*>(
               &_OrderbookV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(OrderbookV2Response& a, OrderbookV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookV2Response& from) {
    OrderbookV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbookV2Response";
  }
  protected:
  explicit OrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbookFieldNumber = 1,
  };
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbookV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeLimitOrderbookV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2) */ {
 public:
  inline DerivativeLimitOrderbookV2() : DerivativeLimitOrderbookV2(nullptr) {}
  ~DerivativeLimitOrderbookV2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeLimitOrderbookV2(const DerivativeLimitOrderbookV2& from);
  DerivativeLimitOrderbookV2(DerivativeLimitOrderbookV2&& from) noexcept
    : DerivativeLimitOrderbookV2() {
    *this = ::std::move(from);
  }

  inline DerivativeLimitOrderbookV2& operator=(const DerivativeLimitOrderbookV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeLimitOrderbookV2& operator=(DerivativeLimitOrderbookV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeLimitOrderbookV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeLimitOrderbookV2* internal_default_instance() {
    return reinterpret_cast<const DerivativeLimitOrderbookV2*>(
               &_DerivativeLimitOrderbookV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DerivativeLimitOrderbookV2& a, DerivativeLimitOrderbookV2& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeLimitOrderbookV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeLimitOrderbookV2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeLimitOrderbookV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeLimitOrderbookV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeLimitOrderbookV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeLimitOrderbookV2& from) {
    DerivativeLimitOrderbookV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeLimitOrderbookV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2";
  }
  protected:
  explicit DerivativeLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 1,
    kSellsFieldNumber = 2,
    kSequenceFieldNumber = 3,
  };
  // repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_derivative_exchange_rpc::PriceLevel* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
      mutable_buys();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevel& _internal_buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>* _internal_mutable_buys();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevel& buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
      buys() const;
  // repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_derivative_exchange_rpc::PriceLevel* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
      mutable_sells();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevel& _internal_sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>* _internal_mutable_sells();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevel& sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevel* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
      sells() const;
  // uint64 sequence = 3 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel > sells_;
    ::uint64_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbooksRequest) */ {
 public:
  inline OrderbooksRequest() : OrderbooksRequest(nullptr) {}
  ~OrderbooksRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksRequest(const OrderbooksRequest& from);
  OrderbooksRequest(OrderbooksRequest&& from) noexcept
    : OrderbooksRequest() {
    *this = ::std::move(from);
  }

  inline OrderbooksRequest& operator=(const OrderbooksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksRequest& operator=(OrderbooksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksRequest* internal_default_instance() {
    return reinterpret_cast<const OrderbooksRequest*>(
               &_OrderbooksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(OrderbooksRequest& a, OrderbooksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksRequest& from) {
    OrderbooksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbooksRequest";
  }
  protected:
  explicit OrderbooksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbooksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbooksResponse) */ {
 public:
  inline OrderbooksResponse() : OrderbooksResponse(nullptr) {}
  ~OrderbooksResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksResponse(const OrderbooksResponse& from);
  OrderbooksResponse(OrderbooksResponse&& from) noexcept
    : OrderbooksResponse() {
    *this = ::std::move(from);
  }

  inline OrderbooksResponse& operator=(const OrderbooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksResponse& operator=(OrderbooksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksResponse* internal_default_instance() {
    return reinterpret_cast<const OrderbooksResponse*>(
               &_OrderbooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(OrderbooksResponse& a, OrderbooksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksResponse& from) {
    OrderbooksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbooksResponse";
  }
  protected:
  explicit OrderbooksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbooksFieldNumber = 1,
  };
  // repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
  int orderbooks_size() const;
  private:
  int _internal_orderbooks_size() const;

  public:
  void clear_orderbooks() ;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* mutable_orderbooks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook >*
      mutable_orderbooks();
  private:
  const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook& _internal_orderbooks(int index) const;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* _internal_add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook>& _internal_orderbooks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook>* _internal_mutable_orderbooks();
  public:
  const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook& orderbooks(int index) const;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook >&
      orderbooks() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbooksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook > orderbooks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SingleDerivativeLimitOrderbook final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook) */ {
 public:
  inline SingleDerivativeLimitOrderbook() : SingleDerivativeLimitOrderbook(nullptr) {}
  ~SingleDerivativeLimitOrderbook() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleDerivativeLimitOrderbook(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleDerivativeLimitOrderbook(const SingleDerivativeLimitOrderbook& from);
  SingleDerivativeLimitOrderbook(SingleDerivativeLimitOrderbook&& from) noexcept
    : SingleDerivativeLimitOrderbook() {
    *this = ::std::move(from);
  }

  inline SingleDerivativeLimitOrderbook& operator=(const SingleDerivativeLimitOrderbook& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleDerivativeLimitOrderbook& operator=(SingleDerivativeLimitOrderbook&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleDerivativeLimitOrderbook& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleDerivativeLimitOrderbook* internal_default_instance() {
    return reinterpret_cast<const SingleDerivativeLimitOrderbook*>(
               &_SingleDerivativeLimitOrderbook_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SingleDerivativeLimitOrderbook& a, SingleDerivativeLimitOrderbook& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleDerivativeLimitOrderbook* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleDerivativeLimitOrderbook* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleDerivativeLimitOrderbook* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleDerivativeLimitOrderbook>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleDerivativeLimitOrderbook& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleDerivativeLimitOrderbook& from) {
    SingleDerivativeLimitOrderbook::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleDerivativeLimitOrderbook* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook";
  }
  protected:
  explicit SingleDerivativeLimitOrderbook(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kOrderbookFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 2 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbooksV2Request) */ {
 public:
  inline OrderbooksV2Request() : OrderbooksV2Request(nullptr) {}
  ~OrderbooksV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksV2Request(const OrderbooksV2Request& from);
  OrderbooksV2Request(OrderbooksV2Request&& from) noexcept
    : OrderbooksV2Request() {
    *this = ::std::move(from);
  }

  inline OrderbooksV2Request& operator=(const OrderbooksV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksV2Request& operator=(OrderbooksV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksV2Request* internal_default_instance() {
    return reinterpret_cast<const OrderbooksV2Request*>(
               &_OrderbooksV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(OrderbooksV2Request& a, OrderbooksV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksV2Request& from) {
    OrderbooksV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbooksV2Request";
  }
  protected:
  explicit OrderbooksV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbooksV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbooksV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbooksV2Response) */ {
 public:
  inline OrderbooksV2Response() : OrderbooksV2Response(nullptr) {}
  ~OrderbooksV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbooksV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbooksV2Response(const OrderbooksV2Response& from);
  OrderbooksV2Response(OrderbooksV2Response&& from) noexcept
    : OrderbooksV2Response() {
    *this = ::std::move(from);
  }

  inline OrderbooksV2Response& operator=(const OrderbooksV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbooksV2Response& operator=(OrderbooksV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbooksV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbooksV2Response* internal_default_instance() {
    return reinterpret_cast<const OrderbooksV2Response*>(
               &_OrderbooksV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(OrderbooksV2Response& a, OrderbooksV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbooksV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbooksV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbooksV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbooksV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbooksV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbooksV2Response& from) {
    OrderbooksV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbooksV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbooksV2Response";
  }
  protected:
  explicit OrderbooksV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderbooksFieldNumber = 1,
  };
  // repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
  int orderbooks_size() const;
  private:
  int _internal_orderbooks_size() const;

  public:
  void clear_orderbooks() ;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* mutable_orderbooks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2 >*
      mutable_orderbooks();
  private:
  const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2& _internal_orderbooks(int index) const;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* _internal_add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2>& _internal_orderbooks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2>* _internal_mutable_orderbooks();
  public:
  const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2& orderbooks(int index) const;
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* add_orderbooks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2 >&
      orderbooks() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbooksV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2 > orderbooks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SingleDerivativeLimitOrderbookV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2) */ {
 public:
  inline SingleDerivativeLimitOrderbookV2() : SingleDerivativeLimitOrderbookV2(nullptr) {}
  ~SingleDerivativeLimitOrderbookV2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleDerivativeLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleDerivativeLimitOrderbookV2(const SingleDerivativeLimitOrderbookV2& from);
  SingleDerivativeLimitOrderbookV2(SingleDerivativeLimitOrderbookV2&& from) noexcept
    : SingleDerivativeLimitOrderbookV2() {
    *this = ::std::move(from);
  }

  inline SingleDerivativeLimitOrderbookV2& operator=(const SingleDerivativeLimitOrderbookV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleDerivativeLimitOrderbookV2& operator=(SingleDerivativeLimitOrderbookV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleDerivativeLimitOrderbookV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleDerivativeLimitOrderbookV2* internal_default_instance() {
    return reinterpret_cast<const SingleDerivativeLimitOrderbookV2*>(
               &_SingleDerivativeLimitOrderbookV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SingleDerivativeLimitOrderbookV2& a, SingleDerivativeLimitOrderbookV2& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleDerivativeLimitOrderbookV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleDerivativeLimitOrderbookV2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleDerivativeLimitOrderbookV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleDerivativeLimitOrderbookV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleDerivativeLimitOrderbookV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleDerivativeLimitOrderbookV2& from) {
    SingleDerivativeLimitOrderbookV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleDerivativeLimitOrderbookV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2";
  }
  protected:
  explicit SingleDerivativeLimitOrderbookV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kOrderbookFieldNumber = 2,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* unsafe_arena_release_orderbook();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookRequest) */ {
 public:
  inline StreamOrderbookRequest() : StreamOrderbookRequest(nullptr) {}
  ~StreamOrderbookRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookRequest(const StreamOrderbookRequest& from);
  StreamOrderbookRequest(StreamOrderbookRequest&& from) noexcept
    : StreamOrderbookRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookRequest& operator=(const StreamOrderbookRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookRequest& operator=(StreamOrderbookRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookRequest*>(
               &_StreamOrderbookRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StreamOrderbookRequest& a, StreamOrderbookRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookRequest& from) {
    StreamOrderbookRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookRequest";
  }
  protected:
  explicit StreamOrderbookRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookResponse) */ {
 public:
  inline StreamOrderbookResponse() : StreamOrderbookResponse(nullptr) {}
  ~StreamOrderbookResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookResponse(const StreamOrderbookResponse& from);
  StreamOrderbookResponse(StreamOrderbookResponse&& from) noexcept
    : StreamOrderbookResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookResponse& operator=(const StreamOrderbookResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookResponse& operator=(StreamOrderbookResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookResponse*>(
               &_StreamOrderbookResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StreamOrderbookResponse& a, StreamOrderbookResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookResponse& from) {
    StreamOrderbookResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookResponse";
  }
  protected:
  explicit StreamOrderbookResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* unsafe_arena_release_orderbook();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookV2Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookV2Request) */ {
 public:
  inline StreamOrderbookV2Request() : StreamOrderbookV2Request(nullptr) {}
  ~StreamOrderbookV2Request() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookV2Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookV2Request(const StreamOrderbookV2Request& from);
  StreamOrderbookV2Request(StreamOrderbookV2Request&& from) noexcept
    : StreamOrderbookV2Request() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookV2Request& operator=(const StreamOrderbookV2Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookV2Request& operator=(StreamOrderbookV2Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookV2Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookV2Request* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookV2Request*>(
               &_StreamOrderbookV2Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StreamOrderbookV2Request& a, StreamOrderbookV2Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookV2Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookV2Request* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookV2Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookV2Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookV2Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookV2Request& from) {
    StreamOrderbookV2Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookV2Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookV2Request";
  }
  protected:
  explicit StreamOrderbookV2Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookV2Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookV2Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookV2Response) */ {
 public:
  inline StreamOrderbookV2Response() : StreamOrderbookV2Response(nullptr) {}
  ~StreamOrderbookV2Response() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookV2Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookV2Response(const StreamOrderbookV2Response& from);
  StreamOrderbookV2Response(StreamOrderbookV2Response&& from) noexcept
    : StreamOrderbookV2Response() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookV2Response& operator=(const StreamOrderbookV2Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookV2Response& operator=(StreamOrderbookV2Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookV2Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookV2Response* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookV2Response*>(
               &_StreamOrderbookV2Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(StreamOrderbookV2Response& a, StreamOrderbookV2Response& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookV2Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookV2Response* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookV2Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookV2Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookV2Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookV2Response& from) {
    StreamOrderbookV2Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookV2Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookV2Response";
  }
  protected:
  explicit StreamOrderbookV2Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
  bool has_orderbook() const;
  void clear_orderbook() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& orderbook() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* release_orderbook();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* mutable_orderbook();
  void set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& _internal_orderbook() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _internal_mutable_orderbook();
  public:
  void unsafe_arena_set_allocated_orderbook(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* unsafe_arena_release_orderbook();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookV2Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest) */ {
 public:
  inline StreamOrderbookUpdateRequest() : StreamOrderbookUpdateRequest(nullptr) {}
  ~StreamOrderbookUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookUpdateRequest(const StreamOrderbookUpdateRequest& from);
  StreamOrderbookUpdateRequest(StreamOrderbookUpdateRequest&& from) noexcept
    : StreamOrderbookUpdateRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookUpdateRequest& operator=(const StreamOrderbookUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookUpdateRequest& operator=(StreamOrderbookUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookUpdateRequest*>(
               &_StreamOrderbookUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(StreamOrderbookUpdateRequest& a, StreamOrderbookUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookUpdateRequest& from) {
    StreamOrderbookUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest";
  }
  protected:
  explicit StreamOrderbookUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 1,
  };
  // repeated string market_ids = 1 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrderbookUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse) */ {
 public:
  inline StreamOrderbookUpdateResponse() : StreamOrderbookUpdateResponse(nullptr) {}
  ~StreamOrderbookUpdateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrderbookUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrderbookUpdateResponse(const StreamOrderbookUpdateResponse& from);
  StreamOrderbookUpdateResponse(StreamOrderbookUpdateResponse&& from) noexcept
    : StreamOrderbookUpdateResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrderbookUpdateResponse& operator=(const StreamOrderbookUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrderbookUpdateResponse& operator=(StreamOrderbookUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrderbookUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrderbookUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrderbookUpdateResponse*>(
               &_StreamOrderbookUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(StreamOrderbookUpdateResponse& a, StreamOrderbookUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrderbookUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrderbookUpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrderbookUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrderbookUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrderbookUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrderbookUpdateResponse& from) {
    StreamOrderbookUpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrderbookUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse";
  }
  protected:
  explicit StreamOrderbookUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kMarketIdFieldNumber = 4,
    kOrderbookLevelUpdatesFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // string market_id = 4 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // .injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
  bool has_orderbook_level_updates() const;
  void clear_orderbook_level_updates() ;
  const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates& orderbook_level_updates() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* release_orderbook_level_updates();
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* mutable_orderbook_level_updates();
  void set_allocated_orderbook_level_updates(::injective_derivative_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates);
  private:
  const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates& _internal_orderbook_level_updates() const;
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* _internal_mutable_orderbook_level_updates();
  public:
  void unsafe_arena_set_allocated_orderbook_level_updates(
      ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates);
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* unsafe_arena_release_orderbook_level_updates();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderbookLevelUpdates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrderbookLevelUpdates) */ {
 public:
  inline OrderbookLevelUpdates() : OrderbookLevelUpdates(nullptr) {}
  ~OrderbookLevelUpdates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderbookLevelUpdates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderbookLevelUpdates(const OrderbookLevelUpdates& from);
  OrderbookLevelUpdates(OrderbookLevelUpdates&& from) noexcept
    : OrderbookLevelUpdates() {
    *this = ::std::move(from);
  }

  inline OrderbookLevelUpdates& operator=(const OrderbookLevelUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderbookLevelUpdates& operator=(OrderbookLevelUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderbookLevelUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderbookLevelUpdates* internal_default_instance() {
    return reinterpret_cast<const OrderbookLevelUpdates*>(
               &_OrderbookLevelUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(OrderbookLevelUpdates& a, OrderbookLevelUpdates& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderbookLevelUpdates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderbookLevelUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderbookLevelUpdates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderbookLevelUpdates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderbookLevelUpdates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderbookLevelUpdates& from) {
    OrderbookLevelUpdates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderbookLevelUpdates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrderbookLevelUpdates";
  }
  protected:
  explicit OrderbookLevelUpdates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuysFieldNumber = 3,
    kSellsFieldNumber = 4,
    kMarketIdFieldNumber = 1,
    kSequenceFieldNumber = 2,
    kUpdatedAtFieldNumber = 5,
  };
  // repeated .injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
  int buys_size() const;
  private:
  int _internal_buys_size() const;

  public:
  void clear_buys() ;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* mutable_buys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >*
      mutable_buys();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevelUpdate& _internal_buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* _internal_add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>& _internal_buys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>* _internal_mutable_buys();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevelUpdate& buys(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* add_buys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >&
      buys() const;
  // repeated .injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
  int sells_size() const;
  private:
  int _internal_sells_size() const;

  public:
  void clear_sells() ;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* mutable_sells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >*
      mutable_sells();
  private:
  const ::injective_derivative_exchange_rpc::PriceLevelUpdate& _internal_sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* _internal_add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>& _internal_sells() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>* _internal_mutable_sells();
  public:
  const ::injective_derivative_exchange_rpc::PriceLevelUpdate& sells(int index) const;
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* add_sells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >&
      sells() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 sequence = 2 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // sint64 updated_at = 5 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrderbookLevelUpdates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate > buys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate > sells_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t sequence_;
    ::int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PriceLevelUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PriceLevelUpdate) */ {
 public:
  inline PriceLevelUpdate() : PriceLevelUpdate(nullptr) {}
  ~PriceLevelUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PriceLevelUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PriceLevelUpdate(const PriceLevelUpdate& from);
  PriceLevelUpdate(PriceLevelUpdate&& from) noexcept
    : PriceLevelUpdate() {
    *this = ::std::move(from);
  }

  inline PriceLevelUpdate& operator=(const PriceLevelUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceLevelUpdate& operator=(PriceLevelUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PriceLevelUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PriceLevelUpdate* internal_default_instance() {
    return reinterpret_cast<const PriceLevelUpdate*>(
               &_PriceLevelUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(PriceLevelUpdate& a, PriceLevelUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceLevelUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceLevelUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PriceLevelUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PriceLevelUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PriceLevelUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PriceLevelUpdate& from) {
    PriceLevelUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceLevelUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PriceLevelUpdate";
  }
  protected:
  explicit PriceLevelUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kIsActiveFieldNumber = 3,
  };
  // string price = 1 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 2 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // sint64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // bool is_active = 3 [json_name = "isActive"];
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PriceLevelUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::int64_t timestamp_;
    bool is_active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrdersRequest) */ {
 public:
  inline OrdersRequest() : OrdersRequest(nullptr) {}
  ~OrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersRequest(const OrdersRequest& from);
  OrdersRequest(OrdersRequest&& from) noexcept
    : OrdersRequest() {
    *this = ::std::move(from);
  }

  inline OrdersRequest& operator=(const OrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersRequest& operator=(OrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersRequest* internal_default_instance() {
    return reinterpret_cast<const OrdersRequest*>(
               &_OrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(OrdersRequest& a, OrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersRequest& from) {
    OrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrdersRequest";
  }
  protected:
  explicit OrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 8,
    kMarketIdFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kIsConditionalFieldNumber = 9,
    kOrderTypeFieldNumber = 10,
    kSkipFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kLimitFieldNumber = 5,
    kIncludeInactiveFieldNumber = 11,
    kSubaccountTotalOrdersFieldNumber = 12,
  };
  // repeated string market_ids = 8 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string is_conditional = 9 [json_name = "isConditional"];
  void clear_is_conditional() ;
  const std::string& is_conditional() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_is_conditional(Arg_&& arg, Args_... args);
  std::string* mutable_is_conditional();
  PROTOBUF_NODISCARD std::string* release_is_conditional();
  void set_allocated_is_conditional(std::string* ptr);

  private:
  const std::string& _internal_is_conditional() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_conditional(
      const std::string& value);
  std::string* _internal_mutable_is_conditional();

  public:
  // string order_type = 10 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 6 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 7 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 5 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool include_inactive = 11 [json_name = "includeInactive"];
  void clear_include_inactive() ;
  bool include_inactive() const;
  void set_include_inactive(bool value);

  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);

  public:
  // bool subaccount_total_orders = 12 [json_name = "subaccountTotalOrders"];
  void clear_subaccount_total_orders() ;
  bool subaccount_total_orders() const;
  void set_subaccount_total_orders(bool value);

  private:
  bool _internal_subaccount_total_orders() const;
  void _internal_set_subaccount_total_orders(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_conditional_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    bool include_inactive_;
    bool subaccount_total_orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrdersResponse) */ {
 public:
  inline OrdersResponse() : OrdersResponse(nullptr) {}
  ~OrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersResponse(const OrdersResponse& from);
  OrdersResponse(OrdersResponse&& from) noexcept
    : OrdersResponse() {
    *this = ::std::move(from);
  }

  inline OrdersResponse& operator=(const OrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersResponse& operator=(OrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersResponse* internal_default_instance() {
    return reinterpret_cast<const OrdersResponse*>(
               &_OrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(OrdersResponse& a, OrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersResponse& from) {
    OrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrdersResponse";
  }
  protected:
  explicit OrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >*
      mutable_orders();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& _internal_orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >&
      orders() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder > orders_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeLimitOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeLimitOrder) */ {
 public:
  inline DerivativeLimitOrder() : DerivativeLimitOrder(nullptr) {}
  ~DerivativeLimitOrder() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeLimitOrder(const DerivativeLimitOrder& from);
  DerivativeLimitOrder(DerivativeLimitOrder&& from) noexcept
    : DerivativeLimitOrder() {
    *this = ::std::move(from);
  }

  inline DerivativeLimitOrder& operator=(const DerivativeLimitOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeLimitOrder& operator=(DerivativeLimitOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeLimitOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeLimitOrder* internal_default_instance() {
    return reinterpret_cast<const DerivativeLimitOrder*>(
               &_DerivativeLimitOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DerivativeLimitOrder& a, DerivativeLimitOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeLimitOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeLimitOrder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeLimitOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeLimitOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeLimitOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeLimitOrder& from) {
    DerivativeLimitOrder::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeLimitOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeLimitOrder";
  }
  protected:
  explicit DerivativeLimitOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kMarginFieldNumber = 6,
    kPriceFieldNumber = 7,
    kQuantityFieldNumber = 8,
    kUnfilledQuantityFieldNumber = 9,
    kTriggerPriceFieldNumber = 10,
    kFeeRecipientFieldNumber = 11,
    kStateFieldNumber = 12,
    kOrderTypeFieldNumber = 16,
    kPlacedOrderHashFieldNumber = 19,
    kExecutionTypeFieldNumber = 20,
    kCreatedAtFieldNumber = 13,
    kUpdatedAtFieldNumber = 14,
    kOrderNumberFieldNumber = 15,
    kTriggerAtFieldNumber = 18,
    kIsReduceOnlyFieldNumber = 5,
    kIsConditionalFieldNumber = 17,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string margin = 6 [json_name = "margin"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string price = 7 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string quantity = 8 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string unfilled_quantity = 9 [json_name = "unfilledQuantity"];
  void clear_unfilled_quantity() ;
  const std::string& unfilled_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unfilled_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_unfilled_quantity();
  PROTOBUF_NODISCARD std::string* release_unfilled_quantity();
  void set_allocated_unfilled_quantity(std::string* ptr);

  private:
  const std::string& _internal_unfilled_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unfilled_quantity(
      const std::string& value);
  std::string* _internal_mutable_unfilled_quantity();

  public:
  // string trigger_price = 10 [json_name = "triggerPrice"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // string fee_recipient = 11 [json_name = "feeRecipient"];
  void clear_fee_recipient() ;
  const std::string& fee_recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient();
  PROTOBUF_NODISCARD std::string* release_fee_recipient();
  void set_allocated_fee_recipient(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient();

  public:
  // string state = 12 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string order_type = 16 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // string placed_order_hash = 19 [json_name = "placedOrderHash"];
  void clear_placed_order_hash() ;
  const std::string& placed_order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_placed_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_placed_order_hash();
  PROTOBUF_NODISCARD std::string* release_placed_order_hash();
  void set_allocated_placed_order_hash(std::string* ptr);

  private:
  const std::string& _internal_placed_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placed_order_hash(
      const std::string& value);
  std::string* _internal_mutable_placed_order_hash();

  public:
  // string execution_type = 20 [json_name = "executionType"];
  void clear_execution_type() ;
  const std::string& execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_execution_type();
  PROTOBUF_NODISCARD std::string* release_execution_type();
  void set_allocated_execution_type(std::string* ptr);

  private:
  const std::string& _internal_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_type(
      const std::string& value);
  std::string* _internal_mutable_execution_type();

  public:
  // sint64 created_at = 13 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // sint64 updated_at = 14 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // sint64 order_number = 15 [json_name = "orderNumber"];
  void clear_order_number() ;
  ::int64_t order_number() const;
  void set_order_number(::int64_t value);

  private:
  ::int64_t _internal_order_number() const;
  void _internal_set_order_number(::int64_t value);

  public:
  // uint64 trigger_at = 18 [json_name = "triggerAt"];
  void clear_trigger_at() ;
  ::uint64_t trigger_at() const;
  void set_trigger_at(::uint64_t value);

  private:
  ::uint64_t _internal_trigger_at() const;
  void _internal_set_trigger_at(::uint64_t value);

  public:
  // bool is_reduce_only = 5 [json_name = "isReduceOnly"];
  void clear_is_reduce_only() ;
  bool is_reduce_only() const;
  void set_is_reduce_only(bool value);

  private:
  bool _internal_is_reduce_only() const;
  void _internal_set_is_reduce_only(bool value);

  public:
  // bool is_conditional = 17 [json_name = "isConditional"];
  void clear_is_conditional() ;
  bool is_conditional() const;
  void set_is_conditional(bool value);

  private:
  bool _internal_is_conditional() const;
  void _internal_set_is_conditional(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeLimitOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unfilled_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placed_order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_type_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    ::int64_t order_number_;
    ::uint64_t trigger_at_;
    bool is_reduce_only_;
    bool is_conditional_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PositionsRequest) */ {
 public:
  inline PositionsRequest() : PositionsRequest(nullptr) {}
  ~PositionsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionsRequest(const PositionsRequest& from);
  PositionsRequest(PositionsRequest&& from) noexcept
    : PositionsRequest() {
    *this = ::std::move(from);
  }

  inline PositionsRequest& operator=(const PositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionsRequest& operator=(PositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionsRequest* internal_default_instance() {
    return reinterpret_cast<const PositionsRequest*>(
               &_PositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(PositionsRequest& a, PositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionsRequest& from) {
    PositionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PositionsRequest";
  }
  protected:
  explicit PositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 7,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDirectionFieldNumber = 8,
    kSkipFieldNumber = 3,
    kStartTimeFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kLimitFieldNumber = 4,
    kSubaccountTotalPositionsFieldNumber = 9,
  };
  // repeated string market_ids = 7 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string direction = 8 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 5 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 6 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool subaccount_total_positions = 9 [json_name = "subaccountTotalPositions"];
  void clear_subaccount_total_positions() ;
  bool subaccount_total_positions() const;
  void set_subaccount_total_positions(bool value);

  private:
  bool _internal_subaccount_total_positions() const;
  void _internal_set_subaccount_total_positions(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    bool subaccount_total_positions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PositionsResponse) */ {
 public:
  inline PositionsResponse() : PositionsResponse(nullptr) {}
  ~PositionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionsResponse(const PositionsResponse& from);
  PositionsResponse(PositionsResponse&& from) noexcept
    : PositionsResponse() {
    *this = ::std::move(from);
  }

  inline PositionsResponse& operator=(const PositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionsResponse& operator=(PositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionsResponse* internal_default_instance() {
    return reinterpret_cast<const PositionsResponse*>(
               &_PositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PositionsResponse& a, PositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionsResponse& from) {
    PositionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PositionsResponse";
  }
  protected:
  explicit PositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::injective_derivative_exchange_rpc::DerivativePosition* mutable_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >*
      mutable_positions();
  private:
  const ::injective_derivative_exchange_rpc::DerivativePosition& _internal_positions(int index) const;
  ::injective_derivative_exchange_rpc::DerivativePosition* _internal_add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>& _internal_positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>* _internal_mutable_positions();
  public:
  const ::injective_derivative_exchange_rpc::DerivativePosition& positions(int index) const;
  ::injective_derivative_exchange_rpc::DerivativePosition* add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >&
      positions() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition > positions_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativePosition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativePosition) */ {
 public:
  inline DerivativePosition() : DerivativePosition(nullptr) {}
  ~DerivativePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativePosition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativePosition(const DerivativePosition& from);
  DerivativePosition(DerivativePosition&& from) noexcept
    : DerivativePosition() {
    *this = ::std::move(from);
  }

  inline DerivativePosition& operator=(const DerivativePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativePosition& operator=(DerivativePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativePosition* internal_default_instance() {
    return reinterpret_cast<const DerivativePosition*>(
               &_DerivativePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DerivativePosition& a, DerivativePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativePosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativePosition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativePosition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativePosition& from) {
    DerivativePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativePosition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativePosition";
  }
  protected:
  explicit DerivativePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickerFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kQuantityFieldNumber = 5,
    kEntryPriceFieldNumber = 6,
    kMarginFieldNumber = 7,
    kLiquidationPriceFieldNumber = 8,
    kMarkPriceFieldNumber = 9,
    kAggregateReduceOnlyQuantityFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
    kCreatedAtFieldNumber = 13,
  };
  // string ticker = 1 [json_name = "ticker"];
  void clear_ticker() ;
  const std::string& ticker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticker(Arg_&& arg, Args_... args);
  std::string* mutable_ticker();
  PROTOBUF_NODISCARD std::string* release_ticker();
  void set_allocated_ticker(std::string* ptr);

  private:
  const std::string& _internal_ticker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticker(
      const std::string& value);
  std::string* _internal_mutable_ticker();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string direction = 4 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string quantity = 5 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string entry_price = 6 [json_name = "entryPrice"];
  void clear_entry_price() ;
  const std::string& entry_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entry_price(Arg_&& arg, Args_... args);
  std::string* mutable_entry_price();
  PROTOBUF_NODISCARD std::string* release_entry_price();
  void set_allocated_entry_price(std::string* ptr);

  private:
  const std::string& _internal_entry_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entry_price(
      const std::string& value);
  std::string* _internal_mutable_entry_price();

  public:
  // string margin = 7 [json_name = "margin"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // string liquidation_price = 8 [json_name = "liquidationPrice"];
  void clear_liquidation_price() ;
  const std::string& liquidation_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_liquidation_price(Arg_&& arg, Args_... args);
  std::string* mutable_liquidation_price();
  PROTOBUF_NODISCARD std::string* release_liquidation_price();
  void set_allocated_liquidation_price(std::string* ptr);

  private:
  const std::string& _internal_liquidation_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_liquidation_price(
      const std::string& value);
  std::string* _internal_mutable_liquidation_price();

  public:
  // string mark_price = 9 [json_name = "markPrice"];
  void clear_mark_price() ;
  const std::string& mark_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mark_price(Arg_&& arg, Args_... args);
  std::string* mutable_mark_price();
  PROTOBUF_NODISCARD std::string* release_mark_price();
  void set_allocated_mark_price(std::string* ptr);

  private:
  const std::string& _internal_mark_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mark_price(
      const std::string& value);
  std::string* _internal_mutable_mark_price();

  public:
  // string aggregate_reduce_only_quantity = 11 [json_name = "aggregateReduceOnlyQuantity"];
  void clear_aggregate_reduce_only_quantity() ;
  const std::string& aggregate_reduce_only_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aggregate_reduce_only_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_aggregate_reduce_only_quantity();
  PROTOBUF_NODISCARD std::string* release_aggregate_reduce_only_quantity();
  void set_allocated_aggregate_reduce_only_quantity(std::string* ptr);

  private:
  const std::string& _internal_aggregate_reduce_only_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregate_reduce_only_quantity(
      const std::string& value);
  std::string* _internal_mutable_aggregate_reduce_only_quantity();

  public:
  // sint64 updated_at = 12 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // sint64 created_at = 13 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativePosition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidation_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mark_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregate_reduce_only_quantity_;
    ::int64_t updated_at_;
    ::int64_t created_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class LiquidablePositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.LiquidablePositionsRequest) */ {
 public:
  inline LiquidablePositionsRequest() : LiquidablePositionsRequest(nullptr) {}
  ~LiquidablePositionsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LiquidablePositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiquidablePositionsRequest(const LiquidablePositionsRequest& from);
  LiquidablePositionsRequest(LiquidablePositionsRequest&& from) noexcept
    : LiquidablePositionsRequest() {
    *this = ::std::move(from);
  }

  inline LiquidablePositionsRequest& operator=(const LiquidablePositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidablePositionsRequest& operator=(LiquidablePositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiquidablePositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiquidablePositionsRequest* internal_default_instance() {
    return reinterpret_cast<const LiquidablePositionsRequest*>(
               &_LiquidablePositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(LiquidablePositionsRequest& a, LiquidablePositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LiquidablePositionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidablePositionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiquidablePositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiquidablePositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiquidablePositionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiquidablePositionsRequest& from) {
    LiquidablePositionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiquidablePositionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.LiquidablePositionsRequest";
  }
  protected:
  explicit LiquidablePositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSkipFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 skip = 2 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.LiquidablePositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class LiquidablePositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.LiquidablePositionsResponse) */ {
 public:
  inline LiquidablePositionsResponse() : LiquidablePositionsResponse(nullptr) {}
  ~LiquidablePositionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LiquidablePositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiquidablePositionsResponse(const LiquidablePositionsResponse& from);
  LiquidablePositionsResponse(LiquidablePositionsResponse&& from) noexcept
    : LiquidablePositionsResponse() {
    *this = ::std::move(from);
  }

  inline LiquidablePositionsResponse& operator=(const LiquidablePositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidablePositionsResponse& operator=(LiquidablePositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiquidablePositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiquidablePositionsResponse* internal_default_instance() {
    return reinterpret_cast<const LiquidablePositionsResponse*>(
               &_LiquidablePositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(LiquidablePositionsResponse& a, LiquidablePositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LiquidablePositionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidablePositionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiquidablePositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiquidablePositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiquidablePositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiquidablePositionsResponse& from) {
    LiquidablePositionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiquidablePositionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.LiquidablePositionsResponse";
  }
  protected:
  explicit LiquidablePositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1 [json_name = "positions"];
  int positions_size() const;
  private:
  int _internal_positions_size() const;

  public:
  void clear_positions() ;
  ::injective_derivative_exchange_rpc::DerivativePosition* mutable_positions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >*
      mutable_positions();
  private:
  const ::injective_derivative_exchange_rpc::DerivativePosition& _internal_positions(int index) const;
  ::injective_derivative_exchange_rpc::DerivativePosition* _internal_add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>& _internal_positions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>* _internal_mutable_positions();
  public:
  const ::injective_derivative_exchange_rpc::DerivativePosition& positions(int index) const;
  ::injective_derivative_exchange_rpc::DerivativePosition* add_positions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >&
      positions() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.LiquidablePositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition > positions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingPaymentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingPaymentsRequest) */ {
 public:
  inline FundingPaymentsRequest() : FundingPaymentsRequest(nullptr) {}
  ~FundingPaymentsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingPaymentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingPaymentsRequest(const FundingPaymentsRequest& from);
  FundingPaymentsRequest(FundingPaymentsRequest&& from) noexcept
    : FundingPaymentsRequest() {
    *this = ::std::move(from);
  }

  inline FundingPaymentsRequest& operator=(const FundingPaymentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingPaymentsRequest& operator=(FundingPaymentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingPaymentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingPaymentsRequest* internal_default_instance() {
    return reinterpret_cast<const FundingPaymentsRequest*>(
               &_FundingPaymentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(FundingPaymentsRequest& a, FundingPaymentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingPaymentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingPaymentsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingPaymentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingPaymentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingPaymentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingPaymentsRequest& from) {
    FundingPaymentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingPaymentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingPaymentsRequest";
  }
  protected:
  explicit FundingPaymentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 6,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSkipFieldNumber = 3,
    kEndTimeFieldNumber = 5,
    kLimitFieldNumber = 4,
  };
  // repeated string market_ids = 6 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 end_time = 5 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingPaymentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t skip_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingPaymentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingPaymentsResponse) */ {
 public:
  inline FundingPaymentsResponse() : FundingPaymentsResponse(nullptr) {}
  ~FundingPaymentsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingPaymentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingPaymentsResponse(const FundingPaymentsResponse& from);
  FundingPaymentsResponse(FundingPaymentsResponse&& from) noexcept
    : FundingPaymentsResponse() {
    *this = ::std::move(from);
  }

  inline FundingPaymentsResponse& operator=(const FundingPaymentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingPaymentsResponse& operator=(FundingPaymentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingPaymentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingPaymentsResponse* internal_default_instance() {
    return reinterpret_cast<const FundingPaymentsResponse*>(
               &_FundingPaymentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(FundingPaymentsResponse& a, FundingPaymentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingPaymentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingPaymentsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingPaymentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingPaymentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingPaymentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingPaymentsResponse& from) {
    FundingPaymentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingPaymentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingPaymentsResponse";
  }
  protected:
  explicit FundingPaymentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaymentsFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.FundingPayment payments = 1 [json_name = "payments"];
  int payments_size() const;
  private:
  int _internal_payments_size() const;

  public:
  void clear_payments() ;
  ::injective_derivative_exchange_rpc::FundingPayment* mutable_payments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingPayment >*
      mutable_payments();
  private:
  const ::injective_derivative_exchange_rpc::FundingPayment& _internal_payments(int index) const;
  ::injective_derivative_exchange_rpc::FundingPayment* _internal_add_payments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingPayment>& _internal_payments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingPayment>* _internal_mutable_payments();
  public:
  const ::injective_derivative_exchange_rpc::FundingPayment& payments(int index) const;
  ::injective_derivative_exchange_rpc::FundingPayment* add_payments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingPayment >&
      payments() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingPaymentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingPayment > payments_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingPayment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingPayment) */ {
 public:
  inline FundingPayment() : FundingPayment(nullptr) {}
  ~FundingPayment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingPayment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingPayment(const FundingPayment& from);
  FundingPayment(FundingPayment&& from) noexcept
    : FundingPayment() {
    *this = ::std::move(from);
  }

  inline FundingPayment& operator=(const FundingPayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingPayment& operator=(FundingPayment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingPayment& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingPayment* internal_default_instance() {
    return reinterpret_cast<const FundingPayment*>(
               &_FundingPayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(FundingPayment& a, FundingPayment& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingPayment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingPayment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingPayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingPayment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingPayment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingPayment& from) {
    FundingPayment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingPayment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingPayment";
  }
  protected:
  explicit FundingPayment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kAmountFieldNumber = 3,
    kTimestampFieldNumber = 4,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string amount = 3 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // sint64 timestamp = 4 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingPayment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingRatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingRatesRequest) */ {
 public:
  inline FundingRatesRequest() : FundingRatesRequest(nullptr) {}
  ~FundingRatesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingRatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingRatesRequest(const FundingRatesRequest& from);
  FundingRatesRequest(FundingRatesRequest&& from) noexcept
    : FundingRatesRequest() {
    *this = ::std::move(from);
  }

  inline FundingRatesRequest& operator=(const FundingRatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingRatesRequest& operator=(FundingRatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingRatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingRatesRequest* internal_default_instance() {
    return reinterpret_cast<const FundingRatesRequest*>(
               &_FundingRatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(FundingRatesRequest& a, FundingRatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingRatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingRatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingRatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingRatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingRatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingRatesRequest& from) {
    FundingRatesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingRatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingRatesRequest";
  }
  protected:
  explicit FundingRatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kSkipFieldNumber = 2,
    kEndTimeFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 skip = 2 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 end_time = 4 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingRatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t skip_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingRatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingRatesResponse) */ {
 public:
  inline FundingRatesResponse() : FundingRatesResponse(nullptr) {}
  ~FundingRatesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingRatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingRatesResponse(const FundingRatesResponse& from);
  FundingRatesResponse(FundingRatesResponse&& from) noexcept
    : FundingRatesResponse() {
    *this = ::std::move(from);
  }

  inline FundingRatesResponse& operator=(const FundingRatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingRatesResponse& operator=(FundingRatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingRatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingRatesResponse* internal_default_instance() {
    return reinterpret_cast<const FundingRatesResponse*>(
               &_FundingRatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(FundingRatesResponse& a, FundingRatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingRatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingRatesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingRatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingRatesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingRatesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingRatesResponse& from) {
    FundingRatesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingRatesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingRatesResponse";
  }
  protected:
  explicit FundingRatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundingRatesFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.FundingRate funding_rates = 1 [json_name = "fundingRates"];
  int funding_rates_size() const;
  private:
  int _internal_funding_rates_size() const;

  public:
  void clear_funding_rates() ;
  ::injective_derivative_exchange_rpc::FundingRate* mutable_funding_rates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingRate >*
      mutable_funding_rates();
  private:
  const ::injective_derivative_exchange_rpc::FundingRate& _internal_funding_rates(int index) const;
  ::injective_derivative_exchange_rpc::FundingRate* _internal_add_funding_rates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingRate>& _internal_funding_rates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingRate>* _internal_mutable_funding_rates();
  public:
  const ::injective_derivative_exchange_rpc::FundingRate& funding_rates(int index) const;
  ::injective_derivative_exchange_rpc::FundingRate* add_funding_rates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingRate >&
      funding_rates() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingRatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingRate > funding_rates_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class FundingRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.FundingRate) */ {
 public:
  inline FundingRate() : FundingRate(nullptr) {}
  ~FundingRate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FundingRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FundingRate(const FundingRate& from);
  FundingRate(FundingRate&& from) noexcept
    : FundingRate() {
    *this = ::std::move(from);
  }

  inline FundingRate& operator=(const FundingRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FundingRate& operator=(FundingRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FundingRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FundingRate* internal_default_instance() {
    return reinterpret_cast<const FundingRate*>(
               &_FundingRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(FundingRate& a, FundingRate& b) {
    a.Swap(&b);
  }
  inline void Swap(FundingRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FundingRate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FundingRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FundingRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FundingRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FundingRate& from) {
    FundingRate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FundingRate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.FundingRate";
  }
  protected:
  explicit FundingRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdFieldNumber = 1,
    kRateFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string rate = 2 [json_name = "rate"];
  void clear_rate() ;
  const std::string& rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rate(Arg_&& arg, Args_... args);
  std::string* mutable_rate();
  PROTOBUF_NODISCARD std::string* release_rate();
  void set_allocated_rate(std::string* ptr);

  private:
  const std::string& _internal_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rate(
      const std::string& value);
  std::string* _internal_mutable_rate();

  public:
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.FundingRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rate_;
    ::int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamPositionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamPositionsRequest) */ {
 public:
  inline StreamPositionsRequest() : StreamPositionsRequest(nullptr) {}
  ~StreamPositionsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamPositionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamPositionsRequest(const StreamPositionsRequest& from);
  StreamPositionsRequest(StreamPositionsRequest&& from) noexcept
    : StreamPositionsRequest() {
    *this = ::std::move(from);
  }

  inline StreamPositionsRequest& operator=(const StreamPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPositionsRequest& operator=(StreamPositionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamPositionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamPositionsRequest* internal_default_instance() {
    return reinterpret_cast<const StreamPositionsRequest*>(
               &_StreamPositionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(StreamPositionsRequest& a, StreamPositionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPositionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPositionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamPositionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamPositionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamPositionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamPositionsRequest& from) {
    StreamPositionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamPositionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamPositionsRequest";
  }
  protected:
  explicit StreamPositionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 3,
    kSubaccountIdsFieldNumber = 4,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
  };
  // repeated string market_ids = 3 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // repeated string subaccount_ids = 4 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const char* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const char* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamPositionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamPositionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamPositionsResponse) */ {
 public:
  inline StreamPositionsResponse() : StreamPositionsResponse(nullptr) {}
  ~StreamPositionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamPositionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamPositionsResponse(const StreamPositionsResponse& from);
  StreamPositionsResponse(StreamPositionsResponse&& from) noexcept
    : StreamPositionsResponse() {
    *this = ::std::move(from);
  }

  inline StreamPositionsResponse& operator=(const StreamPositionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamPositionsResponse& operator=(StreamPositionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamPositionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamPositionsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamPositionsResponse*>(
               &_StreamPositionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(StreamPositionsResponse& a, StreamPositionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamPositionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamPositionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamPositionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamPositionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamPositionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamPositionsResponse& from) {
    StreamPositionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamPositionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamPositionsResponse";
  }
  protected:
  explicit StreamPositionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .injective_derivative_exchange_rpc.DerivativePosition position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::injective_derivative_exchange_rpc::DerivativePosition& position() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativePosition* release_position();
  ::injective_derivative_exchange_rpc::DerivativePosition* mutable_position();
  void set_allocated_position(::injective_derivative_exchange_rpc::DerivativePosition* position);
  private:
  const ::injective_derivative_exchange_rpc::DerivativePosition& _internal_position() const;
  ::injective_derivative_exchange_rpc::DerivativePosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::injective_derivative_exchange_rpc::DerivativePosition* position);
  ::injective_derivative_exchange_rpc::DerivativePosition* unsafe_arena_release_position();
  // sint64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamPositionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_derivative_exchange_rpc::DerivativePosition* position_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrdersRequest) */ {
 public:
  inline StreamOrdersRequest() : StreamOrdersRequest(nullptr) {}
  ~StreamOrdersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersRequest(const StreamOrdersRequest& from);
  StreamOrdersRequest(StreamOrdersRequest&& from) noexcept
    : StreamOrdersRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrdersRequest& operator=(const StreamOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersRequest& operator=(StreamOrdersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersRequest*>(
               &_StreamOrdersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(StreamOrdersRequest& a, StreamOrdersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersRequest& from) {
    StreamOrdersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrdersRequest";
  }
  protected:
  explicit StreamOrdersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 8,
    kMarketIdFieldNumber = 1,
    kOrderSideFieldNumber = 2,
    kSubaccountIdFieldNumber = 3,
    kIsConditionalFieldNumber = 9,
    kOrderTypeFieldNumber = 10,
    kSkipFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kLimitFieldNumber = 5,
    kIncludeInactiveFieldNumber = 11,
    kSubaccountTotalOrdersFieldNumber = 12,
  };
  // repeated string market_ids = 8 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_side = 2 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string subaccount_id = 3 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string is_conditional = 9 [json_name = "isConditional"];
  void clear_is_conditional() ;
  const std::string& is_conditional() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_is_conditional(Arg_&& arg, Args_... args);
  std::string* mutable_is_conditional();
  PROTOBUF_NODISCARD std::string* release_is_conditional();
  void set_allocated_is_conditional(std::string* ptr);

  private:
  const std::string& _internal_is_conditional() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_conditional(
      const std::string& value);
  std::string* _internal_mutable_is_conditional();

  public:
  // string order_type = 10 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 6 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 7 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 5 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool include_inactive = 11 [json_name = "includeInactive"];
  void clear_include_inactive() ;
  bool include_inactive() const;
  void set_include_inactive(bool value);

  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);

  public:
  // bool subaccount_total_orders = 12 [json_name = "subaccountTotalOrders"];
  void clear_subaccount_total_orders() ;
  bool subaccount_total_orders() const;
  void set_subaccount_total_orders(bool value);

  private:
  bool _internal_subaccount_total_orders() const;
  void _internal_set_subaccount_total_orders(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrdersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_conditional_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    bool include_inactive_;
    bool subaccount_total_orders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrdersResponse) */ {
 public:
  inline StreamOrdersResponse() : StreamOrdersResponse(nullptr) {}
  ~StreamOrdersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersResponse(const StreamOrdersResponse& from);
  StreamOrdersResponse(StreamOrdersResponse&& from) noexcept
    : StreamOrdersResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrdersResponse& operator=(const StreamOrdersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersResponse& operator=(StreamOrdersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersResponse*>(
               &_StreamOrdersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(StreamOrdersResponse& a, StreamOrdersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersResponse& from) {
    StreamOrdersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrdersResponse";
  }
  protected:
  explicit StreamOrdersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kOrderFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& order() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeLimitOrder* release_order();
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* mutable_order();
  void set_allocated_order(::injective_derivative_exchange_rpc::DerivativeLimitOrder* order);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& _internal_order() const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective_derivative_exchange_rpc::DerivativeLimitOrder* order);
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* unsafe_arena_release_order();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrdersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_derivative_exchange_rpc::DerivativeLimitOrder* order_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TradesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.TradesRequest) */ {
 public:
  inline TradesRequest() : TradesRequest(nullptr) {}
  ~TradesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradesRequest(const TradesRequest& from);
  TradesRequest(TradesRequest&& from) noexcept
    : TradesRequest() {
    *this = ::std::move(from);
  }

  inline TradesRequest& operator=(const TradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradesRequest& operator=(TradesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradesRequest* internal_default_instance() {
    return reinterpret_cast<const TradesRequest*>(
               &_TradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(TradesRequest& a, TradesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TradesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradesRequest& from) {
    TradesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.TradesRequest";
  }
  protected:
  explicit TradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 9,
    kSubaccountIdsFieldNumber = 10,
    kExecutionTypesFieldNumber = 11,
    kMarketIdFieldNumber = 1,
    kExecutionSideFieldNumber = 2,
    kDirectionFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kSkipFieldNumber = 5,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 6,
  };
  // repeated string market_ids = 9 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const char* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const char* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // repeated string execution_types = 11 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_side = 2 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // string direction = 3 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.TradesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class TradesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.TradesResponse) */ {
 public:
  inline TradesResponse() : TradesResponse(nullptr) {}
  ~TradesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TradesResponse(const TradesResponse& from);
  TradesResponse(TradesResponse&& from) noexcept
    : TradesResponse() {
    *this = ::std::move(from);
  }

  inline TradesResponse& operator=(const TradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradesResponse& operator=(TradesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradesResponse* internal_default_instance() {
    return reinterpret_cast<const TradesResponse*>(
               &_TradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(TradesResponse& a, TradesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TradesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TradesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TradesResponse& from) {
    TradesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.TradesResponse";
  }
  protected:
  explicit TradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective_derivative_exchange_rpc::DerivativeTrade* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >*
      mutable_trades();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeTrade& _internal_trades(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeTrade* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>* _internal_mutable_trades();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeTrade& trades(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeTrade* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >&
      trades() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.TradesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade > trades_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeTrade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeTrade) */ {
 public:
  inline DerivativeTrade() : DerivativeTrade(nullptr) {}
  ~DerivativeTrade() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeTrade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeTrade(const DerivativeTrade& from);
  DerivativeTrade(DerivativeTrade&& from) noexcept
    : DerivativeTrade() {
    *this = ::std::move(from);
  }

  inline DerivativeTrade& operator=(const DerivativeTrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeTrade& operator=(DerivativeTrade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeTrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeTrade* internal_default_instance() {
    return reinterpret_cast<const DerivativeTrade*>(
               &_DerivativeTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(DerivativeTrade& a, DerivativeTrade& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeTrade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeTrade* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeTrade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeTrade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeTrade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeTrade& from) {
    DerivativeTrade::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeTrade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeTrade";
  }
  protected:
  explicit DerivativeTrade(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kTradeExecutionTypeFieldNumber = 4,
    kPayoutFieldNumber = 7,
    kFeeFieldNumber = 8,
    kFeeRecipientFieldNumber = 10,
    kTradeIdFieldNumber = 11,
    kExecutionSideFieldNumber = 12,
    kPositionDeltaFieldNumber = 6,
    kExecutedAtFieldNumber = 9,
    kIsLiquidationFieldNumber = 5,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string trade_execution_type = 4 [json_name = "tradeExecutionType"];
  void clear_trade_execution_type() ;
  const std::string& trade_execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_trade_execution_type();
  PROTOBUF_NODISCARD std::string* release_trade_execution_type();
  void set_allocated_trade_execution_type(std::string* ptr);

  private:
  const std::string& _internal_trade_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_execution_type(
      const std::string& value);
  std::string* _internal_mutable_trade_execution_type();

  public:
  // string payout = 7 [json_name = "payout"];
  void clear_payout() ;
  const std::string& payout() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payout(Arg_&& arg, Args_... args);
  std::string* mutable_payout();
  PROTOBUF_NODISCARD std::string* release_payout();
  void set_allocated_payout(std::string* ptr);

  private:
  const std::string& _internal_payout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payout(
      const std::string& value);
  std::string* _internal_mutable_payout();

  public:
  // string fee = 8 [json_name = "fee"];
  void clear_fee() ;
  const std::string& fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee(Arg_&& arg, Args_... args);
  std::string* mutable_fee();
  PROTOBUF_NODISCARD std::string* release_fee();
  void set_allocated_fee(std::string* ptr);

  private:
  const std::string& _internal_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee(
      const std::string& value);
  std::string* _internal_mutable_fee();

  public:
  // string fee_recipient = 10 [json_name = "feeRecipient"];
  void clear_fee_recipient() ;
  const std::string& fee_recipient() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_recipient(Arg_&& arg, Args_... args);
  std::string* mutable_fee_recipient();
  PROTOBUF_NODISCARD std::string* release_fee_recipient();
  void set_allocated_fee_recipient(std::string* ptr);

  private:
  const std::string& _internal_fee_recipient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_recipient(
      const std::string& value);
  std::string* _internal_mutable_fee_recipient();

  public:
  // string trade_id = 11 [json_name = "tradeId"];
  void clear_trade_id() ;
  const std::string& trade_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_id(Arg_&& arg, Args_... args);
  std::string* mutable_trade_id();
  PROTOBUF_NODISCARD std::string* release_trade_id();
  void set_allocated_trade_id(std::string* ptr);

  private:
  const std::string& _internal_trade_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_id(
      const std::string& value);
  std::string* _internal_mutable_trade_id();

  public:
  // string execution_side = 12 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // .injective_derivative_exchange_rpc.PositionDelta position_delta = 6 [json_name = "positionDelta"];
  bool has_position_delta() const;
  void clear_position_delta() ;
  const ::injective_derivative_exchange_rpc::PositionDelta& position_delta() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::PositionDelta* release_position_delta();
  ::injective_derivative_exchange_rpc::PositionDelta* mutable_position_delta();
  void set_allocated_position_delta(::injective_derivative_exchange_rpc::PositionDelta* position_delta);
  private:
  const ::injective_derivative_exchange_rpc::PositionDelta& _internal_position_delta() const;
  ::injective_derivative_exchange_rpc::PositionDelta* _internal_mutable_position_delta();
  public:
  void unsafe_arena_set_allocated_position_delta(
      ::injective_derivative_exchange_rpc::PositionDelta* position_delta);
  ::injective_derivative_exchange_rpc::PositionDelta* unsafe_arena_release_position_delta();
  // sint64 executed_at = 9 [json_name = "executedAt"];
  void clear_executed_at() ;
  ::int64_t executed_at() const;
  void set_executed_at(::int64_t value);

  private:
  ::int64_t _internal_executed_at() const;
  void _internal_set_executed_at(::int64_t value);

  public:
  // bool is_liquidation = 5 [json_name = "isLiquidation"];
  void clear_is_liquidation() ;
  bool is_liquidation() const;
  void set_is_liquidation(bool value);

  private:
  bool _internal_is_liquidation() const;
  void _internal_set_is_liquidation(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeTrade)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_recipient_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::injective_derivative_exchange_rpc::PositionDelta* position_delta_;
    ::int64_t executed_at_;
    bool is_liquidation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PositionDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.PositionDelta) */ {
 public:
  inline PositionDelta() : PositionDelta(nullptr) {}
  ~PositionDelta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionDelta(const PositionDelta& from);
  PositionDelta(PositionDelta&& from) noexcept
    : PositionDelta() {
    *this = ::std::move(from);
  }

  inline PositionDelta& operator=(const PositionDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionDelta& operator=(PositionDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionDelta* internal_default_instance() {
    return reinterpret_cast<const PositionDelta*>(
               &_PositionDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(PositionDelta& a, PositionDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionDelta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PositionDelta& from) {
    PositionDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.PositionDelta";
  }
  protected:
  explicit PositionDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeDirectionFieldNumber = 1,
    kExecutionPriceFieldNumber = 2,
    kExecutionQuantityFieldNumber = 3,
    kExecutionMarginFieldNumber = 4,
  };
  // string trade_direction = 1 [json_name = "tradeDirection"];
  void clear_trade_direction() ;
  const std::string& trade_direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_direction(Arg_&& arg, Args_... args);
  std::string* mutable_trade_direction();
  PROTOBUF_NODISCARD std::string* release_trade_direction();
  void set_allocated_trade_direction(std::string* ptr);

  private:
  const std::string& _internal_trade_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_direction(
      const std::string& value);
  std::string* _internal_mutable_trade_direction();

  public:
  // string execution_price = 2 [json_name = "executionPrice"];
  void clear_execution_price() ;
  const std::string& execution_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_price(Arg_&& arg, Args_... args);
  std::string* mutable_execution_price();
  PROTOBUF_NODISCARD std::string* release_execution_price();
  void set_allocated_execution_price(std::string* ptr);

  private:
  const std::string& _internal_execution_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_price(
      const std::string& value);
  std::string* _internal_mutable_execution_price();

  public:
  // string execution_quantity = 3 [json_name = "executionQuantity"];
  void clear_execution_quantity() ;
  const std::string& execution_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_execution_quantity();
  PROTOBUF_NODISCARD std::string* release_execution_quantity();
  void set_allocated_execution_quantity(std::string* ptr);

  private:
  const std::string& _internal_execution_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_quantity(
      const std::string& value);
  std::string* _internal_mutable_execution_quantity();

  public:
  // string execution_margin = 4 [json_name = "executionMargin"];
  void clear_execution_margin() ;
  const std::string& execution_margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_margin(Arg_&& arg, Args_... args);
  std::string* mutable_execution_margin();
  PROTOBUF_NODISCARD std::string* release_execution_margin();
  void set_allocated_execution_margin(std::string* ptr);

  private:
  const std::string& _internal_execution_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_margin(
      const std::string& value);
  std::string* _internal_mutable_execution_margin();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.PositionDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trade_direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_margin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTradesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamTradesRequest) */ {
 public:
  inline StreamTradesRequest() : StreamTradesRequest(nullptr) {}
  ~StreamTradesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTradesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTradesRequest(const StreamTradesRequest& from);
  StreamTradesRequest(StreamTradesRequest&& from) noexcept
    : StreamTradesRequest() {
    *this = ::std::move(from);
  }

  inline StreamTradesRequest& operator=(const StreamTradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTradesRequest& operator=(StreamTradesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTradesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTradesRequest* internal_default_instance() {
    return reinterpret_cast<const StreamTradesRequest*>(
               &_StreamTradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(StreamTradesRequest& a, StreamTradesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTradesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTradesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTradesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTradesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamTradesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamTradesRequest& from) {
    StreamTradesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTradesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamTradesRequest";
  }
  protected:
  explicit StreamTradesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIdsFieldNumber = 9,
    kSubaccountIdsFieldNumber = 10,
    kExecutionTypesFieldNumber = 11,
    kMarketIdFieldNumber = 1,
    kExecutionSideFieldNumber = 2,
    kDirectionFieldNumber = 3,
    kSubaccountIdFieldNumber = 4,
    kSkipFieldNumber = 5,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 6,
  };
  // repeated string market_ids = 9 [json_name = "marketIds"];
  int market_ids_size() const;
  private:
  int _internal_market_ids_size() const;

  public:
  void clear_market_ids() ;
  const std::string& market_ids(int index) const;
  std::string* mutable_market_ids(int index);
  void set_market_ids(int index, const std::string& value);
  void set_market_ids(int index, std::string&& value);
  void set_market_ids(int index, const char* value);
  void set_market_ids(int index, const char* value, std::size_t size);
  void set_market_ids(int index, absl::string_view value);
  std::string* add_market_ids();
  void add_market_ids(const std::string& value);
  void add_market_ids(std::string&& value);
  void add_market_ids(const char* value);
  void add_market_ids(const char* value, std::size_t size);
  void add_market_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_ids();

  private:
  const std::string& _internal_market_ids(int index) const;
  std::string* _internal_add_market_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_ids();

  public:
  // repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
  int subaccount_ids_size() const;
  private:
  int _internal_subaccount_ids_size() const;

  public:
  void clear_subaccount_ids() ;
  const std::string& subaccount_ids(int index) const;
  std::string* mutable_subaccount_ids(int index);
  void set_subaccount_ids(int index, const std::string& value);
  void set_subaccount_ids(int index, std::string&& value);
  void set_subaccount_ids(int index, const char* value);
  void set_subaccount_ids(int index, const char* value, std::size_t size);
  void set_subaccount_ids(int index, absl::string_view value);
  std::string* add_subaccount_ids();
  void add_subaccount_ids(const std::string& value);
  void add_subaccount_ids(std::string&& value);
  void add_subaccount_ids(const char* value);
  void add_subaccount_ids(const char* value, std::size_t size);
  void add_subaccount_ids(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccount_ids();

  private:
  const std::string& _internal_subaccount_ids(int index) const;
  std::string* _internal_add_subaccount_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccount_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccount_ids();

  public:
  // repeated string execution_types = 11 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_side = 2 [json_name = "executionSide"];
  void clear_execution_side() ;
  const std::string& execution_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_side(Arg_&& arg, Args_... args);
  std::string* mutable_execution_side();
  PROTOBUF_NODISCARD std::string* release_execution_side();
  void set_allocated_execution_side(std::string* ptr);

  private:
  const std::string& _internal_execution_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_side(
      const std::string& value);
  std::string* _internal_mutable_execution_side();

  public:
  // string direction = 3 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamTradesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccount_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTradesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamTradesResponse) */ {
 public:
  inline StreamTradesResponse() : StreamTradesResponse(nullptr) {}
  ~StreamTradesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTradesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTradesResponse(const StreamTradesResponse& from);
  StreamTradesResponse(StreamTradesResponse&& from) noexcept
    : StreamTradesResponse() {
    *this = ::std::move(from);
  }

  inline StreamTradesResponse& operator=(const StreamTradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTradesResponse& operator=(StreamTradesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTradesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTradesResponse* internal_default_instance() {
    return reinterpret_cast<const StreamTradesResponse*>(
               &_StreamTradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(StreamTradesResponse& a, StreamTradesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTradesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTradesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTradesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTradesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamTradesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamTradesResponse& from) {
    StreamTradesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTradesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamTradesResponse";
  }
  protected:
  explicit StreamTradesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kTradeFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_derivative_exchange_rpc.DerivativeTrade trade = 1 [json_name = "trade"];
  bool has_trade() const;
  void clear_trade() ;
  const ::injective_derivative_exchange_rpc::DerivativeTrade& trade() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeTrade* release_trade();
  ::injective_derivative_exchange_rpc::DerivativeTrade* mutable_trade();
  void set_allocated_trade(::injective_derivative_exchange_rpc::DerivativeTrade* trade);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeTrade& _internal_trade() const;
  ::injective_derivative_exchange_rpc::DerivativeTrade* _internal_mutable_trade();
  public:
  void unsafe_arena_set_allocated_trade(
      ::injective_derivative_exchange_rpc::DerivativeTrade* trade);
  ::injective_derivative_exchange_rpc::DerivativeTrade* unsafe_arena_release_trade();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamTradesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_derivative_exchange_rpc::DerivativeTrade* trade_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrdersListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SubaccountOrdersListRequest) */ {
 public:
  inline SubaccountOrdersListRequest() : SubaccountOrdersListRequest(nullptr) {}
  ~SubaccountOrdersListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrdersListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrdersListRequest(const SubaccountOrdersListRequest& from);
  SubaccountOrdersListRequest(SubaccountOrdersListRequest&& from) noexcept
    : SubaccountOrdersListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountOrdersListRequest& operator=(const SubaccountOrdersListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrdersListRequest& operator=(SubaccountOrdersListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrdersListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrdersListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrdersListRequest*>(
               &_SubaccountOrdersListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(SubaccountOrdersListRequest& a, SubaccountOrdersListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrdersListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrdersListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrdersListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrdersListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrdersListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrdersListRequest& from) {
    SubaccountOrdersListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrdersListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SubaccountOrdersListRequest";
  }
  protected:
  explicit SubaccountOrdersListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSkipFieldNumber = 3,
    kLimitFieldNumber = 4,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SubaccountOrdersListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrdersListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SubaccountOrdersListResponse) */ {
 public:
  inline SubaccountOrdersListResponse() : SubaccountOrdersListResponse(nullptr) {}
  ~SubaccountOrdersListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrdersListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrdersListResponse(const SubaccountOrdersListResponse& from);
  SubaccountOrdersListResponse(SubaccountOrdersListResponse&& from) noexcept
    : SubaccountOrdersListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountOrdersListResponse& operator=(const SubaccountOrdersListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrdersListResponse& operator=(SubaccountOrdersListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrdersListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrdersListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrdersListResponse*>(
               &_SubaccountOrdersListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SubaccountOrdersListResponse& a, SubaccountOrdersListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrdersListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrdersListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrdersListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrdersListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrdersListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrdersListResponse& from) {
    SubaccountOrdersListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrdersListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SubaccountOrdersListResponse";
  }
  protected:
  explicit SubaccountOrdersListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >*
      mutable_orders();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& _internal_orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>* _internal_mutable_orders();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >&
      orders() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SubaccountOrdersListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder > orders_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountTradesListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SubaccountTradesListRequest) */ {
 public:
  inline SubaccountTradesListRequest() : SubaccountTradesListRequest(nullptr) {}
  ~SubaccountTradesListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountTradesListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountTradesListRequest(const SubaccountTradesListRequest& from);
  SubaccountTradesListRequest(SubaccountTradesListRequest&& from) noexcept
    : SubaccountTradesListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountTradesListRequest& operator=(const SubaccountTradesListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountTradesListRequest& operator=(SubaccountTradesListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountTradesListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountTradesListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountTradesListRequest*>(
               &_SubaccountTradesListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SubaccountTradesListRequest& a, SubaccountTradesListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountTradesListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountTradesListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountTradesListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountTradesListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountTradesListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountTradesListRequest& from) {
    SubaccountTradesListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountTradesListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SubaccountTradesListRequest";
  }
  protected:
  explicit SubaccountTradesListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kExecutionTypeFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kSkipFieldNumber = 5,
    kLimitFieldNumber = 6,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string execution_type = 3 [json_name = "executionType"];
  void clear_execution_type() ;
  const std::string& execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_execution_type();
  PROTOBUF_NODISCARD std::string* release_execution_type();
  void set_allocated_execution_type(std::string* ptr);

  private:
  const std::string& _internal_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_type(
      const std::string& value);
  std::string* _internal_mutable_execution_type();

  public:
  // string direction = 4 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 6 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SubaccountTradesListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountTradesListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.SubaccountTradesListResponse) */ {
 public:
  inline SubaccountTradesListResponse() : SubaccountTradesListResponse(nullptr) {}
  ~SubaccountTradesListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountTradesListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountTradesListResponse(const SubaccountTradesListResponse& from);
  SubaccountTradesListResponse(SubaccountTradesListResponse&& from) noexcept
    : SubaccountTradesListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountTradesListResponse& operator=(const SubaccountTradesListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountTradesListResponse& operator=(SubaccountTradesListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountTradesListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountTradesListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountTradesListResponse*>(
               &_SubaccountTradesListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(SubaccountTradesListResponse& a, SubaccountTradesListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountTradesListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountTradesListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountTradesListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountTradesListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountTradesListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountTradesListResponse& from) {
    SubaccountTradesListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountTradesListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.SubaccountTradesListResponse";
  }
  protected:
  explicit SubaccountTradesListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradesFieldNumber = 1,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1 [json_name = "trades"];
  int trades_size() const;
  private:
  int _internal_trades_size() const;

  public:
  void clear_trades() ;
  ::injective_derivative_exchange_rpc::DerivativeTrade* mutable_trades(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >*
      mutable_trades();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeTrade& _internal_trades(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeTrade* _internal_add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>& _internal_trades() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>* _internal_mutable_trades();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeTrade& trades(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeTrade* add_trades();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >&
      trades() const;
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.SubaccountTradesListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade > trades_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrdersHistoryRequest) */ {
 public:
  inline OrdersHistoryRequest() : OrdersHistoryRequest(nullptr) {}
  ~OrdersHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersHistoryRequest(const OrdersHistoryRequest& from);
  OrdersHistoryRequest(OrdersHistoryRequest&& from) noexcept
    : OrdersHistoryRequest() {
    *this = ::std::move(from);
  }

  inline OrdersHistoryRequest& operator=(const OrdersHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersHistoryRequest& operator=(OrdersHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const OrdersHistoryRequest*>(
               &_OrdersHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(OrdersHistoryRequest& a, OrdersHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersHistoryRequest& from) {
    OrdersHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrdersHistoryRequest";
  }
  protected:
  explicit OrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderTypesFieldNumber = 5,
    kExecutionTypesFieldNumber = 12,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDirectionFieldNumber = 6,
    kIsConditionalFieldNumber = 9,
    kOrderTypeFieldNumber = 10,
    kStateFieldNumber = 11,
    kSkipFieldNumber = 3,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kLimitFieldNumber = 4,
  };
  // repeated string order_types = 5 [json_name = "orderTypes"];
  int order_types_size() const;
  private:
  int _internal_order_types_size() const;

  public:
  void clear_order_types() ;
  const std::string& order_types(int index) const;
  std::string* mutable_order_types(int index);
  void set_order_types(int index, const std::string& value);
  void set_order_types(int index, std::string&& value);
  void set_order_types(int index, const char* value);
  void set_order_types(int index, const char* value, std::size_t size);
  void set_order_types(int index, absl::string_view value);
  std::string* add_order_types();
  void add_order_types(const std::string& value);
  void add_order_types(std::string&& value);
  void add_order_types(const char* value);
  void add_order_types(const char* value, std::size_t size);
  void add_order_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_types();

  private:
  const std::string& _internal_order_types(int index) const;
  std::string* _internal_add_order_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_types();

  public:
  // repeated string execution_types = 12 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string direction = 6 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string is_conditional = 9 [json_name = "isConditional"];
  void clear_is_conditional() ;
  const std::string& is_conditional() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_is_conditional(Arg_&& arg, Args_... args);
  std::string* mutable_is_conditional();
  PROTOBUF_NODISCARD std::string* release_is_conditional();
  void set_allocated_is_conditional(std::string* ptr);

  private:
  const std::string& _internal_is_conditional() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_conditional(
      const std::string& value);
  std::string* _internal_mutable_is_conditional();

  public:
  // string order_type = 10 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // string state = 11 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 start_time = 7 [json_name = "startTime"];
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // sint64 end_time = 8 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrdersHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_conditional_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::uint64_t skip_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrdersHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.OrdersHistoryResponse) */ {
 public:
  inline OrdersHistoryResponse() : OrdersHistoryResponse(nullptr) {}
  ~OrdersHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrdersHistoryResponse(const OrdersHistoryResponse& from);
  OrdersHistoryResponse(OrdersHistoryResponse&& from) noexcept
    : OrdersHistoryResponse() {
    *this = ::std::move(from);
  }

  inline OrdersHistoryResponse& operator=(const OrdersHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrdersHistoryResponse& operator=(OrdersHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrdersHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrdersHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const OrdersHistoryResponse*>(
               &_OrdersHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(OrdersHistoryResponse& a, OrdersHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrdersHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrdersHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrdersHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrdersHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrdersHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrdersHistoryResponse& from) {
    OrdersHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrdersHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.OrdersHistoryResponse";
  }
  protected:
  explicit OrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrdersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1 [json_name = "orders"];
  int orders_size() const;
  private:
  int _internal_orders_size() const;

  public:
  void clear_orders() ;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* mutable_orders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeOrderHistory >*
      mutable_orders();
  private:
  const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& _internal_orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* _internal_add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeOrderHistory>& _internal_orders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeOrderHistory>* _internal_mutable_orders();
  public:
  const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& orders(int index) const;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* add_orders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeOrderHistory >&
      orders() const;
  // .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_derivative_exchange_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::Paging* release_paging();
  ::injective_derivative_exchange_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging);
  private:
  const ::injective_derivative_exchange_rpc::Paging& _internal_paging() const;
  ::injective_derivative_exchange_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_derivative_exchange_rpc::Paging* paging);
  ::injective_derivative_exchange_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.OrdersHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeOrderHistory > orders_;
    ::injective_derivative_exchange_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class DerivativeOrderHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.DerivativeOrderHistory) */ {
 public:
  inline DerivativeOrderHistory() : DerivativeOrderHistory(nullptr) {}
  ~DerivativeOrderHistory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivativeOrderHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivativeOrderHistory(const DerivativeOrderHistory& from);
  DerivativeOrderHistory(DerivativeOrderHistory&& from) noexcept
    : DerivativeOrderHistory() {
    *this = ::std::move(from);
  }

  inline DerivativeOrderHistory& operator=(const DerivativeOrderHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivativeOrderHistory& operator=(DerivativeOrderHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivativeOrderHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivativeOrderHistory* internal_default_instance() {
    return reinterpret_cast<const DerivativeOrderHistory*>(
               &_DerivativeOrderHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(DerivativeOrderHistory& a, DerivativeOrderHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivativeOrderHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivativeOrderHistory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivativeOrderHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivativeOrderHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivativeOrderHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DerivativeOrderHistory& from) {
    DerivativeOrderHistory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivativeOrderHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.DerivativeOrderHistory";
  }
  protected:
  explicit DerivativeOrderHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kSubaccountIdFieldNumber = 4,
    kExecutionTypeFieldNumber = 5,
    kOrderTypeFieldNumber = 6,
    kPriceFieldNumber = 7,
    kTriggerPriceFieldNumber = 8,
    kQuantityFieldNumber = 9,
    kFilledQuantityFieldNumber = 10,
    kStateFieldNumber = 11,
    kDirectionFieldNumber = 15,
    kPlacedOrderHashFieldNumber = 18,
    kMarginFieldNumber = 19,
    kCreatedAtFieldNumber = 12,
    kUpdatedAtFieldNumber = 13,
    kTriggerAtFieldNumber = 17,
    kIsActiveFieldNumber = 3,
    kIsReduceOnlyFieldNumber = 14,
    kIsConditionalFieldNumber = 16,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string subaccount_id = 4 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string execution_type = 5 [json_name = "executionType"];
  void clear_execution_type() ;
  const std::string& execution_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_execution_type(Arg_&& arg, Args_... args);
  std::string* mutable_execution_type();
  PROTOBUF_NODISCARD std::string* release_execution_type();
  void set_allocated_execution_type(std::string* ptr);

  private:
  const std::string& _internal_execution_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_type(
      const std::string& value);
  std::string* _internal_mutable_execution_type();

  public:
  // string order_type = 6 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // string price = 7 [json_name = "price"];
  void clear_price() ;
  const std::string& price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_price(Arg_&& arg, Args_... args);
  std::string* mutable_price();
  PROTOBUF_NODISCARD std::string* release_price();
  void set_allocated_price(std::string* ptr);

  private:
  const std::string& _internal_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_price(
      const std::string& value);
  std::string* _internal_mutable_price();

  public:
  // string trigger_price = 8 [json_name = "triggerPrice"];
  void clear_trigger_price() ;
  const std::string& trigger_price() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trigger_price(Arg_&& arg, Args_... args);
  std::string* mutable_trigger_price();
  PROTOBUF_NODISCARD std::string* release_trigger_price();
  void set_allocated_trigger_price(std::string* ptr);

  private:
  const std::string& _internal_trigger_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_price(
      const std::string& value);
  std::string* _internal_mutable_trigger_price();

  public:
  // string quantity = 9 [json_name = "quantity"];
  void clear_quantity() ;
  const std::string& quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* ptr);

  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(
      const std::string& value);
  std::string* _internal_mutable_quantity();

  public:
  // string filled_quantity = 10 [json_name = "filledQuantity"];
  void clear_filled_quantity() ;
  const std::string& filled_quantity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filled_quantity(Arg_&& arg, Args_... args);
  std::string* mutable_filled_quantity();
  PROTOBUF_NODISCARD std::string* release_filled_quantity();
  void set_allocated_filled_quantity(std::string* ptr);

  private:
  const std::string& _internal_filled_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filled_quantity(
      const std::string& value);
  std::string* _internal_mutable_filled_quantity();

  public:
  // string state = 11 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string direction = 15 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string placed_order_hash = 18 [json_name = "placedOrderHash"];
  void clear_placed_order_hash() ;
  const std::string& placed_order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_placed_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_placed_order_hash();
  PROTOBUF_NODISCARD std::string* release_placed_order_hash();
  void set_allocated_placed_order_hash(std::string* ptr);

  private:
  const std::string& _internal_placed_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placed_order_hash(
      const std::string& value);
  std::string* _internal_mutable_placed_order_hash();

  public:
  // string margin = 19 [json_name = "margin"];
  void clear_margin() ;
  const std::string& margin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_margin(Arg_&& arg, Args_... args);
  std::string* mutable_margin();
  PROTOBUF_NODISCARD std::string* release_margin();
  void set_allocated_margin(std::string* ptr);

  private:
  const std::string& _internal_margin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_margin(
      const std::string& value);
  std::string* _internal_mutable_margin();

  public:
  // sint64 created_at = 12 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // sint64 updated_at = 13 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // uint64 trigger_at = 17 [json_name = "triggerAt"];
  void clear_trigger_at() ;
  ::uint64_t trigger_at() const;
  void set_trigger_at(::uint64_t value);

  private:
  ::uint64_t _internal_trigger_at() const;
  void _internal_set_trigger_at(::uint64_t value);

  public:
  // bool is_active = 3 [json_name = "isActive"];
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // bool is_reduce_only = 14 [json_name = "isReduceOnly"];
  void clear_is_reduce_only() ;
  bool is_reduce_only() const;
  void set_is_reduce_only(bool value);

  private:
  bool _internal_is_reduce_only() const;
  void _internal_set_is_reduce_only(bool value);

  public:
  // bool is_conditional = 16 [json_name = "isConditional"];
  void clear_is_conditional() ;
  bool is_conditional() const;
  void set_is_conditional(bool value);

  private:
  bool _internal_is_conditional() const;
  void _internal_set_is_conditional(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.DerivativeOrderHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_price_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filled_quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placed_order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr margin_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    ::uint64_t trigger_at_;
    bool is_active_;
    bool is_reduce_only_;
    bool is_conditional_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest) */ {
 public:
  inline StreamOrdersHistoryRequest() : StreamOrdersHistoryRequest(nullptr) {}
  ~StreamOrdersHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersHistoryRequest(const StreamOrdersHistoryRequest& from);
  StreamOrdersHistoryRequest(StreamOrdersHistoryRequest&& from) noexcept
    : StreamOrdersHistoryRequest() {
    *this = ::std::move(from);
  }

  inline StreamOrdersHistoryRequest& operator=(const StreamOrdersHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersHistoryRequest& operator=(StreamOrdersHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersHistoryRequest*>(
               &_StreamOrdersHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(StreamOrdersHistoryRequest& a, StreamOrdersHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersHistoryRequest& from) {
    StreamOrdersHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrdersHistoryRequest";
  }
  protected:
  explicit StreamOrdersHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderTypesFieldNumber = 3,
    kExecutionTypesFieldNumber = 6,
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kDirectionFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // repeated string order_types = 3 [json_name = "orderTypes"];
  int order_types_size() const;
  private:
  int _internal_order_types_size() const;

  public:
  void clear_order_types() ;
  const std::string& order_types(int index) const;
  std::string* mutable_order_types(int index);
  void set_order_types(int index, const std::string& value);
  void set_order_types(int index, std::string&& value);
  void set_order_types(int index, const char* value);
  void set_order_types(int index, const char* value, std::size_t size);
  void set_order_types(int index, absl::string_view value);
  std::string* add_order_types();
  void add_order_types(const std::string& value);
  void add_order_types(std::string&& value);
  void add_order_types(const char* value);
  void add_order_types(const char* value, std::size_t size);
  void add_order_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_order_types();

  private:
  const std::string& _internal_order_types(int index) const;
  std::string* _internal_add_order_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_order_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_order_types();

  public:
  // repeated string execution_types = 6 [json_name = "executionTypes"];
  int execution_types_size() const;
  private:
  int _internal_execution_types_size() const;

  public:
  void clear_execution_types() ;
  const std::string& execution_types(int index) const;
  std::string* mutable_execution_types(int index);
  void set_execution_types(int index, const std::string& value);
  void set_execution_types(int index, std::string&& value);
  void set_execution_types(int index, const char* value);
  void set_execution_types(int index, const char* value, std::size_t size);
  void set_execution_types(int index, absl::string_view value);
  std::string* add_execution_types();
  void add_execution_types(const std::string& value);
  void add_execution_types(std::string&& value);
  void add_execution_types(const char* value);
  void add_execution_types(const char* value, std::size_t size);
  void add_execution_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_types();

  private:
  const std::string& _internal_execution_types(int index) const;
  std::string* _internal_add_execution_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_execution_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_execution_types();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string direction = 4 [json_name = "direction"];
  void clear_direction() ;
  const std::string& direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_direction(Arg_&& arg, Args_... args);
  std::string* mutable_direction();
  PROTOBUF_NODISCARD std::string* release_direction();
  void set_allocated_direction(std::string* ptr);

  private:
  const std::string& _internal_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_direction(
      const std::string& value);
  std::string* _internal_mutable_direction();

  public:
  // string state = 5 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> order_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr direction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamOrdersHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse) */ {
 public:
  inline StreamOrdersHistoryResponse() : StreamOrdersHistoryResponse(nullptr) {}
  ~StreamOrdersHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamOrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOrdersHistoryResponse(const StreamOrdersHistoryResponse& from);
  StreamOrdersHistoryResponse(StreamOrdersHistoryResponse&& from) noexcept
    : StreamOrdersHistoryResponse() {
    *this = ::std::move(from);
  }

  inline StreamOrdersHistoryResponse& operator=(const StreamOrdersHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOrdersHistoryResponse& operator=(StreamOrdersHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOrdersHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOrdersHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const StreamOrdersHistoryResponse*>(
               &_StreamOrdersHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(StreamOrdersHistoryResponse& a, StreamOrdersHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOrdersHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOrdersHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOrdersHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOrdersHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOrdersHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOrdersHistoryResponse& from) {
    StreamOrdersHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOrdersHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_derivative_exchange_rpc.StreamOrdersHistoryResponse";
  }
  protected:
  explicit StreamOrdersHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationTypeFieldNumber = 2,
    kOrderFieldNumber = 1,
    kTimestampFieldNumber = 3,
  };
  // string operation_type = 2 [json_name = "operationType"];
  void clear_operation_type() ;
  const std::string& operation_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operation_type(Arg_&& arg, Args_... args);
  std::string* mutable_operation_type();
  PROTOBUF_NODISCARD std::string* release_operation_type();
  void set_allocated_operation_type(std::string* ptr);

  private:
  const std::string& _internal_operation_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_type(
      const std::string& value);
  std::string* _internal_mutable_operation_type();

  public:
  // .injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1 [json_name = "order"];
  bool has_order() const;
  void clear_order() ;
  const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& order() const;
  PROTOBUF_NODISCARD ::injective_derivative_exchange_rpc::DerivativeOrderHistory* release_order();
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* mutable_order();
  void set_allocated_order(::injective_derivative_exchange_rpc::DerivativeOrderHistory* order);
  private:
  const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& _internal_order() const;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::injective_derivative_exchange_rpc::DerivativeOrderHistory* order);
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* unsafe_arena_release_order();
  // sint64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_type_;
    ::injective_derivative_exchange_rpc::DerivativeOrderHistory* order_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MarketsRequest

// string market_status = 1 [json_name = "marketStatus"];
inline void MarketsRequest::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& MarketsRequest::market_status() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.MarketsRequest.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketsRequest::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.MarketsRequest.market_status)
}
inline std::string* MarketsRequest::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.MarketsRequest.market_status)
  return _s;
}
inline const std::string& MarketsRequest::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void MarketsRequest::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketsRequest::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketsRequest::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.MarketsRequest.market_status)
  return _impl_.market_status_.Release();
}
inline void MarketsRequest::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.MarketsRequest.market_status)
}

// string quote_denom = 2 [json_name = "quoteDenom"];
inline void MarketsRequest::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& MarketsRequest::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.MarketsRequest.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketsRequest::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.MarketsRequest.quote_denom)
}
inline std::string* MarketsRequest::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.MarketsRequest.quote_denom)
  return _s;
}
inline const std::string& MarketsRequest::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void MarketsRequest::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketsRequest::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketsRequest::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.MarketsRequest.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void MarketsRequest::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.MarketsRequest.quote_denom)
}

// -------------------------------------------------------------------

// MarketsResponse

// repeated .injective_derivative_exchange_rpc.DerivativeMarketInfo markets = 1 [json_name = "markets"];
inline int MarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int MarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline void MarketsResponse::clear_markets() {
  _internal_mutable_markets()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.MarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeMarketInfo >*
MarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.MarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& MarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& MarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.MarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketsResponse::add_markets() {
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.MarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeMarketInfo >&
MarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.MarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeMarketInfo>&
MarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeMarketInfo>*
MarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// -------------------------------------------------------------------

// DerivativeMarketInfo

// string market_id = 1 [json_name = "marketId"];
inline void DerivativeMarketInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_id)
}
inline std::string* DerivativeMarketInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_id)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeMarketInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeMarketInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_id)
}

// string market_status = 2 [json_name = "marketStatus"];
inline void DerivativeMarketInfo::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::market_status() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_status)
}
inline std::string* DerivativeMarketInfo::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_status)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void DerivativeMarketInfo::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_status)
  return _impl_.market_status_.Release();
}
inline void DerivativeMarketInfo::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.market_status)
}

// string ticker = 3 [json_name = "ticker"];
inline void DerivativeMarketInfo::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::ticker() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.ticker)
}
inline std::string* DerivativeMarketInfo::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.ticker)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void DerivativeMarketInfo::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_ticker() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.ticker)
  return _impl_.ticker_.Release();
}
inline void DerivativeMarketInfo::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.ticker)
}

// string oracle_base = 4 [json_name = "oracleBase"];
inline void DerivativeMarketInfo::clear_oracle_base() {
  _impl_.oracle_base_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::oracle_base() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_base)
  return _internal_oracle_base();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_oracle_base(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_base_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_base)
}
inline std::string* DerivativeMarketInfo::mutable_oracle_base() {
  std::string* _s = _internal_mutable_oracle_base();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_base)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_oracle_base() const {
  return _impl_.oracle_base_.Get();
}
inline void DerivativeMarketInfo::_internal_set_oracle_base(const std::string& value) {
  ;


  _impl_.oracle_base_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_oracle_base() {
  ;
  return _impl_.oracle_base_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_oracle_base() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_base)
  return _impl_.oracle_base_.Release();
}
inline void DerivativeMarketInfo::set_allocated_oracle_base(std::string* value) {
  _impl_.oracle_base_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_base_.IsDefault()) {
          _impl_.oracle_base_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_base)
}

// string oracle_quote = 5 [json_name = "oracleQuote"];
inline void DerivativeMarketInfo::clear_oracle_quote() {
  _impl_.oracle_quote_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::oracle_quote() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_quote)
  return _internal_oracle_quote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_oracle_quote(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_quote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_quote)
}
inline std::string* DerivativeMarketInfo::mutable_oracle_quote() {
  std::string* _s = _internal_mutable_oracle_quote();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_quote)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_oracle_quote() const {
  return _impl_.oracle_quote_.Get();
}
inline void DerivativeMarketInfo::_internal_set_oracle_quote(const std::string& value) {
  ;


  _impl_.oracle_quote_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_oracle_quote() {
  ;
  return _impl_.oracle_quote_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_oracle_quote() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_quote)
  return _impl_.oracle_quote_.Release();
}
inline void DerivativeMarketInfo::set_allocated_oracle_quote(std::string* value) {
  _impl_.oracle_quote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_quote_.IsDefault()) {
          _impl_.oracle_quote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_quote)
}

// string oracle_type = 6 [json_name = "oracleType"];
inline void DerivativeMarketInfo::clear_oracle_type() {
  _impl_.oracle_type_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_type)
  return _internal_oracle_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_oracle_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_type)
}
inline std::string* DerivativeMarketInfo::mutable_oracle_type() {
  std::string* _s = _internal_mutable_oracle_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_type)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_oracle_type() const {
  return _impl_.oracle_type_.Get();
}
inline void DerivativeMarketInfo::_internal_set_oracle_type(const std::string& value) {
  ;


  _impl_.oracle_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_oracle_type() {
  ;
  return _impl_.oracle_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_oracle_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_type)
  return _impl_.oracle_type_.Release();
}
inline void DerivativeMarketInfo::set_allocated_oracle_type(std::string* value) {
  _impl_.oracle_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_type_.IsDefault()) {
          _impl_.oracle_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_type)
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void DerivativeMarketInfo::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t DerivativeMarketInfo::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void DerivativeMarketInfo::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.oracle_scale_factor)
}
inline ::uint32_t DerivativeMarketInfo::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void DerivativeMarketInfo::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// string initial_margin_ratio = 8 [json_name = "initialMarginRatio"];
inline void DerivativeMarketInfo::clear_initial_margin_ratio() {
  _impl_.initial_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::initial_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.initial_margin_ratio)
  return _internal_initial_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_initial_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.initial_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.initial_margin_ratio)
}
inline std::string* DerivativeMarketInfo::mutable_initial_margin_ratio() {
  std::string* _s = _internal_mutable_initial_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.initial_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_initial_margin_ratio() const {
  return _impl_.initial_margin_ratio_.Get();
}
inline void DerivativeMarketInfo::_internal_set_initial_margin_ratio(const std::string& value) {
  ;


  _impl_.initial_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_initial_margin_ratio() {
  ;
  return _impl_.initial_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_initial_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.initial_margin_ratio)
  return _impl_.initial_margin_ratio_.Release();
}
inline void DerivativeMarketInfo::set_allocated_initial_margin_ratio(std::string* value) {
  _impl_.initial_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_margin_ratio_.IsDefault()) {
          _impl_.initial_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.initial_margin_ratio)
}

// string maintenance_margin_ratio = 9 [json_name = "maintenanceMarginRatio"];
inline void DerivativeMarketInfo::clear_maintenance_margin_ratio() {
  _impl_.maintenance_margin_ratio_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::maintenance_margin_ratio() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.maintenance_margin_ratio)
  return _internal_maintenance_margin_ratio();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_maintenance_margin_ratio(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maintenance_margin_ratio_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.maintenance_margin_ratio)
}
inline std::string* DerivativeMarketInfo::mutable_maintenance_margin_ratio() {
  std::string* _s = _internal_mutable_maintenance_margin_ratio();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.maintenance_margin_ratio)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_maintenance_margin_ratio() const {
  return _impl_.maintenance_margin_ratio_.Get();
}
inline void DerivativeMarketInfo::_internal_set_maintenance_margin_ratio(const std::string& value) {
  ;


  _impl_.maintenance_margin_ratio_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_maintenance_margin_ratio() {
  ;
  return _impl_.maintenance_margin_ratio_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_maintenance_margin_ratio() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.maintenance_margin_ratio)
  return _impl_.maintenance_margin_ratio_.Release();
}
inline void DerivativeMarketInfo::set_allocated_maintenance_margin_ratio(std::string* value) {
  _impl_.maintenance_margin_ratio_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maintenance_margin_ratio_.IsDefault()) {
          _impl_.maintenance_margin_ratio_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.maintenance_margin_ratio)
}

// string quote_denom = 10 [json_name = "quoteDenom"];
inline void DerivativeMarketInfo::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_denom)
}
inline std::string* DerivativeMarketInfo::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_denom)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void DerivativeMarketInfo::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void DerivativeMarketInfo::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_denom)
}

// .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11 [json_name = "quoteTokenMeta"];
inline bool DerivativeMarketInfo::has_quote_token_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quote_token_meta_ != nullptr);
  return value;
}
inline void DerivativeMarketInfo::clear_quote_token_meta() {
  if (_impl_.quote_token_meta_ != nullptr) _impl_.quote_token_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::TokenMeta& DerivativeMarketInfo::_internal_quote_token_meta() const {
  const ::injective_derivative_exchange_rpc::TokenMeta* p = _impl_.quote_token_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::TokenMeta&>(
      ::injective_derivative_exchange_rpc::_TokenMeta_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::TokenMeta& DerivativeMarketInfo::quote_token_meta() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_token_meta)
  return _internal_quote_token_meta();
}
inline void DerivativeMarketInfo::unsafe_arena_set_allocated_quote_token_meta(
    ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quote_token_meta_);
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  if (quote_token_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_token_meta)
}
inline ::injective_derivative_exchange_rpc::TokenMeta* DerivativeMarketInfo::release_quote_token_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* DerivativeMarketInfo::unsafe_arena_release_quote_token_meta() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_token_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* DerivativeMarketInfo::_internal_mutable_quote_token_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.quote_token_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::TokenMeta>(GetArenaForAllocation());
    _impl_.quote_token_meta_ = p;
  }
  return _impl_.quote_token_meta_;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* DerivativeMarketInfo::mutable_quote_token_meta() {
  ::injective_derivative_exchange_rpc::TokenMeta* _msg = _internal_mutable_quote_token_meta();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_token_meta)
  return _msg;
}
inline void DerivativeMarketInfo::set_allocated_quote_token_meta(::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quote_token_meta_;
  }
  if (quote_token_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote_token_meta);
    if (message_arena != submessage_arena) {
      quote_token_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote_token_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.quote_token_meta)
}

// string maker_fee_rate = 12 [json_name = "makerFeeRate"];
inline void DerivativeMarketInfo::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.maker_fee_rate)
}
inline std::string* DerivativeMarketInfo::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.maker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void DerivativeMarketInfo::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void DerivativeMarketInfo::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.maker_fee_rate)
}

// string taker_fee_rate = 13 [json_name = "takerFeeRate"];
inline void DerivativeMarketInfo::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.taker_fee_rate)
}
inline std::string* DerivativeMarketInfo::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.taker_fee_rate)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void DerivativeMarketInfo::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void DerivativeMarketInfo::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.taker_fee_rate)
}

// string service_provider_fee = 14 [json_name = "serviceProviderFee"];
inline void DerivativeMarketInfo::clear_service_provider_fee() {
  _impl_.service_provider_fee_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::service_provider_fee() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.service_provider_fee)
  return _internal_service_provider_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_service_provider_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.service_provider_fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.service_provider_fee)
}
inline std::string* DerivativeMarketInfo::mutable_service_provider_fee() {
  std::string* _s = _internal_mutable_service_provider_fee();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.service_provider_fee)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_service_provider_fee() const {
  return _impl_.service_provider_fee_.Get();
}
inline void DerivativeMarketInfo::_internal_set_service_provider_fee(const std::string& value) {
  ;


  _impl_.service_provider_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_service_provider_fee() {
  ;
  return _impl_.service_provider_fee_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_service_provider_fee() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.service_provider_fee)
  return _impl_.service_provider_fee_.Release();
}
inline void DerivativeMarketInfo::set_allocated_service_provider_fee(std::string* value) {
  _impl_.service_provider_fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_provider_fee_.IsDefault()) {
          _impl_.service_provider_fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.service_provider_fee)
}

// bool is_perpetual = 15 [json_name = "isPerpetual"];
inline void DerivativeMarketInfo::clear_is_perpetual() {
  _impl_.is_perpetual_ = false;
}
inline bool DerivativeMarketInfo::is_perpetual() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.is_perpetual)
  return _internal_is_perpetual();
}
inline void DerivativeMarketInfo::set_is_perpetual(bool value) {
  _internal_set_is_perpetual(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.is_perpetual)
}
inline bool DerivativeMarketInfo::_internal_is_perpetual() const {
  return _impl_.is_perpetual_;
}
inline void DerivativeMarketInfo::_internal_set_is_perpetual(bool value) {
  ;
  _impl_.is_perpetual_ = value;
}

// string min_price_tick_size = 16 [json_name = "minPriceTickSize"];
inline void DerivativeMarketInfo::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_price_tick_size)
}
inline std::string* DerivativeMarketInfo::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_price_tick_size)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void DerivativeMarketInfo::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void DerivativeMarketInfo::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_price_tick_size)
}

// string min_quantity_tick_size = 17 [json_name = "minQuantityTickSize"];
inline void DerivativeMarketInfo::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& DerivativeMarketInfo::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeMarketInfo::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_quantity_tick_size)
}
inline std::string* DerivativeMarketInfo::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_quantity_tick_size)
  return _s;
}
inline const std::string& DerivativeMarketInfo::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void DerivativeMarketInfo::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeMarketInfo::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void DerivativeMarketInfo::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.min_quantity_tick_size)
}

// .injective_derivative_exchange_rpc.PerpetualMarketInfo perpetual_market_info = 18 [json_name = "perpetualMarketInfo"];
inline bool DerivativeMarketInfo::has_perpetual_market_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.perpetual_market_info_ != nullptr);
  return value;
}
inline void DerivativeMarketInfo::clear_perpetual_market_info() {
  if (_impl_.perpetual_market_info_ != nullptr) _impl_.perpetual_market_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective_derivative_exchange_rpc::PerpetualMarketInfo& DerivativeMarketInfo::_internal_perpetual_market_info() const {
  const ::injective_derivative_exchange_rpc::PerpetualMarketInfo* p = _impl_.perpetual_market_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::PerpetualMarketInfo&>(
      ::injective_derivative_exchange_rpc::_PerpetualMarketInfo_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::PerpetualMarketInfo& DerivativeMarketInfo::perpetual_market_info() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_info)
  return _internal_perpetual_market_info();
}
inline void DerivativeMarketInfo::unsafe_arena_set_allocated_perpetual_market_info(
    ::injective_derivative_exchange_rpc::PerpetualMarketInfo* perpetual_market_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perpetual_market_info_);
  }
  _impl_.perpetual_market_info_ = perpetual_market_info;
  if (perpetual_market_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_info)
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketInfo* DerivativeMarketInfo::release_perpetual_market_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* temp = _impl_.perpetual_market_info_;
  _impl_.perpetual_market_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketInfo* DerivativeMarketInfo::unsafe_arena_release_perpetual_market_info() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* temp = _impl_.perpetual_market_info_;
  _impl_.perpetual_market_info_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketInfo* DerivativeMarketInfo::_internal_mutable_perpetual_market_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.perpetual_market_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::PerpetualMarketInfo>(GetArenaForAllocation());
    _impl_.perpetual_market_info_ = p;
  }
  return _impl_.perpetual_market_info_;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketInfo* DerivativeMarketInfo::mutable_perpetual_market_info() {
  ::injective_derivative_exchange_rpc::PerpetualMarketInfo* _msg = _internal_mutable_perpetual_market_info();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_info)
  return _msg;
}
inline void DerivativeMarketInfo::set_allocated_perpetual_market_info(::injective_derivative_exchange_rpc::PerpetualMarketInfo* perpetual_market_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.perpetual_market_info_;
  }
  if (perpetual_market_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(perpetual_market_info);
    if (message_arena != submessage_arena) {
      perpetual_market_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, perpetual_market_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.perpetual_market_info_ = perpetual_market_info;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_info)
}

// .injective_derivative_exchange_rpc.PerpetualMarketFunding perpetual_market_funding = 19 [json_name = "perpetualMarketFunding"];
inline bool DerivativeMarketInfo::has_perpetual_market_funding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.perpetual_market_funding_ != nullptr);
  return value;
}
inline void DerivativeMarketInfo::clear_perpetual_market_funding() {
  if (_impl_.perpetual_market_funding_ != nullptr) _impl_.perpetual_market_funding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::injective_derivative_exchange_rpc::PerpetualMarketFunding& DerivativeMarketInfo::_internal_perpetual_market_funding() const {
  const ::injective_derivative_exchange_rpc::PerpetualMarketFunding* p = _impl_.perpetual_market_funding_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::PerpetualMarketFunding&>(
      ::injective_derivative_exchange_rpc::_PerpetualMarketFunding_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::PerpetualMarketFunding& DerivativeMarketInfo::perpetual_market_funding() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_funding)
  return _internal_perpetual_market_funding();
}
inline void DerivativeMarketInfo::unsafe_arena_set_allocated_perpetual_market_funding(
    ::injective_derivative_exchange_rpc::PerpetualMarketFunding* perpetual_market_funding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.perpetual_market_funding_);
  }
  _impl_.perpetual_market_funding_ = perpetual_market_funding;
  if (perpetual_market_funding) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_funding)
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketFunding* DerivativeMarketInfo::release_perpetual_market_funding() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* temp = _impl_.perpetual_market_funding_;
  _impl_.perpetual_market_funding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketFunding* DerivativeMarketInfo::unsafe_arena_release_perpetual_market_funding() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_funding)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* temp = _impl_.perpetual_market_funding_;
  _impl_.perpetual_market_funding_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketFunding* DerivativeMarketInfo::_internal_mutable_perpetual_market_funding() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.perpetual_market_funding_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::PerpetualMarketFunding>(GetArenaForAllocation());
    _impl_.perpetual_market_funding_ = p;
  }
  return _impl_.perpetual_market_funding_;
}
inline ::injective_derivative_exchange_rpc::PerpetualMarketFunding* DerivativeMarketInfo::mutable_perpetual_market_funding() {
  ::injective_derivative_exchange_rpc::PerpetualMarketFunding* _msg = _internal_mutable_perpetual_market_funding();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_funding)
  return _msg;
}
inline void DerivativeMarketInfo::set_allocated_perpetual_market_funding(::injective_derivative_exchange_rpc::PerpetualMarketFunding* perpetual_market_funding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.perpetual_market_funding_;
  }
  if (perpetual_market_funding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(perpetual_market_funding);
    if (message_arena != submessage_arena) {
      perpetual_market_funding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, perpetual_market_funding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.perpetual_market_funding_ = perpetual_market_funding;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.perpetual_market_funding)
}

// .injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo expiry_futures_market_info = 20 [json_name = "expiryFuturesMarketInfo"];
inline bool DerivativeMarketInfo::has_expiry_futures_market_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiry_futures_market_info_ != nullptr);
  return value;
}
inline void DerivativeMarketInfo::clear_expiry_futures_market_info() {
  if (_impl_.expiry_futures_market_info_ != nullptr) _impl_.expiry_futures_market_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo& DerivativeMarketInfo::_internal_expiry_futures_market_info() const {
  const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* p = _impl_.expiry_futures_market_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo&>(
      ::injective_derivative_exchange_rpc::_ExpiryFuturesMarketInfo_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo& DerivativeMarketInfo::expiry_futures_market_info() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeMarketInfo.expiry_futures_market_info)
  return _internal_expiry_futures_market_info();
}
inline void DerivativeMarketInfo::unsafe_arena_set_allocated_expiry_futures_market_info(
    ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* expiry_futures_market_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiry_futures_market_info_);
  }
  _impl_.expiry_futures_market_info_ = expiry_futures_market_info;
  if (expiry_futures_market_info) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.expiry_futures_market_info)
}
inline ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* DerivativeMarketInfo::release_expiry_futures_market_info() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* temp = _impl_.expiry_futures_market_info_;
  _impl_.expiry_futures_market_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* DerivativeMarketInfo::unsafe_arena_release_expiry_futures_market_info() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeMarketInfo.expiry_futures_market_info)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* temp = _impl_.expiry_futures_market_info_;
  _impl_.expiry_futures_market_info_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* DerivativeMarketInfo::_internal_mutable_expiry_futures_market_info() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.expiry_futures_market_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo>(GetArenaForAllocation());
    _impl_.expiry_futures_market_info_ = p;
  }
  return _impl_.expiry_futures_market_info_;
}
inline ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* DerivativeMarketInfo::mutable_expiry_futures_market_info() {
  ::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* _msg = _internal_mutable_expiry_futures_market_info();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeMarketInfo.expiry_futures_market_info)
  return _msg;
}
inline void DerivativeMarketInfo::set_allocated_expiry_futures_market_info(::injective_derivative_exchange_rpc::ExpiryFuturesMarketInfo* expiry_futures_market_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.expiry_futures_market_info_;
  }
  if (expiry_futures_market_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expiry_futures_market_info);
    if (message_arena != submessage_arena) {
      expiry_futures_market_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expiry_futures_market_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.expiry_futures_market_info_ = expiry_futures_market_info;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeMarketInfo.expiry_futures_market_info)
}

// -------------------------------------------------------------------

// TokenMeta

// string name = 1 [json_name = "name"];
inline void TokenMeta::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TokenMeta::name() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.name)
}
inline std::string* TokenMeta::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TokenMeta.name)
  return _s;
}
inline const std::string& TokenMeta::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TokenMeta::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_name() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TokenMeta.name)
  return _impl_.name_.Release();
}
inline void TokenMeta::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TokenMeta.name)
}

// string address = 2 [json_name = "address"];
inline void TokenMeta::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& TokenMeta::address() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.address)
}
inline std::string* TokenMeta::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TokenMeta.address)
  return _s;
}
inline const std::string& TokenMeta::_internal_address() const {
  return _impl_.address_.Get();
}
inline void TokenMeta::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_address() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TokenMeta.address)
  return _impl_.address_.Release();
}
inline void TokenMeta::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TokenMeta.address)
}

// string symbol = 3 [json_name = "symbol"];
inline void TokenMeta::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& TokenMeta::symbol() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.symbol)
}
inline std::string* TokenMeta::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TokenMeta.symbol)
  return _s;
}
inline const std::string& TokenMeta::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void TokenMeta::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_symbol() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TokenMeta.symbol)
  return _impl_.symbol_.Release();
}
inline void TokenMeta::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TokenMeta.symbol)
}

// string logo = 4 [json_name = "logo"];
inline void TokenMeta::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& TokenMeta::logo() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.logo)
  return _internal_logo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TokenMeta::set_logo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.logo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.logo)
}
inline std::string* TokenMeta::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TokenMeta.logo)
  return _s;
}
inline const std::string& TokenMeta::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void TokenMeta::_internal_set_logo(const std::string& value) {
  ;


  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenMeta::_internal_mutable_logo() {
  ;
  return _impl_.logo_.Mutable( GetArenaForAllocation());
}
inline std::string* TokenMeta::release_logo() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TokenMeta.logo)
  return _impl_.logo_.Release();
}
inline void TokenMeta::set_allocated_logo(std::string* value) {
  _impl_.logo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logo_.IsDefault()) {
          _impl_.logo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TokenMeta.logo)
}

// sint32 decimals = 5 [json_name = "decimals"];
inline void TokenMeta::clear_decimals() {
  _impl_.decimals_ = 0;
}
inline ::int32_t TokenMeta::decimals() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.decimals)
  return _internal_decimals();
}
inline void TokenMeta::set_decimals(::int32_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.decimals)
}
inline ::int32_t TokenMeta::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void TokenMeta::_internal_set_decimals(::int32_t value) {
  ;
  _impl_.decimals_ = value;
}

// sint64 updated_at = 6 [json_name = "updatedAt"];
inline void TokenMeta::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t TokenMeta::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TokenMeta.updated_at)
  return _internal_updated_at();
}
inline void TokenMeta::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TokenMeta.updated_at)
}
inline ::int64_t TokenMeta::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void TokenMeta::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// PerpetualMarketInfo

// string hourly_funding_rate_cap = 1 [json_name = "hourlyFundingRateCap"];
inline void PerpetualMarketInfo::clear_hourly_funding_rate_cap() {
  _impl_.hourly_funding_rate_cap_.ClearToEmpty();
}
inline const std::string& PerpetualMarketInfo::hourly_funding_rate_cap() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _internal_hourly_funding_rate_cap();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketInfo::set_hourly_funding_rate_cap(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourly_funding_rate_cap_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_funding_rate_cap)
}
inline std::string* PerpetualMarketInfo::mutable_hourly_funding_rate_cap() {
  std::string* _s = _internal_mutable_hourly_funding_rate_cap();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _s;
}
inline const std::string& PerpetualMarketInfo::_internal_hourly_funding_rate_cap() const {
  return _impl_.hourly_funding_rate_cap_.Get();
}
inline void PerpetualMarketInfo::_internal_set_hourly_funding_rate_cap(const std::string& value) {
  ;


  _impl_.hourly_funding_rate_cap_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::_internal_mutable_hourly_funding_rate_cap() {
  ;
  return _impl_.hourly_funding_rate_cap_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::release_hourly_funding_rate_cap() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_funding_rate_cap)
  return _impl_.hourly_funding_rate_cap_.Release();
}
inline void PerpetualMarketInfo::set_allocated_hourly_funding_rate_cap(std::string* value) {
  _impl_.hourly_funding_rate_cap_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourly_funding_rate_cap_.IsDefault()) {
          _impl_.hourly_funding_rate_cap_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_funding_rate_cap)
}

// string hourly_interest_rate = 2 [json_name = "hourlyInterestRate"];
inline void PerpetualMarketInfo::clear_hourly_interest_rate() {
  _impl_.hourly_interest_rate_.ClearToEmpty();
}
inline const std::string& PerpetualMarketInfo::hourly_interest_rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_interest_rate)
  return _internal_hourly_interest_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketInfo::set_hourly_interest_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hourly_interest_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_interest_rate)
}
inline std::string* PerpetualMarketInfo::mutable_hourly_interest_rate() {
  std::string* _s = _internal_mutable_hourly_interest_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_interest_rate)
  return _s;
}
inline const std::string& PerpetualMarketInfo::_internal_hourly_interest_rate() const {
  return _impl_.hourly_interest_rate_.Get();
}
inline void PerpetualMarketInfo::_internal_set_hourly_interest_rate(const std::string& value) {
  ;


  _impl_.hourly_interest_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::_internal_mutable_hourly_interest_rate() {
  ;
  return _impl_.hourly_interest_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketInfo::release_hourly_interest_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_interest_rate)
  return _impl_.hourly_interest_rate_.Release();
}
inline void PerpetualMarketInfo::set_allocated_hourly_interest_rate(std::string* value) {
  _impl_.hourly_interest_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hourly_interest_rate_.IsDefault()) {
          _impl_.hourly_interest_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PerpetualMarketInfo.hourly_interest_rate)
}

// sint64 next_funding_timestamp = 3 [json_name = "nextFundingTimestamp"];
inline void PerpetualMarketInfo::clear_next_funding_timestamp() {
  _impl_.next_funding_timestamp_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketInfo::next_funding_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketInfo.next_funding_timestamp)
  return _internal_next_funding_timestamp();
}
inline void PerpetualMarketInfo::set_next_funding_timestamp(::int64_t value) {
  _internal_set_next_funding_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketInfo.next_funding_timestamp)
}
inline ::int64_t PerpetualMarketInfo::_internal_next_funding_timestamp() const {
  return _impl_.next_funding_timestamp_;
}
inline void PerpetualMarketInfo::_internal_set_next_funding_timestamp(::int64_t value) {
  ;
  _impl_.next_funding_timestamp_ = value;
}

// sint64 funding_interval = 4 [json_name = "fundingInterval"];
inline void PerpetualMarketInfo::clear_funding_interval() {
  _impl_.funding_interval_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketInfo::funding_interval() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketInfo.funding_interval)
  return _internal_funding_interval();
}
inline void PerpetualMarketInfo::set_funding_interval(::int64_t value) {
  _internal_set_funding_interval(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketInfo.funding_interval)
}
inline ::int64_t PerpetualMarketInfo::_internal_funding_interval() const {
  return _impl_.funding_interval_;
}
inline void PerpetualMarketInfo::_internal_set_funding_interval(::int64_t value) {
  ;
  _impl_.funding_interval_ = value;
}

// -------------------------------------------------------------------

// PerpetualMarketFunding

// string cumulative_funding = 1 [json_name = "cumulativeFunding"];
inline void PerpetualMarketFunding::clear_cumulative_funding() {
  _impl_.cumulative_funding_.ClearToEmpty();
}
inline const std::string& PerpetualMarketFunding::cumulative_funding() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_funding)
  return _internal_cumulative_funding();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketFunding::set_cumulative_funding(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_funding_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_funding)
}
inline std::string* PerpetualMarketFunding::mutable_cumulative_funding() {
  std::string* _s = _internal_mutable_cumulative_funding();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_funding)
  return _s;
}
inline const std::string& PerpetualMarketFunding::_internal_cumulative_funding() const {
  return _impl_.cumulative_funding_.Get();
}
inline void PerpetualMarketFunding::_internal_set_cumulative_funding(const std::string& value) {
  ;


  _impl_.cumulative_funding_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::_internal_mutable_cumulative_funding() {
  ;
  return _impl_.cumulative_funding_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::release_cumulative_funding() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_funding)
  return _impl_.cumulative_funding_.Release();
}
inline void PerpetualMarketFunding::set_allocated_cumulative_funding(std::string* value) {
  _impl_.cumulative_funding_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_funding_.IsDefault()) {
          _impl_.cumulative_funding_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_funding)
}

// string cumulative_price = 2 [json_name = "cumulativePrice"];
inline void PerpetualMarketFunding::clear_cumulative_price() {
  _impl_.cumulative_price_.ClearToEmpty();
}
inline const std::string& PerpetualMarketFunding::cumulative_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_price)
  return _internal_cumulative_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PerpetualMarketFunding::set_cumulative_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cumulative_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_price)
}
inline std::string* PerpetualMarketFunding::mutable_cumulative_price() {
  std::string* _s = _internal_mutable_cumulative_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_price)
  return _s;
}
inline const std::string& PerpetualMarketFunding::_internal_cumulative_price() const {
  return _impl_.cumulative_price_.Get();
}
inline void PerpetualMarketFunding::_internal_set_cumulative_price(const std::string& value) {
  ;


  _impl_.cumulative_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::_internal_mutable_cumulative_price() {
  ;
  return _impl_.cumulative_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PerpetualMarketFunding::release_cumulative_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_price)
  return _impl_.cumulative_price_.Release();
}
inline void PerpetualMarketFunding::set_allocated_cumulative_price(std::string* value) {
  _impl_.cumulative_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cumulative_price_.IsDefault()) {
          _impl_.cumulative_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PerpetualMarketFunding.cumulative_price)
}

// sint64 last_timestamp = 3 [json_name = "lastTimestamp"];
inline void PerpetualMarketFunding::clear_last_timestamp() {
  _impl_.last_timestamp_ = ::int64_t{0};
}
inline ::int64_t PerpetualMarketFunding::last_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PerpetualMarketFunding.last_timestamp)
  return _internal_last_timestamp();
}
inline void PerpetualMarketFunding::set_last_timestamp(::int64_t value) {
  _internal_set_last_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PerpetualMarketFunding.last_timestamp)
}
inline ::int64_t PerpetualMarketFunding::_internal_last_timestamp() const {
  return _impl_.last_timestamp_;
}
inline void PerpetualMarketFunding::_internal_set_last_timestamp(::int64_t value) {
  ;
  _impl_.last_timestamp_ = value;
}

// -------------------------------------------------------------------

// ExpiryFuturesMarketInfo

// sint64 expiration_timestamp = 1 [json_name = "expirationTimestamp"];
inline void ExpiryFuturesMarketInfo::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t ExpiryFuturesMarketInfo::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void ExpiryFuturesMarketInfo::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.expiration_timestamp)
}
inline ::int64_t ExpiryFuturesMarketInfo::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void ExpiryFuturesMarketInfo::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// string settlement_price = 2 [json_name = "settlementPrice"];
inline void ExpiryFuturesMarketInfo::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& ExpiryFuturesMarketInfo::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExpiryFuturesMarketInfo::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.settlement_price)
}
inline std::string* ExpiryFuturesMarketInfo::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.settlement_price)
  return _s;
}
inline const std::string& ExpiryFuturesMarketInfo::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void ExpiryFuturesMarketInfo::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* ExpiryFuturesMarketInfo::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void ExpiryFuturesMarketInfo::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.ExpiryFuturesMarketInfo.settlement_price)
}

// -------------------------------------------------------------------

// MarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void MarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& MarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.MarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.MarketRequest.market_id)
}
inline std::string* MarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.MarketRequest.market_id)
  return _s;
}
inline const std::string& MarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void MarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* MarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.MarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void MarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.MarketRequest.market_id)
}

// -------------------------------------------------------------------

// MarketResponse

// .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1 [json_name = "market"];
inline bool MarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void MarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& MarketResponse::_internal_market() const {
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeMarketInfo&>(
      ::injective_derivative_exchange_rpc::_DerivativeMarketInfo_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& MarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.MarketResponse.market)
  return _internal_market();
}
inline void MarketResponse::unsafe_arena_set_allocated_market(
    ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.MarketResponse.market)
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.MarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeMarketInfo>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* MarketResponse::mutable_market() {
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.MarketResponse.market)
  return _msg;
}
inline void MarketResponse::set_allocated_market(::injective_derivative_exchange_rpc::DerivativeMarketInfo* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.MarketResponse.market)
}

// -------------------------------------------------------------------

// StreamMarketRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamMarketRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamMarketRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamMarketRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamMarketRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
  return _s;
}
inline const std::string& StreamMarketRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamMarketRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamMarketRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline void StreamMarketRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamMarketRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamMarketRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamMarketRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamMarketRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamMarketRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamMarketRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamMarketRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamMarketResponse

// .injective_derivative_exchange_rpc.DerivativeMarketInfo market = 1 [json_name = "market"];
inline bool StreamMarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void StreamMarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& StreamMarketResponse::_internal_market() const {
  const ::injective_derivative_exchange_rpc::DerivativeMarketInfo* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeMarketInfo&>(
      ::injective_derivative_exchange_rpc::_DerivativeMarketInfo_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeMarketInfo& StreamMarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamMarketResponse.market)
  return _internal_market();
}
inline void StreamMarketResponse::unsafe_arena_set_allocated_market(
    ::injective_derivative_exchange_rpc::DerivativeMarketInfo* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamMarketResponse.market)
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* StreamMarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* StreamMarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamMarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* StreamMarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeMarketInfo>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective_derivative_exchange_rpc::DerivativeMarketInfo* StreamMarketResponse::mutable_market() {
  ::injective_derivative_exchange_rpc::DerivativeMarketInfo* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamMarketResponse.market)
  return _msg;
}
inline void StreamMarketResponse::set_allocated_market(::injective_derivative_exchange_rpc::DerivativeMarketInfo* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamMarketResponse.market)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamMarketResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamMarketResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamMarketResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamMarketResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamMarketResponse.operation_type)
}
inline std::string* StreamMarketResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamMarketResponse.operation_type)
  return _s;
}
inline const std::string& StreamMarketResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamMarketResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamMarketResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamMarketResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamMarketResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamMarketResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamMarketResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamMarketResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamMarketResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamMarketResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamMarketResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamMarketResponse.timestamp)
}
inline ::int64_t StreamMarketResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamMarketResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// BinaryOptionsMarketsRequest

// string market_status = 1 [json_name = "marketStatus"];
inline void BinaryOptionsMarketsRequest::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketsRequest::market_status() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketsRequest::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.market_status)
}
inline std::string* BinaryOptionsMarketsRequest::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.market_status)
  return _s;
}
inline const std::string& BinaryOptionsMarketsRequest::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void BinaryOptionsMarketsRequest::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketsRequest::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketsRequest::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.market_status)
  return _impl_.market_status_.Release();
}
inline void BinaryOptionsMarketsRequest::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.market_status)
}

// string quote_denom = 2 [json_name = "quoteDenom"];
inline void BinaryOptionsMarketsRequest::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketsRequest::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketsRequest::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.quote_denom)
}
inline std::string* BinaryOptionsMarketsRequest::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.quote_denom)
  return _s;
}
inline const std::string& BinaryOptionsMarketsRequest::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void BinaryOptionsMarketsRequest::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketsRequest::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketsRequest::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void BinaryOptionsMarketsRequest::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.quote_denom)
}

// uint64 skip = 3 [json_name = "skip"];
inline void BinaryOptionsMarketsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t BinaryOptionsMarketsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.skip)
  return _internal_skip();
}
inline void BinaryOptionsMarketsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.skip)
}
inline ::uint64_t BinaryOptionsMarketsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void BinaryOptionsMarketsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void BinaryOptionsMarketsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t BinaryOptionsMarketsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.limit)
  return _internal_limit();
}
inline void BinaryOptionsMarketsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketsRequest.limit)
}
inline ::int32_t BinaryOptionsMarketsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void BinaryOptionsMarketsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// BinaryOptionsMarketsResponse

// repeated .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo markets = 1 [json_name = "markets"];
inline int BinaryOptionsMarketsResponse::_internal_markets_size() const {
  return _impl_.markets_.size();
}
inline int BinaryOptionsMarketsResponse::markets_size() const {
  return _internal_markets_size();
}
inline void BinaryOptionsMarketsResponse::clear_markets() {
  _internal_mutable_markets()->Clear();
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketsResponse::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.markets)
  return _internal_mutable_markets()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo >*
BinaryOptionsMarketsResponse::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.markets)
  return _internal_mutable_markets();
}
inline const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& BinaryOptionsMarketsResponse::_internal_markets(int index) const {
  return _internal_markets().Get(index);
}
inline const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& BinaryOptionsMarketsResponse::markets(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.markets)
  return _internal_markets(index);
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketsResponse::_internal_add_markets() {
  return _internal_mutable_markets()->Add();
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketsResponse::add_markets() {
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* _add = _internal_add_markets();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.markets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo >&
BinaryOptionsMarketsResponse::markets() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.markets)
  return _internal_markets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>&
BinaryOptionsMarketsResponse::_internal_markets() const {
  return _impl_.markets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>*
BinaryOptionsMarketsResponse::_internal_mutable_markets() {
  return &_impl_.markets_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool BinaryOptionsMarketsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void BinaryOptionsMarketsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& BinaryOptionsMarketsResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& BinaryOptionsMarketsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.paging)
  return _internal_paging();
}
inline void BinaryOptionsMarketsResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* BinaryOptionsMarketsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* BinaryOptionsMarketsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* BinaryOptionsMarketsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* BinaryOptionsMarketsResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.paging)
  return _msg;
}
inline void BinaryOptionsMarketsResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketsResponse.paging)
}

// -------------------------------------------------------------------

// BinaryOptionsMarketInfo

// string market_id = 1 [json_name = "marketId"];
inline void BinaryOptionsMarketInfo::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_id)
}
inline std::string* BinaryOptionsMarketInfo::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_id)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_id)
  return _impl_.market_id_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_id)
}

// string market_status = 2 [json_name = "marketStatus"];
inline void BinaryOptionsMarketInfo::clear_market_status() {
  _impl_.market_status_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::market_status() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_status)
  return _internal_market_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_market_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_status)
}
inline std::string* BinaryOptionsMarketInfo::mutable_market_status() {
  std::string* _s = _internal_mutable_market_status();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_status)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_market_status() const {
  return _impl_.market_status_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_market_status(const std::string& value) {
  ;


  _impl_.market_status_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_market_status() {
  ;
  return _impl_.market_status_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_market_status() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_status)
  return _impl_.market_status_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_market_status(std::string* value) {
  _impl_.market_status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_status_.IsDefault()) {
          _impl_.market_status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.market_status)
}

// string ticker = 3 [json_name = "ticker"];
inline void BinaryOptionsMarketInfo::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::ticker() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.ticker)
}
inline std::string* BinaryOptionsMarketInfo::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.ticker)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_ticker() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.ticker)
  return _impl_.ticker_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.ticker)
}

// string oracle_symbol = 4 [json_name = "oracleSymbol"];
inline void BinaryOptionsMarketInfo::clear_oracle_symbol() {
  _impl_.oracle_symbol_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::oracle_symbol() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_symbol)
  return _internal_oracle_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_oracle_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_symbol)
}
inline std::string* BinaryOptionsMarketInfo::mutable_oracle_symbol() {
  std::string* _s = _internal_mutable_oracle_symbol();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_symbol)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_oracle_symbol() const {
  return _impl_.oracle_symbol_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_oracle_symbol(const std::string& value) {
  ;


  _impl_.oracle_symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_oracle_symbol() {
  ;
  return _impl_.oracle_symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_oracle_symbol() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_symbol)
  return _impl_.oracle_symbol_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_oracle_symbol(std::string* value) {
  _impl_.oracle_symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_symbol_.IsDefault()) {
          _impl_.oracle_symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_symbol)
}

// string oracle_provider = 5 [json_name = "oracleProvider"];
inline void BinaryOptionsMarketInfo::clear_oracle_provider() {
  _impl_.oracle_provider_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::oracle_provider() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_provider)
  return _internal_oracle_provider();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_oracle_provider(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_provider_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_provider)
}
inline std::string* BinaryOptionsMarketInfo::mutable_oracle_provider() {
  std::string* _s = _internal_mutable_oracle_provider();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_provider)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_oracle_provider() const {
  return _impl_.oracle_provider_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_oracle_provider(const std::string& value) {
  ;


  _impl_.oracle_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_oracle_provider() {
  ;
  return _impl_.oracle_provider_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_oracle_provider() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_provider)
  return _impl_.oracle_provider_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_oracle_provider(std::string* value) {
  _impl_.oracle_provider_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_provider_.IsDefault()) {
          _impl_.oracle_provider_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_provider)
}

// string oracle_type = 6 [json_name = "oracleType"];
inline void BinaryOptionsMarketInfo::clear_oracle_type() {
  _impl_.oracle_type_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::oracle_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_type)
  return _internal_oracle_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_oracle_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.oracle_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_type)
}
inline std::string* BinaryOptionsMarketInfo::mutable_oracle_type() {
  std::string* _s = _internal_mutable_oracle_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_type)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_oracle_type() const {
  return _impl_.oracle_type_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_oracle_type(const std::string& value) {
  ;


  _impl_.oracle_type_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_oracle_type() {
  ;
  return _impl_.oracle_type_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_oracle_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_type)
  return _impl_.oracle_type_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_oracle_type(std::string* value) {
  _impl_.oracle_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oracle_type_.IsDefault()) {
          _impl_.oracle_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_type)
}

// uint32 oracle_scale_factor = 7 [json_name = "oracleScaleFactor"];
inline void BinaryOptionsMarketInfo::clear_oracle_scale_factor() {
  _impl_.oracle_scale_factor_ = 0u;
}
inline ::uint32_t BinaryOptionsMarketInfo::oracle_scale_factor() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_scale_factor)
  return _internal_oracle_scale_factor();
}
inline void BinaryOptionsMarketInfo::set_oracle_scale_factor(::uint32_t value) {
  _internal_set_oracle_scale_factor(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.oracle_scale_factor)
}
inline ::uint32_t BinaryOptionsMarketInfo::_internal_oracle_scale_factor() const {
  return _impl_.oracle_scale_factor_;
}
inline void BinaryOptionsMarketInfo::_internal_set_oracle_scale_factor(::uint32_t value) {
  ;
  _impl_.oracle_scale_factor_ = value;
}

// sint64 expiration_timestamp = 8 [json_name = "expirationTimestamp"];
inline void BinaryOptionsMarketInfo::clear_expiration_timestamp() {
  _impl_.expiration_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketInfo::expiration_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.expiration_timestamp)
  return _internal_expiration_timestamp();
}
inline void BinaryOptionsMarketInfo::set_expiration_timestamp(::int64_t value) {
  _internal_set_expiration_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.expiration_timestamp)
}
inline ::int64_t BinaryOptionsMarketInfo::_internal_expiration_timestamp() const {
  return _impl_.expiration_timestamp_;
}
inline void BinaryOptionsMarketInfo::_internal_set_expiration_timestamp(::int64_t value) {
  ;
  _impl_.expiration_timestamp_ = value;
}

// sint64 settlement_timestamp = 9 [json_name = "settlementTimestamp"];
inline void BinaryOptionsMarketInfo::clear_settlement_timestamp() {
  _impl_.settlement_timestamp_ = ::int64_t{0};
}
inline ::int64_t BinaryOptionsMarketInfo::settlement_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_timestamp)
  return _internal_settlement_timestamp();
}
inline void BinaryOptionsMarketInfo::set_settlement_timestamp(::int64_t value) {
  _internal_set_settlement_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_timestamp)
}
inline ::int64_t BinaryOptionsMarketInfo::_internal_settlement_timestamp() const {
  return _impl_.settlement_timestamp_;
}
inline void BinaryOptionsMarketInfo::_internal_set_settlement_timestamp(::int64_t value) {
  ;
  _impl_.settlement_timestamp_ = value;
}

// string quote_denom = 10 [json_name = "quoteDenom"];
inline void BinaryOptionsMarketInfo::clear_quote_denom() {
  _impl_.quote_denom_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::quote_denom() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_denom)
  return _internal_quote_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_quote_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quote_denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_denom)
}
inline std::string* BinaryOptionsMarketInfo::mutable_quote_denom() {
  std::string* _s = _internal_mutable_quote_denom();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_denom)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_quote_denom() const {
  return _impl_.quote_denom_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_quote_denom(const std::string& value) {
  ;


  _impl_.quote_denom_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_quote_denom() {
  ;
  return _impl_.quote_denom_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_quote_denom() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_denom)
  return _impl_.quote_denom_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_quote_denom(std::string* value) {
  _impl_.quote_denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quote_denom_.IsDefault()) {
          _impl_.quote_denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_denom)
}

// .injective_derivative_exchange_rpc.TokenMeta quote_token_meta = 11 [json_name = "quoteTokenMeta"];
inline bool BinaryOptionsMarketInfo::has_quote_token_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quote_token_meta_ != nullptr);
  return value;
}
inline void BinaryOptionsMarketInfo::clear_quote_token_meta() {
  if (_impl_.quote_token_meta_ != nullptr) _impl_.quote_token_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::TokenMeta& BinaryOptionsMarketInfo::_internal_quote_token_meta() const {
  const ::injective_derivative_exchange_rpc::TokenMeta* p = _impl_.quote_token_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::TokenMeta&>(
      ::injective_derivative_exchange_rpc::_TokenMeta_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::TokenMeta& BinaryOptionsMarketInfo::quote_token_meta() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_token_meta)
  return _internal_quote_token_meta();
}
inline void BinaryOptionsMarketInfo::unsafe_arena_set_allocated_quote_token_meta(
    ::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quote_token_meta_);
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  if (quote_token_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_token_meta)
}
inline ::injective_derivative_exchange_rpc::TokenMeta* BinaryOptionsMarketInfo::release_quote_token_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* BinaryOptionsMarketInfo::unsafe_arena_release_quote_token_meta() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_token_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::TokenMeta* temp = _impl_.quote_token_meta_;
  _impl_.quote_token_meta_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* BinaryOptionsMarketInfo::_internal_mutable_quote_token_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.quote_token_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::TokenMeta>(GetArenaForAllocation());
    _impl_.quote_token_meta_ = p;
  }
  return _impl_.quote_token_meta_;
}
inline ::injective_derivative_exchange_rpc::TokenMeta* BinaryOptionsMarketInfo::mutable_quote_token_meta() {
  ::injective_derivative_exchange_rpc::TokenMeta* _msg = _internal_mutable_quote_token_meta();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_token_meta)
  return _msg;
}
inline void BinaryOptionsMarketInfo::set_allocated_quote_token_meta(::injective_derivative_exchange_rpc::TokenMeta* quote_token_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quote_token_meta_;
  }
  if (quote_token_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quote_token_meta);
    if (message_arena != submessage_arena) {
      quote_token_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quote_token_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.quote_token_meta_ = quote_token_meta;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.quote_token_meta)
}

// string maker_fee_rate = 12 [json_name = "makerFeeRate"];
inline void BinaryOptionsMarketInfo::clear_maker_fee_rate() {
  _impl_.maker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::maker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.maker_fee_rate)
  return _internal_maker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_maker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.maker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.maker_fee_rate)
}
inline std::string* BinaryOptionsMarketInfo::mutable_maker_fee_rate() {
  std::string* _s = _internal_mutable_maker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.maker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_maker_fee_rate() const {
  return _impl_.maker_fee_rate_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_maker_fee_rate(const std::string& value) {
  ;


  _impl_.maker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_maker_fee_rate() {
  ;
  return _impl_.maker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_maker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.maker_fee_rate)
  return _impl_.maker_fee_rate_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_maker_fee_rate(std::string* value) {
  _impl_.maker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.maker_fee_rate_.IsDefault()) {
          _impl_.maker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.maker_fee_rate)
}

// string taker_fee_rate = 13 [json_name = "takerFeeRate"];
inline void BinaryOptionsMarketInfo::clear_taker_fee_rate() {
  _impl_.taker_fee_rate_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::taker_fee_rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.taker_fee_rate)
  return _internal_taker_fee_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_taker_fee_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.taker_fee_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.taker_fee_rate)
}
inline std::string* BinaryOptionsMarketInfo::mutable_taker_fee_rate() {
  std::string* _s = _internal_mutable_taker_fee_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.taker_fee_rate)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_taker_fee_rate() const {
  return _impl_.taker_fee_rate_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_taker_fee_rate(const std::string& value) {
  ;


  _impl_.taker_fee_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_taker_fee_rate() {
  ;
  return _impl_.taker_fee_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_taker_fee_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.taker_fee_rate)
  return _impl_.taker_fee_rate_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_taker_fee_rate(std::string* value) {
  _impl_.taker_fee_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taker_fee_rate_.IsDefault()) {
          _impl_.taker_fee_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.taker_fee_rate)
}

// string service_provider_fee = 14 [json_name = "serviceProviderFee"];
inline void BinaryOptionsMarketInfo::clear_service_provider_fee() {
  _impl_.service_provider_fee_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::service_provider_fee() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.service_provider_fee)
  return _internal_service_provider_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_service_provider_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.service_provider_fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.service_provider_fee)
}
inline std::string* BinaryOptionsMarketInfo::mutable_service_provider_fee() {
  std::string* _s = _internal_mutable_service_provider_fee();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.service_provider_fee)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_service_provider_fee() const {
  return _impl_.service_provider_fee_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_service_provider_fee(const std::string& value) {
  ;


  _impl_.service_provider_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_service_provider_fee() {
  ;
  return _impl_.service_provider_fee_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_service_provider_fee() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.service_provider_fee)
  return _impl_.service_provider_fee_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_service_provider_fee(std::string* value) {
  _impl_.service_provider_fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.service_provider_fee_.IsDefault()) {
          _impl_.service_provider_fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.service_provider_fee)
}

// string min_price_tick_size = 15 [json_name = "minPriceTickSize"];
inline void BinaryOptionsMarketInfo::clear_min_price_tick_size() {
  _impl_.min_price_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::min_price_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_price_tick_size)
  return _internal_min_price_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_min_price_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_price_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_price_tick_size)
}
inline std::string* BinaryOptionsMarketInfo::mutable_min_price_tick_size() {
  std::string* _s = _internal_mutable_min_price_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_price_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_min_price_tick_size() const {
  return _impl_.min_price_tick_size_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_min_price_tick_size(const std::string& value) {
  ;


  _impl_.min_price_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_min_price_tick_size() {
  ;
  return _impl_.min_price_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_min_price_tick_size() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_price_tick_size)
  return _impl_.min_price_tick_size_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_min_price_tick_size(std::string* value) {
  _impl_.min_price_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_price_tick_size_.IsDefault()) {
          _impl_.min_price_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_price_tick_size)
}

// string min_quantity_tick_size = 16 [json_name = "minQuantityTickSize"];
inline void BinaryOptionsMarketInfo::clear_min_quantity_tick_size() {
  _impl_.min_quantity_tick_size_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::min_quantity_tick_size() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_quantity_tick_size)
  return _internal_min_quantity_tick_size();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_min_quantity_tick_size(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.min_quantity_tick_size_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_quantity_tick_size)
}
inline std::string* BinaryOptionsMarketInfo::mutable_min_quantity_tick_size() {
  std::string* _s = _internal_mutable_min_quantity_tick_size();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_quantity_tick_size)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_min_quantity_tick_size() const {
  return _impl_.min_quantity_tick_size_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_min_quantity_tick_size(const std::string& value) {
  ;


  _impl_.min_quantity_tick_size_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_min_quantity_tick_size() {
  ;
  return _impl_.min_quantity_tick_size_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_min_quantity_tick_size() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_quantity_tick_size)
  return _impl_.min_quantity_tick_size_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_min_quantity_tick_size(std::string* value) {
  _impl_.min_quantity_tick_size_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.min_quantity_tick_size_.IsDefault()) {
          _impl_.min_quantity_tick_size_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.min_quantity_tick_size)
}

// string settlement_price = 17 [json_name = "settlementPrice"];
inline void BinaryOptionsMarketInfo::clear_settlement_price() {
  _impl_.settlement_price_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketInfo::settlement_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_price)
  return _internal_settlement_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketInfo::set_settlement_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.settlement_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_price)
}
inline std::string* BinaryOptionsMarketInfo::mutable_settlement_price() {
  std::string* _s = _internal_mutable_settlement_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_price)
  return _s;
}
inline const std::string& BinaryOptionsMarketInfo::_internal_settlement_price() const {
  return _impl_.settlement_price_.Get();
}
inline void BinaryOptionsMarketInfo::_internal_set_settlement_price(const std::string& value) {
  ;


  _impl_.settlement_price_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::_internal_mutable_settlement_price() {
  ;
  return _impl_.settlement_price_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketInfo::release_settlement_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_price)
  return _impl_.settlement_price_.Release();
}
inline void BinaryOptionsMarketInfo::set_allocated_settlement_price(std::string* value) {
  _impl_.settlement_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.settlement_price_.IsDefault()) {
          _impl_.settlement_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketInfo.settlement_price)
}

// -------------------------------------------------------------------

// Paging

// sint64 total = 1 [json_name = "total"];
inline void Paging::clear_total() {
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t Paging::total() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.Paging.total)
  return _internal_total();
}
inline void Paging::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.Paging.total)
}
inline ::int64_t Paging::_internal_total() const {
  return _impl_.total_;
}
inline void Paging::_internal_set_total(::int64_t value) {
  ;
  _impl_.total_ = value;
}

// sint32 from = 2 [json_name = "from"];
inline void Paging::clear_from() {
  _impl_.from_ = 0;
}
inline ::int32_t Paging::from() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.Paging.from)
  return _internal_from();
}
inline void Paging::set_from(::int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.Paging.from)
}
inline ::int32_t Paging::_internal_from() const {
  return _impl_.from_;
}
inline void Paging::_internal_set_from(::int32_t value) {
  ;
  _impl_.from_ = value;
}

// sint32 to = 3 [json_name = "to"];
inline void Paging::clear_to() {
  _impl_.to_ = 0;
}
inline ::int32_t Paging::to() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.Paging.to)
  return _internal_to();
}
inline void Paging::set_to(::int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.Paging.to)
}
inline ::int32_t Paging::_internal_to() const {
  return _impl_.to_;
}
inline void Paging::_internal_set_to(::int32_t value) {
  ;
  _impl_.to_ = value;
}

// sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
inline void Paging::clear_count_by_subaccount() {
  _impl_.count_by_subaccount_ = ::int64_t{0};
}
inline ::int64_t Paging::count_by_subaccount() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.Paging.count_by_subaccount)
  return _internal_count_by_subaccount();
}
inline void Paging::set_count_by_subaccount(::int64_t value) {
  _internal_set_count_by_subaccount(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.Paging.count_by_subaccount)
}
inline ::int64_t Paging::_internal_count_by_subaccount() const {
  return _impl_.count_by_subaccount_;
}
inline void Paging::_internal_set_count_by_subaccount(::int64_t value) {
  ;
  _impl_.count_by_subaccount_ = value;
}

// -------------------------------------------------------------------

// BinaryOptionsMarketRequest

// string market_id = 1 [json_name = "marketId"];
inline void BinaryOptionsMarketRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& BinaryOptionsMarketRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BinaryOptionsMarketRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest.market_id)
}
inline std::string* BinaryOptionsMarketRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest.market_id)
  return _s;
}
inline const std::string& BinaryOptionsMarketRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void BinaryOptionsMarketRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* BinaryOptionsMarketRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void BinaryOptionsMarketRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketRequest.market_id)
}

// -------------------------------------------------------------------

// BinaryOptionsMarketResponse

// .injective_derivative_exchange_rpc.BinaryOptionsMarketInfo market = 1 [json_name = "market"];
inline bool BinaryOptionsMarketResponse::has_market() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.market_ != nullptr);
  return value;
}
inline void BinaryOptionsMarketResponse::clear_market() {
  if (_impl_.market_ != nullptr) _impl_.market_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& BinaryOptionsMarketResponse::_internal_market() const {
  const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* p = _impl_.market_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo&>(
      ::injective_derivative_exchange_rpc::_BinaryOptionsMarketInfo_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo& BinaryOptionsMarketResponse::market() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse.market)
  return _internal_market();
}
inline void BinaryOptionsMarketResponse::unsafe_arena_set_allocated_market(
    ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* market) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.market_);
  }
  _impl_.market_ = market;
  if (market) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse.market)
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketResponse::release_market() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketResponse::unsafe_arena_release_market() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse.market)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* temp = _impl_.market_;
  _impl_.market_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketResponse::_internal_mutable_market() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.market_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo>(GetArenaForAllocation());
    _impl_.market_ = p;
  }
  return _impl_.market_;
}
inline ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* BinaryOptionsMarketResponse::mutable_market() {
  ::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* _msg = _internal_mutable_market();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse.market)
  return _msg;
}
inline void BinaryOptionsMarketResponse::set_allocated_market(::injective_derivative_exchange_rpc::BinaryOptionsMarketInfo* market) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.market_;
  }
  if (market) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(market);
    if (message_arena != submessage_arena) {
      market = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.market_ = market;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.BinaryOptionsMarketResponse.market)
}

// -------------------------------------------------------------------

// OrderbookRequest

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbookRequest.market_id)
}
inline std::string* OrderbookRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookRequest.market_id)
  return _s;
}
inline const std::string& OrderbookRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrderbookRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrderbookRequest.market_id)
}

// -------------------------------------------------------------------

// OrderbookResponse

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1 [json_name = "orderbook"];
inline bool OrderbookResponse::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void OrderbookResponse::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& OrderbookResponse::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbook_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& OrderbookResponse::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookResponse.orderbook)
  return _internal_orderbook();
}
inline void OrderbookResponse::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.OrderbookResponse.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* OrderbookResponse::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* OrderbookResponse::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrderbookResponse.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* OrderbookResponse::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* OrderbookResponse::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookResponse.orderbook)
  return _msg;
}
inline void OrderbookResponse::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrderbookResponse.orderbook)
}

// -------------------------------------------------------------------

// DerivativeLimitOrderbook

// repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
inline int DerivativeLimitOrderbook::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int DerivativeLimitOrderbook::buys_size() const {
  return _internal_buys_size();
}
inline void DerivativeLimitOrderbook::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
DerivativeLimitOrderbook::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.buys)
  return _internal_mutable_buys();
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbook::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbook::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.buys)
  return _internal_buys(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::add_buys() {
  ::injective_derivative_exchange_rpc::PriceLevel* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
DerivativeLimitOrderbook::buys() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>&
DerivativeLimitOrderbook::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>*
DerivativeLimitOrderbook::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
inline int DerivativeLimitOrderbook::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int DerivativeLimitOrderbook::sells_size() const {
  return _internal_sells_size();
}
inline void DerivativeLimitOrderbook::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
DerivativeLimitOrderbook::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.sells)
  return _internal_mutable_sells();
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbook::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbook::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.sells)
  return _internal_sells(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbook::add_sells() {
  ::injective_derivative_exchange_rpc::PriceLevel* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
DerivativeLimitOrderbook::sells() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbook.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>&
DerivativeLimitOrderbook::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>*
DerivativeLimitOrderbook::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// -------------------------------------------------------------------

// PriceLevel

// string price = 1 [json_name = "price"];
inline void PriceLevel::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceLevel::price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevel.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevel.price)
}
inline std::string* PriceLevel::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PriceLevel.price)
  return _s;
}
inline const std::string& PriceLevel::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceLevel::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PriceLevel.price)
  return _impl_.price_.Release();
}
inline void PriceLevel::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PriceLevel.price)
}

// string quantity = 2 [json_name = "quantity"];
inline void PriceLevel::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& PriceLevel::quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevel.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevel::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevel.quantity)
}
inline std::string* PriceLevel::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PriceLevel.quantity)
  return _s;
}
inline const std::string& PriceLevel::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void PriceLevel::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevel::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevel::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PriceLevel.quantity)
  return _impl_.quantity_.Release();
}
inline void PriceLevel::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PriceLevel.quantity)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void PriceLevel::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceLevel::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevel.timestamp)
  return _internal_timestamp();
}
inline void PriceLevel::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevel.timestamp)
}
inline ::int64_t PriceLevel::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceLevel::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// OrderbookV2Request

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookV2Request::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookV2Request::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookV2Request.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookV2Request::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbookV2Request.market_id)
}
inline std::string* OrderbookV2Request::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookV2Request.market_id)
  return _s;
}
inline const std::string& OrderbookV2Request::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookV2Request::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookV2Request::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookV2Request::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrderbookV2Request.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookV2Request::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrderbookV2Request.market_id)
}

// -------------------------------------------------------------------

// OrderbookV2Response

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
inline bool OrderbookV2Response::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void OrderbookV2Response::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& OrderbookV2Response::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbookV2_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& OrderbookV2Response::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookV2Response.orderbook)
  return _internal_orderbook();
}
inline void OrderbookV2Response::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.OrderbookV2Response.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* OrderbookV2Response::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* OrderbookV2Response::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrderbookV2Response.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* OrderbookV2Response::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* OrderbookV2Response::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookV2Response.orderbook)
  return _msg;
}
inline void OrderbookV2Response::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrderbookV2Response.orderbook)
}

// -------------------------------------------------------------------

// DerivativeLimitOrderbookV2

// repeated .injective_derivative_exchange_rpc.PriceLevel buys = 1 [json_name = "buys"];
inline int DerivativeLimitOrderbookV2::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int DerivativeLimitOrderbookV2::buys_size() const {
  return _internal_buys_size();
}
inline void DerivativeLimitOrderbookV2::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
DerivativeLimitOrderbookV2::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.buys)
  return _internal_mutable_buys();
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbookV2::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbookV2::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.buys)
  return _internal_buys(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::add_buys() {
  ::injective_derivative_exchange_rpc::PriceLevel* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
DerivativeLimitOrderbookV2::buys() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>&
DerivativeLimitOrderbookV2::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>*
DerivativeLimitOrderbookV2::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_derivative_exchange_rpc.PriceLevel sells = 2 [json_name = "sells"];
inline int DerivativeLimitOrderbookV2::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int DerivativeLimitOrderbookV2::sells_size() const {
  return _internal_sells_size();
}
inline void DerivativeLimitOrderbookV2::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >*
DerivativeLimitOrderbookV2::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sells)
  return _internal_mutable_sells();
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbookV2::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevel& DerivativeLimitOrderbookV2::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sells)
  return _internal_sells(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevel* DerivativeLimitOrderbookV2::add_sells() {
  ::injective_derivative_exchange_rpc::PriceLevel* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevel >&
DerivativeLimitOrderbookV2::sells() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>&
DerivativeLimitOrderbookV2::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevel>*
DerivativeLimitOrderbookV2::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// uint64 sequence = 3 [json_name = "sequence"];
inline void DerivativeLimitOrderbookV2::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t DerivativeLimitOrderbookV2::sequence() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sequence)
  return _internal_sequence();
}
inline void DerivativeLimitOrderbookV2::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2.sequence)
}
inline ::uint64_t DerivativeLimitOrderbookV2::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void DerivativeLimitOrderbookV2::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// -------------------------------------------------------------------

// OrderbooksRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int OrderbooksRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrderbooksRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrderbooksRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrderbooksRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
  return _s;
}
inline const std::string& OrderbooksRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrderbooksRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrderbooksRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline void OrderbooksRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderbooksRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbooksRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrderbooksRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrderbooksRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderbooksRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// OrderbooksResponse

// repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook orderbooks = 1 [json_name = "orderbooks"];
inline int OrderbooksResponse::_internal_orderbooks_size() const {
  return _impl_.orderbooks_.size();
}
inline int OrderbooksResponse::orderbooks_size() const {
  return _internal_orderbooks_size();
}
inline void OrderbooksResponse::clear_orderbooks() {
  _internal_mutable_orderbooks()->Clear();
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* OrderbooksResponse::mutable_orderbooks(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_mutable_orderbooks()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook >*
OrderbooksResponse::mutable_orderbooks() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_mutable_orderbooks();
}
inline const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook& OrderbooksResponse::_internal_orderbooks(int index) const {
  return _internal_orderbooks().Get(index);
}
inline const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook& OrderbooksResponse::orderbooks(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_orderbooks(index);
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* OrderbooksResponse::_internal_add_orderbooks() {
  return _internal_mutable_orderbooks()->Add();
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* OrderbooksResponse::add_orderbooks() {
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook* _add = _internal_add_orderbooks();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksResponse.orderbooks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook >&
OrderbooksResponse::orderbooks() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbooksResponse.orderbooks)
  return _internal_orderbooks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook>&
OrderbooksResponse::_internal_orderbooks() const {
  return _impl_.orderbooks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbook>*
OrderbooksResponse::_internal_mutable_orderbooks() {
  return &_impl_.orderbooks_;
}

// -------------------------------------------------------------------

// SingleDerivativeLimitOrderbook

// string market_id = 1 [json_name = "marketId"];
inline void SingleDerivativeLimitOrderbook::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SingleDerivativeLimitOrderbook::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleDerivativeLimitOrderbook::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.market_id)
}
inline std::string* SingleDerivativeLimitOrderbook::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.market_id)
  return _s;
}
inline const std::string& SingleDerivativeLimitOrderbook::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SingleDerivativeLimitOrderbook::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleDerivativeLimitOrderbook::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleDerivativeLimitOrderbook::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.market_id)
  return _impl_.market_id_.Release();
}
inline void SingleDerivativeLimitOrderbook::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.market_id)
}

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 2 [json_name = "orderbook"];
inline bool SingleDerivativeLimitOrderbook::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void SingleDerivativeLimitOrderbook::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& SingleDerivativeLimitOrderbook::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbook_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& SingleDerivativeLimitOrderbook::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.orderbook)
  return _internal_orderbook();
}
inline void SingleDerivativeLimitOrderbook::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* SingleDerivativeLimitOrderbook::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* SingleDerivativeLimitOrderbook::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* SingleDerivativeLimitOrderbook::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* SingleDerivativeLimitOrderbook::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.orderbook)
  return _msg;
}
inline void SingleDerivativeLimitOrderbook::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbook.orderbook)
}

// -------------------------------------------------------------------

// OrderbooksV2Request

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int OrderbooksV2Request::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrderbooksV2Request::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrderbooksV2Request::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrderbooksV2Request::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
  return _s;
}
inline const std::string& OrderbooksV2Request::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrderbooksV2Request::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrderbooksV2Request::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline void OrderbooksV2Request::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksV2Request::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderbooksV2Request::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbooksV2Request.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrderbooksV2Request::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrderbooksV2Request::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderbooksV2Request::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderbooksV2Request::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// OrderbooksV2Response

// repeated .injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2 orderbooks = 1 [json_name = "orderbooks"];
inline int OrderbooksV2Response::_internal_orderbooks_size() const {
  return _impl_.orderbooks_.size();
}
inline int OrderbooksV2Response::orderbooks_size() const {
  return _internal_orderbooks_size();
}
inline void OrderbooksV2Response::clear_orderbooks() {
  _internal_mutable_orderbooks()->Clear();
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* OrderbooksV2Response::mutable_orderbooks(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_mutable_orderbooks()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2 >*
OrderbooksV2Response::mutable_orderbooks() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_mutable_orderbooks();
}
inline const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2& OrderbooksV2Response::_internal_orderbooks(int index) const {
  return _internal_orderbooks().Get(index);
}
inline const ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2& OrderbooksV2Response::orderbooks(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_orderbooks(index);
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* OrderbooksV2Response::_internal_add_orderbooks() {
  return _internal_mutable_orderbooks()->Add();
}
inline ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* OrderbooksV2Response::add_orderbooks() {
  ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2* _add = _internal_add_orderbooks();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2 >&
OrderbooksV2Response::orderbooks() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbooksV2Response.orderbooks)
  return _internal_orderbooks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2>&
OrderbooksV2Response::_internal_orderbooks() const {
  return _impl_.orderbooks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::SingleDerivativeLimitOrderbookV2>*
OrderbooksV2Response::_internal_mutable_orderbooks() {
  return &_impl_.orderbooks_;
}

// -------------------------------------------------------------------

// SingleDerivativeLimitOrderbookV2

// string market_id = 1 [json_name = "marketId"];
inline void SingleDerivativeLimitOrderbookV2::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SingleDerivativeLimitOrderbookV2::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleDerivativeLimitOrderbookV2::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.market_id)
}
inline std::string* SingleDerivativeLimitOrderbookV2::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.market_id)
  return _s;
}
inline const std::string& SingleDerivativeLimitOrderbookV2::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SingleDerivativeLimitOrderbookV2::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleDerivativeLimitOrderbookV2::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleDerivativeLimitOrderbookV2::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.market_id)
  return _impl_.market_id_.Release();
}
inline void SingleDerivativeLimitOrderbookV2::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.market_id)
}

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 2 [json_name = "orderbook"];
inline bool SingleDerivativeLimitOrderbookV2::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void SingleDerivativeLimitOrderbookV2::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& SingleDerivativeLimitOrderbookV2::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbookV2_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& SingleDerivativeLimitOrderbookV2::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.orderbook)
  return _internal_orderbook();
}
inline void SingleDerivativeLimitOrderbookV2::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* SingleDerivativeLimitOrderbookV2::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* SingleDerivativeLimitOrderbookV2::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* SingleDerivativeLimitOrderbookV2::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* SingleDerivativeLimitOrderbookV2::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.orderbook)
  return _msg;
}
inline void SingleDerivativeLimitOrderbookV2::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SingleDerivativeLimitOrderbookV2.orderbook)
}

// -------------------------------------------------------------------

// StreamOrderbookRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline void StreamOrderbookRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrderbookRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookResponse

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbook orderbook = 1 [json_name = "orderbook"];
inline bool StreamOrderbookResponse::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void StreamOrderbookResponse::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& StreamOrderbookResponse::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbook_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook& StreamOrderbookResponse::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookResponse.orderbook)
  return _internal_orderbook();
}
inline void StreamOrderbookResponse::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookResponse.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* StreamOrderbookResponse::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* StreamOrderbookResponse::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookResponse.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* StreamOrderbookResponse::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbook>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* StreamOrderbookResponse::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookResponse.orderbook)
  return _msg;
}
inline void StreamOrderbookResponse::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbook* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookResponse.orderbook)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookResponse.operation_type)
}
inline std::string* StreamOrderbookResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookResponse.timestamp)
}
inline ::int64_t StreamOrderbookResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookResponse::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookResponse::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookResponse.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookResponse::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookResponse.market_id)
}
inline std::string* StreamOrderbookResponse::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookResponse.market_id)
  return _s;
}
inline const std::string& StreamOrderbookResponse::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookResponse::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookResponse::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookResponse.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookResponse::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookResponse.market_id)
}

// -------------------------------------------------------------------

// StreamOrderbookV2Request

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookV2Request::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookV2Request::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookV2Request::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookV2Request::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookV2Request::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookV2Request::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline void StreamOrderbookV2Request::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookV2Request::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookV2Request::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrderbookV2Request.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookV2Request::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookV2Request::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookV2Request::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookV2Request::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookV2Response

// .injective_derivative_exchange_rpc.DerivativeLimitOrderbookV2 orderbook = 1 [json_name = "orderbook"];
inline bool StreamOrderbookV2Response::has_orderbook() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_ != nullptr);
  return value;
}
inline void StreamOrderbookV2Response::clear_orderbook() {
  if (_impl_.orderbook_ != nullptr) _impl_.orderbook_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& StreamOrderbookV2Response::_internal_orderbook() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* p = _impl_.orderbook_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrderbookV2_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2& StreamOrderbookV2Response::orderbook() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookV2Response.orderbook)
  return _internal_orderbook();
}
inline void StreamOrderbookV2Response::unsafe_arena_set_allocated_orderbook(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_);
  }
  _impl_.orderbook_ = orderbook;
  if (orderbook) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookV2Response.orderbook)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* StreamOrderbookV2Response::release_orderbook() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* StreamOrderbookV2Response::unsafe_arena_release_orderbook() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookV2Response.orderbook)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* temp = _impl_.orderbook_;
  _impl_.orderbook_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* StreamOrderbookV2Response::_internal_mutable_orderbook() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2>(GetArenaForAllocation());
    _impl_.orderbook_ = p;
  }
  return _impl_.orderbook_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* StreamOrderbookV2Response::mutable_orderbook() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* _msg = _internal_mutable_orderbook();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookV2Response.orderbook)
  return _msg;
}
inline void StreamOrderbookV2Response::set_allocated_orderbook(::injective_derivative_exchange_rpc::DerivativeLimitOrderbookV2* orderbook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_;
  }
  if (orderbook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook);
    if (message_arena != submessage_arena) {
      orderbook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_ = orderbook;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookV2Response.orderbook)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookV2Response::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookV2Response::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookV2Response::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookV2Response.operation_type)
}
inline std::string* StreamOrderbookV2Response::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookV2Response::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookV2Response::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookV2Response.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookV2Response::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookV2Response.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookV2Response::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookV2Response::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookV2Response.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookV2Response::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookV2Response.timestamp)
}
inline ::int64_t StreamOrderbookV2Response::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookV2Response::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookV2Response::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookV2Response::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookV2Response::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookV2Response.market_id)
}
inline std::string* StreamOrderbookV2Response::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _s;
}
inline const std::string& StreamOrderbookV2Response::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookV2Response::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookV2Response::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookV2Response.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookV2Response::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookV2Response.market_id)
}

// -------------------------------------------------------------------

// StreamOrderbookUpdateRequest

// repeated string market_ids = 1 [json_name = "marketIds"];
inline int StreamOrderbookUpdateRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrderbookUpdateRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrderbookUpdateRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrderbookUpdateRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrderbookUpdateRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrderbookUpdateRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline void StreamOrderbookUpdateRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookUpdateRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrderbookUpdateRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrderbookUpdateRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrderbookUpdateRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrderbookUpdateRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrderbookUpdateRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrderbookUpdateRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// StreamOrderbookUpdateResponse

// .injective_derivative_exchange_rpc.OrderbookLevelUpdates orderbook_level_updates = 1 [json_name = "orderbookLevelUpdates"];
inline bool StreamOrderbookUpdateResponse::has_orderbook_level_updates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orderbook_level_updates_ != nullptr);
  return value;
}
inline void StreamOrderbookUpdateResponse::clear_orderbook_level_updates() {
  if (_impl_.orderbook_level_updates_ != nullptr) _impl_.orderbook_level_updates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates& StreamOrderbookUpdateResponse::_internal_orderbook_level_updates() const {
  const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* p = _impl_.orderbook_level_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates&>(
      ::injective_derivative_exchange_rpc::_OrderbookLevelUpdates_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::OrderbookLevelUpdates& StreamOrderbookUpdateResponse::orderbook_level_updates() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  return _internal_orderbook_level_updates();
}
inline void StreamOrderbookUpdateResponse::unsafe_arena_set_allocated_orderbook_level_updates(
    ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orderbook_level_updates_);
  }
  _impl_.orderbook_level_updates_ = orderbook_level_updates;
  if (orderbook_level_updates) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
}
inline ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::release_orderbook_level_updates() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* temp = _impl_.orderbook_level_updates_;
  _impl_.orderbook_level_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::unsafe_arena_release_orderbook_level_updates() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* temp = _impl_.orderbook_level_updates_;
  _impl_.orderbook_level_updates_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::_internal_mutable_orderbook_level_updates() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.orderbook_level_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::OrderbookLevelUpdates>(GetArenaForAllocation());
    _impl_.orderbook_level_updates_ = p;
  }
  return _impl_.orderbook_level_updates_;
}
inline ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* StreamOrderbookUpdateResponse::mutable_orderbook_level_updates() {
  ::injective_derivative_exchange_rpc::OrderbookLevelUpdates* _msg = _internal_mutable_orderbook_level_updates();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
  return _msg;
}
inline void StreamOrderbookUpdateResponse::set_allocated_orderbook_level_updates(::injective_derivative_exchange_rpc::OrderbookLevelUpdates* orderbook_level_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.orderbook_level_updates_;
  }
  if (orderbook_level_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orderbook_level_updates);
    if (message_arena != submessage_arena) {
      orderbook_level_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orderbook_level_updates, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.orderbook_level_updates_ = orderbook_level_updates;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.orderbook_level_updates)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrderbookUpdateResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrderbookUpdateResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookUpdateResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
}
inline std::string* StreamOrderbookUpdateResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrderbookUpdateResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrderbookUpdateResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrderbookUpdateResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrderbookUpdateResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrderbookUpdateResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrderbookUpdateResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.timestamp)
}
inline ::int64_t StreamOrderbookUpdateResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrderbookUpdateResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// string market_id = 4 [json_name = "marketId"];
inline void StreamOrderbookUpdateResponse::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrderbookUpdateResponse::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrderbookUpdateResponse::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
}
inline std::string* StreamOrderbookUpdateResponse::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _s;
}
inline const std::string& StreamOrderbookUpdateResponse::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrderbookUpdateResponse::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrderbookUpdateResponse::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrderbookUpdateResponse::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrderbookUpdateResponse.market_id)
}

// -------------------------------------------------------------------

// OrderbookLevelUpdates

// string market_id = 1 [json_name = "marketId"];
inline void OrderbookLevelUpdates::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderbookLevelUpdates::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderbookLevelUpdates::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbookLevelUpdates.market_id)
}
inline std::string* OrderbookLevelUpdates::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _s;
}
inline const std::string& OrderbookLevelUpdates::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderbookLevelUpdates::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderbookLevelUpdates::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderbookLevelUpdates::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrderbookLevelUpdates.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderbookLevelUpdates::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrderbookLevelUpdates.market_id)
}

// uint64 sequence = 2 [json_name = "sequence"];
inline void OrderbookLevelUpdates::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t OrderbookLevelUpdates::sequence() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sequence)
  return _internal_sequence();
}
inline void OrderbookLevelUpdates::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sequence)
}
inline ::uint64_t OrderbookLevelUpdates::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void OrderbookLevelUpdates::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// repeated .injective_derivative_exchange_rpc.PriceLevelUpdate buys = 3 [json_name = "buys"];
inline int OrderbookLevelUpdates::_internal_buys_size() const {
  return _impl_.buys_.size();
}
inline int OrderbookLevelUpdates::buys_size() const {
  return _internal_buys_size();
}
inline void OrderbookLevelUpdates::clear_buys() {
  _internal_mutable_buys()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::mutable_buys(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_mutable_buys()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >*
OrderbookLevelUpdates::mutable_buys() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_mutable_buys();
}
inline const ::injective_derivative_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::_internal_buys(int index) const {
  return _internal_buys().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::buys(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_buys(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::_internal_add_buys() {
  return _internal_mutable_buys()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::add_buys() {
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* _add = _internal_add_buys();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbookLevelUpdates.buys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >&
OrderbookLevelUpdates::buys() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbookLevelUpdates.buys)
  return _internal_buys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>&
OrderbookLevelUpdates::_internal_buys() const {
  return _impl_.buys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>*
OrderbookLevelUpdates::_internal_mutable_buys() {
  return &_impl_.buys_;
}

// repeated .injective_derivative_exchange_rpc.PriceLevelUpdate sells = 4 [json_name = "sells"];
inline int OrderbookLevelUpdates::_internal_sells_size() const {
  return _impl_.sells_.size();
}
inline int OrderbookLevelUpdates::sells_size() const {
  return _internal_sells_size();
}
inline void OrderbookLevelUpdates::clear_sells() {
  _internal_mutable_sells()->Clear();
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::mutable_sells(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_mutable_sells()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >*
OrderbookLevelUpdates::mutable_sells() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_mutable_sells();
}
inline const ::injective_derivative_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::_internal_sells(int index) const {
  return _internal_sells().Get(index);
}
inline const ::injective_derivative_exchange_rpc::PriceLevelUpdate& OrderbookLevelUpdates::sells(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_sells(index);
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::_internal_add_sells() {
  return _internal_mutable_sells()->Add();
}
inline ::injective_derivative_exchange_rpc::PriceLevelUpdate* OrderbookLevelUpdates::add_sells() {
  ::injective_derivative_exchange_rpc::PriceLevelUpdate* _add = _internal_add_sells();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::PriceLevelUpdate >&
OrderbookLevelUpdates::sells() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrderbookLevelUpdates.sells)
  return _internal_sells();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>&
OrderbookLevelUpdates::_internal_sells() const {
  return _impl_.sells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::PriceLevelUpdate>*
OrderbookLevelUpdates::_internal_mutable_sells() {
  return &_impl_.sells_;
}

// sint64 updated_at = 5 [json_name = "updatedAt"];
inline void OrderbookLevelUpdates::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t OrderbookLevelUpdates::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrderbookLevelUpdates.updated_at)
  return _internal_updated_at();
}
inline void OrderbookLevelUpdates::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrderbookLevelUpdates.updated_at)
}
inline ::int64_t OrderbookLevelUpdates::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void OrderbookLevelUpdates::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// PriceLevelUpdate

// string price = 1 [json_name = "price"];
inline void PriceLevelUpdate::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& PriceLevelUpdate::price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevelUpdate.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevelUpdate::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevelUpdate.price)
}
inline std::string* PriceLevelUpdate::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PriceLevelUpdate.price)
  return _s;
}
inline const std::string& PriceLevelUpdate::_internal_price() const {
  return _impl_.price_.Get();
}
inline void PriceLevelUpdate::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::release_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PriceLevelUpdate.price)
  return _impl_.price_.Release();
}
inline void PriceLevelUpdate::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PriceLevelUpdate.price)
}

// string quantity = 2 [json_name = "quantity"];
inline void PriceLevelUpdate::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& PriceLevelUpdate::quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevelUpdate.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PriceLevelUpdate::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevelUpdate.quantity)
}
inline std::string* PriceLevelUpdate::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PriceLevelUpdate.quantity)
  return _s;
}
inline const std::string& PriceLevelUpdate::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void PriceLevelUpdate::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PriceLevelUpdate::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PriceLevelUpdate.quantity)
  return _impl_.quantity_.Release();
}
inline void PriceLevelUpdate::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PriceLevelUpdate.quantity)
}

// bool is_active = 3 [json_name = "isActive"];
inline void PriceLevelUpdate::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool PriceLevelUpdate::is_active() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevelUpdate.is_active)
  return _internal_is_active();
}
inline void PriceLevelUpdate::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevelUpdate.is_active)
}
inline bool PriceLevelUpdate::_internal_is_active() const {
  return _impl_.is_active_;
}
inline void PriceLevelUpdate::_internal_set_is_active(bool value) {
  ;
  _impl_.is_active_ = value;
}

// sint64 timestamp = 4 [json_name = "timestamp"];
inline void PriceLevelUpdate::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t PriceLevelUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PriceLevelUpdate.timestamp)
  return _internal_timestamp();
}
inline void PriceLevelUpdate::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PriceLevelUpdate.timestamp)
}
inline ::int64_t PriceLevelUpdate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void PriceLevelUpdate::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// OrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void OrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.market_id)
}
inline std::string* OrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.market_id)
  return _s;
}
inline const std::string& OrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersRequest.market_id)
}

// string order_side = 2 [json_name = "orderSide"];
inline void OrdersRequest::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& OrdersRequest::order_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.order_side)
}
inline std::string* OrdersRequest::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.order_side)
  return _s;
}
inline const std::string& OrdersRequest::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void OrdersRequest::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersRequest.order_side)
  return _impl_.order_side_.Release();
}
inline void OrdersRequest::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersRequest.order_side)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void OrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.subaccount_id)
}
inline std::string* OrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& OrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersRequest.subaccount_id)
}

// uint64 skip = 4 [json_name = "skip"];
inline void OrdersRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t OrdersRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.skip)
  return _internal_skip();
}
inline void OrdersRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.skip)
}
inline ::uint64_t OrdersRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void OrdersRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 5 [json_name = "limit"];
inline void OrdersRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t OrdersRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.limit)
  return _internal_limit();
}
inline void OrdersRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.limit)
}
inline ::int32_t OrdersRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void OrdersRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 6 [json_name = "startTime"];
inline void OrdersRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t OrdersRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.start_time)
  return _internal_start_time();
}
inline void OrdersRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.start_time)
}
inline ::int64_t OrdersRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void OrdersRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 7 [json_name = "endTime"];
inline void OrdersRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t OrdersRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.end_time)
  return _internal_end_time();
}
inline void OrdersRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.end_time)
}
inline ::int64_t OrdersRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void OrdersRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 8 [json_name = "marketIds"];
inline int OrdersRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int OrdersRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void OrdersRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* OrdersRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
  return _s;
}
inline const std::string& OrdersRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* OrdersRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void OrdersRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline void OrdersRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrdersRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& OrdersRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* OrdersRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// string is_conditional = 9 [json_name = "isConditional"];
inline void OrdersRequest::clear_is_conditional() {
  _impl_.is_conditional_.ClearToEmpty();
}
inline const std::string& OrdersRequest::is_conditional() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.is_conditional)
  return _internal_is_conditional();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_is_conditional(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.is_conditional_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.is_conditional)
}
inline std::string* OrdersRequest::mutable_is_conditional() {
  std::string* _s = _internal_mutable_is_conditional();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.is_conditional)
  return _s;
}
inline const std::string& OrdersRequest::_internal_is_conditional() const {
  return _impl_.is_conditional_.Get();
}
inline void OrdersRequest::_internal_set_is_conditional(const std::string& value) {
  ;


  _impl_.is_conditional_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_is_conditional() {
  ;
  return _impl_.is_conditional_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_is_conditional() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersRequest.is_conditional)
  return _impl_.is_conditional_.Release();
}
inline void OrdersRequest::set_allocated_is_conditional(std::string* value) {
  _impl_.is_conditional_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.is_conditional_.IsDefault()) {
          _impl_.is_conditional_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersRequest.is_conditional)
}

// string order_type = 10 [json_name = "orderType"];
inline void OrdersRequest::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& OrdersRequest::order_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersRequest::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.order_type)
}
inline std::string* OrdersRequest::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersRequest.order_type)
  return _s;
}
inline const std::string& OrdersRequest::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void OrdersRequest::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersRequest::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersRequest::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersRequest.order_type)
  return _impl_.order_type_.Release();
}
inline void OrdersRequest::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersRequest.order_type)
}

// bool include_inactive = 11 [json_name = "includeInactive"];
inline void OrdersRequest::clear_include_inactive() {
  _impl_.include_inactive_ = false;
}
inline bool OrdersRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.include_inactive)
  return _internal_include_inactive();
}
inline void OrdersRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.include_inactive)
}
inline bool OrdersRequest::_internal_include_inactive() const {
  return _impl_.include_inactive_;
}
inline void OrdersRequest::_internal_set_include_inactive(bool value) {
  ;
  _impl_.include_inactive_ = value;
}

// bool subaccount_total_orders = 12 [json_name = "subaccountTotalOrders"];
inline void OrdersRequest::clear_subaccount_total_orders() {
  _impl_.subaccount_total_orders_ = false;
}
inline bool OrdersRequest::subaccount_total_orders() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersRequest.subaccount_total_orders)
  return _internal_subaccount_total_orders();
}
inline void OrdersRequest::set_subaccount_total_orders(bool value) {
  _internal_set_subaccount_total_orders(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersRequest.subaccount_total_orders)
}
inline bool OrdersRequest::_internal_subaccount_total_orders() const {
  return _impl_.subaccount_total_orders_;
}
inline void OrdersRequest::_internal_set_subaccount_total_orders(bool value) {
  ;
  _impl_.subaccount_total_orders_ = value;
}

// -------------------------------------------------------------------

// OrdersResponse

// repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1 [json_name = "orders"];
inline int OrdersResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int OrdersResponse::orders_size() const {
  return _internal_orders_size();
}
inline void OrdersResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* OrdersResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >*
OrdersResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrdersResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& OrdersResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& OrdersResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersResponse.orders)
  return _internal_orders(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* OrdersResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* OrdersResponse::add_orders() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >&
OrdersResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrdersResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>&
OrdersResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>*
OrdersResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool OrdersResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void OrdersResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& OrdersResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& OrdersResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersResponse.paging)
  return _internal_paging();
}
inline void OrdersResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.OrdersResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersResponse.paging)
  return _msg;
}
inline void OrdersResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersResponse.paging)
}

// -------------------------------------------------------------------

// DerivativeLimitOrder

// string order_hash = 1 [json_name = "orderHash"];
inline void DerivativeLimitOrder::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_hash)
}
inline std::string* DerivativeLimitOrder::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_hash)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeLimitOrder::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeLimitOrder::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_hash)
}

// string order_side = 2 [json_name = "orderSide"];
inline void DerivativeLimitOrder::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::order_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_side)
}
inline std::string* DerivativeLimitOrder::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_side)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void DerivativeLimitOrder::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_side)
  return _impl_.order_side_.Release();
}
inline void DerivativeLimitOrder::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_side)
}

// string market_id = 3 [json_name = "marketId"];
inline void DerivativeLimitOrder::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.market_id)
}
inline std::string* DerivativeLimitOrder::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.market_id)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeLimitOrder::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeLimitOrder::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.market_id)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void DerivativeLimitOrder::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.subaccount_id)
}
inline std::string* DerivativeLimitOrder::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.subaccount_id)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void DerivativeLimitOrder::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void DerivativeLimitOrder::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.subaccount_id)
}

// bool is_reduce_only = 5 [json_name = "isReduceOnly"];
inline void DerivativeLimitOrder::clear_is_reduce_only() {
  _impl_.is_reduce_only_ = false;
}
inline bool DerivativeLimitOrder::is_reduce_only() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.is_reduce_only)
  return _internal_is_reduce_only();
}
inline void DerivativeLimitOrder::set_is_reduce_only(bool value) {
  _internal_set_is_reduce_only(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.is_reduce_only)
}
inline bool DerivativeLimitOrder::_internal_is_reduce_only() const {
  return _impl_.is_reduce_only_;
}
inline void DerivativeLimitOrder::_internal_set_is_reduce_only(bool value) {
  ;
  _impl_.is_reduce_only_ = value;
}

// string margin = 6 [json_name = "margin"];
inline void DerivativeLimitOrder::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::margin() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.margin)
}
inline std::string* DerivativeLimitOrder::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.margin)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativeLimitOrder::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_margin() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.margin)
  return _impl_.margin_.Release();
}
inline void DerivativeLimitOrder::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.margin)
}

// string price = 7 [json_name = "price"];
inline void DerivativeLimitOrder::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.price)
}
inline std::string* DerivativeLimitOrder::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.price)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_price() const {
  return _impl_.price_.Get();
}
inline void DerivativeLimitOrder::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.price)
  return _impl_.price_.Release();
}
inline void DerivativeLimitOrder::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.price)
}

// string quantity = 8 [json_name = "quantity"];
inline void DerivativeLimitOrder::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.quantity)
}
inline std::string* DerivativeLimitOrder::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.quantity)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void DerivativeLimitOrder::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.quantity)
  return _impl_.quantity_.Release();
}
inline void DerivativeLimitOrder::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.quantity)
}

// string unfilled_quantity = 9 [json_name = "unfilledQuantity"];
inline void DerivativeLimitOrder::clear_unfilled_quantity() {
  _impl_.unfilled_quantity_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::unfilled_quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.unfilled_quantity)
  return _internal_unfilled_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_unfilled_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unfilled_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.unfilled_quantity)
}
inline std::string* DerivativeLimitOrder::mutable_unfilled_quantity() {
  std::string* _s = _internal_mutable_unfilled_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.unfilled_quantity)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_unfilled_quantity() const {
  return _impl_.unfilled_quantity_.Get();
}
inline void DerivativeLimitOrder::_internal_set_unfilled_quantity(const std::string& value) {
  ;


  _impl_.unfilled_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_unfilled_quantity() {
  ;
  return _impl_.unfilled_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_unfilled_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.unfilled_quantity)
  return _impl_.unfilled_quantity_.Release();
}
inline void DerivativeLimitOrder::set_allocated_unfilled_quantity(std::string* value) {
  _impl_.unfilled_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unfilled_quantity_.IsDefault()) {
          _impl_.unfilled_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.unfilled_quantity)
}

// string trigger_price = 10 [json_name = "triggerPrice"];
inline void DerivativeLimitOrder::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_price)
}
inline std::string* DerivativeLimitOrder::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_price)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void DerivativeLimitOrder::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void DerivativeLimitOrder::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_price)
}

// string fee_recipient = 11 [json_name = "feeRecipient"];
inline void DerivativeLimitOrder::clear_fee_recipient() {
  _impl_.fee_recipient_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::fee_recipient() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.fee_recipient)
  return _internal_fee_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_fee_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.fee_recipient)
}
inline std::string* DerivativeLimitOrder::mutable_fee_recipient() {
  std::string* _s = _internal_mutable_fee_recipient();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.fee_recipient)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_fee_recipient() const {
  return _impl_.fee_recipient_.Get();
}
inline void DerivativeLimitOrder::_internal_set_fee_recipient(const std::string& value) {
  ;


  _impl_.fee_recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_fee_recipient() {
  ;
  return _impl_.fee_recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_fee_recipient() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.fee_recipient)
  return _impl_.fee_recipient_.Release();
}
inline void DerivativeLimitOrder::set_allocated_fee_recipient(std::string* value) {
  _impl_.fee_recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_.IsDefault()) {
          _impl_.fee_recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.fee_recipient)
}

// string state = 12 [json_name = "state"];
inline void DerivativeLimitOrder::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::state() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.state)
}
inline std::string* DerivativeLimitOrder::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.state)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_state() const {
  return _impl_.state_.Get();
}
inline void DerivativeLimitOrder::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_state() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.state)
  return _impl_.state_.Release();
}
inline void DerivativeLimitOrder::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.state)
}

// sint64 created_at = 13 [json_name = "createdAt"];
inline void DerivativeLimitOrder::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t DerivativeLimitOrder::created_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.created_at)
  return _internal_created_at();
}
inline void DerivativeLimitOrder::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.created_at)
}
inline ::int64_t DerivativeLimitOrder::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void DerivativeLimitOrder::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// sint64 updated_at = 14 [json_name = "updatedAt"];
inline void DerivativeLimitOrder::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t DerivativeLimitOrder::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.updated_at)
  return _internal_updated_at();
}
inline void DerivativeLimitOrder::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.updated_at)
}
inline ::int64_t DerivativeLimitOrder::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void DerivativeLimitOrder::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// sint64 order_number = 15 [json_name = "orderNumber"];
inline void DerivativeLimitOrder::clear_order_number() {
  _impl_.order_number_ = ::int64_t{0};
}
inline ::int64_t DerivativeLimitOrder::order_number() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_number)
  return _internal_order_number();
}
inline void DerivativeLimitOrder::set_order_number(::int64_t value) {
  _internal_set_order_number(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_number)
}
inline ::int64_t DerivativeLimitOrder::_internal_order_number() const {
  return _impl_.order_number_;
}
inline void DerivativeLimitOrder::_internal_set_order_number(::int64_t value) {
  ;
  _impl_.order_number_ = value;
}

// string order_type = 16 [json_name = "orderType"];
inline void DerivativeLimitOrder::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::order_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_type)
}
inline std::string* DerivativeLimitOrder::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_type)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void DerivativeLimitOrder::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_type)
  return _impl_.order_type_.Release();
}
inline void DerivativeLimitOrder::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.order_type)
}

// bool is_conditional = 17 [json_name = "isConditional"];
inline void DerivativeLimitOrder::clear_is_conditional() {
  _impl_.is_conditional_ = false;
}
inline bool DerivativeLimitOrder::is_conditional() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.is_conditional)
  return _internal_is_conditional();
}
inline void DerivativeLimitOrder::set_is_conditional(bool value) {
  _internal_set_is_conditional(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.is_conditional)
}
inline bool DerivativeLimitOrder::_internal_is_conditional() const {
  return _impl_.is_conditional_;
}
inline void DerivativeLimitOrder::_internal_set_is_conditional(bool value) {
  ;
  _impl_.is_conditional_ = value;
}

// uint64 trigger_at = 18 [json_name = "triggerAt"];
inline void DerivativeLimitOrder::clear_trigger_at() {
  _impl_.trigger_at_ = ::uint64_t{0u};
}
inline ::uint64_t DerivativeLimitOrder::trigger_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_at)
  return _internal_trigger_at();
}
inline void DerivativeLimitOrder::set_trigger_at(::uint64_t value) {
  _internal_set_trigger_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.trigger_at)
}
inline ::uint64_t DerivativeLimitOrder::_internal_trigger_at() const {
  return _impl_.trigger_at_;
}
inline void DerivativeLimitOrder::_internal_set_trigger_at(::uint64_t value) {
  ;
  _impl_.trigger_at_ = value;
}

// string placed_order_hash = 19 [json_name = "placedOrderHash"];
inline void DerivativeLimitOrder::clear_placed_order_hash() {
  _impl_.placed_order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::placed_order_hash() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.placed_order_hash)
  return _internal_placed_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_placed_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.placed_order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.placed_order_hash)
}
inline std::string* DerivativeLimitOrder::mutable_placed_order_hash() {
  std::string* _s = _internal_mutable_placed_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.placed_order_hash)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_placed_order_hash() const {
  return _impl_.placed_order_hash_.Get();
}
inline void DerivativeLimitOrder::_internal_set_placed_order_hash(const std::string& value) {
  ;


  _impl_.placed_order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_placed_order_hash() {
  ;
  return _impl_.placed_order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_placed_order_hash() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.placed_order_hash)
  return _impl_.placed_order_hash_.Release();
}
inline void DerivativeLimitOrder::set_allocated_placed_order_hash(std::string* value) {
  _impl_.placed_order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.placed_order_hash_.IsDefault()) {
          _impl_.placed_order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.placed_order_hash)
}

// string execution_type = 20 [json_name = "executionType"];
inline void DerivativeLimitOrder::clear_execution_type() {
  _impl_.execution_type_.ClearToEmpty();
}
inline const std::string& DerivativeLimitOrder::execution_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeLimitOrder.execution_type)
  return _internal_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeLimitOrder::set_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeLimitOrder.execution_type)
}
inline std::string* DerivativeLimitOrder::mutable_execution_type() {
  std::string* _s = _internal_mutable_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeLimitOrder.execution_type)
  return _s;
}
inline const std::string& DerivativeLimitOrder::_internal_execution_type() const {
  return _impl_.execution_type_.Get();
}
inline void DerivativeLimitOrder::_internal_set_execution_type(const std::string& value) {
  ;


  _impl_.execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::_internal_mutable_execution_type() {
  ;
  return _impl_.execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeLimitOrder::release_execution_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeLimitOrder.execution_type)
  return _impl_.execution_type_.Release();
}
inline void DerivativeLimitOrder::set_allocated_execution_type(std::string* value) {
  _impl_.execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_type_.IsDefault()) {
          _impl_.execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeLimitOrder.execution_type)
}

// -------------------------------------------------------------------

// PositionsRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void PositionsRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& PositionsRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionsRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.subaccount_id)
}
inline std::string* PositionsRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsRequest.subaccount_id)
  return _s;
}
inline const std::string& PositionsRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void PositionsRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionsRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionsRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionsRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void PositionsRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionsRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void PositionsRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& PositionsRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionsRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.market_id)
}
inline std::string* PositionsRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsRequest.market_id)
  return _s;
}
inline const std::string& PositionsRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void PositionsRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionsRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionsRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionsRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void PositionsRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionsRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void PositionsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t PositionsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.skip)
  return _internal_skip();
}
inline void PositionsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.skip)
}
inline ::uint64_t PositionsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void PositionsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void PositionsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t PositionsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.limit)
  return _internal_limit();
}
inline void PositionsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.limit)
}
inline ::int32_t PositionsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void PositionsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 5 [json_name = "startTime"];
inline void PositionsRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t PositionsRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.start_time)
  return _internal_start_time();
}
inline void PositionsRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.start_time)
}
inline ::int64_t PositionsRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void PositionsRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 6 [json_name = "endTime"];
inline void PositionsRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t PositionsRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.end_time)
  return _internal_end_time();
}
inline void PositionsRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.end_time)
}
inline ::int64_t PositionsRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void PositionsRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 7 [json_name = "marketIds"];
inline int PositionsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int PositionsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void PositionsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* PositionsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
  return _s;
}
inline const std::string& PositionsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* PositionsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void PositionsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline void PositionsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PositionsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PositionsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.PositionsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& PositionsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* PositionsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PositionsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PositionsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// string direction = 8 [json_name = "direction"];
inline void PositionsRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& PositionsRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionsRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.direction)
}
inline std::string* PositionsRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsRequest.direction)
  return _s;
}
inline const std::string& PositionsRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void PositionsRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionsRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionsRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionsRequest.direction)
  return _impl_.direction_.Release();
}
inline void PositionsRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionsRequest.direction)
}

// bool subaccount_total_positions = 9 [json_name = "subaccountTotalPositions"];
inline void PositionsRequest::clear_subaccount_total_positions() {
  _impl_.subaccount_total_positions_ = false;
}
inline bool PositionsRequest::subaccount_total_positions() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsRequest.subaccount_total_positions)
  return _internal_subaccount_total_positions();
}
inline void PositionsRequest::set_subaccount_total_positions(bool value) {
  _internal_set_subaccount_total_positions(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionsRequest.subaccount_total_positions)
}
inline bool PositionsRequest::_internal_subaccount_total_positions() const {
  return _impl_.subaccount_total_positions_;
}
inline void PositionsRequest::_internal_set_subaccount_total_positions(bool value) {
  ;
  _impl_.subaccount_total_positions_ = value;
}

// -------------------------------------------------------------------

// PositionsResponse

// repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1 [json_name = "positions"];
inline int PositionsResponse::_internal_positions_size() const {
  return _impl_.positions_.size();
}
inline int PositionsResponse::positions_size() const {
  return _internal_positions_size();
}
inline void PositionsResponse::clear_positions() {
  _internal_mutable_positions()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* PositionsResponse::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsResponse.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >*
PositionsResponse::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.PositionsResponse.positions)
  return _internal_mutable_positions();
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& PositionsResponse::_internal_positions(int index) const {
  return _internal_positions().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& PositionsResponse::positions(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsResponse.positions)
  return _internal_positions(index);
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* PositionsResponse::_internal_add_positions() {
  return _internal_mutable_positions()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* PositionsResponse::add_positions() {
  ::injective_derivative_exchange_rpc::DerivativePosition* _add = _internal_add_positions();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.PositionsResponse.positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >&
PositionsResponse::positions() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.PositionsResponse.positions)
  return _internal_positions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>&
PositionsResponse::_internal_positions() const {
  return _impl_.positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>*
PositionsResponse::_internal_mutable_positions() {
  return &_impl_.positions_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool PositionsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void PositionsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& PositionsResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& PositionsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionsResponse.paging)
  return _internal_paging();
}
inline void PositionsResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.PositionsResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* PositionsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* PositionsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* PositionsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* PositionsResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionsResponse.paging)
  return _msg;
}
inline void PositionsResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionsResponse.paging)
}

// -------------------------------------------------------------------

// DerivativePosition

// string ticker = 1 [json_name = "ticker"];
inline void DerivativePosition::clear_ticker() {
  _impl_.ticker_.ClearToEmpty();
}
inline const std::string& DerivativePosition::ticker() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.ticker)
  return _internal_ticker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_ticker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ticker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.ticker)
}
inline std::string* DerivativePosition::mutable_ticker() {
  std::string* _s = _internal_mutable_ticker();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.ticker)
  return _s;
}
inline const std::string& DerivativePosition::_internal_ticker() const {
  return _impl_.ticker_.Get();
}
inline void DerivativePosition::_internal_set_ticker(const std::string& value) {
  ;


  _impl_.ticker_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_ticker() {
  ;
  return _impl_.ticker_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_ticker() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.ticker)
  return _impl_.ticker_.Release();
}
inline void DerivativePosition::set_allocated_ticker(std::string* value) {
  _impl_.ticker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ticker_.IsDefault()) {
          _impl_.ticker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.ticker)
}

// string market_id = 2 [json_name = "marketId"];
inline void DerivativePosition::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativePosition::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.market_id)
}
inline std::string* DerivativePosition::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.market_id)
  return _s;
}
inline const std::string& DerivativePosition::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativePosition::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativePosition::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.market_id)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void DerivativePosition::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& DerivativePosition::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.subaccount_id)
}
inline std::string* DerivativePosition::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.subaccount_id)
  return _s;
}
inline const std::string& DerivativePosition::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void DerivativePosition::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void DerivativePosition::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.subaccount_id)
}

// string direction = 4 [json_name = "direction"];
inline void DerivativePosition::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& DerivativePosition::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.direction)
}
inline std::string* DerivativePosition::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.direction)
  return _s;
}
inline const std::string& DerivativePosition::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void DerivativePosition::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.direction)
  return _impl_.direction_.Release();
}
inline void DerivativePosition::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.direction)
}

// string quantity = 5 [json_name = "quantity"];
inline void DerivativePosition::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& DerivativePosition::quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.quantity)
}
inline std::string* DerivativePosition::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.quantity)
  return _s;
}
inline const std::string& DerivativePosition::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void DerivativePosition::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.quantity)
  return _impl_.quantity_.Release();
}
inline void DerivativePosition::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.quantity)
}

// string entry_price = 6 [json_name = "entryPrice"];
inline void DerivativePosition::clear_entry_price() {
  _impl_.entry_price_.ClearToEmpty();
}
inline const std::string& DerivativePosition::entry_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.entry_price)
  return _internal_entry_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_entry_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.entry_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.entry_price)
}
inline std::string* DerivativePosition::mutable_entry_price() {
  std::string* _s = _internal_mutable_entry_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.entry_price)
  return _s;
}
inline const std::string& DerivativePosition::_internal_entry_price() const {
  return _impl_.entry_price_.Get();
}
inline void DerivativePosition::_internal_set_entry_price(const std::string& value) {
  ;


  _impl_.entry_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_entry_price() {
  ;
  return _impl_.entry_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_entry_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.entry_price)
  return _impl_.entry_price_.Release();
}
inline void DerivativePosition::set_allocated_entry_price(std::string* value) {
  _impl_.entry_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entry_price_.IsDefault()) {
          _impl_.entry_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.entry_price)
}

// string margin = 7 [json_name = "margin"];
inline void DerivativePosition::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativePosition::margin() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.margin)
}
inline std::string* DerivativePosition::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.margin)
  return _s;
}
inline const std::string& DerivativePosition::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativePosition::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_margin() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.margin)
  return _impl_.margin_.Release();
}
inline void DerivativePosition::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.margin)
}

// string liquidation_price = 8 [json_name = "liquidationPrice"];
inline void DerivativePosition::clear_liquidation_price() {
  _impl_.liquidation_price_.ClearToEmpty();
}
inline const std::string& DerivativePosition::liquidation_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.liquidation_price)
  return _internal_liquidation_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_liquidation_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.liquidation_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.liquidation_price)
}
inline std::string* DerivativePosition::mutable_liquidation_price() {
  std::string* _s = _internal_mutable_liquidation_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.liquidation_price)
  return _s;
}
inline const std::string& DerivativePosition::_internal_liquidation_price() const {
  return _impl_.liquidation_price_.Get();
}
inline void DerivativePosition::_internal_set_liquidation_price(const std::string& value) {
  ;


  _impl_.liquidation_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_liquidation_price() {
  ;
  return _impl_.liquidation_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_liquidation_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.liquidation_price)
  return _impl_.liquidation_price_.Release();
}
inline void DerivativePosition::set_allocated_liquidation_price(std::string* value) {
  _impl_.liquidation_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.liquidation_price_.IsDefault()) {
          _impl_.liquidation_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.liquidation_price)
}

// string mark_price = 9 [json_name = "markPrice"];
inline void DerivativePosition::clear_mark_price() {
  _impl_.mark_price_.ClearToEmpty();
}
inline const std::string& DerivativePosition::mark_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.mark_price)
  return _internal_mark_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_mark_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mark_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.mark_price)
}
inline std::string* DerivativePosition::mutable_mark_price() {
  std::string* _s = _internal_mutable_mark_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.mark_price)
  return _s;
}
inline const std::string& DerivativePosition::_internal_mark_price() const {
  return _impl_.mark_price_.Get();
}
inline void DerivativePosition::_internal_set_mark_price(const std::string& value) {
  ;


  _impl_.mark_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_mark_price() {
  ;
  return _impl_.mark_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_mark_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.mark_price)
  return _impl_.mark_price_.Release();
}
inline void DerivativePosition::set_allocated_mark_price(std::string* value) {
  _impl_.mark_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mark_price_.IsDefault()) {
          _impl_.mark_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.mark_price)
}

// string aggregate_reduce_only_quantity = 11 [json_name = "aggregateReduceOnlyQuantity"];
inline void DerivativePosition::clear_aggregate_reduce_only_quantity() {
  _impl_.aggregate_reduce_only_quantity_.ClearToEmpty();
}
inline const std::string& DerivativePosition::aggregate_reduce_only_quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.aggregate_reduce_only_quantity)
  return _internal_aggregate_reduce_only_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativePosition::set_aggregate_reduce_only_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.aggregate_reduce_only_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.aggregate_reduce_only_quantity)
}
inline std::string* DerivativePosition::mutable_aggregate_reduce_only_quantity() {
  std::string* _s = _internal_mutable_aggregate_reduce_only_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativePosition.aggregate_reduce_only_quantity)
  return _s;
}
inline const std::string& DerivativePosition::_internal_aggregate_reduce_only_quantity() const {
  return _impl_.aggregate_reduce_only_quantity_.Get();
}
inline void DerivativePosition::_internal_set_aggregate_reduce_only_quantity(const std::string& value) {
  ;


  _impl_.aggregate_reduce_only_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativePosition::_internal_mutable_aggregate_reduce_only_quantity() {
  ;
  return _impl_.aggregate_reduce_only_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativePosition::release_aggregate_reduce_only_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativePosition.aggregate_reduce_only_quantity)
  return _impl_.aggregate_reduce_only_quantity_.Release();
}
inline void DerivativePosition::set_allocated_aggregate_reduce_only_quantity(std::string* value) {
  _impl_.aggregate_reduce_only_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aggregate_reduce_only_quantity_.IsDefault()) {
          _impl_.aggregate_reduce_only_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativePosition.aggregate_reduce_only_quantity)
}

// sint64 updated_at = 12 [json_name = "updatedAt"];
inline void DerivativePosition::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t DerivativePosition::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.updated_at)
  return _internal_updated_at();
}
inline void DerivativePosition::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.updated_at)
}
inline ::int64_t DerivativePosition::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void DerivativePosition::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// sint64 created_at = 13 [json_name = "createdAt"];
inline void DerivativePosition::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t DerivativePosition::created_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativePosition.created_at)
  return _internal_created_at();
}
inline void DerivativePosition::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativePosition.created_at)
}
inline ::int64_t DerivativePosition::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void DerivativePosition::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// -------------------------------------------------------------------

// LiquidablePositionsRequest

// string market_id = 1 [json_name = "marketId"];
inline void LiquidablePositionsRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& LiquidablePositionsRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.LiquidablePositionsRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LiquidablePositionsRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.LiquidablePositionsRequest.market_id)
}
inline std::string* LiquidablePositionsRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.LiquidablePositionsRequest.market_id)
  return _s;
}
inline const std::string& LiquidablePositionsRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void LiquidablePositionsRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LiquidablePositionsRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* LiquidablePositionsRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.LiquidablePositionsRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void LiquidablePositionsRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.LiquidablePositionsRequest.market_id)
}

// uint64 skip = 2 [json_name = "skip"];
inline void LiquidablePositionsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t LiquidablePositionsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.LiquidablePositionsRequest.skip)
  return _internal_skip();
}
inline void LiquidablePositionsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.LiquidablePositionsRequest.skip)
}
inline ::uint64_t LiquidablePositionsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void LiquidablePositionsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 3 [json_name = "limit"];
inline void LiquidablePositionsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t LiquidablePositionsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.LiquidablePositionsRequest.limit)
  return _internal_limit();
}
inline void LiquidablePositionsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.LiquidablePositionsRequest.limit)
}
inline ::int32_t LiquidablePositionsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void LiquidablePositionsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// LiquidablePositionsResponse

// repeated .injective_derivative_exchange_rpc.DerivativePosition positions = 1 [json_name = "positions"];
inline int LiquidablePositionsResponse::_internal_positions_size() const {
  return _impl_.positions_.size();
}
inline int LiquidablePositionsResponse::positions_size() const {
  return _internal_positions_size();
}
inline void LiquidablePositionsResponse::clear_positions() {
  _internal_mutable_positions()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* LiquidablePositionsResponse::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.LiquidablePositionsResponse.positions)
  return _internal_mutable_positions()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >*
LiquidablePositionsResponse::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.LiquidablePositionsResponse.positions)
  return _internal_mutable_positions();
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& LiquidablePositionsResponse::_internal_positions(int index) const {
  return _internal_positions().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& LiquidablePositionsResponse::positions(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.LiquidablePositionsResponse.positions)
  return _internal_positions(index);
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* LiquidablePositionsResponse::_internal_add_positions() {
  return _internal_mutable_positions()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* LiquidablePositionsResponse::add_positions() {
  ::injective_derivative_exchange_rpc::DerivativePosition* _add = _internal_add_positions();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.LiquidablePositionsResponse.positions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativePosition >&
LiquidablePositionsResponse::positions() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.LiquidablePositionsResponse.positions)
  return _internal_positions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>&
LiquidablePositionsResponse::_internal_positions() const {
  return _impl_.positions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativePosition>*
LiquidablePositionsResponse::_internal_mutable_positions() {
  return &_impl_.positions_;
}

// -------------------------------------------------------------------

// FundingPaymentsRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void FundingPaymentsRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& FundingPaymentsRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingPaymentsRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.subaccount_id)
}
inline std::string* FundingPaymentsRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPaymentsRequest.subaccount_id)
  return _s;
}
inline const std::string& FundingPaymentsRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void FundingPaymentsRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingPaymentsRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingPaymentsRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPaymentsRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void FundingPaymentsRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPaymentsRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void FundingPaymentsRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& FundingPaymentsRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingPaymentsRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_id)
}
inline std::string* FundingPaymentsRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_id)
  return _s;
}
inline const std::string& FundingPaymentsRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void FundingPaymentsRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingPaymentsRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingPaymentsRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void FundingPaymentsRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void FundingPaymentsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t FundingPaymentsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.skip)
  return _internal_skip();
}
inline void FundingPaymentsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.skip)
}
inline ::uint64_t FundingPaymentsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void FundingPaymentsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void FundingPaymentsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t FundingPaymentsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.limit)
  return _internal_limit();
}
inline void FundingPaymentsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.limit)
}
inline ::int32_t FundingPaymentsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void FundingPaymentsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 end_time = 5 [json_name = "endTime"];
inline void FundingPaymentsRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t FundingPaymentsRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.end_time)
  return _internal_end_time();
}
inline void FundingPaymentsRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.end_time)
}
inline ::int64_t FundingPaymentsRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void FundingPaymentsRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 6 [json_name = "marketIds"];
inline int FundingPaymentsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int FundingPaymentsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void FundingPaymentsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* FundingPaymentsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
  return _s;
}
inline const std::string& FundingPaymentsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* FundingPaymentsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void FundingPaymentsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline void FundingPaymentsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FundingPaymentsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FundingPaymentsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.FundingPaymentsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& FundingPaymentsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* FundingPaymentsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FundingPaymentsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FundingPaymentsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// -------------------------------------------------------------------

// FundingPaymentsResponse

// repeated .injective_derivative_exchange_rpc.FundingPayment payments = 1 [json_name = "payments"];
inline int FundingPaymentsResponse::_internal_payments_size() const {
  return _impl_.payments_.size();
}
inline int FundingPaymentsResponse::payments_size() const {
  return _internal_payments_size();
}
inline void FundingPaymentsResponse::clear_payments() {
  _internal_mutable_payments()->Clear();
}
inline ::injective_derivative_exchange_rpc::FundingPayment* FundingPaymentsResponse::mutable_payments(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPaymentsResponse.payments)
  return _internal_mutable_payments()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingPayment >*
FundingPaymentsResponse::mutable_payments() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.FundingPaymentsResponse.payments)
  return _internal_mutable_payments();
}
inline const ::injective_derivative_exchange_rpc::FundingPayment& FundingPaymentsResponse::_internal_payments(int index) const {
  return _internal_payments().Get(index);
}
inline const ::injective_derivative_exchange_rpc::FundingPayment& FundingPaymentsResponse::payments(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsResponse.payments)
  return _internal_payments(index);
}
inline ::injective_derivative_exchange_rpc::FundingPayment* FundingPaymentsResponse::_internal_add_payments() {
  return _internal_mutable_payments()->Add();
}
inline ::injective_derivative_exchange_rpc::FundingPayment* FundingPaymentsResponse::add_payments() {
  ::injective_derivative_exchange_rpc::FundingPayment* _add = _internal_add_payments();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.FundingPaymentsResponse.payments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingPayment >&
FundingPaymentsResponse::payments() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.FundingPaymentsResponse.payments)
  return _internal_payments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingPayment>&
FundingPaymentsResponse::_internal_payments() const {
  return _impl_.payments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingPayment>*
FundingPaymentsResponse::_internal_mutable_payments() {
  return &_impl_.payments_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool FundingPaymentsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void FundingPaymentsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& FundingPaymentsResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& FundingPaymentsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPaymentsResponse.paging)
  return _internal_paging();
}
inline void FundingPaymentsResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.FundingPaymentsResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* FundingPaymentsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingPaymentsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPaymentsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingPaymentsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingPaymentsResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPaymentsResponse.paging)
  return _msg;
}
inline void FundingPaymentsResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPaymentsResponse.paging)
}

// -------------------------------------------------------------------

// FundingPayment

// string market_id = 1 [json_name = "marketId"];
inline void FundingPayment::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& FundingPayment::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPayment.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingPayment::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPayment.market_id)
}
inline std::string* FundingPayment::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPayment.market_id)
  return _s;
}
inline const std::string& FundingPayment::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void FundingPayment::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingPayment::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingPayment::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPayment.market_id)
  return _impl_.market_id_.Release();
}
inline void FundingPayment::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPayment.market_id)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void FundingPayment::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& FundingPayment::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPayment.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingPayment::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPayment.subaccount_id)
}
inline std::string* FundingPayment::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPayment.subaccount_id)
  return _s;
}
inline const std::string& FundingPayment::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void FundingPayment::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingPayment::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingPayment::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPayment.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void FundingPayment::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPayment.subaccount_id)
}

// string amount = 3 [json_name = "amount"];
inline void FundingPayment::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& FundingPayment::amount() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPayment.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingPayment::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPayment.amount)
}
inline std::string* FundingPayment::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingPayment.amount)
  return _s;
}
inline const std::string& FundingPayment::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void FundingPayment::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingPayment::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingPayment::release_amount() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingPayment.amount)
  return _impl_.amount_.Release();
}
inline void FundingPayment::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingPayment.amount)
}

// sint64 timestamp = 4 [json_name = "timestamp"];
inline void FundingPayment::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t FundingPayment::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingPayment.timestamp)
  return _internal_timestamp();
}
inline void FundingPayment::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingPayment.timestamp)
}
inline ::int64_t FundingPayment::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void FundingPayment::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// FundingRatesRequest

// string market_id = 1 [json_name = "marketId"];
inline void FundingRatesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& FundingRatesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingRatesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRatesRequest.market_id)
}
inline std::string* FundingRatesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingRatesRequest.market_id)
  return _s;
}
inline const std::string& FundingRatesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void FundingRatesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingRatesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingRatesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingRatesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void FundingRatesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingRatesRequest.market_id)
}

// uint64 skip = 2 [json_name = "skip"];
inline void FundingRatesRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t FundingRatesRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesRequest.skip)
  return _internal_skip();
}
inline void FundingRatesRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRatesRequest.skip)
}
inline ::uint64_t FundingRatesRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void FundingRatesRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 3 [json_name = "limit"];
inline void FundingRatesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t FundingRatesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesRequest.limit)
  return _internal_limit();
}
inline void FundingRatesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRatesRequest.limit)
}
inline ::int32_t FundingRatesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void FundingRatesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 end_time = 4 [json_name = "endTime"];
inline void FundingRatesRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t FundingRatesRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesRequest.end_time)
  return _internal_end_time();
}
inline void FundingRatesRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRatesRequest.end_time)
}
inline ::int64_t FundingRatesRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void FundingRatesRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// FundingRatesResponse

// repeated .injective_derivative_exchange_rpc.FundingRate funding_rates = 1 [json_name = "fundingRates"];
inline int FundingRatesResponse::_internal_funding_rates_size() const {
  return _impl_.funding_rates_.size();
}
inline int FundingRatesResponse::funding_rates_size() const {
  return _internal_funding_rates_size();
}
inline void FundingRatesResponse::clear_funding_rates() {
  _internal_mutable_funding_rates()->Clear();
}
inline ::injective_derivative_exchange_rpc::FundingRate* FundingRatesResponse::mutable_funding_rates(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingRatesResponse.funding_rates)
  return _internal_mutable_funding_rates()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingRate >*
FundingRatesResponse::mutable_funding_rates() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.FundingRatesResponse.funding_rates)
  return _internal_mutable_funding_rates();
}
inline const ::injective_derivative_exchange_rpc::FundingRate& FundingRatesResponse::_internal_funding_rates(int index) const {
  return _internal_funding_rates().Get(index);
}
inline const ::injective_derivative_exchange_rpc::FundingRate& FundingRatesResponse::funding_rates(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesResponse.funding_rates)
  return _internal_funding_rates(index);
}
inline ::injective_derivative_exchange_rpc::FundingRate* FundingRatesResponse::_internal_add_funding_rates() {
  return _internal_mutable_funding_rates()->Add();
}
inline ::injective_derivative_exchange_rpc::FundingRate* FundingRatesResponse::add_funding_rates() {
  ::injective_derivative_exchange_rpc::FundingRate* _add = _internal_add_funding_rates();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.FundingRatesResponse.funding_rates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::FundingRate >&
FundingRatesResponse::funding_rates() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.FundingRatesResponse.funding_rates)
  return _internal_funding_rates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingRate>&
FundingRatesResponse::_internal_funding_rates() const {
  return _impl_.funding_rates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::FundingRate>*
FundingRatesResponse::_internal_mutable_funding_rates() {
  return &_impl_.funding_rates_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool FundingRatesResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void FundingRatesResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& FundingRatesResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& FundingRatesResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRatesResponse.paging)
  return _internal_paging();
}
inline void FundingRatesResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.FundingRatesResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* FundingRatesResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingRatesResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingRatesResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingRatesResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* FundingRatesResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingRatesResponse.paging)
  return _msg;
}
inline void FundingRatesResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingRatesResponse.paging)
}

// -------------------------------------------------------------------

// FundingRate

// string market_id = 1 [json_name = "marketId"];
inline void FundingRate::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& FundingRate::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRate.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingRate::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRate.market_id)
}
inline std::string* FundingRate::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingRate.market_id)
  return _s;
}
inline const std::string& FundingRate::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void FundingRate::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingRate::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingRate::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingRate.market_id)
  return _impl_.market_id_.Release();
}
inline void FundingRate::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingRate.market_id)
}

// string rate = 2 [json_name = "rate"];
inline void FundingRate::clear_rate() {
  _impl_.rate_.ClearToEmpty();
}
inline const std::string& FundingRate::rate() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRate.rate)
  return _internal_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FundingRate::set_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRate.rate)
}
inline std::string* FundingRate::mutable_rate() {
  std::string* _s = _internal_mutable_rate();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.FundingRate.rate)
  return _s;
}
inline const std::string& FundingRate::_internal_rate() const {
  return _impl_.rate_.Get();
}
inline void FundingRate::_internal_set_rate(const std::string& value) {
  ;


  _impl_.rate_.Set(value, GetArenaForAllocation());
}
inline std::string* FundingRate::_internal_mutable_rate() {
  ;
  return _impl_.rate_.Mutable( GetArenaForAllocation());
}
inline std::string* FundingRate::release_rate() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.FundingRate.rate)
  return _impl_.rate_.Release();
}
inline void FundingRate::set_allocated_rate(std::string* value) {
  _impl_.rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rate_.IsDefault()) {
          _impl_.rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.FundingRate.rate)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void FundingRate::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t FundingRate::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.FundingRate.timestamp)
  return _internal_timestamp();
}
inline void FundingRate::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.FundingRate.timestamp)
}
inline ::int64_t FundingRate::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void FundingRate::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// StreamPositionsRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void StreamPositionsRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamPositionsRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPositionsRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_id)
}
inline std::string* StreamPositionsRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamPositionsRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamPositionsRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamPositionsRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamPositionsRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamPositionsRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void StreamPositionsRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamPositionsRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamPositionsRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.market_id)
}
inline std::string* StreamPositionsRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.market_id)
  return _s;
}
inline const std::string& StreamPositionsRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamPositionsRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamPositionsRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamPositionsRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamPositionsRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamPositionsRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamPositionsRequest.market_id)
}

// repeated string market_ids = 3 [json_name = "marketIds"];
inline int StreamPositionsRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamPositionsRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamPositionsRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamPositionsRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
  return _s;
}
inline const std::string& StreamPositionsRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamPositionsRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamPositionsRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline void StreamPositionsRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamPositionsRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamPositionsRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamPositionsRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamPositionsRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamPositionsRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamPositionsRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamPositionsRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// repeated string subaccount_ids = 4 [json_name = "subaccountIds"];
inline int StreamPositionsRequest::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int StreamPositionsRequest::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void StreamPositionsRequest::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* StreamPositionsRequest::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
  return _s;
}
inline const std::string& StreamPositionsRequest::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* StreamPositionsRequest::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void StreamPositionsRequest::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::set_subaccount_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::add_subaccount_ids(const char* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline void StreamPositionsRequest::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamPositionsRequest::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamPositionsRequest::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamPositionsRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& StreamPositionsRequest::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* StreamPositionsRequest::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamPositionsRequest::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamPositionsRequest::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// -------------------------------------------------------------------

// StreamPositionsResponse

// .injective_derivative_exchange_rpc.DerivativePosition position = 1 [json_name = "position"];
inline bool StreamPositionsResponse::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void StreamPositionsResponse::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& StreamPositionsResponse::_internal_position() const {
  const ::injective_derivative_exchange_rpc::DerivativePosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativePosition&>(
      ::injective_derivative_exchange_rpc::_DerivativePosition_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativePosition& StreamPositionsResponse::position() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsResponse.position)
  return _internal_position();
}
inline void StreamPositionsResponse::unsafe_arena_set_allocated_position(
    ::injective_derivative_exchange_rpc::DerivativePosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamPositionsResponse.position)
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* StreamPositionsResponse::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativePosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* StreamPositionsResponse::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamPositionsResponse.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativePosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* StreamPositionsResponse::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativePosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::injective_derivative_exchange_rpc::DerivativePosition* StreamPositionsResponse::mutable_position() {
  ::injective_derivative_exchange_rpc::DerivativePosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamPositionsResponse.position)
  return _msg;
}
inline void StreamPositionsResponse::set_allocated_position(::injective_derivative_exchange_rpc::DerivativePosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamPositionsResponse.position)
}

// sint64 timestamp = 2 [json_name = "timestamp"];
inline void StreamPositionsResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamPositionsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamPositionsResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamPositionsResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamPositionsResponse.timestamp)
}
inline ::int64_t StreamPositionsResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamPositionsResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// StreamOrdersRequest

// string market_id = 1 [json_name = "marketId"];
inline void StreamOrdersRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.market_id)
}
inline std::string* StreamOrdersRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.market_id)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrdersRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrdersRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersRequest.market_id)
}

// string order_side = 2 [json_name = "orderSide"];
inline void StreamOrdersRequest::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::order_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.order_side)
}
inline std::string* StreamOrdersRequest::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.order_side)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void StreamOrdersRequest::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersRequest.order_side)
  return _impl_.order_side_.Release();
}
inline void StreamOrdersRequest::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersRequest.order_side)
}

// string subaccount_id = 3 [json_name = "subaccountId"];
inline void StreamOrdersRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_id)
}
inline std::string* StreamOrdersRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamOrdersRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamOrdersRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_id)
}

// uint64 skip = 4 [json_name = "skip"];
inline void StreamOrdersRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t StreamOrdersRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.skip)
  return _internal_skip();
}
inline void StreamOrdersRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.skip)
}
inline ::uint64_t StreamOrdersRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void StreamOrdersRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 5 [json_name = "limit"];
inline void StreamOrdersRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t StreamOrdersRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.limit)
  return _internal_limit();
}
inline void StreamOrdersRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.limit)
}
inline ::int32_t StreamOrdersRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void StreamOrdersRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 6 [json_name = "startTime"];
inline void StreamOrdersRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.start_time)
  return _internal_start_time();
}
inline void StreamOrdersRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.start_time)
}
inline ::int64_t StreamOrdersRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void StreamOrdersRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 7 [json_name = "endTime"];
inline void StreamOrdersRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.end_time)
  return _internal_end_time();
}
inline void StreamOrdersRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.end_time)
}
inline ::int64_t StreamOrdersRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void StreamOrdersRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 8 [json_name = "marketIds"];
inline int StreamOrdersRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamOrdersRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamOrdersRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamOrdersRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
  return _s;
}
inline const std::string& StreamOrdersRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamOrdersRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamOrdersRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline void StreamOrdersRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrdersRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamOrdersRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamOrdersRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// string is_conditional = 9 [json_name = "isConditional"];
inline void StreamOrdersRequest::clear_is_conditional() {
  _impl_.is_conditional_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::is_conditional() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.is_conditional)
  return _internal_is_conditional();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_is_conditional(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.is_conditional_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.is_conditional)
}
inline std::string* StreamOrdersRequest::mutable_is_conditional() {
  std::string* _s = _internal_mutable_is_conditional();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.is_conditional)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_is_conditional() const {
  return _impl_.is_conditional_.Get();
}
inline void StreamOrdersRequest::_internal_set_is_conditional(const std::string& value) {
  ;


  _impl_.is_conditional_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_is_conditional() {
  ;
  return _impl_.is_conditional_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_is_conditional() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersRequest.is_conditional)
  return _impl_.is_conditional_.Release();
}
inline void StreamOrdersRequest::set_allocated_is_conditional(std::string* value) {
  _impl_.is_conditional_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.is_conditional_.IsDefault()) {
          _impl_.is_conditional_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersRequest.is_conditional)
}

// string order_type = 10 [json_name = "orderType"];
inline void StreamOrdersRequest::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& StreamOrdersRequest::order_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersRequest::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.order_type)
}
inline std::string* StreamOrdersRequest::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersRequest.order_type)
  return _s;
}
inline const std::string& StreamOrdersRequest::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void StreamOrdersRequest::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersRequest::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersRequest.order_type)
  return _impl_.order_type_.Release();
}
inline void StreamOrdersRequest::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersRequest.order_type)
}

// bool include_inactive = 11 [json_name = "includeInactive"];
inline void StreamOrdersRequest::clear_include_inactive() {
  _impl_.include_inactive_ = false;
}
inline bool StreamOrdersRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.include_inactive)
  return _internal_include_inactive();
}
inline void StreamOrdersRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.include_inactive)
}
inline bool StreamOrdersRequest::_internal_include_inactive() const {
  return _impl_.include_inactive_;
}
inline void StreamOrdersRequest::_internal_set_include_inactive(bool value) {
  ;
  _impl_.include_inactive_ = value;
}

// bool subaccount_total_orders = 12 [json_name = "subaccountTotalOrders"];
inline void StreamOrdersRequest::clear_subaccount_total_orders() {
  _impl_.subaccount_total_orders_ = false;
}
inline bool StreamOrdersRequest::subaccount_total_orders() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_total_orders)
  return _internal_subaccount_total_orders();
}
inline void StreamOrdersRequest::set_subaccount_total_orders(bool value) {
  _internal_set_subaccount_total_orders(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersRequest.subaccount_total_orders)
}
inline bool StreamOrdersRequest::_internal_subaccount_total_orders() const {
  return _impl_.subaccount_total_orders_;
}
inline void StreamOrdersRequest::_internal_set_subaccount_total_orders(bool value) {
  ;
  _impl_.subaccount_total_orders_ = value;
}

// -------------------------------------------------------------------

// StreamOrdersResponse

// .injective_derivative_exchange_rpc.DerivativeLimitOrder order = 1 [json_name = "order"];
inline bool StreamOrdersResponse::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void StreamOrdersResponse::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& StreamOrdersResponse::_internal_order() const {
  const ::injective_derivative_exchange_rpc::DerivativeLimitOrder* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeLimitOrder&>(
      ::injective_derivative_exchange_rpc::_DerivativeLimitOrder_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& StreamOrdersResponse::order() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersResponse.order)
  return _internal_order();
}
inline void StreamOrdersResponse::unsafe_arena_set_allocated_order(
    ::injective_derivative_exchange_rpc::DerivativeLimitOrder* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamOrdersResponse.order)
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* StreamOrdersResponse::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* StreamOrdersResponse::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersResponse.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* StreamOrdersResponse::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeLimitOrder>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* StreamOrdersResponse::mutable_order() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersResponse.order)
  return _msg;
}
inline void StreamOrdersResponse::set_allocated_order(::injective_derivative_exchange_rpc::DerivativeLimitOrder* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersResponse.order)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrdersResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrdersResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersResponse.operation_type)
}
inline std::string* StreamOrdersResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrdersResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrdersResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrdersResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrdersResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrdersResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersResponse.timestamp)
}
inline ::int64_t StreamOrdersResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrdersResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// TradesRequest

// string market_id = 1 [json_name = "marketId"];
inline void TradesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& TradesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.market_id)
}
inline std::string* TradesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.market_id)
  return _s;
}
inline const std::string& TradesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void TradesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TradesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void TradesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TradesRequest.market_id)
}

// string execution_side = 2 [json_name = "executionSide"];
inline void TradesRequest::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& TradesRequest::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.execution_side)
}
inline std::string* TradesRequest::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.execution_side)
  return _s;
}
inline const std::string& TradesRequest::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void TradesRequest::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TradesRequest.execution_side)
  return _impl_.execution_side_.Release();
}
inline void TradesRequest::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TradesRequest.execution_side)
}

// string direction = 3 [json_name = "direction"];
inline void TradesRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& TradesRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.direction)
}
inline std::string* TradesRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.direction)
  return _s;
}
inline const std::string& TradesRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void TradesRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TradesRequest.direction)
  return _impl_.direction_.Release();
}
inline void TradesRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TradesRequest.direction)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void TradesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& TradesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.subaccount_id)
}
inline std::string* TradesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.subaccount_id)
  return _s;
}
inline const std::string& TradesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void TradesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TradesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* TradesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TradesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void TradesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TradesRequest.subaccount_id)
}

// uint64 skip = 5 [json_name = "skip"];
inline void TradesRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t TradesRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.skip)
  return _internal_skip();
}
inline void TradesRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.skip)
}
inline ::uint64_t TradesRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void TradesRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void TradesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t TradesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.limit)
  return _internal_limit();
}
inline void TradesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.limit)
}
inline ::int32_t TradesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void TradesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void TradesRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t TradesRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.start_time)
  return _internal_start_time();
}
inline void TradesRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.start_time)
}
inline ::int64_t TradesRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void TradesRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void TradesRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t TradesRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.end_time)
  return _internal_end_time();
}
inline void TradesRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.end_time)
}
inline ::int64_t TradesRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void TradesRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 9 [json_name = "marketIds"];
inline int TradesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int TradesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void TradesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* TradesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.TradesRequest.market_ids)
  return _s;
}
inline const std::string& TradesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* TradesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void TradesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline void TradesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.TradesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.TradesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.TradesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& TradesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* TradesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
inline int TradesRequest::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int TradesRequest::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void TradesRequest::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* TradesRequest::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
  return _s;
}
inline const std::string& TradesRequest::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* TradesRequest::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void TradesRequest::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(const char* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline void TradesRequest::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.TradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& TradesRequest::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* TradesRequest::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// repeated string execution_types = 11 [json_name = "executionTypes"];
inline int TradesRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int TradesRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void TradesRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* TradesRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.TradesRequest.execution_types)
  return _s;
}
inline const std::string& TradesRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* TradesRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void TradesRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline void TradesRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.TradesRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.TradesRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TradesRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.TradesRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& TradesRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* TradesRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TradesRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TradesRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// TradesResponse

// repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1 [json_name = "trades"];
inline int TradesResponse::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int TradesResponse::trades_size() const {
  return _internal_trades_size();
}
inline void TradesResponse::clear_trades() {
  _internal_mutable_trades()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* TradesResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesResponse.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >*
TradesResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.TradesResponse.trades)
  return _internal_mutable_trades();
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& TradesResponse::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& TradesResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesResponse.trades)
  return _internal_trades(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* TradesResponse::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* TradesResponse::add_trades() {
  ::injective_derivative_exchange_rpc::DerivativeTrade* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.TradesResponse.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >&
TradesResponse::trades() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.TradesResponse.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>&
TradesResponse::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>*
TradesResponse::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool TradesResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void TradesResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& TradesResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& TradesResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.TradesResponse.paging)
  return _internal_paging();
}
inline void TradesResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.TradesResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* TradesResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* TradesResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.TradesResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* TradesResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* TradesResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.TradesResponse.paging)
  return _msg;
}
inline void TradesResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.TradesResponse.paging)
}

// -------------------------------------------------------------------

// DerivativeTrade

// string order_hash = 1 [json_name = "orderHash"];
inline void DerivativeTrade::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.order_hash)
}
inline std::string* DerivativeTrade::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.order_hash)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeTrade::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeTrade::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.order_hash)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void DerivativeTrade::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.subaccount_id)
}
inline std::string* DerivativeTrade::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.subaccount_id)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void DerivativeTrade::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void DerivativeTrade::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.subaccount_id)
}

// string market_id = 3 [json_name = "marketId"];
inline void DerivativeTrade::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.market_id)
}
inline std::string* DerivativeTrade::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.market_id)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeTrade::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeTrade::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.market_id)
}

// string trade_execution_type = 4 [json_name = "tradeExecutionType"];
inline void DerivativeTrade::clear_trade_execution_type() {
  _impl_.trade_execution_type_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::trade_execution_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.trade_execution_type)
  return _internal_trade_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_trade_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.trade_execution_type)
}
inline std::string* DerivativeTrade::mutable_trade_execution_type() {
  std::string* _s = _internal_mutable_trade_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.trade_execution_type)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_trade_execution_type() const {
  return _impl_.trade_execution_type_.Get();
}
inline void DerivativeTrade::_internal_set_trade_execution_type(const std::string& value) {
  ;


  _impl_.trade_execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_trade_execution_type() {
  ;
  return _impl_.trade_execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_trade_execution_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.trade_execution_type)
  return _impl_.trade_execution_type_.Release();
}
inline void DerivativeTrade::set_allocated_trade_execution_type(std::string* value) {
  _impl_.trade_execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_execution_type_.IsDefault()) {
          _impl_.trade_execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.trade_execution_type)
}

// bool is_liquidation = 5 [json_name = "isLiquidation"];
inline void DerivativeTrade::clear_is_liquidation() {
  _impl_.is_liquidation_ = false;
}
inline bool DerivativeTrade::is_liquidation() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.is_liquidation)
  return _internal_is_liquidation();
}
inline void DerivativeTrade::set_is_liquidation(bool value) {
  _internal_set_is_liquidation(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.is_liquidation)
}
inline bool DerivativeTrade::_internal_is_liquidation() const {
  return _impl_.is_liquidation_;
}
inline void DerivativeTrade::_internal_set_is_liquidation(bool value) {
  ;
  _impl_.is_liquidation_ = value;
}

// .injective_derivative_exchange_rpc.PositionDelta position_delta = 6 [json_name = "positionDelta"];
inline bool DerivativeTrade::has_position_delta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_delta_ != nullptr);
  return value;
}
inline void DerivativeTrade::clear_position_delta() {
  if (_impl_.position_delta_ != nullptr) _impl_.position_delta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::PositionDelta& DerivativeTrade::_internal_position_delta() const {
  const ::injective_derivative_exchange_rpc::PositionDelta* p = _impl_.position_delta_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::PositionDelta&>(
      ::injective_derivative_exchange_rpc::_PositionDelta_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::PositionDelta& DerivativeTrade::position_delta() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.position_delta)
  return _internal_position_delta();
}
inline void DerivativeTrade::unsafe_arena_set_allocated_position_delta(
    ::injective_derivative_exchange_rpc::PositionDelta* position_delta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_delta_);
  }
  _impl_.position_delta_ = position_delta;
  if (position_delta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.position_delta)
}
inline ::injective_derivative_exchange_rpc::PositionDelta* DerivativeTrade::release_position_delta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::PositionDelta* DerivativeTrade::unsafe_arena_release_position_delta() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.position_delta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::PositionDelta* temp = _impl_.position_delta_;
  _impl_.position_delta_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::PositionDelta* DerivativeTrade::_internal_mutable_position_delta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_delta_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::PositionDelta>(GetArenaForAllocation());
    _impl_.position_delta_ = p;
  }
  return _impl_.position_delta_;
}
inline ::injective_derivative_exchange_rpc::PositionDelta* DerivativeTrade::mutable_position_delta() {
  ::injective_derivative_exchange_rpc::PositionDelta* _msg = _internal_mutable_position_delta();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.position_delta)
  return _msg;
}
inline void DerivativeTrade::set_allocated_position_delta(::injective_derivative_exchange_rpc::PositionDelta* position_delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_delta_;
  }
  if (position_delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position_delta);
    if (message_arena != submessage_arena) {
      position_delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_delta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_delta_ = position_delta;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.position_delta)
}

// string payout = 7 [json_name = "payout"];
inline void DerivativeTrade::clear_payout() {
  _impl_.payout_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::payout() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.payout)
  return _internal_payout();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_payout(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payout_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.payout)
}
inline std::string* DerivativeTrade::mutable_payout() {
  std::string* _s = _internal_mutable_payout();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.payout)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_payout() const {
  return _impl_.payout_.Get();
}
inline void DerivativeTrade::_internal_set_payout(const std::string& value) {
  ;


  _impl_.payout_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_payout() {
  ;
  return _impl_.payout_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_payout() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.payout)
  return _impl_.payout_.Release();
}
inline void DerivativeTrade::set_allocated_payout(std::string* value) {
  _impl_.payout_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payout_.IsDefault()) {
          _impl_.payout_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.payout)
}

// string fee = 8 [json_name = "fee"];
inline void DerivativeTrade::clear_fee() {
  _impl_.fee_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::fee() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.fee)
  return _internal_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.fee)
}
inline std::string* DerivativeTrade::mutable_fee() {
  std::string* _s = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.fee)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_fee() const {
  return _impl_.fee_.Get();
}
inline void DerivativeTrade::_internal_set_fee(const std::string& value) {
  ;


  _impl_.fee_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_fee() {
  ;
  return _impl_.fee_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_fee() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.fee)
  return _impl_.fee_.Release();
}
inline void DerivativeTrade::set_allocated_fee(std::string* value) {
  _impl_.fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_.IsDefault()) {
          _impl_.fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.fee)
}

// sint64 executed_at = 9 [json_name = "executedAt"];
inline void DerivativeTrade::clear_executed_at() {
  _impl_.executed_at_ = ::int64_t{0};
}
inline ::int64_t DerivativeTrade::executed_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.executed_at)
  return _internal_executed_at();
}
inline void DerivativeTrade::set_executed_at(::int64_t value) {
  _internal_set_executed_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.executed_at)
}
inline ::int64_t DerivativeTrade::_internal_executed_at() const {
  return _impl_.executed_at_;
}
inline void DerivativeTrade::_internal_set_executed_at(::int64_t value) {
  ;
  _impl_.executed_at_ = value;
}

// string fee_recipient = 10 [json_name = "feeRecipient"];
inline void DerivativeTrade::clear_fee_recipient() {
  _impl_.fee_recipient_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::fee_recipient() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.fee_recipient)
  return _internal_fee_recipient();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_fee_recipient(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_recipient_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.fee_recipient)
}
inline std::string* DerivativeTrade::mutable_fee_recipient() {
  std::string* _s = _internal_mutable_fee_recipient();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.fee_recipient)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_fee_recipient() const {
  return _impl_.fee_recipient_.Get();
}
inline void DerivativeTrade::_internal_set_fee_recipient(const std::string& value) {
  ;


  _impl_.fee_recipient_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_fee_recipient() {
  ;
  return _impl_.fee_recipient_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_fee_recipient() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.fee_recipient)
  return _impl_.fee_recipient_.Release();
}
inline void DerivativeTrade::set_allocated_fee_recipient(std::string* value) {
  _impl_.fee_recipient_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_recipient_.IsDefault()) {
          _impl_.fee_recipient_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.fee_recipient)
}

// string trade_id = 11 [json_name = "tradeId"];
inline void DerivativeTrade::clear_trade_id() {
  _impl_.trade_id_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::trade_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.trade_id)
  return _internal_trade_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_trade_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.trade_id)
}
inline std::string* DerivativeTrade::mutable_trade_id() {
  std::string* _s = _internal_mutable_trade_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.trade_id)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_trade_id() const {
  return _impl_.trade_id_.Get();
}
inline void DerivativeTrade::_internal_set_trade_id(const std::string& value) {
  ;


  _impl_.trade_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_trade_id() {
  ;
  return _impl_.trade_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_trade_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.trade_id)
  return _impl_.trade_id_.Release();
}
inline void DerivativeTrade::set_allocated_trade_id(std::string* value) {
  _impl_.trade_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_id_.IsDefault()) {
          _impl_.trade_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.trade_id)
}

// string execution_side = 12 [json_name = "executionSide"];
inline void DerivativeTrade::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& DerivativeTrade::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeTrade.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeTrade::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeTrade.execution_side)
}
inline std::string* DerivativeTrade::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeTrade.execution_side)
  return _s;
}
inline const std::string& DerivativeTrade::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void DerivativeTrade::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeTrade::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeTrade::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeTrade.execution_side)
  return _impl_.execution_side_.Release();
}
inline void DerivativeTrade::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeTrade.execution_side)
}

// -------------------------------------------------------------------

// PositionDelta

// string trade_direction = 1 [json_name = "tradeDirection"];
inline void PositionDelta::clear_trade_direction() {
  _impl_.trade_direction_.ClearToEmpty();
}
inline const std::string& PositionDelta::trade_direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionDelta.trade_direction)
  return _internal_trade_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_trade_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trade_direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionDelta.trade_direction)
}
inline std::string* PositionDelta::mutable_trade_direction() {
  std::string* _s = _internal_mutable_trade_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionDelta.trade_direction)
  return _s;
}
inline const std::string& PositionDelta::_internal_trade_direction() const {
  return _impl_.trade_direction_.Get();
}
inline void PositionDelta::_internal_set_trade_direction(const std::string& value) {
  ;


  _impl_.trade_direction_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_trade_direction() {
  ;
  return _impl_.trade_direction_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_trade_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionDelta.trade_direction)
  return _impl_.trade_direction_.Release();
}
inline void PositionDelta::set_allocated_trade_direction(std::string* value) {
  _impl_.trade_direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_direction_.IsDefault()) {
          _impl_.trade_direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionDelta.trade_direction)
}

// string execution_price = 2 [json_name = "executionPrice"];
inline void PositionDelta::clear_execution_price() {
  _impl_.execution_price_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionDelta.execution_price)
  return _internal_execution_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionDelta.execution_price)
}
inline std::string* PositionDelta::mutable_execution_price() {
  std::string* _s = _internal_mutable_execution_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionDelta.execution_price)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_price() const {
  return _impl_.execution_price_.Get();
}
inline void PositionDelta::_internal_set_execution_price(const std::string& value) {
  ;


  _impl_.execution_price_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_price() {
  ;
  return _impl_.execution_price_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionDelta.execution_price)
  return _impl_.execution_price_.Release();
}
inline void PositionDelta::set_allocated_execution_price(std::string* value) {
  _impl_.execution_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_price_.IsDefault()) {
          _impl_.execution_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionDelta.execution_price)
}

// string execution_quantity = 3 [json_name = "executionQuantity"];
inline void PositionDelta::clear_execution_quantity() {
  _impl_.execution_quantity_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionDelta.execution_quantity)
  return _internal_execution_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionDelta.execution_quantity)
}
inline std::string* PositionDelta::mutable_execution_quantity() {
  std::string* _s = _internal_mutable_execution_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionDelta.execution_quantity)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_quantity() const {
  return _impl_.execution_quantity_.Get();
}
inline void PositionDelta::_internal_set_execution_quantity(const std::string& value) {
  ;


  _impl_.execution_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_quantity() {
  ;
  return _impl_.execution_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionDelta.execution_quantity)
  return _impl_.execution_quantity_.Release();
}
inline void PositionDelta::set_allocated_execution_quantity(std::string* value) {
  _impl_.execution_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_quantity_.IsDefault()) {
          _impl_.execution_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionDelta.execution_quantity)
}

// string execution_margin = 4 [json_name = "executionMargin"];
inline void PositionDelta::clear_execution_margin() {
  _impl_.execution_margin_.ClearToEmpty();
}
inline const std::string& PositionDelta::execution_margin() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.PositionDelta.execution_margin)
  return _internal_execution_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PositionDelta::set_execution_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.PositionDelta.execution_margin)
}
inline std::string* PositionDelta::mutable_execution_margin() {
  std::string* _s = _internal_mutable_execution_margin();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.PositionDelta.execution_margin)
  return _s;
}
inline const std::string& PositionDelta::_internal_execution_margin() const {
  return _impl_.execution_margin_.Get();
}
inline void PositionDelta::_internal_set_execution_margin(const std::string& value) {
  ;


  _impl_.execution_margin_.Set(value, GetArenaForAllocation());
}
inline std::string* PositionDelta::_internal_mutable_execution_margin() {
  ;
  return _impl_.execution_margin_.Mutable( GetArenaForAllocation());
}
inline std::string* PositionDelta::release_execution_margin() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.PositionDelta.execution_margin)
  return _impl_.execution_margin_.Release();
}
inline void PositionDelta::set_allocated_execution_margin(std::string* value) {
  _impl_.execution_margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_margin_.IsDefault()) {
          _impl_.execution_margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.PositionDelta.execution_margin)
}

// -------------------------------------------------------------------

// StreamTradesRequest

// string market_id = 1 [json_name = "marketId"];
inline void StreamTradesRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.market_id)
}
inline std::string* StreamTradesRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.market_id)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamTradesRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamTradesRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesRequest.market_id)
}

// string execution_side = 2 [json_name = "executionSide"];
inline void StreamTradesRequest::clear_execution_side() {
  _impl_.execution_side_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::execution_side() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.execution_side)
  return _internal_execution_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_execution_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.execution_side)
}
inline std::string* StreamTradesRequest::mutable_execution_side() {
  std::string* _s = _internal_mutable_execution_side();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.execution_side)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_execution_side() const {
  return _impl_.execution_side_.Get();
}
inline void StreamTradesRequest::_internal_set_execution_side(const std::string& value) {
  ;


  _impl_.execution_side_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_execution_side() {
  ;
  return _impl_.execution_side_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_execution_side() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesRequest.execution_side)
  return _impl_.execution_side_.Release();
}
inline void StreamTradesRequest::set_allocated_execution_side(std::string* value) {
  _impl_.execution_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_side_.IsDefault()) {
          _impl_.execution_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesRequest.execution_side)
}

// string direction = 3 [json_name = "direction"];
inline void StreamTradesRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.direction)
}
inline std::string* StreamTradesRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.direction)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void StreamTradesRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesRequest.direction)
  return _impl_.direction_.Release();
}
inline void StreamTradesRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesRequest.direction)
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void StreamTradesRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamTradesRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_id)
}
inline std::string* StreamTradesRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamTradesRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamTradesRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamTradesRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_id)
}

// uint64 skip = 5 [json_name = "skip"];
inline void StreamTradesRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t StreamTradesRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.skip)
  return _internal_skip();
}
inline void StreamTradesRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.skip)
}
inline ::uint64_t StreamTradesRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void StreamTradesRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void StreamTradesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t StreamTradesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.limit)
  return _internal_limit();
}
inline void StreamTradesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.limit)
}
inline ::int32_t StreamTradesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void StreamTradesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void StreamTradesRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t StreamTradesRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.start_time)
  return _internal_start_time();
}
inline void StreamTradesRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.start_time)
}
inline ::int64_t StreamTradesRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void StreamTradesRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void StreamTradesRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t StreamTradesRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.end_time)
  return _internal_end_time();
}
inline void StreamTradesRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.end_time)
}
inline ::int64_t StreamTradesRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void StreamTradesRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// repeated string market_ids = 9 [json_name = "marketIds"];
inline int StreamTradesRequest::_internal_market_ids_size() const {
  return _impl_.market_ids_.size();
}
inline int StreamTradesRequest::market_ids_size() const {
  return _internal_market_ids_size();
}
inline void StreamTradesRequest::clear_market_ids() {
  _internal_mutable_market_ids()->Clear();
}
inline std::string* StreamTradesRequest::add_market_ids() {
  std::string* _s = _internal_add_market_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
  return _s;
}
inline const std::string& StreamTradesRequest::market_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_market_ids(index);
}
inline std::string* StreamTradesRequest::mutable_market_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_mutable_market_ids()->Mutable(index);
}
inline void StreamTradesRequest::set_market_ids(int index, const std::string& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, std::string&& value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::set_market_ids(int index, absl::string_view value) {
  _internal_mutable_market_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const std::string& value) {
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(std::string&& value) {
  _internal_mutable_market_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(const char* value, std::size_t size) {
  _internal_mutable_market_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline void StreamTradesRequest::add_market_ids(absl::string_view value) {
  _internal_mutable_market_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::market_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_market_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_market_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamTradesRequest.market_ids)
  return _internal_mutable_market_ids();
}
inline const std::string& StreamTradesRequest::_internal_market_ids(int index) const {
  return _internal_market_ids().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_market_ids() {
  return _internal_mutable_market_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_market_ids() const {
  return _impl_.market_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_market_ids() {
  return &_impl_.market_ids_;
}

// repeated string subaccount_ids = 10 [json_name = "subaccountIds"];
inline int StreamTradesRequest::_internal_subaccount_ids_size() const {
  return _impl_.subaccount_ids_.size();
}
inline int StreamTradesRequest::subaccount_ids_size() const {
  return _internal_subaccount_ids_size();
}
inline void StreamTradesRequest::clear_subaccount_ids() {
  _internal_mutable_subaccount_ids()->Clear();
}
inline std::string* StreamTradesRequest::add_subaccount_ids() {
  std::string* _s = _internal_add_subaccount_ids();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _s;
}
inline const std::string& StreamTradesRequest::subaccount_ids(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_subaccount_ids(index);
}
inline std::string* StreamTradesRequest::mutable_subaccount_ids(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids()->Mutable(index);
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const std::string& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, std::string&& value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::set_subaccount_ids(int index, absl::string_view value) {
  _internal_mutable_subaccount_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const std::string& value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(std::string&& value) {
  _internal_mutable_subaccount_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccount_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(const char* value, std::size_t size) {
  _internal_mutable_subaccount_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline void StreamTradesRequest::add_subaccount_ids(absl::string_view value) {
  _internal_mutable_subaccount_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::subaccount_ids() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_subaccount_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_subaccount_ids() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamTradesRequest.subaccount_ids)
  return _internal_mutable_subaccount_ids();
}
inline const std::string& StreamTradesRequest::_internal_subaccount_ids(int index) const {
  return _internal_subaccount_ids().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_subaccount_ids() {
  return _internal_mutable_subaccount_ids()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_subaccount_ids() const {
  return _impl_.subaccount_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_subaccount_ids() {
  return &_impl_.subaccount_ids_;
}

// repeated string execution_types = 11 [json_name = "executionTypes"];
inline int StreamTradesRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int StreamTradesRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void StreamTradesRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* StreamTradesRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
  return _s;
}
inline const std::string& StreamTradesRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* StreamTradesRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void StreamTradesRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline void StreamTradesRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamTradesRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamTradesRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& StreamTradesRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* StreamTradesRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamTradesRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamTradesRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// StreamTradesResponse

// .injective_derivative_exchange_rpc.DerivativeTrade trade = 1 [json_name = "trade"];
inline bool StreamTradesResponse::has_trade() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trade_ != nullptr);
  return value;
}
inline void StreamTradesResponse::clear_trade() {
  if (_impl_.trade_ != nullptr) _impl_.trade_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& StreamTradesResponse::_internal_trade() const {
  const ::injective_derivative_exchange_rpc::DerivativeTrade* p = _impl_.trade_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeTrade&>(
      ::injective_derivative_exchange_rpc::_DerivativeTrade_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& StreamTradesResponse::trade() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesResponse.trade)
  return _internal_trade();
}
inline void StreamTradesResponse::unsafe_arena_set_allocated_trade(
    ::injective_derivative_exchange_rpc::DerivativeTrade* trade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trade_);
  }
  _impl_.trade_ = trade;
  if (trade) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamTradesResponse.trade)
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* StreamTradesResponse::release_trade() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeTrade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* StreamTradesResponse::unsafe_arena_release_trade() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesResponse.trade)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeTrade* temp = _impl_.trade_;
  _impl_.trade_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* StreamTradesResponse::_internal_mutable_trade() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeTrade>(GetArenaForAllocation());
    _impl_.trade_ = p;
  }
  return _impl_.trade_;
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* StreamTradesResponse::mutable_trade() {
  ::injective_derivative_exchange_rpc::DerivativeTrade* _msg = _internal_mutable_trade();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesResponse.trade)
  return _msg;
}
inline void StreamTradesResponse::set_allocated_trade(::injective_derivative_exchange_rpc::DerivativeTrade* trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trade_;
  }
  if (trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trade);
    if (message_arena != submessage_arena) {
      trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesResponse.trade)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamTradesResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamTradesResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTradesResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesResponse.operation_type)
}
inline std::string* StreamTradesResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamTradesResponse.operation_type)
  return _s;
}
inline const std::string& StreamTradesResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamTradesResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTradesResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTradesResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamTradesResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamTradesResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamTradesResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamTradesResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamTradesResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamTradesResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamTradesResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamTradesResponse.timestamp)
}
inline ::int64_t StreamTradesResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamTradesResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrdersListRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountOrdersListRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrdersListRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrdersListRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
}
inline std::string* SubaccountOrdersListRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountOrdersListRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountOrdersListRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountOrdersListRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountOrdersListRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrdersListRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrdersListRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.market_id)
}
inline std::string* SubaccountOrdersListRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _s;
}
inline const std::string& SubaccountOrdersListRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountOrdersListRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrdersListRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountOrdersListRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void SubaccountOrdersListRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t SubaccountOrdersListRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.skip)
  return _internal_skip();
}
inline void SubaccountOrdersListRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.skip)
}
inline ::uint64_t SubaccountOrdersListRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void SubaccountOrdersListRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void SubaccountOrdersListRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t SubaccountOrdersListRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.limit)
  return _internal_limit();
}
inline void SubaccountOrdersListRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountOrdersListRequest.limit)
}
inline ::int32_t SubaccountOrdersListRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void SubaccountOrdersListRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrdersListResponse

// repeated .injective_derivative_exchange_rpc.DerivativeLimitOrder orders = 1 [json_name = "orders"];
inline int SubaccountOrdersListResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int SubaccountOrdersListResponse::orders_size() const {
  return _internal_orders_size();
}
inline void SubaccountOrdersListResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* SubaccountOrdersListResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >*
SubaccountOrdersListResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& SubaccountOrdersListResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeLimitOrder& SubaccountOrdersListResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_orders(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* SubaccountOrdersListResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeLimitOrder* SubaccountOrdersListResponse::add_orders() {
  ::injective_derivative_exchange_rpc::DerivativeLimitOrder* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeLimitOrder >&
SubaccountOrdersListResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>&
SubaccountOrdersListResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeLimitOrder>*
SubaccountOrdersListResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool SubaccountOrdersListResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void SubaccountOrdersListResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& SubaccountOrdersListResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& SubaccountOrdersListResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.paging)
  return _internal_paging();
}
inline void SubaccountOrdersListResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* SubaccountOrdersListResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* SubaccountOrdersListResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* SubaccountOrdersListResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* SubaccountOrdersListResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.paging)
  return _msg;
}
inline void SubaccountOrdersListResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountOrdersListResponse.paging)
}

// -------------------------------------------------------------------

// SubaccountTradesListRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountTradesListRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
}
inline std::string* SubaccountTradesListRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountTradesListRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountTradesListRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.market_id)
}
inline std::string* SubaccountTradesListRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountTradesListRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountTradesListRequest.market_id)
}

// string execution_type = 3 [json_name = "executionType"];
inline void SubaccountTradesListRequest::clear_execution_type() {
  _impl_.execution_type_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::execution_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _internal_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.execution_type)
}
inline std::string* SubaccountTradesListRequest::mutable_execution_type() {
  std::string* _s = _internal_mutable_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_execution_type() const {
  return _impl_.execution_type_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_execution_type(const std::string& value) {
  ;


  _impl_.execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_execution_type() {
  ;
  return _impl_.execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_execution_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountTradesListRequest.execution_type)
  return _impl_.execution_type_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_execution_type(std::string* value) {
  _impl_.execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_type_.IsDefault()) {
          _impl_.execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountTradesListRequest.execution_type)
}

// string direction = 4 [json_name = "direction"];
inline void SubaccountTradesListRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& SubaccountTradesListRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountTradesListRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.direction)
}
inline std::string* SubaccountTradesListRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountTradesListRequest.direction)
  return _s;
}
inline const std::string& SubaccountTradesListRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void SubaccountTradesListRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountTradesListRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.SubaccountTradesListRequest.direction)
  return _impl_.direction_.Release();
}
inline void SubaccountTradesListRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.SubaccountTradesListRequest.direction)
}

// uint64 skip = 5 [json_name = "skip"];
inline void SubaccountTradesListRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t SubaccountTradesListRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.skip)
  return _internal_skip();
}
inline void SubaccountTradesListRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.skip)
}
inline ::uint64_t SubaccountTradesListRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void SubaccountTradesListRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 6 [json_name = "limit"];
inline void SubaccountTradesListRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t SubaccountTradesListRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListRequest.limit)
  return _internal_limit();
}
inline void SubaccountTradesListRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.SubaccountTradesListRequest.limit)
}
inline ::int32_t SubaccountTradesListRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void SubaccountTradesListRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// SubaccountTradesListResponse

// repeated .injective_derivative_exchange_rpc.DerivativeTrade trades = 1 [json_name = "trades"];
inline int SubaccountTradesListResponse::_internal_trades_size() const {
  return _impl_.trades_.size();
}
inline int SubaccountTradesListResponse::trades_size() const {
  return _internal_trades_size();
}
inline void SubaccountTradesListResponse::clear_trades() {
  _internal_mutable_trades()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* SubaccountTradesListResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_mutable_trades()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >*
SubaccountTradesListResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_mutable_trades();
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& SubaccountTradesListResponse::_internal_trades(int index) const {
  return _internal_trades().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeTrade& SubaccountTradesListResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_trades(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* SubaccountTradesListResponse::_internal_add_trades() {
  return _internal_mutable_trades()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeTrade* SubaccountTradesListResponse::add_trades() {
  ::injective_derivative_exchange_rpc::DerivativeTrade* _add = _internal_add_trades();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.SubaccountTradesListResponse.trades)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeTrade >&
SubaccountTradesListResponse::trades() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.SubaccountTradesListResponse.trades)
  return _internal_trades();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>&
SubaccountTradesListResponse::_internal_trades() const {
  return _impl_.trades_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeTrade>*
SubaccountTradesListResponse::_internal_mutable_trades() {
  return &_impl_.trades_;
}

// -------------------------------------------------------------------

// OrdersHistoryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void OrdersHistoryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.subaccount_id)
}
inline std::string* OrdersHistoryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrdersHistoryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrdersHistoryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void OrdersHistoryRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.market_id)
}
inline std::string* OrdersHistoryRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.market_id)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrdersHistoryRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void OrdersHistoryRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.market_id)
}

// uint64 skip = 3 [json_name = "skip"];
inline void OrdersHistoryRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t OrdersHistoryRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.skip)
  return _internal_skip();
}
inline void OrdersHistoryRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.skip)
}
inline ::uint64_t OrdersHistoryRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void OrdersHistoryRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void OrdersHistoryRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t OrdersHistoryRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.limit)
  return _internal_limit();
}
inline void OrdersHistoryRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.limit)
}
inline ::int32_t OrdersHistoryRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void OrdersHistoryRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// repeated string order_types = 5 [json_name = "orderTypes"];
inline int OrdersHistoryRequest::_internal_order_types_size() const {
  return _impl_.order_types_.size();
}
inline int OrdersHistoryRequest::order_types_size() const {
  return _internal_order_types_size();
}
inline void OrdersHistoryRequest::clear_order_types() {
  _internal_mutable_order_types()->Clear();
}
inline std::string* OrdersHistoryRequest::add_order_types() {
  std::string* _s = _internal_add_order_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
  return _s;
}
inline const std::string& OrdersHistoryRequest::order_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_order_types(index);
}
inline std::string* OrdersHistoryRequest::mutable_order_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_mutable_order_types()->Mutable(index);
}
inline void OrdersHistoryRequest::set_order_types(int index, const std::string& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, std::string&& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::set_order_types(int index, absl::string_view value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const std::string& value) {
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(std::string&& value) {
  _internal_mutable_order_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(const char* value, std::size_t size) {
  _internal_mutable_order_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline void OrdersHistoryRequest::add_order_types(absl::string_view value) {
  _internal_mutable_order_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::order_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_order_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersHistoryRequest::mutable_order_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_types)
  return _internal_mutable_order_types();
}
inline const std::string& OrdersHistoryRequest::_internal_order_types(int index) const {
  return _internal_order_types().Get(index);
}
inline std::string* OrdersHistoryRequest::_internal_add_order_types() {
  return _internal_mutable_order_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::_internal_order_types() const {
  return _impl_.order_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersHistoryRequest::_internal_mutable_order_types() {
  return &_impl_.order_types_;
}

// string direction = 6 [json_name = "direction"];
inline void OrdersHistoryRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.direction)
}
inline std::string* OrdersHistoryRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.direction)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void OrdersHistoryRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.direction)
  return _impl_.direction_.Release();
}
inline void OrdersHistoryRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.direction)
}

// sint64 start_time = 7 [json_name = "startTime"];
inline void OrdersHistoryRequest::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
}
inline ::int64_t OrdersHistoryRequest::start_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.start_time)
  return _internal_start_time();
}
inline void OrdersHistoryRequest::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.start_time)
}
inline ::int64_t OrdersHistoryRequest::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void OrdersHistoryRequest::_internal_set_start_time(::int64_t value) {
  ;
  _impl_.start_time_ = value;
}

// sint64 end_time = 8 [json_name = "endTime"];
inline void OrdersHistoryRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t OrdersHistoryRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.end_time)
  return _internal_end_time();
}
inline void OrdersHistoryRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.end_time)
}
inline ::int64_t OrdersHistoryRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void OrdersHistoryRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// string is_conditional = 9 [json_name = "isConditional"];
inline void OrdersHistoryRequest::clear_is_conditional() {
  _impl_.is_conditional_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::is_conditional() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.is_conditional)
  return _internal_is_conditional();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_is_conditional(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.is_conditional_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.is_conditional)
}
inline std::string* OrdersHistoryRequest::mutable_is_conditional() {
  std::string* _s = _internal_mutable_is_conditional();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.is_conditional)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_is_conditional() const {
  return _impl_.is_conditional_.Get();
}
inline void OrdersHistoryRequest::_internal_set_is_conditional(const std::string& value) {
  ;


  _impl_.is_conditional_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_is_conditional() {
  ;
  return _impl_.is_conditional_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_is_conditional() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.is_conditional)
  return _impl_.is_conditional_.Release();
}
inline void OrdersHistoryRequest::set_allocated_is_conditional(std::string* value) {
  _impl_.is_conditional_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.is_conditional_.IsDefault()) {
          _impl_.is_conditional_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.is_conditional)
}

// string order_type = 10 [json_name = "orderType"];
inline void OrdersHistoryRequest::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::order_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_type)
}
inline std::string* OrdersHistoryRequest::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_type)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void OrdersHistoryRequest::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_type)
  return _impl_.order_type_.Release();
}
inline void OrdersHistoryRequest::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.order_type)
}

// string state = 11 [json_name = "state"];
inline void OrdersHistoryRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& OrdersHistoryRequest::state() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrdersHistoryRequest::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.state)
}
inline std::string* OrdersHistoryRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.state)
  return _s;
}
inline const std::string& OrdersHistoryRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void OrdersHistoryRequest::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* OrdersHistoryRequest::release_state() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryRequest.state)
  return _impl_.state_.Release();
}
inline void OrdersHistoryRequest::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryRequest.state)
}

// repeated string execution_types = 12 [json_name = "executionTypes"];
inline int OrdersHistoryRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int OrdersHistoryRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void OrdersHistoryRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* OrdersHistoryRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _s;
}
inline const std::string& OrdersHistoryRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* OrdersHistoryRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void OrdersHistoryRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline void OrdersHistoryRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrdersHistoryRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& OrdersHistoryRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* OrdersHistoryRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrdersHistoryRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrdersHistoryRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// OrdersHistoryResponse

// repeated .injective_derivative_exchange_rpc.DerivativeOrderHistory orders = 1 [json_name = "orders"];
inline int OrdersHistoryResponse::_internal_orders_size() const {
  return _impl_.orders_.size();
}
inline int OrdersHistoryResponse::orders_size() const {
  return _internal_orders_size();
}
inline void OrdersHistoryResponse::clear_orders() {
  _internal_mutable_orders()->Clear();
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* OrdersHistoryResponse::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_mutable_orders()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeOrderHistory >*
OrdersHistoryResponse::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_mutable_orders();
}
inline const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& OrdersHistoryResponse::_internal_orders(int index) const {
  return _internal_orders().Get(index);
}
inline const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& OrdersHistoryResponse::orders(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_orders(index);
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* OrdersHistoryResponse::_internal_add_orders() {
  return _internal_mutable_orders()->Add();
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* OrdersHistoryResponse::add_orders() {
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* _add = _internal_add_orders();
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.OrdersHistoryResponse.orders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_derivative_exchange_rpc::DerivativeOrderHistory >&
OrdersHistoryResponse::orders() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.OrdersHistoryResponse.orders)
  return _internal_orders();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeOrderHistory>&
OrdersHistoryResponse::_internal_orders() const {
  return _impl_.orders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_derivative_exchange_rpc::DerivativeOrderHistory>*
OrdersHistoryResponse::_internal_mutable_orders() {
  return &_impl_.orders_;
}

// .injective_derivative_exchange_rpc.Paging paging = 2 [json_name = "paging"];
inline bool OrdersHistoryResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void OrdersHistoryResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::Paging& OrdersHistoryResponse::_internal_paging() const {
  const ::injective_derivative_exchange_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::Paging&>(
      ::injective_derivative_exchange_rpc::_Paging_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::Paging& OrdersHistoryResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.OrdersHistoryResponse.paging)
  return _internal_paging();
}
inline void OrdersHistoryResponse::unsafe_arena_set_allocated_paging(
    ::injective_derivative_exchange_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryResponse.paging)
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersHistoryResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersHistoryResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.OrdersHistoryResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersHistoryResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_derivative_exchange_rpc::Paging* OrdersHistoryResponse::mutable_paging() {
  ::injective_derivative_exchange_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.OrdersHistoryResponse.paging)
  return _msg;
}
inline void OrdersHistoryResponse::set_allocated_paging(::injective_derivative_exchange_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.OrdersHistoryResponse.paging)
}

// -------------------------------------------------------------------

// DerivativeOrderHistory

// string order_hash = 1 [json_name = "orderHash"];
inline void DerivativeOrderHistory::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_hash)
}
inline std::string* DerivativeOrderHistory::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_hash)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void DerivativeOrderHistory::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_hash)
  return _impl_.order_hash_.Release();
}
inline void DerivativeOrderHistory::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_hash)
}

// string market_id = 2 [json_name = "marketId"];
inline void DerivativeOrderHistory::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.market_id)
}
inline std::string* DerivativeOrderHistory::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.market_id)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void DerivativeOrderHistory::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.market_id)
  return _impl_.market_id_.Release();
}
inline void DerivativeOrderHistory::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.market_id)
}

// bool is_active = 3 [json_name = "isActive"];
inline void DerivativeOrderHistory::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool DerivativeOrderHistory::is_active() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_active)
  return _internal_is_active();
}
inline void DerivativeOrderHistory::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_active)
}
inline bool DerivativeOrderHistory::_internal_is_active() const {
  return _impl_.is_active_;
}
inline void DerivativeOrderHistory::_internal_set_is_active(bool value) {
  ;
  _impl_.is_active_ = value;
}

// string subaccount_id = 4 [json_name = "subaccountId"];
inline void DerivativeOrderHistory::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.subaccount_id)
}
inline std::string* DerivativeOrderHistory::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.subaccount_id)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void DerivativeOrderHistory::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void DerivativeOrderHistory::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.subaccount_id)
}

// string execution_type = 5 [json_name = "executionType"];
inline void DerivativeOrderHistory::clear_execution_type() {
  _impl_.execution_type_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::execution_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.execution_type)
  return _internal_execution_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_execution_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.execution_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.execution_type)
}
inline std::string* DerivativeOrderHistory::mutable_execution_type() {
  std::string* _s = _internal_mutable_execution_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.execution_type)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_execution_type() const {
  return _impl_.execution_type_.Get();
}
inline void DerivativeOrderHistory::_internal_set_execution_type(const std::string& value) {
  ;


  _impl_.execution_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_execution_type() {
  ;
  return _impl_.execution_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_execution_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.execution_type)
  return _impl_.execution_type_.Release();
}
inline void DerivativeOrderHistory::set_allocated_execution_type(std::string* value) {
  _impl_.execution_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.execution_type_.IsDefault()) {
          _impl_.execution_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.execution_type)
}

// string order_type = 6 [json_name = "orderType"];
inline void DerivativeOrderHistory::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::order_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_type)
}
inline std::string* DerivativeOrderHistory::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_type)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void DerivativeOrderHistory::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_type)
  return _impl_.order_type_.Release();
}
inline void DerivativeOrderHistory::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.order_type)
}

// string price = 7 [json_name = "price"];
inline void DerivativeOrderHistory::clear_price() {
  _impl_.price_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.price)
  return _internal_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.price)
}
inline std::string* DerivativeOrderHistory::mutable_price() {
  std::string* _s = _internal_mutable_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.price)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_price() const {
  return _impl_.price_.Get();
}
inline void DerivativeOrderHistory::_internal_set_price(const std::string& value) {
  ;


  _impl_.price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_price() {
  ;
  return _impl_.price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.price)
  return _impl_.price_.Release();
}
inline void DerivativeOrderHistory::set_allocated_price(std::string* value) {
  _impl_.price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.price_.IsDefault()) {
          _impl_.price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.price)
}

// string trigger_price = 8 [json_name = "triggerPrice"];
inline void DerivativeOrderHistory::clear_trigger_price() {
  _impl_.trigger_price_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::trigger_price() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_price)
  return _internal_trigger_price();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_trigger_price(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.trigger_price_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_price)
}
inline std::string* DerivativeOrderHistory::mutable_trigger_price() {
  std::string* _s = _internal_mutable_trigger_price();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_price)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_trigger_price() const {
  return _impl_.trigger_price_.Get();
}
inline void DerivativeOrderHistory::_internal_set_trigger_price(const std::string& value) {
  ;


  _impl_.trigger_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_trigger_price() {
  ;
  return _impl_.trigger_price_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_trigger_price() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_price)
  return _impl_.trigger_price_.Release();
}
inline void DerivativeOrderHistory::set_allocated_trigger_price(std::string* value) {
  _impl_.trigger_price_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trigger_price_.IsDefault()) {
          _impl_.trigger_price_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_price)
}

// string quantity = 9 [json_name = "quantity"];
inline void DerivativeOrderHistory::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.quantity)
  return _internal_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.quantity)
}
inline std::string* DerivativeOrderHistory::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.quantity)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void DerivativeOrderHistory::_internal_set_quantity(const std::string& value) {
  ;


  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_quantity() {
  ;
  return _impl_.quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.quantity)
  return _impl_.quantity_.Release();
}
inline void DerivativeOrderHistory::set_allocated_quantity(std::string* value) {
  _impl_.quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_.IsDefault()) {
          _impl_.quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.quantity)
}

// string filled_quantity = 10 [json_name = "filledQuantity"];
inline void DerivativeOrderHistory::clear_filled_quantity() {
  _impl_.filled_quantity_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::filled_quantity() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.filled_quantity)
  return _internal_filled_quantity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_filled_quantity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.filled_quantity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.filled_quantity)
}
inline std::string* DerivativeOrderHistory::mutable_filled_quantity() {
  std::string* _s = _internal_mutable_filled_quantity();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.filled_quantity)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_filled_quantity() const {
  return _impl_.filled_quantity_.Get();
}
inline void DerivativeOrderHistory::_internal_set_filled_quantity(const std::string& value) {
  ;


  _impl_.filled_quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_filled_quantity() {
  ;
  return _impl_.filled_quantity_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_filled_quantity() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.filled_quantity)
  return _impl_.filled_quantity_.Release();
}
inline void DerivativeOrderHistory::set_allocated_filled_quantity(std::string* value) {
  _impl_.filled_quantity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filled_quantity_.IsDefault()) {
          _impl_.filled_quantity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.filled_quantity)
}

// string state = 11 [json_name = "state"];
inline void DerivativeOrderHistory::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::state() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.state)
}
inline std::string* DerivativeOrderHistory::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.state)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_state() const {
  return _impl_.state_.Get();
}
inline void DerivativeOrderHistory::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_state() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.state)
  return _impl_.state_.Release();
}
inline void DerivativeOrderHistory::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.state)
}

// sint64 created_at = 12 [json_name = "createdAt"];
inline void DerivativeOrderHistory::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t DerivativeOrderHistory::created_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.created_at)
  return _internal_created_at();
}
inline void DerivativeOrderHistory::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.created_at)
}
inline ::int64_t DerivativeOrderHistory::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void DerivativeOrderHistory::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// sint64 updated_at = 13 [json_name = "updatedAt"];
inline void DerivativeOrderHistory::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t DerivativeOrderHistory::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.updated_at)
  return _internal_updated_at();
}
inline void DerivativeOrderHistory::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.updated_at)
}
inline ::int64_t DerivativeOrderHistory::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void DerivativeOrderHistory::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// bool is_reduce_only = 14 [json_name = "isReduceOnly"];
inline void DerivativeOrderHistory::clear_is_reduce_only() {
  _impl_.is_reduce_only_ = false;
}
inline bool DerivativeOrderHistory::is_reduce_only() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_reduce_only)
  return _internal_is_reduce_only();
}
inline void DerivativeOrderHistory::set_is_reduce_only(bool value) {
  _internal_set_is_reduce_only(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_reduce_only)
}
inline bool DerivativeOrderHistory::_internal_is_reduce_only() const {
  return _impl_.is_reduce_only_;
}
inline void DerivativeOrderHistory::_internal_set_is_reduce_only(bool value) {
  ;
  _impl_.is_reduce_only_ = value;
}

// string direction = 15 [json_name = "direction"];
inline void DerivativeOrderHistory::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.direction)
}
inline std::string* DerivativeOrderHistory::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.direction)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void DerivativeOrderHistory::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.direction)
  return _impl_.direction_.Release();
}
inline void DerivativeOrderHistory::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.direction)
}

// bool is_conditional = 16 [json_name = "isConditional"];
inline void DerivativeOrderHistory::clear_is_conditional() {
  _impl_.is_conditional_ = false;
}
inline bool DerivativeOrderHistory::is_conditional() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_conditional)
  return _internal_is_conditional();
}
inline void DerivativeOrderHistory::set_is_conditional(bool value) {
  _internal_set_is_conditional(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.is_conditional)
}
inline bool DerivativeOrderHistory::_internal_is_conditional() const {
  return _impl_.is_conditional_;
}
inline void DerivativeOrderHistory::_internal_set_is_conditional(bool value) {
  ;
  _impl_.is_conditional_ = value;
}

// uint64 trigger_at = 17 [json_name = "triggerAt"];
inline void DerivativeOrderHistory::clear_trigger_at() {
  _impl_.trigger_at_ = ::uint64_t{0u};
}
inline ::uint64_t DerivativeOrderHistory::trigger_at() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_at)
  return _internal_trigger_at();
}
inline void DerivativeOrderHistory::set_trigger_at(::uint64_t value) {
  _internal_set_trigger_at(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.trigger_at)
}
inline ::uint64_t DerivativeOrderHistory::_internal_trigger_at() const {
  return _impl_.trigger_at_;
}
inline void DerivativeOrderHistory::_internal_set_trigger_at(::uint64_t value) {
  ;
  _impl_.trigger_at_ = value;
}

// string placed_order_hash = 18 [json_name = "placedOrderHash"];
inline void DerivativeOrderHistory::clear_placed_order_hash() {
  _impl_.placed_order_hash_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::placed_order_hash() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.placed_order_hash)
  return _internal_placed_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_placed_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.placed_order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.placed_order_hash)
}
inline std::string* DerivativeOrderHistory::mutable_placed_order_hash() {
  std::string* _s = _internal_mutable_placed_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.placed_order_hash)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_placed_order_hash() const {
  return _impl_.placed_order_hash_.Get();
}
inline void DerivativeOrderHistory::_internal_set_placed_order_hash(const std::string& value) {
  ;


  _impl_.placed_order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_placed_order_hash() {
  ;
  return _impl_.placed_order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_placed_order_hash() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.placed_order_hash)
  return _impl_.placed_order_hash_.Release();
}
inline void DerivativeOrderHistory::set_allocated_placed_order_hash(std::string* value) {
  _impl_.placed_order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.placed_order_hash_.IsDefault()) {
          _impl_.placed_order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.placed_order_hash)
}

// string margin = 19 [json_name = "margin"];
inline void DerivativeOrderHistory::clear_margin() {
  _impl_.margin_.ClearToEmpty();
}
inline const std::string& DerivativeOrderHistory::margin() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.DerivativeOrderHistory.margin)
  return _internal_margin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivativeOrderHistory::set_margin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.margin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.DerivativeOrderHistory.margin)
}
inline std::string* DerivativeOrderHistory::mutable_margin() {
  std::string* _s = _internal_mutable_margin();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.DerivativeOrderHistory.margin)
  return _s;
}
inline const std::string& DerivativeOrderHistory::_internal_margin() const {
  return _impl_.margin_.Get();
}
inline void DerivativeOrderHistory::_internal_set_margin(const std::string& value) {
  ;


  _impl_.margin_.Set(value, GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::_internal_mutable_margin() {
  ;
  return _impl_.margin_.Mutable( GetArenaForAllocation());
}
inline std::string* DerivativeOrderHistory::release_margin() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.DerivativeOrderHistory.margin)
  return _impl_.margin_.Release();
}
inline void DerivativeOrderHistory::set_allocated_margin(std::string* value) {
  _impl_.margin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.margin_.IsDefault()) {
          _impl_.margin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.DerivativeOrderHistory.margin)
}

// -------------------------------------------------------------------

// StreamOrdersHistoryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void StreamOrdersHistoryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
}
inline std::string* StreamOrdersHistoryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void StreamOrdersHistoryRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.market_id)
}
inline std::string* StreamOrdersHistoryRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.market_id)
}

// repeated string order_types = 3 [json_name = "orderTypes"];
inline int StreamOrdersHistoryRequest::_internal_order_types_size() const {
  return _impl_.order_types_.size();
}
inline int StreamOrdersHistoryRequest::order_types_size() const {
  return _internal_order_types_size();
}
inline void StreamOrdersHistoryRequest::clear_order_types() {
  _internal_mutable_order_types()->Clear();
}
inline std::string* StreamOrdersHistoryRequest::add_order_types() {
  std::string* _s = _internal_add_order_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::order_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_order_types(index);
}
inline std::string* StreamOrdersHistoryRequest::mutable_order_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_mutable_order_types()->Mutable(index);
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const std::string& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, std::string&& value) {
  _internal_mutable_order_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_order_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::set_order_types(int index, absl::string_view value) {
  _internal_mutable_order_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const std::string& value) {
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(std::string&& value) {
  _internal_mutable_order_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_order_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(const char* value, std::size_t size) {
  _internal_mutable_order_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline void StreamOrdersHistoryRequest::add_order_types(absl::string_view value) {
  _internal_mutable_order_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::order_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_order_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersHistoryRequest::mutable_order_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.order_types)
  return _internal_mutable_order_types();
}
inline const std::string& StreamOrdersHistoryRequest::_internal_order_types(int index) const {
  return _internal_order_types().Get(index);
}
inline std::string* StreamOrdersHistoryRequest::_internal_add_order_types() {
  return _internal_mutable_order_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::_internal_order_types() const {
  return _impl_.order_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersHistoryRequest::_internal_mutable_order_types() {
  return &_impl_.order_types_;
}

// string direction = 4 [json_name = "direction"];
inline void StreamOrdersHistoryRequest::clear_direction() {
  _impl_.direction_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::direction() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _internal_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.direction)
}
inline std::string* StreamOrdersHistoryRequest::mutable_direction() {
  std::string* _s = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_direction() const {
  return _impl_.direction_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_direction(const std::string& value) {
  ;


  _impl_.direction_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_direction() {
  ;
  return _impl_.direction_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_direction() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.direction)
  return _impl_.direction_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_direction(std::string* value) {
  _impl_.direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.direction_.IsDefault()) {
          _impl_.direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.direction)
}

// string state = 5 [json_name = "state"];
inline void StreamOrdersHistoryRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryRequest::state() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryRequest::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.state)
}
inline std::string* StreamOrdersHistoryRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void StreamOrdersHistoryRequest::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryRequest::release_state() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.state)
  return _impl_.state_.Release();
}
inline void StreamOrdersHistoryRequest::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.state)
}

// repeated string execution_types = 6 [json_name = "executionTypes"];
inline int StreamOrdersHistoryRequest::_internal_execution_types_size() const {
  return _impl_.execution_types_.size();
}
inline int StreamOrdersHistoryRequest::execution_types_size() const {
  return _internal_execution_types_size();
}
inline void StreamOrdersHistoryRequest::clear_execution_types() {
  _internal_mutable_execution_types()->Clear();
}
inline std::string* StreamOrdersHistoryRequest::add_execution_types() {
  std::string* _s = _internal_add_execution_types();
  // @@protoc_insertion_point(field_add_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _s;
}
inline const std::string& StreamOrdersHistoryRequest::execution_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_execution_types(index);
}
inline std::string* StreamOrdersHistoryRequest::mutable_execution_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types()->Mutable(index);
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const std::string& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, std::string&& value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_execution_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::set_execution_types(int index, absl::string_view value) {
  _internal_mutable_execution_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const std::string& value) {
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(std::string&& value) {
  _internal_mutable_execution_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_execution_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(const char* value, std::size_t size) {
  _internal_mutable_execution_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline void StreamOrdersHistoryRequest::add_execution_types(absl::string_view value) {
  _internal_mutable_execution_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::execution_types() const {
  // @@protoc_insertion_point(field_list:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_execution_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamOrdersHistoryRequest::mutable_execution_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_derivative_exchange_rpc.StreamOrdersHistoryRequest.execution_types)
  return _internal_mutable_execution_types();
}
inline const std::string& StreamOrdersHistoryRequest::_internal_execution_types(int index) const {
  return _internal_execution_types().Get(index);
}
inline std::string* StreamOrdersHistoryRequest::_internal_add_execution_types() {
  return _internal_mutable_execution_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOrdersHistoryRequest::_internal_execution_types() const {
  return _impl_.execution_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOrdersHistoryRequest::_internal_mutable_execution_types() {
  return &_impl_.execution_types_;
}

// -------------------------------------------------------------------

// StreamOrdersHistoryResponse

// .injective_derivative_exchange_rpc.DerivativeOrderHistory order = 1 [json_name = "order"];
inline bool StreamOrdersHistoryResponse::has_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.order_ != nullptr);
  return value;
}
inline void StreamOrdersHistoryResponse::clear_order() {
  if (_impl_.order_ != nullptr) _impl_.order_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& StreamOrdersHistoryResponse::_internal_order() const {
  const ::injective_derivative_exchange_rpc::DerivativeOrderHistory* p = _impl_.order_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_derivative_exchange_rpc::DerivativeOrderHistory&>(
      ::injective_derivative_exchange_rpc::_DerivativeOrderHistory_default_instance_);
}
inline const ::injective_derivative_exchange_rpc::DerivativeOrderHistory& StreamOrdersHistoryResponse::order() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.order)
  return _internal_order();
}
inline void StreamOrdersHistoryResponse::unsafe_arena_set_allocated_order(
    ::injective_derivative_exchange_rpc::DerivativeOrderHistory* order) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.order_);
  }
  _impl_.order_ = order;
  if (order) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.order)
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* StreamOrdersHistoryResponse::release_order() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* temp = _impl_.order_;
  _impl_.order_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* StreamOrdersHistoryResponse::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.order)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* temp = _impl_.order_;
  _impl_.order_ = nullptr;
  return temp;
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* StreamOrdersHistoryResponse::_internal_mutable_order() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.order_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_derivative_exchange_rpc::DerivativeOrderHistory>(GetArenaForAllocation());
    _impl_.order_ = p;
  }
  return _impl_.order_;
}
inline ::injective_derivative_exchange_rpc::DerivativeOrderHistory* StreamOrdersHistoryResponse::mutable_order() {
  ::injective_derivative_exchange_rpc::DerivativeOrderHistory* _msg = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.order)
  return _msg;
}
inline void StreamOrdersHistoryResponse::set_allocated_order(::injective_derivative_exchange_rpc::DerivativeOrderHistory* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.order_ = order;
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.order)
}

// string operation_type = 2 [json_name = "operationType"];
inline void StreamOrdersHistoryResponse::clear_operation_type() {
  _impl_.operation_type_.ClearToEmpty();
}
inline const std::string& StreamOrdersHistoryResponse::operation_type() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _internal_operation_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamOrdersHistoryResponse::set_operation_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operation_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
}
inline std::string* StreamOrdersHistoryResponse::mutable_operation_type() {
  std::string* _s = _internal_mutable_operation_type();
  // @@protoc_insertion_point(field_mutable:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _s;
}
inline const std::string& StreamOrdersHistoryResponse::_internal_operation_type() const {
  return _impl_.operation_type_.Get();
}
inline void StreamOrdersHistoryResponse::_internal_set_operation_type(const std::string& value) {
  ;


  _impl_.operation_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryResponse::_internal_mutable_operation_type() {
  ;
  return _impl_.operation_type_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamOrdersHistoryResponse::release_operation_type() {
  // @@protoc_insertion_point(field_release:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
  return _impl_.operation_type_.Release();
}
inline void StreamOrdersHistoryResponse::set_allocated_operation_type(std::string* value) {
  _impl_.operation_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operation_type_.IsDefault()) {
          _impl_.operation_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.operation_type)
}

// sint64 timestamp = 3 [json_name = "timestamp"];
inline void StreamOrdersHistoryResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamOrdersHistoryResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamOrdersHistoryResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_derivative_exchange_rpc.StreamOrdersHistoryResponse.timestamp)
}
inline ::int64_t StreamOrdersHistoryResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamOrdersHistoryResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_derivative_exchange_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto_2epb_2eh
