// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_accounts_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5faccounts_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5faccounts_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5faccounts_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5faccounts_5frpc_2eproto;
namespace injective_accounts_rpc {
class AccountPortfolio;
struct AccountPortfolioDefaultTypeInternal;
extern AccountPortfolioDefaultTypeInternal _AccountPortfolio_default_instance_;
class Coin;
struct CoinDefaultTypeInternal;
extern CoinDefaultTypeInternal _Coin_default_instance_;
class CosmosCoin;
struct CosmosCoinDefaultTypeInternal;
extern CosmosCoinDefaultTypeInternal _CosmosCoin_default_instance_;
class OrderStateRecord;
struct OrderStateRecordDefaultTypeInternal;
extern OrderStateRecordDefaultTypeInternal _OrderStateRecord_default_instance_;
class OrderStatesRequest;
struct OrderStatesRequestDefaultTypeInternal;
extern OrderStatesRequestDefaultTypeInternal _OrderStatesRequest_default_instance_;
class OrderStatesResponse;
struct OrderStatesResponseDefaultTypeInternal;
extern OrderStatesResponseDefaultTypeInternal _OrderStatesResponse_default_instance_;
class Paging;
struct PagingDefaultTypeInternal;
extern PagingDefaultTypeInternal _Paging_default_instance_;
class PortfolioRequest;
struct PortfolioRequestDefaultTypeInternal;
extern PortfolioRequestDefaultTypeInternal _PortfolioRequest_default_instance_;
class PortfolioResponse;
struct PortfolioResponseDefaultTypeInternal;
extern PortfolioResponseDefaultTypeInternal _PortfolioResponse_default_instance_;
class Reward;
struct RewardDefaultTypeInternal;
extern RewardDefaultTypeInternal _Reward_default_instance_;
class RewardsRequest;
struct RewardsRequestDefaultTypeInternal;
extern RewardsRequestDefaultTypeInternal _RewardsRequest_default_instance_;
class RewardsResponse;
struct RewardsResponseDefaultTypeInternal;
extern RewardsResponseDefaultTypeInternal _RewardsResponse_default_instance_;
class StreamSubaccountBalanceRequest;
struct StreamSubaccountBalanceRequestDefaultTypeInternal;
extern StreamSubaccountBalanceRequestDefaultTypeInternal _StreamSubaccountBalanceRequest_default_instance_;
class StreamSubaccountBalanceResponse;
struct StreamSubaccountBalanceResponseDefaultTypeInternal;
extern StreamSubaccountBalanceResponseDefaultTypeInternal _StreamSubaccountBalanceResponse_default_instance_;
class SubaccountBalance;
struct SubaccountBalanceDefaultTypeInternal;
extern SubaccountBalanceDefaultTypeInternal _SubaccountBalance_default_instance_;
class SubaccountBalanceRequest;
struct SubaccountBalanceRequestDefaultTypeInternal;
extern SubaccountBalanceRequestDefaultTypeInternal _SubaccountBalanceRequest_default_instance_;
class SubaccountBalanceResponse;
struct SubaccountBalanceResponseDefaultTypeInternal;
extern SubaccountBalanceResponseDefaultTypeInternal _SubaccountBalanceResponse_default_instance_;
class SubaccountBalanceTransfer;
struct SubaccountBalanceTransferDefaultTypeInternal;
extern SubaccountBalanceTransferDefaultTypeInternal _SubaccountBalanceTransfer_default_instance_;
class SubaccountBalancesListRequest;
struct SubaccountBalancesListRequestDefaultTypeInternal;
extern SubaccountBalancesListRequestDefaultTypeInternal _SubaccountBalancesListRequest_default_instance_;
class SubaccountBalancesListResponse;
struct SubaccountBalancesListResponseDefaultTypeInternal;
extern SubaccountBalancesListResponseDefaultTypeInternal _SubaccountBalancesListResponse_default_instance_;
class SubaccountDeposit;
struct SubaccountDepositDefaultTypeInternal;
extern SubaccountDepositDefaultTypeInternal _SubaccountDeposit_default_instance_;
class SubaccountHistoryRequest;
struct SubaccountHistoryRequestDefaultTypeInternal;
extern SubaccountHistoryRequestDefaultTypeInternal _SubaccountHistoryRequest_default_instance_;
class SubaccountHistoryResponse;
struct SubaccountHistoryResponseDefaultTypeInternal;
extern SubaccountHistoryResponseDefaultTypeInternal _SubaccountHistoryResponse_default_instance_;
class SubaccountOrderSummaryRequest;
struct SubaccountOrderSummaryRequestDefaultTypeInternal;
extern SubaccountOrderSummaryRequestDefaultTypeInternal _SubaccountOrderSummaryRequest_default_instance_;
class SubaccountOrderSummaryResponse;
struct SubaccountOrderSummaryResponseDefaultTypeInternal;
extern SubaccountOrderSummaryResponseDefaultTypeInternal _SubaccountOrderSummaryResponse_default_instance_;
class SubaccountPortfolio;
struct SubaccountPortfolioDefaultTypeInternal;
extern SubaccountPortfolioDefaultTypeInternal _SubaccountPortfolio_default_instance_;
class SubaccountsListRequest;
struct SubaccountsListRequestDefaultTypeInternal;
extern SubaccountsListRequestDefaultTypeInternal _SubaccountsListRequest_default_instance_;
class SubaccountsListResponse;
struct SubaccountsListResponseDefaultTypeInternal;
extern SubaccountsListResponseDefaultTypeInternal _SubaccountsListResponse_default_instance_;
}  // namespace injective_accounts_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_accounts_rpc::AccountPortfolio* Arena::CreateMaybeMessage<::injective_accounts_rpc::AccountPortfolio>(Arena*);
template <>
::injective_accounts_rpc::Coin* Arena::CreateMaybeMessage<::injective_accounts_rpc::Coin>(Arena*);
template <>
::injective_accounts_rpc::CosmosCoin* Arena::CreateMaybeMessage<::injective_accounts_rpc::CosmosCoin>(Arena*);
template <>
::injective_accounts_rpc::OrderStateRecord* Arena::CreateMaybeMessage<::injective_accounts_rpc::OrderStateRecord>(Arena*);
template <>
::injective_accounts_rpc::OrderStatesRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::OrderStatesRequest>(Arena*);
template <>
::injective_accounts_rpc::OrderStatesResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::OrderStatesResponse>(Arena*);
template <>
::injective_accounts_rpc::Paging* Arena::CreateMaybeMessage<::injective_accounts_rpc::Paging>(Arena*);
template <>
::injective_accounts_rpc::PortfolioRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::PortfolioRequest>(Arena*);
template <>
::injective_accounts_rpc::PortfolioResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::PortfolioResponse>(Arena*);
template <>
::injective_accounts_rpc::Reward* Arena::CreateMaybeMessage<::injective_accounts_rpc::Reward>(Arena*);
template <>
::injective_accounts_rpc::RewardsRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::RewardsRequest>(Arena*);
template <>
::injective_accounts_rpc::RewardsResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::RewardsResponse>(Arena*);
template <>
::injective_accounts_rpc::StreamSubaccountBalanceRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::StreamSubaccountBalanceRequest>(Arena*);
template <>
::injective_accounts_rpc::StreamSubaccountBalanceResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::StreamSubaccountBalanceResponse>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalance* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalance>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalanceRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalanceRequest>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalanceResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalanceResponse>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalanceTransfer* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalanceTransfer>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalancesListRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalancesListRequest>(Arena*);
template <>
::injective_accounts_rpc::SubaccountBalancesListResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalancesListResponse>(Arena*);
template <>
::injective_accounts_rpc::SubaccountDeposit* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountDeposit>(Arena*);
template <>
::injective_accounts_rpc::SubaccountHistoryRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountHistoryRequest>(Arena*);
template <>
::injective_accounts_rpc::SubaccountHistoryResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountHistoryResponse>(Arena*);
template <>
::injective_accounts_rpc::SubaccountOrderSummaryRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountOrderSummaryRequest>(Arena*);
template <>
::injective_accounts_rpc::SubaccountOrderSummaryResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountOrderSummaryResponse>(Arena*);
template <>
::injective_accounts_rpc::SubaccountPortfolio* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountPortfolio>(Arena*);
template <>
::injective_accounts_rpc::SubaccountsListRequest* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountsListRequest>(Arena*);
template <>
::injective_accounts_rpc::SubaccountsListResponse* Arena::CreateMaybeMessage<::injective_accounts_rpc::SubaccountsListResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_accounts_rpc {

// ===================================================================


// -------------------------------------------------------------------

class PortfolioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.PortfolioRequest) */ {
 public:
  inline PortfolioRequest() : PortfolioRequest(nullptr) {}
  ~PortfolioRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortfolioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortfolioRequest(const PortfolioRequest& from);
  PortfolioRequest(PortfolioRequest&& from) noexcept
    : PortfolioRequest() {
    *this = ::std::move(from);
  }

  inline PortfolioRequest& operator=(const PortfolioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortfolioRequest& operator=(PortfolioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortfolioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortfolioRequest* internal_default_instance() {
    return reinterpret_cast<const PortfolioRequest*>(
               &_PortfolioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PortfolioRequest& a, PortfolioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PortfolioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortfolioRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortfolioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortfolioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortfolioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortfolioRequest& from) {
    PortfolioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortfolioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.PortfolioRequest";
  }
  protected:
  explicit PortfolioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAddressFieldNumber = 1,
  };
  // string account_address = 1 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.PortfolioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class PortfolioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.PortfolioResponse) */ {
 public:
  inline PortfolioResponse() : PortfolioResponse(nullptr) {}
  ~PortfolioResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PortfolioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortfolioResponse(const PortfolioResponse& from);
  PortfolioResponse(PortfolioResponse&& from) noexcept
    : PortfolioResponse() {
    *this = ::std::move(from);
  }

  inline PortfolioResponse& operator=(const PortfolioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortfolioResponse& operator=(PortfolioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortfolioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortfolioResponse* internal_default_instance() {
    return reinterpret_cast<const PortfolioResponse*>(
               &_PortfolioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PortfolioResponse& a, PortfolioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PortfolioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortfolioResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortfolioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortfolioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortfolioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PortfolioResponse& from) {
    PortfolioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortfolioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.PortfolioResponse";
  }
  protected:
  explicit PortfolioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortfolioFieldNumber = 1,
  };
  // .injective_accounts_rpc.AccountPortfolio portfolio = 1 [json_name = "portfolio"];
  bool has_portfolio() const;
  void clear_portfolio() ;
  const ::injective_accounts_rpc::AccountPortfolio& portfolio() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::AccountPortfolio* release_portfolio();
  ::injective_accounts_rpc::AccountPortfolio* mutable_portfolio();
  void set_allocated_portfolio(::injective_accounts_rpc::AccountPortfolio* portfolio);
  private:
  const ::injective_accounts_rpc::AccountPortfolio& _internal_portfolio() const;
  ::injective_accounts_rpc::AccountPortfolio* _internal_mutable_portfolio();
  public:
  void unsafe_arena_set_allocated_portfolio(
      ::injective_accounts_rpc::AccountPortfolio* portfolio);
  ::injective_accounts_rpc::AccountPortfolio* unsafe_arena_release_portfolio();
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.PortfolioResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_accounts_rpc::AccountPortfolio* portfolio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class AccountPortfolio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.AccountPortfolio) */ {
 public:
  inline AccountPortfolio() : AccountPortfolio(nullptr) {}
  ~AccountPortfolio() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AccountPortfolio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountPortfolio(const AccountPortfolio& from);
  AccountPortfolio(AccountPortfolio&& from) noexcept
    : AccountPortfolio() {
    *this = ::std::move(from);
  }

  inline AccountPortfolio& operator=(const AccountPortfolio& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountPortfolio& operator=(AccountPortfolio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountPortfolio& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountPortfolio* internal_default_instance() {
    return reinterpret_cast<const AccountPortfolio*>(
               &_AccountPortfolio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AccountPortfolio& a, AccountPortfolio& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountPortfolio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountPortfolio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountPortfolio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountPortfolio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountPortfolio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountPortfolio& from) {
    AccountPortfolio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountPortfolio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.AccountPortfolio";
  }
  protected:
  explicit AccountPortfolio(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountsFieldNumber = 5,
    kPortfolioValueFieldNumber = 1,
    kAvailableBalanceFieldNumber = 2,
    kLockedBalanceFieldNumber = 3,
    kUnrealizedPnlFieldNumber = 4,
  };
  // repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5 [json_name = "subaccounts"];
  int subaccounts_size() const;
  private:
  int _internal_subaccounts_size() const;

  public:
  void clear_subaccounts() ;
  ::injective_accounts_rpc::SubaccountPortfolio* mutable_subaccounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountPortfolio >*
      mutable_subaccounts();
  private:
  const ::injective_accounts_rpc::SubaccountPortfolio& _internal_subaccounts(int index) const;
  ::injective_accounts_rpc::SubaccountPortfolio* _internal_add_subaccounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountPortfolio>& _internal_subaccounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountPortfolio>* _internal_mutable_subaccounts();
  public:
  const ::injective_accounts_rpc::SubaccountPortfolio& subaccounts(int index) const;
  ::injective_accounts_rpc::SubaccountPortfolio* add_subaccounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountPortfolio >&
      subaccounts() const;
  // string portfolio_value = 1 [json_name = "portfolioValue"];
  void clear_portfolio_value() ;
  const std::string& portfolio_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_portfolio_value(Arg_&& arg, Args_... args);
  std::string* mutable_portfolio_value();
  PROTOBUF_NODISCARD std::string* release_portfolio_value();
  void set_allocated_portfolio_value(std::string* ptr);

  private:
  const std::string& _internal_portfolio_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_portfolio_value(
      const std::string& value);
  std::string* _internal_mutable_portfolio_value();

  public:
  // string available_balance = 2 [json_name = "availableBalance"];
  void clear_available_balance() ;
  const std::string& available_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available_balance(Arg_&& arg, Args_... args);
  std::string* mutable_available_balance();
  PROTOBUF_NODISCARD std::string* release_available_balance();
  void set_allocated_available_balance(std::string* ptr);

  private:
  const std::string& _internal_available_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_balance(
      const std::string& value);
  std::string* _internal_mutable_available_balance();

  public:
  // string locked_balance = 3 [json_name = "lockedBalance"];
  void clear_locked_balance() ;
  const std::string& locked_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locked_balance(Arg_&& arg, Args_... args);
  std::string* mutable_locked_balance();
  PROTOBUF_NODISCARD std::string* release_locked_balance();
  void set_allocated_locked_balance(std::string* ptr);

  private:
  const std::string& _internal_locked_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locked_balance(
      const std::string& value);
  std::string* _internal_mutable_locked_balance();

  public:
  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  void clear_unrealized_pnl() ;
  const std::string& unrealized_pnl() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unrealized_pnl(Arg_&& arg, Args_... args);
  std::string* mutable_unrealized_pnl();
  PROTOBUF_NODISCARD std::string* release_unrealized_pnl();
  void set_allocated_unrealized_pnl(std::string* ptr);

  private:
  const std::string& _internal_unrealized_pnl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unrealized_pnl(
      const std::string& value);
  std::string* _internal_mutable_unrealized_pnl();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.AccountPortfolio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountPortfolio > subaccounts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr portfolio_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locked_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unrealized_pnl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountPortfolio final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountPortfolio) */ {
 public:
  inline SubaccountPortfolio() : SubaccountPortfolio(nullptr) {}
  ~SubaccountPortfolio() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountPortfolio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountPortfolio(const SubaccountPortfolio& from);
  SubaccountPortfolio(SubaccountPortfolio&& from) noexcept
    : SubaccountPortfolio() {
    *this = ::std::move(from);
  }

  inline SubaccountPortfolio& operator=(const SubaccountPortfolio& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountPortfolio& operator=(SubaccountPortfolio&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountPortfolio& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountPortfolio* internal_default_instance() {
    return reinterpret_cast<const SubaccountPortfolio*>(
               &_SubaccountPortfolio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SubaccountPortfolio& a, SubaccountPortfolio& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountPortfolio* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountPortfolio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountPortfolio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountPortfolio>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountPortfolio& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountPortfolio& from) {
    SubaccountPortfolio::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountPortfolio* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountPortfolio";
  }
  protected:
  explicit SubaccountPortfolio(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kAvailableBalanceFieldNumber = 2,
    kLockedBalanceFieldNumber = 3,
    kUnrealizedPnlFieldNumber = 4,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string available_balance = 2 [json_name = "availableBalance"];
  void clear_available_balance() ;
  const std::string& available_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available_balance(Arg_&& arg, Args_... args);
  std::string* mutable_available_balance();
  PROTOBUF_NODISCARD std::string* release_available_balance();
  void set_allocated_available_balance(std::string* ptr);

  private:
  const std::string& _internal_available_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_balance(
      const std::string& value);
  std::string* _internal_mutable_available_balance();

  public:
  // string locked_balance = 3 [json_name = "lockedBalance"];
  void clear_locked_balance() ;
  const std::string& locked_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_locked_balance(Arg_&& arg, Args_... args);
  std::string* mutable_locked_balance();
  PROTOBUF_NODISCARD std::string* release_locked_balance();
  void set_allocated_locked_balance(std::string* ptr);

  private:
  const std::string& _internal_locked_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locked_balance(
      const std::string& value);
  std::string* _internal_mutable_locked_balance();

  public:
  // string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
  void clear_unrealized_pnl() ;
  const std::string& unrealized_pnl() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unrealized_pnl(Arg_&& arg, Args_... args);
  std::string* mutable_unrealized_pnl();
  PROTOBUF_NODISCARD std::string* release_unrealized_pnl();
  void set_allocated_unrealized_pnl(std::string* ptr);

  private:
  const std::string& _internal_unrealized_pnl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unrealized_pnl(
      const std::string& value);
  std::string* _internal_mutable_unrealized_pnl();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountPortfolio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locked_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unrealized_pnl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderStatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.OrderStatesRequest) */ {
 public:
  inline OrderStatesRequest() : OrderStatesRequest(nullptr) {}
  ~OrderStatesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderStatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderStatesRequest(const OrderStatesRequest& from);
  OrderStatesRequest(OrderStatesRequest&& from) noexcept
    : OrderStatesRequest() {
    *this = ::std::move(from);
  }

  inline OrderStatesRequest& operator=(const OrderStatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStatesRequest& operator=(OrderStatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderStatesRequest* internal_default_instance() {
    return reinterpret_cast<const OrderStatesRequest*>(
               &_OrderStatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OrderStatesRequest& a, OrderStatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderStatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderStatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderStatesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderStatesRequest& from) {
    OrderStatesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderStatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.OrderStatesRequest";
  }
  protected:
  explicit OrderStatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotOrderHashesFieldNumber = 1,
    kDerivativeOrderHashesFieldNumber = 2,
  };
  // repeated string spot_order_hashes = 1 [json_name = "spotOrderHashes"];
  int spot_order_hashes_size() const;
  private:
  int _internal_spot_order_hashes_size() const;

  public:
  void clear_spot_order_hashes() ;
  const std::string& spot_order_hashes(int index) const;
  std::string* mutable_spot_order_hashes(int index);
  void set_spot_order_hashes(int index, const std::string& value);
  void set_spot_order_hashes(int index, std::string&& value);
  void set_spot_order_hashes(int index, const char* value);
  void set_spot_order_hashes(int index, const char* value, std::size_t size);
  void set_spot_order_hashes(int index, absl::string_view value);
  std::string* add_spot_order_hashes();
  void add_spot_order_hashes(const std::string& value);
  void add_spot_order_hashes(std::string&& value);
  void add_spot_order_hashes(const char* value);
  void add_spot_order_hashes(const char* value, std::size_t size);
  void add_spot_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& spot_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_spot_order_hashes();

  private:
  const std::string& _internal_spot_order_hashes(int index) const;
  std::string* _internal_add_spot_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_spot_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_spot_order_hashes();

  public:
  // repeated string derivative_order_hashes = 2 [json_name = "derivativeOrderHashes"];
  int derivative_order_hashes_size() const;
  private:
  int _internal_derivative_order_hashes_size() const;

  public:
  void clear_derivative_order_hashes() ;
  const std::string& derivative_order_hashes(int index) const;
  std::string* mutable_derivative_order_hashes(int index);
  void set_derivative_order_hashes(int index, const std::string& value);
  void set_derivative_order_hashes(int index, std::string&& value);
  void set_derivative_order_hashes(int index, const char* value);
  void set_derivative_order_hashes(int index, const char* value, std::size_t size);
  void set_derivative_order_hashes(int index, absl::string_view value);
  std::string* add_derivative_order_hashes();
  void add_derivative_order_hashes(const std::string& value);
  void add_derivative_order_hashes(std::string&& value);
  void add_derivative_order_hashes(const char* value);
  void add_derivative_order_hashes(const char* value, std::size_t size);
  void add_derivative_order_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& derivative_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_derivative_order_hashes();

  private:
  const std::string& _internal_derivative_order_hashes(int index) const;
  std::string* _internal_add_derivative_order_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_derivative_order_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_derivative_order_hashes();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.OrderStatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> spot_order_hashes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> derivative_order_hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderStatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.OrderStatesResponse) */ {
 public:
  inline OrderStatesResponse() : OrderStatesResponse(nullptr) {}
  ~OrderStatesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderStatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderStatesResponse(const OrderStatesResponse& from);
  OrderStatesResponse(OrderStatesResponse&& from) noexcept
    : OrderStatesResponse() {
    *this = ::std::move(from);
  }

  inline OrderStatesResponse& operator=(const OrderStatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStatesResponse& operator=(OrderStatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderStatesResponse* internal_default_instance() {
    return reinterpret_cast<const OrderStatesResponse*>(
               &_OrderStatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OrderStatesResponse& a, OrderStatesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderStatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStatesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderStatesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderStatesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderStatesResponse& from) {
    OrderStatesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderStatesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.OrderStatesResponse";
  }
  protected:
  explicit OrderStatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotOrderStatesFieldNumber = 1,
    kDerivativeOrderStatesFieldNumber = 2,
  };
  // repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1 [json_name = "spotOrderStates"];
  int spot_order_states_size() const;
  private:
  int _internal_spot_order_states_size() const;

  public:
  void clear_spot_order_states() ;
  ::injective_accounts_rpc::OrderStateRecord* mutable_spot_order_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >*
      mutable_spot_order_states();
  private:
  const ::injective_accounts_rpc::OrderStateRecord& _internal_spot_order_states(int index) const;
  ::injective_accounts_rpc::OrderStateRecord* _internal_add_spot_order_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>& _internal_spot_order_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>* _internal_mutable_spot_order_states();
  public:
  const ::injective_accounts_rpc::OrderStateRecord& spot_order_states(int index) const;
  ::injective_accounts_rpc::OrderStateRecord* add_spot_order_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >&
      spot_order_states() const;
  // repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2 [json_name = "derivativeOrderStates"];
  int derivative_order_states_size() const;
  private:
  int _internal_derivative_order_states_size() const;

  public:
  void clear_derivative_order_states() ;
  ::injective_accounts_rpc::OrderStateRecord* mutable_derivative_order_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >*
      mutable_derivative_order_states();
  private:
  const ::injective_accounts_rpc::OrderStateRecord& _internal_derivative_order_states(int index) const;
  ::injective_accounts_rpc::OrderStateRecord* _internal_add_derivative_order_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>& _internal_derivative_order_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>* _internal_mutable_derivative_order_states();
  public:
  const ::injective_accounts_rpc::OrderStateRecord& derivative_order_states(int index) const;
  ::injective_accounts_rpc::OrderStateRecord* add_derivative_order_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >&
      derivative_order_states() const;
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.OrderStatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord > spot_order_states_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord > derivative_order_states_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class OrderStateRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.OrderStateRecord) */ {
 public:
  inline OrderStateRecord() : OrderStateRecord(nullptr) {}
  ~OrderStateRecord() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrderStateRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderStateRecord(const OrderStateRecord& from);
  OrderStateRecord(OrderStateRecord&& from) noexcept
    : OrderStateRecord() {
    *this = ::std::move(from);
  }

  inline OrderStateRecord& operator=(const OrderStateRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStateRecord& operator=(OrderStateRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStateRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderStateRecord* internal_default_instance() {
    return reinterpret_cast<const OrderStateRecord*>(
               &_OrderStateRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OrderStateRecord& a, OrderStateRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderStateRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStateRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStateRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderStateRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderStateRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderStateRecord& from) {
    OrderStateRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderStateRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.OrderStateRecord";
  }
  protected:
  explicit OrderStateRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderHashFieldNumber = 1,
    kSubaccountIdFieldNumber = 2,
    kMarketIdFieldNumber = 3,
    kOrderTypeFieldNumber = 4,
    kOrderSideFieldNumber = 5,
    kStateFieldNumber = 6,
    kQuantityFilledFieldNumber = 7,
    kQuantityRemainingFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kUpdatedAtFieldNumber = 10,
  };
  // string order_hash = 1 [json_name = "orderHash"];
  void clear_order_hash() ;
  const std::string& order_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_hash(Arg_&& arg, Args_... args);
  std::string* mutable_order_hash();
  PROTOBUF_NODISCARD std::string* release_order_hash();
  void set_allocated_order_hash(std::string* ptr);

  private:
  const std::string& _internal_order_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_hash(
      const std::string& value);
  std::string* _internal_mutable_order_hash();

  public:
  // string subaccount_id = 2 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 3 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_type = 4 [json_name = "orderType"];
  void clear_order_type() ;
  const std::string& order_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  std::string* mutable_order_type();
  PROTOBUF_NODISCARD std::string* release_order_type();
  void set_allocated_order_type(std::string* ptr);

  private:
  const std::string& _internal_order_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(
      const std::string& value);
  std::string* _internal_mutable_order_type();

  public:
  // string order_side = 5 [json_name = "orderSide"];
  void clear_order_side() ;
  const std::string& order_side() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_side(Arg_&& arg, Args_... args);
  std::string* mutable_order_side();
  PROTOBUF_NODISCARD std::string* release_order_side();
  void set_allocated_order_side(std::string* ptr);

  private:
  const std::string& _internal_order_side() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_side(
      const std::string& value);
  std::string* _internal_mutable_order_side();

  public:
  // string state = 6 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string quantity_filled = 7 [json_name = "quantityFilled"];
  void clear_quantity_filled() ;
  const std::string& quantity_filled() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity_filled(Arg_&& arg, Args_... args);
  std::string* mutable_quantity_filled();
  PROTOBUF_NODISCARD std::string* release_quantity_filled();
  void set_allocated_quantity_filled(std::string* ptr);

  private:
  const std::string& _internal_quantity_filled() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity_filled(
      const std::string& value);
  std::string* _internal_mutable_quantity_filled();

  public:
  // string quantity_remaining = 8 [json_name = "quantityRemaining"];
  void clear_quantity_remaining() ;
  const std::string& quantity_remaining() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quantity_remaining(Arg_&& arg, Args_... args);
  std::string* mutable_quantity_remaining();
  PROTOBUF_NODISCARD std::string* release_quantity_remaining();
  void set_allocated_quantity_remaining(std::string* ptr);

  private:
  const std::string& _internal_quantity_remaining() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity_remaining(
      const std::string& value);
  std::string* _internal_mutable_quantity_remaining();

  public:
  // sint64 created_at = 9 [json_name = "createdAt"];
  void clear_created_at() ;
  ::int64_t created_at() const;
  void set_created_at(::int64_t value);

  private:
  ::int64_t _internal_created_at() const;
  void _internal_set_created_at(::int64_t value);

  public:
  // sint64 updated_at = 10 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.OrderStateRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_side_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_filled_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_remaining_;
    ::int64_t created_at_;
    ::int64_t updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountsListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountsListRequest) */ {
 public:
  inline SubaccountsListRequest() : SubaccountsListRequest(nullptr) {}
  ~SubaccountsListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountsListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountsListRequest(const SubaccountsListRequest& from);
  SubaccountsListRequest(SubaccountsListRequest&& from) noexcept
    : SubaccountsListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountsListRequest& operator=(const SubaccountsListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountsListRequest& operator=(SubaccountsListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountsListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountsListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountsListRequest*>(
               &_SubaccountsListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubaccountsListRequest& a, SubaccountsListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountsListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountsListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountsListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountsListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountsListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountsListRequest& from) {
    SubaccountsListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountsListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountsListRequest";
  }
  protected:
  explicit SubaccountsListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAddressFieldNumber = 1,
  };
  // string account_address = 1 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountsListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountsListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountsListResponse) */ {
 public:
  inline SubaccountsListResponse() : SubaccountsListResponse(nullptr) {}
  ~SubaccountsListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountsListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountsListResponse(const SubaccountsListResponse& from);
  SubaccountsListResponse(SubaccountsListResponse&& from) noexcept
    : SubaccountsListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountsListResponse& operator=(const SubaccountsListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountsListResponse& operator=(SubaccountsListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountsListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountsListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountsListResponse*>(
               &_SubaccountsListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SubaccountsListResponse& a, SubaccountsListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountsListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountsListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountsListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountsListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountsListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountsListResponse& from) {
    SubaccountsListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountsListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountsListResponse";
  }
  protected:
  explicit SubaccountsListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountsFieldNumber = 1,
  };
  // repeated string subaccounts = 1 [json_name = "subaccounts"];
  int subaccounts_size() const;
  private:
  int _internal_subaccounts_size() const;

  public:
  void clear_subaccounts() ;
  const std::string& subaccounts(int index) const;
  std::string* mutable_subaccounts(int index);
  void set_subaccounts(int index, const std::string& value);
  void set_subaccounts(int index, std::string&& value);
  void set_subaccounts(int index, const char* value);
  void set_subaccounts(int index, const char* value, std::size_t size);
  void set_subaccounts(int index, absl::string_view value);
  std::string* add_subaccounts();
  void add_subaccounts(const std::string& value);
  void add_subaccounts(std::string&& value);
  void add_subaccounts(const char* value);
  void add_subaccounts(const char* value, std::size_t size);
  void add_subaccounts(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subaccounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subaccounts();

  private:
  const std::string& _internal_subaccounts(int index) const;
  std::string* _internal_add_subaccounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_subaccounts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_subaccounts();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountsListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subaccounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalancesListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalancesListRequest) */ {
 public:
  inline SubaccountBalancesListRequest() : SubaccountBalancesListRequest(nullptr) {}
  ~SubaccountBalancesListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalancesListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalancesListRequest(const SubaccountBalancesListRequest& from);
  SubaccountBalancesListRequest(SubaccountBalancesListRequest&& from) noexcept
    : SubaccountBalancesListRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountBalancesListRequest& operator=(const SubaccountBalancesListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalancesListRequest& operator=(SubaccountBalancesListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalancesListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalancesListRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalancesListRequest*>(
               &_SubaccountBalancesListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SubaccountBalancesListRequest& a, SubaccountBalancesListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalancesListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalancesListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalancesListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalancesListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalancesListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalancesListRequest& from) {
    SubaccountBalancesListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalancesListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalancesListRequest";
  }
  protected:
  explicit SubaccountBalancesListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomsFieldNumber = 2,
    kSubaccountIdFieldNumber = 1,
  };
  // repeated string denoms = 2 [json_name = "denoms"];
  int denoms_size() const;
  private:
  int _internal_denoms_size() const;

  public:
  void clear_denoms() ;
  const std::string& denoms(int index) const;
  std::string* mutable_denoms(int index);
  void set_denoms(int index, const std::string& value);
  void set_denoms(int index, std::string&& value);
  void set_denoms(int index, const char* value);
  void set_denoms(int index, const char* value, std::size_t size);
  void set_denoms(int index, absl::string_view value);
  std::string* add_denoms();
  void add_denoms(const std::string& value);
  void add_denoms(std::string&& value);
  void add_denoms(const char* value);
  void add_denoms(const char* value, std::size_t size);
  void add_denoms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_denoms();

  private:
  const std::string& _internal_denoms(int index) const;
  std::string* _internal_add_denoms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_denoms();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalancesListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> denoms_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalancesListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalancesListResponse) */ {
 public:
  inline SubaccountBalancesListResponse() : SubaccountBalancesListResponse(nullptr) {}
  ~SubaccountBalancesListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalancesListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalancesListResponse(const SubaccountBalancesListResponse& from);
  SubaccountBalancesListResponse(SubaccountBalancesListResponse&& from) noexcept
    : SubaccountBalancesListResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountBalancesListResponse& operator=(const SubaccountBalancesListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalancesListResponse& operator=(SubaccountBalancesListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalancesListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalancesListResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalancesListResponse*>(
               &_SubaccountBalancesListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubaccountBalancesListResponse& a, SubaccountBalancesListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalancesListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalancesListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalancesListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalancesListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalancesListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalancesListResponse& from) {
    SubaccountBalancesListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalancesListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalancesListResponse";
  }
  protected:
  explicit SubaccountBalancesListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalancesFieldNumber = 1,
  };
  // repeated .injective_accounts_rpc.SubaccountBalance balances = 1 [json_name = "balances"];
  int balances_size() const;
  private:
  int _internal_balances_size() const;

  public:
  void clear_balances() ;
  ::injective_accounts_rpc::SubaccountBalance* mutable_balances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalance >*
      mutable_balances();
  private:
  const ::injective_accounts_rpc::SubaccountBalance& _internal_balances(int index) const;
  ::injective_accounts_rpc::SubaccountBalance* _internal_add_balances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalance>& _internal_balances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalance>* _internal_mutable_balances();
  public:
  const ::injective_accounts_rpc::SubaccountBalance& balances(int index) const;
  ::injective_accounts_rpc::SubaccountBalance* add_balances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalance >&
      balances() const;
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalancesListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalance > balances_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalance) */ {
 public:
  inline SubaccountBalance() : SubaccountBalance(nullptr) {}
  ~SubaccountBalance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalance(const SubaccountBalance& from);
  SubaccountBalance(SubaccountBalance&& from) noexcept
    : SubaccountBalance() {
    *this = ::std::move(from);
  }

  inline SubaccountBalance& operator=(const SubaccountBalance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalance& operator=(SubaccountBalance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalance* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalance*>(
               &_SubaccountBalance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubaccountBalance& a, SubaccountBalance& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalance& from) {
    SubaccountBalance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalance";
  }
  protected:
  explicit SubaccountBalance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kAccountAddressFieldNumber = 2,
    kDenomFieldNumber = 3,
    kDepositFieldNumber = 4,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string account_address = 2 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // string denom = 3 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // .injective_accounts_rpc.SubaccountDeposit deposit = 4 [json_name = "deposit"];
  bool has_deposit() const;
  void clear_deposit() ;
  const ::injective_accounts_rpc::SubaccountDeposit& deposit() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::SubaccountDeposit* release_deposit();
  ::injective_accounts_rpc::SubaccountDeposit* mutable_deposit();
  void set_allocated_deposit(::injective_accounts_rpc::SubaccountDeposit* deposit);
  private:
  const ::injective_accounts_rpc::SubaccountDeposit& _internal_deposit() const;
  ::injective_accounts_rpc::SubaccountDeposit* _internal_mutable_deposit();
  public:
  void unsafe_arena_set_allocated_deposit(
      ::injective_accounts_rpc::SubaccountDeposit* deposit);
  ::injective_accounts_rpc::SubaccountDeposit* unsafe_arena_release_deposit();
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::injective_accounts_rpc::SubaccountDeposit* deposit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountDeposit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountDeposit) */ {
 public:
  inline SubaccountDeposit() : SubaccountDeposit(nullptr) {}
  ~SubaccountDeposit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountDeposit(const SubaccountDeposit& from);
  SubaccountDeposit(SubaccountDeposit&& from) noexcept
    : SubaccountDeposit() {
    *this = ::std::move(from);
  }

  inline SubaccountDeposit& operator=(const SubaccountDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountDeposit& operator=(SubaccountDeposit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountDeposit& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountDeposit* internal_default_instance() {
    return reinterpret_cast<const SubaccountDeposit*>(
               &_SubaccountDeposit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubaccountDeposit& a, SubaccountDeposit& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountDeposit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountDeposit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountDeposit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountDeposit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountDeposit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountDeposit& from) {
    SubaccountDeposit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountDeposit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountDeposit";
  }
  protected:
  explicit SubaccountDeposit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalBalanceFieldNumber = 1,
    kAvailableBalanceFieldNumber = 2,
  };
  // string total_balance = 1 [json_name = "totalBalance"];
  void clear_total_balance() ;
  const std::string& total_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_balance(Arg_&& arg, Args_... args);
  std::string* mutable_total_balance();
  PROTOBUF_NODISCARD std::string* release_total_balance();
  void set_allocated_total_balance(std::string* ptr);

  private:
  const std::string& _internal_total_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_balance(
      const std::string& value);
  std::string* _internal_mutable_total_balance();

  public:
  // string available_balance = 2 [json_name = "availableBalance"];
  void clear_available_balance() ;
  const std::string& available_balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_available_balance(Arg_&& arg, Args_... args);
  std::string* mutable_available_balance();
  PROTOBUF_NODISCARD std::string* release_available_balance();
  void set_allocated_available_balance(std::string* ptr);

  private:
  const std::string& _internal_available_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_balance(
      const std::string& value);
  std::string* _internal_mutable_available_balance();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountDeposit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_balance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalanceRequest) */ {
 public:
  inline SubaccountBalanceRequest() : SubaccountBalanceRequest(nullptr) {}
  ~SubaccountBalanceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalanceRequest(const SubaccountBalanceRequest& from);
  SubaccountBalanceRequest(SubaccountBalanceRequest&& from) noexcept
    : SubaccountBalanceRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountBalanceRequest& operator=(const SubaccountBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalanceRequest& operator=(SubaccountBalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalanceRequest*>(
               &_SubaccountBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SubaccountBalanceRequest& a, SubaccountBalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalanceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalanceRequest& from) {
    SubaccountBalanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalanceRequest";
  }
  protected:
  explicit SubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kDenomFieldNumber = 2,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string denom = 2 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalanceResponse) */ {
 public:
  inline SubaccountBalanceResponse() : SubaccountBalanceResponse(nullptr) {}
  ~SubaccountBalanceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalanceResponse(const SubaccountBalanceResponse& from);
  SubaccountBalanceResponse(SubaccountBalanceResponse&& from) noexcept
    : SubaccountBalanceResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountBalanceResponse& operator=(const SubaccountBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalanceResponse& operator=(SubaccountBalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalanceResponse*>(
               &_SubaccountBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SubaccountBalanceResponse& a, SubaccountBalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalanceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalanceResponse& from) {
    SubaccountBalanceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalanceResponse";
  }
  protected:
  explicit SubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 1,
  };
  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  bool has_balance() const;
  void clear_balance() ;
  const ::injective_accounts_rpc::SubaccountBalance& balance() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::SubaccountBalance* release_balance();
  ::injective_accounts_rpc::SubaccountBalance* mutable_balance();
  void set_allocated_balance(::injective_accounts_rpc::SubaccountBalance* balance);
  private:
  const ::injective_accounts_rpc::SubaccountBalance& _internal_balance() const;
  ::injective_accounts_rpc::SubaccountBalance* _internal_mutable_balance();
  public:
  void unsafe_arena_set_allocated_balance(
      ::injective_accounts_rpc::SubaccountBalance* balance);
  ::injective_accounts_rpc::SubaccountBalance* unsafe_arena_release_balance();
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_accounts_rpc::SubaccountBalance* balance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamSubaccountBalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.StreamSubaccountBalanceRequest) */ {
 public:
  inline StreamSubaccountBalanceRequest() : StreamSubaccountBalanceRequest(nullptr) {}
  ~StreamSubaccountBalanceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamSubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamSubaccountBalanceRequest(const StreamSubaccountBalanceRequest& from);
  StreamSubaccountBalanceRequest(StreamSubaccountBalanceRequest&& from) noexcept
    : StreamSubaccountBalanceRequest() {
    *this = ::std::move(from);
  }

  inline StreamSubaccountBalanceRequest& operator=(const StreamSubaccountBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamSubaccountBalanceRequest& operator=(StreamSubaccountBalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamSubaccountBalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamSubaccountBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const StreamSubaccountBalanceRequest*>(
               &_StreamSubaccountBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StreamSubaccountBalanceRequest& a, StreamSubaccountBalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamSubaccountBalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamSubaccountBalanceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamSubaccountBalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamSubaccountBalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamSubaccountBalanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamSubaccountBalanceRequest& from) {
    StreamSubaccountBalanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamSubaccountBalanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.StreamSubaccountBalanceRequest";
  }
  protected:
  explicit StreamSubaccountBalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomsFieldNumber = 2,
    kSubaccountIdFieldNumber = 1,
  };
  // repeated string denoms = 2 [json_name = "denoms"];
  int denoms_size() const;
  private:
  int _internal_denoms_size() const;

  public:
  void clear_denoms() ;
  const std::string& denoms(int index) const;
  std::string* mutable_denoms(int index);
  void set_denoms(int index, const std::string& value);
  void set_denoms(int index, std::string&& value);
  void set_denoms(int index, const char* value);
  void set_denoms(int index, const char* value, std::size_t size);
  void set_denoms(int index, absl::string_view value);
  std::string* add_denoms();
  void add_denoms(const std::string& value);
  void add_denoms(std::string&& value);
  void add_denoms(const char* value);
  void add_denoms(const char* value, std::size_t size);
  void add_denoms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_denoms();

  private:
  const std::string& _internal_denoms(int index) const;
  std::string* _internal_add_denoms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_denoms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_denoms();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.StreamSubaccountBalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> denoms_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamSubaccountBalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.StreamSubaccountBalanceResponse) */ {
 public:
  inline StreamSubaccountBalanceResponse() : StreamSubaccountBalanceResponse(nullptr) {}
  ~StreamSubaccountBalanceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamSubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamSubaccountBalanceResponse(const StreamSubaccountBalanceResponse& from);
  StreamSubaccountBalanceResponse(StreamSubaccountBalanceResponse&& from) noexcept
    : StreamSubaccountBalanceResponse() {
    *this = ::std::move(from);
  }

  inline StreamSubaccountBalanceResponse& operator=(const StreamSubaccountBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamSubaccountBalanceResponse& operator=(StreamSubaccountBalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamSubaccountBalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamSubaccountBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const StreamSubaccountBalanceResponse*>(
               &_StreamSubaccountBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StreamSubaccountBalanceResponse& a, StreamSubaccountBalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamSubaccountBalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamSubaccountBalanceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamSubaccountBalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamSubaccountBalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamSubaccountBalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamSubaccountBalanceResponse& from) {
    StreamSubaccountBalanceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamSubaccountBalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.StreamSubaccountBalanceResponse";
  }
  protected:
  explicit StreamSubaccountBalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalanceFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
  bool has_balance() const;
  void clear_balance() ;
  const ::injective_accounts_rpc::SubaccountBalance& balance() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::SubaccountBalance* release_balance();
  ::injective_accounts_rpc::SubaccountBalance* mutable_balance();
  void set_allocated_balance(::injective_accounts_rpc::SubaccountBalance* balance);
  private:
  const ::injective_accounts_rpc::SubaccountBalance& _internal_balance() const;
  ::injective_accounts_rpc::SubaccountBalance* _internal_mutable_balance();
  public:
  void unsafe_arena_set_allocated_balance(
      ::injective_accounts_rpc::SubaccountBalance* balance);
  ::injective_accounts_rpc::SubaccountBalance* unsafe_arena_release_balance();
  // sint64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp() ;
  ::int64_t timestamp() const;
  void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.StreamSubaccountBalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_accounts_rpc::SubaccountBalance* balance_;
    ::int64_t timestamp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountHistoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountHistoryRequest) */ {
 public:
  inline SubaccountHistoryRequest() : SubaccountHistoryRequest(nullptr) {}
  ~SubaccountHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountHistoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountHistoryRequest(const SubaccountHistoryRequest& from);
  SubaccountHistoryRequest(SubaccountHistoryRequest&& from) noexcept
    : SubaccountHistoryRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountHistoryRequest& operator=(const SubaccountHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountHistoryRequest& operator=(SubaccountHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountHistoryRequest*>(
               &_SubaccountHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SubaccountHistoryRequest& a, SubaccountHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountHistoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountHistoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountHistoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountHistoryRequest& from) {
    SubaccountHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountHistoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountHistoryRequest";
  }
  protected:
  explicit SubaccountHistoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransferTypesFieldNumber = 3,
    kSubaccountIdFieldNumber = 1,
    kDenomFieldNumber = 2,
    kSkipFieldNumber = 4,
    kEndTimeFieldNumber = 6,
    kLimitFieldNumber = 5,
  };
  // repeated string transfer_types = 3 [json_name = "transferTypes"];
  int transfer_types_size() const;
  private:
  int _internal_transfer_types_size() const;

  public:
  void clear_transfer_types() ;
  const std::string& transfer_types(int index) const;
  std::string* mutable_transfer_types(int index);
  void set_transfer_types(int index, const std::string& value);
  void set_transfer_types(int index, std::string&& value);
  void set_transfer_types(int index, const char* value);
  void set_transfer_types(int index, const char* value, std::size_t size);
  void set_transfer_types(int index, absl::string_view value);
  std::string* add_transfer_types();
  void add_transfer_types(const std::string& value);
  void add_transfer_types(std::string&& value);
  void add_transfer_types(const char* value);
  void add_transfer_types(const char* value, std::size_t size);
  void add_transfer_types(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transfer_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transfer_types();

  private:
  const std::string& _internal_transfer_types(int index) const;
  std::string* _internal_add_transfer_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_transfer_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_transfer_types();

  public:
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string denom = 2 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 end_time = 6 [json_name = "endTime"];
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // sint32 limit = 5 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountHistoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transfer_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::uint64_t skip_;
    ::int64_t end_time_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountHistoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountHistoryResponse) */ {
 public:
  inline SubaccountHistoryResponse() : SubaccountHistoryResponse(nullptr) {}
  ~SubaccountHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountHistoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountHistoryResponse(const SubaccountHistoryResponse& from);
  SubaccountHistoryResponse(SubaccountHistoryResponse&& from) noexcept
    : SubaccountHistoryResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountHistoryResponse& operator=(const SubaccountHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountHistoryResponse& operator=(SubaccountHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountHistoryResponse*>(
               &_SubaccountHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SubaccountHistoryResponse& a, SubaccountHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountHistoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountHistoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountHistoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountHistoryResponse& from) {
    SubaccountHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountHistoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountHistoryResponse";
  }
  protected:
  explicit SubaccountHistoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransfersFieldNumber = 1,
    kPagingFieldNumber = 2,
  };
  // repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1 [json_name = "transfers"];
  int transfers_size() const;
  private:
  int _internal_transfers_size() const;

  public:
  void clear_transfers() ;
  ::injective_accounts_rpc::SubaccountBalanceTransfer* mutable_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalanceTransfer >*
      mutable_transfers();
  private:
  const ::injective_accounts_rpc::SubaccountBalanceTransfer& _internal_transfers(int index) const;
  ::injective_accounts_rpc::SubaccountBalanceTransfer* _internal_add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalanceTransfer>& _internal_transfers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalanceTransfer>* _internal_mutable_transfers();
  public:
  const ::injective_accounts_rpc::SubaccountBalanceTransfer& transfers(int index) const;
  ::injective_accounts_rpc::SubaccountBalanceTransfer* add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalanceTransfer >&
      transfers() const;
  // .injective_accounts_rpc.Paging paging = 2 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_accounts_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::Paging* release_paging();
  ::injective_accounts_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_accounts_rpc::Paging* paging);
  private:
  const ::injective_accounts_rpc::Paging& _internal_paging() const;
  ::injective_accounts_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_accounts_rpc::Paging* paging);
  ::injective_accounts_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountHistoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalanceTransfer > transfers_;
    ::injective_accounts_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountBalanceTransfer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountBalanceTransfer) */ {
 public:
  inline SubaccountBalanceTransfer() : SubaccountBalanceTransfer(nullptr) {}
  ~SubaccountBalanceTransfer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountBalanceTransfer(const SubaccountBalanceTransfer& from);
  SubaccountBalanceTransfer(SubaccountBalanceTransfer&& from) noexcept
    : SubaccountBalanceTransfer() {
    *this = ::std::move(from);
  }

  inline SubaccountBalanceTransfer& operator=(const SubaccountBalanceTransfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountBalanceTransfer& operator=(SubaccountBalanceTransfer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountBalanceTransfer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountBalanceTransfer* internal_default_instance() {
    return reinterpret_cast<const SubaccountBalanceTransfer*>(
               &_SubaccountBalanceTransfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SubaccountBalanceTransfer& a, SubaccountBalanceTransfer& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountBalanceTransfer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountBalanceTransfer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountBalanceTransfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountBalanceTransfer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountBalanceTransfer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountBalanceTransfer& from) {
    SubaccountBalanceTransfer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountBalanceTransfer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountBalanceTransfer";
  }
  protected:
  explicit SubaccountBalanceTransfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransferTypeFieldNumber = 1,
    kSrcSubaccountIdFieldNumber = 2,
    kSrcAccountAddressFieldNumber = 3,
    kDstSubaccountIdFieldNumber = 4,
    kDstAccountAddressFieldNumber = 5,
    kAmountFieldNumber = 6,
    kExecutedAtFieldNumber = 7,
  };
  // string transfer_type = 1 [json_name = "transferType"];
  void clear_transfer_type() ;
  const std::string& transfer_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transfer_type(Arg_&& arg, Args_... args);
  std::string* mutable_transfer_type();
  PROTOBUF_NODISCARD std::string* release_transfer_type();
  void set_allocated_transfer_type(std::string* ptr);

  private:
  const std::string& _internal_transfer_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transfer_type(
      const std::string& value);
  std::string* _internal_mutable_transfer_type();

  public:
  // string src_subaccount_id = 2 [json_name = "srcSubaccountId"];
  void clear_src_subaccount_id() ;
  const std::string& src_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_src_subaccount_id();
  void set_allocated_src_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_src_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_src_subaccount_id();

  public:
  // string src_account_address = 3 [json_name = "srcAccountAddress"];
  void clear_src_account_address() ;
  const std::string& src_account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_src_account_address();
  PROTOBUF_NODISCARD std::string* release_src_account_address();
  void set_allocated_src_account_address(std::string* ptr);

  private:
  const std::string& _internal_src_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_account_address(
      const std::string& value);
  std::string* _internal_mutable_src_account_address();

  public:
  // string dst_subaccount_id = 4 [json_name = "dstSubaccountId"];
  void clear_dst_subaccount_id() ;
  const std::string& dst_subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_dst_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_dst_subaccount_id();
  void set_allocated_dst_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_dst_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_dst_subaccount_id();

  public:
  // string dst_account_address = 5 [json_name = "dstAccountAddress"];
  void clear_dst_account_address() ;
  const std::string& dst_account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dst_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_dst_account_address();
  PROTOBUF_NODISCARD std::string* release_dst_account_address();
  void set_allocated_dst_account_address(std::string* ptr);

  private:
  const std::string& _internal_dst_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_account_address(
      const std::string& value);
  std::string* _internal_mutable_dst_account_address();

  public:
  // .injective_accounts_rpc.CosmosCoin amount = 6 [json_name = "amount"];
  bool has_amount() const;
  void clear_amount() ;
  const ::injective_accounts_rpc::CosmosCoin& amount() const;
  PROTOBUF_NODISCARD ::injective_accounts_rpc::CosmosCoin* release_amount();
  ::injective_accounts_rpc::CosmosCoin* mutable_amount();
  void set_allocated_amount(::injective_accounts_rpc::CosmosCoin* amount);
  private:
  const ::injective_accounts_rpc::CosmosCoin& _internal_amount() const;
  ::injective_accounts_rpc::CosmosCoin* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::injective_accounts_rpc::CosmosCoin* amount);
  ::injective_accounts_rpc::CosmosCoin* unsafe_arena_release_amount();
  // sint64 executed_at = 7 [json_name = "executedAt"];
  void clear_executed_at() ;
  ::int64_t executed_at() const;
  void set_executed_at(::int64_t value);

  private:
  ::int64_t _internal_executed_at() const;
  void _internal_set_executed_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountBalanceTransfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transfer_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_account_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_account_address_;
    ::injective_accounts_rpc::CosmosCoin* amount_;
    ::int64_t executed_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class CosmosCoin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.CosmosCoin) */ {
 public:
  inline CosmosCoin() : CosmosCoin(nullptr) {}
  ~CosmosCoin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CosmosCoin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosmosCoin(const CosmosCoin& from);
  CosmosCoin(CosmosCoin&& from) noexcept
    : CosmosCoin() {
    *this = ::std::move(from);
  }

  inline CosmosCoin& operator=(const CosmosCoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosmosCoin& operator=(CosmosCoin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosmosCoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosmosCoin* internal_default_instance() {
    return reinterpret_cast<const CosmosCoin*>(
               &_CosmosCoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CosmosCoin& a, CosmosCoin& b) {
    a.Swap(&b);
  }
  inline void Swap(CosmosCoin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosmosCoin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CosmosCoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CosmosCoin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosmosCoin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CosmosCoin& from) {
    CosmosCoin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosmosCoin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.CosmosCoin";
  }
  protected:
  explicit CosmosCoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.CosmosCoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class Paging final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.Paging) */ {
 public:
  inline Paging() : Paging(nullptr) {}
  ~Paging() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Paging(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paging(const Paging& from);
  Paging(Paging&& from) noexcept
    : Paging() {
    *this = ::std::move(from);
  }

  inline Paging& operator=(const Paging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paging& operator=(Paging&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paging& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paging* internal_default_instance() {
    return reinterpret_cast<const Paging*>(
               &_Paging_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Paging& a, Paging& b) {
    a.Swap(&b);
  }
  inline void Swap(Paging* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paging* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Paging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Paging>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paging& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Paging& from) {
    Paging::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paging* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.Paging";
  }
  protected:
  explicit Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kCountBySubaccountFieldNumber = 4,
  };
  // sint64 total = 1 [json_name = "total"];
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // sint32 from = 2 [json_name = "from"];
  void clear_from() ;
  ::int32_t from() const;
  void set_from(::int32_t value);

  private:
  ::int32_t _internal_from() const;
  void _internal_set_from(::int32_t value);

  public:
  // sint32 to = 3 [json_name = "to"];
  void clear_to() ;
  ::int32_t to() const;
  void set_to(::int32_t value);

  private:
  ::int32_t _internal_to() const;
  void _internal_set_to(::int32_t value);

  public:
  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  void clear_count_by_subaccount() ;
  ::int64_t count_by_subaccount() const;
  void set_count_by_subaccount(::int64_t value);

  private:
  ::int64_t _internal_count_by_subaccount() const;
  void _internal_set_count_by_subaccount(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.Paging)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t total_;
    ::int32_t from_;
    ::int32_t to_;
    ::int64_t count_by_subaccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrderSummaryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountOrderSummaryRequest) */ {
 public:
  inline SubaccountOrderSummaryRequest() : SubaccountOrderSummaryRequest(nullptr) {}
  ~SubaccountOrderSummaryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrderSummaryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrderSummaryRequest(const SubaccountOrderSummaryRequest& from);
  SubaccountOrderSummaryRequest(SubaccountOrderSummaryRequest&& from) noexcept
    : SubaccountOrderSummaryRequest() {
    *this = ::std::move(from);
  }

  inline SubaccountOrderSummaryRequest& operator=(const SubaccountOrderSummaryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrderSummaryRequest& operator=(SubaccountOrderSummaryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrderSummaryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrderSummaryRequest* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrderSummaryRequest*>(
               &_SubaccountOrderSummaryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SubaccountOrderSummaryRequest& a, SubaccountOrderSummaryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrderSummaryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrderSummaryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrderSummaryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrderSummaryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrderSummaryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrderSummaryRequest& from) {
    SubaccountOrderSummaryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrderSummaryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountOrderSummaryRequest";
  }
  protected:
  explicit SubaccountOrderSummaryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubaccountIdFieldNumber = 1,
    kMarketIdFieldNumber = 2,
    kOrderDirectionFieldNumber = 3,
  };
  // string subaccount_id = 1 [json_name = "subaccountId"];
  void clear_subaccount_id() ;
  const std::string& subaccount_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subaccount_id(Arg_&& arg, Args_... args);
  std::string* mutable_subaccount_id();
  PROTOBUF_NODISCARD std::string* release_subaccount_id();
  void set_allocated_subaccount_id(std::string* ptr);

  private:
  const std::string& _internal_subaccount_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subaccount_id(
      const std::string& value);
  std::string* _internal_mutable_subaccount_id();

  public:
  // string market_id = 2 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // string order_direction = 3 [json_name = "orderDirection"];
  void clear_order_direction() ;
  const std::string& order_direction() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_order_direction(Arg_&& arg, Args_... args);
  std::string* mutable_order_direction();
  PROTOBUF_NODISCARD std::string* release_order_direction();
  void set_allocated_order_direction(std::string* ptr);

  private:
  const std::string& _internal_order_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_direction(
      const std::string& value);
  std::string* _internal_mutable_order_direction();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountOrderSummaryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subaccount_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class SubaccountOrderSummaryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.SubaccountOrderSummaryResponse) */ {
 public:
  inline SubaccountOrderSummaryResponse() : SubaccountOrderSummaryResponse(nullptr) {}
  ~SubaccountOrderSummaryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubaccountOrderSummaryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubaccountOrderSummaryResponse(const SubaccountOrderSummaryResponse& from);
  SubaccountOrderSummaryResponse(SubaccountOrderSummaryResponse&& from) noexcept
    : SubaccountOrderSummaryResponse() {
    *this = ::std::move(from);
  }

  inline SubaccountOrderSummaryResponse& operator=(const SubaccountOrderSummaryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubaccountOrderSummaryResponse& operator=(SubaccountOrderSummaryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubaccountOrderSummaryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubaccountOrderSummaryResponse* internal_default_instance() {
    return reinterpret_cast<const SubaccountOrderSummaryResponse*>(
               &_SubaccountOrderSummaryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SubaccountOrderSummaryResponse& a, SubaccountOrderSummaryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubaccountOrderSummaryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubaccountOrderSummaryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubaccountOrderSummaryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubaccountOrderSummaryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubaccountOrderSummaryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubaccountOrderSummaryResponse& from) {
    SubaccountOrderSummaryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubaccountOrderSummaryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.SubaccountOrderSummaryResponse";
  }
  protected:
  explicit SubaccountOrderSummaryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpotOrdersTotalFieldNumber = 1,
    kDerivativeOrdersTotalFieldNumber = 2,
  };
  // sint64 spot_orders_total = 1 [json_name = "spotOrdersTotal"];
  void clear_spot_orders_total() ;
  ::int64_t spot_orders_total() const;
  void set_spot_orders_total(::int64_t value);

  private:
  ::int64_t _internal_spot_orders_total() const;
  void _internal_set_spot_orders_total(::int64_t value);

  public:
  // sint64 derivative_orders_total = 2 [json_name = "derivativeOrdersTotal"];
  void clear_derivative_orders_total() ;
  ::int64_t derivative_orders_total() const;
  void set_derivative_orders_total(::int64_t value);

  private:
  ::int64_t _internal_derivative_orders_total() const;
  void _internal_set_derivative_orders_total(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.SubaccountOrderSummaryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t spot_orders_total_;
    ::int64_t derivative_orders_total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class RewardsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.RewardsRequest) */ {
 public:
  inline RewardsRequest() : RewardsRequest(nullptr) {}
  ~RewardsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RewardsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RewardsRequest(const RewardsRequest& from);
  RewardsRequest(RewardsRequest&& from) noexcept
    : RewardsRequest() {
    *this = ::std::move(from);
  }

  inline RewardsRequest& operator=(const RewardsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RewardsRequest& operator=(RewardsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RewardsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RewardsRequest* internal_default_instance() {
    return reinterpret_cast<const RewardsRequest*>(
               &_RewardsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RewardsRequest& a, RewardsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RewardsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RewardsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RewardsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RewardsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RewardsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RewardsRequest& from) {
    RewardsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RewardsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.RewardsRequest";
  }
  protected:
  explicit RewardsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountAddressFieldNumber = 2,
    kEpochFieldNumber = 1,
  };
  // string account_address = 2 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // sint64 epoch = 1 [json_name = "epoch"];
  void clear_epoch() ;
  ::int64_t epoch() const;
  void set_epoch(::int64_t value);

  private:
  ::int64_t _internal_epoch() const;
  void _internal_set_epoch(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.RewardsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    ::int64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class RewardsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.RewardsResponse) */ {
 public:
  inline RewardsResponse() : RewardsResponse(nullptr) {}
  ~RewardsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RewardsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RewardsResponse(const RewardsResponse& from);
  RewardsResponse(RewardsResponse&& from) noexcept
    : RewardsResponse() {
    *this = ::std::move(from);
  }

  inline RewardsResponse& operator=(const RewardsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RewardsResponse& operator=(RewardsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RewardsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RewardsResponse* internal_default_instance() {
    return reinterpret_cast<const RewardsResponse*>(
               &_RewardsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RewardsResponse& a, RewardsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RewardsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RewardsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RewardsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RewardsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RewardsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RewardsResponse& from) {
    RewardsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RewardsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.RewardsResponse";
  }
  protected:
  explicit RewardsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 1,
  };
  // repeated .injective_accounts_rpc.Reward rewards = 1 [json_name = "rewards"];
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::injective_accounts_rpc::Reward* mutable_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Reward >*
      mutable_rewards();
  private:
  const ::injective_accounts_rpc::Reward& _internal_rewards(int index) const;
  ::injective_accounts_rpc::Reward* _internal_add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Reward>& _internal_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Reward>* _internal_mutable_rewards();
  public:
  const ::injective_accounts_rpc::Reward& rewards(int index) const;
  ::injective_accounts_rpc::Reward* add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Reward >&
      rewards() const;
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.RewardsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Reward > rewards_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class Reward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.Reward) */ {
 public:
  inline Reward() : Reward(nullptr) {}
  ~Reward() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Reward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reward(const Reward& from);
  Reward(Reward&& from) noexcept
    : Reward() {
    *this = ::std::move(from);
  }

  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reward& operator=(Reward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reward& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reward* internal_default_instance() {
    return reinterpret_cast<const Reward*>(
               &_Reward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Reward& a, Reward& b) {
    a.Swap(&b);
  }
  inline void Swap(Reward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reward& from) {
    Reward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.Reward";
  }
  protected:
  explicit Reward(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 2,
    kAccountAddressFieldNumber = 1,
    kDistributedAtFieldNumber = 3,
  };
  // repeated .injective_accounts_rpc.Coin rewards = 2 [json_name = "rewards"];
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::injective_accounts_rpc::Coin* mutable_rewards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Coin >*
      mutable_rewards();
  private:
  const ::injective_accounts_rpc::Coin& _internal_rewards(int index) const;
  ::injective_accounts_rpc::Coin* _internal_add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Coin>& _internal_rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Coin>* _internal_mutable_rewards();
  public:
  const ::injective_accounts_rpc::Coin& rewards(int index) const;
  ::injective_accounts_rpc::Coin* add_rewards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Coin >&
      rewards() const;
  // string account_address = 1 [json_name = "accountAddress"];
  void clear_account_address() ;
  const std::string& account_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_address(Arg_&& arg, Args_... args);
  std::string* mutable_account_address();
  PROTOBUF_NODISCARD std::string* release_account_address();
  void set_allocated_account_address(std::string* ptr);

  private:
  const std::string& _internal_account_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_address(
      const std::string& value);
  std::string* _internal_mutable_account_address();

  public:
  // sint64 distributed_at = 3 [json_name = "distributedAt"];
  void clear_distributed_at() ;
  ::int64_t distributed_at() const;
  void set_distributed_at(::int64_t value);

  private:
  ::int64_t _internal_distributed_at() const;
  void _internal_set_distributed_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.Reward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Coin > rewards_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_address_;
    ::int64_t distributed_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};// -------------------------------------------------------------------

class Coin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_accounts_rpc.Coin) */ {
 public:
  inline Coin() : Coin(nullptr) {}
  ~Coin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Coin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Coin(const Coin& from);
  Coin(Coin&& from) noexcept
    : Coin() {
    *this = ::std::move(from);
  }

  inline Coin& operator=(const Coin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coin& operator=(Coin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coin* internal_default_instance() {
    return reinterpret_cast<const Coin*>(
               &_Coin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Coin& a, Coin& b) {
    a.Swap(&b);
  }
  inline void Swap(Coin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Coin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Coin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Coin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Coin& from) {
    Coin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_accounts_rpc.Coin";
  }
  protected:
  explicit Coin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_accounts_rpc.Coin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5faccounts_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PortfolioRequest

// string account_address = 1 [json_name = "accountAddress"];
inline void PortfolioRequest::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& PortfolioRequest::account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.PortfolioRequest.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PortfolioRequest::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.PortfolioRequest.account_address)
}
inline std::string* PortfolioRequest::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.PortfolioRequest.account_address)
  return _s;
}
inline const std::string& PortfolioRequest::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void PortfolioRequest::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PortfolioRequest::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* PortfolioRequest::release_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.PortfolioRequest.account_address)
  return _impl_.account_address_.Release();
}
inline void PortfolioRequest::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.PortfolioRequest.account_address)
}

// -------------------------------------------------------------------

// PortfolioResponse

// .injective_accounts_rpc.AccountPortfolio portfolio = 1 [json_name = "portfolio"];
inline bool PortfolioResponse::has_portfolio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.portfolio_ != nullptr);
  return value;
}
inline void PortfolioResponse::clear_portfolio() {
  if (_impl_.portfolio_ != nullptr) _impl_.portfolio_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::AccountPortfolio& PortfolioResponse::_internal_portfolio() const {
  const ::injective_accounts_rpc::AccountPortfolio* p = _impl_.portfolio_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::AccountPortfolio&>(
      ::injective_accounts_rpc::_AccountPortfolio_default_instance_);
}
inline const ::injective_accounts_rpc::AccountPortfolio& PortfolioResponse::portfolio() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.PortfolioResponse.portfolio)
  return _internal_portfolio();
}
inline void PortfolioResponse::unsafe_arena_set_allocated_portfolio(
    ::injective_accounts_rpc::AccountPortfolio* portfolio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.portfolio_);
  }
  _impl_.portfolio_ = portfolio;
  if (portfolio) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.PortfolioResponse.portfolio)
}
inline ::injective_accounts_rpc::AccountPortfolio* PortfolioResponse::release_portfolio() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::AccountPortfolio* temp = _impl_.portfolio_;
  _impl_.portfolio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::AccountPortfolio* PortfolioResponse::unsafe_arena_release_portfolio() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.PortfolioResponse.portfolio)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::AccountPortfolio* temp = _impl_.portfolio_;
  _impl_.portfolio_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::AccountPortfolio* PortfolioResponse::_internal_mutable_portfolio() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.portfolio_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::AccountPortfolio>(GetArenaForAllocation());
    _impl_.portfolio_ = p;
  }
  return _impl_.portfolio_;
}
inline ::injective_accounts_rpc::AccountPortfolio* PortfolioResponse::mutable_portfolio() {
  ::injective_accounts_rpc::AccountPortfolio* _msg = _internal_mutable_portfolio();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.PortfolioResponse.portfolio)
  return _msg;
}
inline void PortfolioResponse::set_allocated_portfolio(::injective_accounts_rpc::AccountPortfolio* portfolio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.portfolio_;
  }
  if (portfolio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(portfolio);
    if (message_arena != submessage_arena) {
      portfolio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, portfolio, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.portfolio_ = portfolio;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.PortfolioResponse.portfolio)
}

// -------------------------------------------------------------------

// AccountPortfolio

// string portfolio_value = 1 [json_name = "portfolioValue"];
inline void AccountPortfolio::clear_portfolio_value() {
  _impl_.portfolio_value_.ClearToEmpty();
}
inline const std::string& AccountPortfolio::portfolio_value() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.AccountPortfolio.portfolio_value)
  return _internal_portfolio_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccountPortfolio::set_portfolio_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.portfolio_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.AccountPortfolio.portfolio_value)
}
inline std::string* AccountPortfolio::mutable_portfolio_value() {
  std::string* _s = _internal_mutable_portfolio_value();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.AccountPortfolio.portfolio_value)
  return _s;
}
inline const std::string& AccountPortfolio::_internal_portfolio_value() const {
  return _impl_.portfolio_value_.Get();
}
inline void AccountPortfolio::_internal_set_portfolio_value(const std::string& value) {
  ;


  _impl_.portfolio_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountPortfolio::_internal_mutable_portfolio_value() {
  ;
  return _impl_.portfolio_value_.Mutable( GetArenaForAllocation());
}
inline std::string* AccountPortfolio::release_portfolio_value() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.AccountPortfolio.portfolio_value)
  return _impl_.portfolio_value_.Release();
}
inline void AccountPortfolio::set_allocated_portfolio_value(std::string* value) {
  _impl_.portfolio_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.portfolio_value_.IsDefault()) {
          _impl_.portfolio_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.AccountPortfolio.portfolio_value)
}

// string available_balance = 2 [json_name = "availableBalance"];
inline void AccountPortfolio::clear_available_balance() {
  _impl_.available_balance_.ClearToEmpty();
}
inline const std::string& AccountPortfolio::available_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.AccountPortfolio.available_balance)
  return _internal_available_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccountPortfolio::set_available_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.AccountPortfolio.available_balance)
}
inline std::string* AccountPortfolio::mutable_available_balance() {
  std::string* _s = _internal_mutable_available_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.AccountPortfolio.available_balance)
  return _s;
}
inline const std::string& AccountPortfolio::_internal_available_balance() const {
  return _impl_.available_balance_.Get();
}
inline void AccountPortfolio::_internal_set_available_balance(const std::string& value) {
  ;


  _impl_.available_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountPortfolio::_internal_mutable_available_balance() {
  ;
  return _impl_.available_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* AccountPortfolio::release_available_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.AccountPortfolio.available_balance)
  return _impl_.available_balance_.Release();
}
inline void AccountPortfolio::set_allocated_available_balance(std::string* value) {
  _impl_.available_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_balance_.IsDefault()) {
          _impl_.available_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.AccountPortfolio.available_balance)
}

// string locked_balance = 3 [json_name = "lockedBalance"];
inline void AccountPortfolio::clear_locked_balance() {
  _impl_.locked_balance_.ClearToEmpty();
}
inline const std::string& AccountPortfolio::locked_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.AccountPortfolio.locked_balance)
  return _internal_locked_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccountPortfolio::set_locked_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.locked_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.AccountPortfolio.locked_balance)
}
inline std::string* AccountPortfolio::mutable_locked_balance() {
  std::string* _s = _internal_mutable_locked_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.AccountPortfolio.locked_balance)
  return _s;
}
inline const std::string& AccountPortfolio::_internal_locked_balance() const {
  return _impl_.locked_balance_.Get();
}
inline void AccountPortfolio::_internal_set_locked_balance(const std::string& value) {
  ;


  _impl_.locked_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountPortfolio::_internal_mutable_locked_balance() {
  ;
  return _impl_.locked_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* AccountPortfolio::release_locked_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.AccountPortfolio.locked_balance)
  return _impl_.locked_balance_.Release();
}
inline void AccountPortfolio::set_allocated_locked_balance(std::string* value) {
  _impl_.locked_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locked_balance_.IsDefault()) {
          _impl_.locked_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.AccountPortfolio.locked_balance)
}

// string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
inline void AccountPortfolio::clear_unrealized_pnl() {
  _impl_.unrealized_pnl_.ClearToEmpty();
}
inline const std::string& AccountPortfolio::unrealized_pnl() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.AccountPortfolio.unrealized_pnl)
  return _internal_unrealized_pnl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AccountPortfolio::set_unrealized_pnl(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unrealized_pnl_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.AccountPortfolio.unrealized_pnl)
}
inline std::string* AccountPortfolio::mutable_unrealized_pnl() {
  std::string* _s = _internal_mutable_unrealized_pnl();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.AccountPortfolio.unrealized_pnl)
  return _s;
}
inline const std::string& AccountPortfolio::_internal_unrealized_pnl() const {
  return _impl_.unrealized_pnl_.Get();
}
inline void AccountPortfolio::_internal_set_unrealized_pnl(const std::string& value) {
  ;


  _impl_.unrealized_pnl_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountPortfolio::_internal_mutable_unrealized_pnl() {
  ;
  return _impl_.unrealized_pnl_.Mutable( GetArenaForAllocation());
}
inline std::string* AccountPortfolio::release_unrealized_pnl() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.AccountPortfolio.unrealized_pnl)
  return _impl_.unrealized_pnl_.Release();
}
inline void AccountPortfolio::set_allocated_unrealized_pnl(std::string* value) {
  _impl_.unrealized_pnl_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unrealized_pnl_.IsDefault()) {
          _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.AccountPortfolio.unrealized_pnl)
}

// repeated .injective_accounts_rpc.SubaccountPortfolio subaccounts = 5 [json_name = "subaccounts"];
inline int AccountPortfolio::_internal_subaccounts_size() const {
  return _impl_.subaccounts_.size();
}
inline int AccountPortfolio::subaccounts_size() const {
  return _internal_subaccounts_size();
}
inline void AccountPortfolio::clear_subaccounts() {
  _internal_mutable_subaccounts()->Clear();
}
inline ::injective_accounts_rpc::SubaccountPortfolio* AccountPortfolio::mutable_subaccounts(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.AccountPortfolio.subaccounts)
  return _internal_mutable_subaccounts()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountPortfolio >*
AccountPortfolio::mutable_subaccounts() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.AccountPortfolio.subaccounts)
  return _internal_mutable_subaccounts();
}
inline const ::injective_accounts_rpc::SubaccountPortfolio& AccountPortfolio::_internal_subaccounts(int index) const {
  return _internal_subaccounts().Get(index);
}
inline const ::injective_accounts_rpc::SubaccountPortfolio& AccountPortfolio::subaccounts(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.AccountPortfolio.subaccounts)
  return _internal_subaccounts(index);
}
inline ::injective_accounts_rpc::SubaccountPortfolio* AccountPortfolio::_internal_add_subaccounts() {
  return _internal_mutable_subaccounts()->Add();
}
inline ::injective_accounts_rpc::SubaccountPortfolio* AccountPortfolio::add_subaccounts() {
  ::injective_accounts_rpc::SubaccountPortfolio* _add = _internal_add_subaccounts();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.AccountPortfolio.subaccounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountPortfolio >&
AccountPortfolio::subaccounts() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.AccountPortfolio.subaccounts)
  return _internal_subaccounts();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountPortfolio>&
AccountPortfolio::_internal_subaccounts() const {
  return _impl_.subaccounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountPortfolio>*
AccountPortfolio::_internal_mutable_subaccounts() {
  return &_impl_.subaccounts_;
}

// -------------------------------------------------------------------

// SubaccountPortfolio

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountPortfolio::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountPortfolio::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountPortfolio.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountPortfolio::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountPortfolio.subaccount_id)
}
inline std::string* SubaccountPortfolio::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountPortfolio.subaccount_id)
  return _s;
}
inline const std::string& SubaccountPortfolio::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountPortfolio::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountPortfolio.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountPortfolio::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountPortfolio.subaccount_id)
}

// string available_balance = 2 [json_name = "availableBalance"];
inline void SubaccountPortfolio::clear_available_balance() {
  _impl_.available_balance_.ClearToEmpty();
}
inline const std::string& SubaccountPortfolio::available_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountPortfolio.available_balance)
  return _internal_available_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountPortfolio::set_available_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountPortfolio.available_balance)
}
inline std::string* SubaccountPortfolio::mutable_available_balance() {
  std::string* _s = _internal_mutable_available_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountPortfolio.available_balance)
  return _s;
}
inline const std::string& SubaccountPortfolio::_internal_available_balance() const {
  return _impl_.available_balance_.Get();
}
inline void SubaccountPortfolio::_internal_set_available_balance(const std::string& value) {
  ;


  _impl_.available_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::_internal_mutable_available_balance() {
  ;
  return _impl_.available_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::release_available_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountPortfolio.available_balance)
  return _impl_.available_balance_.Release();
}
inline void SubaccountPortfolio::set_allocated_available_balance(std::string* value) {
  _impl_.available_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_balance_.IsDefault()) {
          _impl_.available_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountPortfolio.available_balance)
}

// string locked_balance = 3 [json_name = "lockedBalance"];
inline void SubaccountPortfolio::clear_locked_balance() {
  _impl_.locked_balance_.ClearToEmpty();
}
inline const std::string& SubaccountPortfolio::locked_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountPortfolio.locked_balance)
  return _internal_locked_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountPortfolio::set_locked_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.locked_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountPortfolio.locked_balance)
}
inline std::string* SubaccountPortfolio::mutable_locked_balance() {
  std::string* _s = _internal_mutable_locked_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountPortfolio.locked_balance)
  return _s;
}
inline const std::string& SubaccountPortfolio::_internal_locked_balance() const {
  return _impl_.locked_balance_.Get();
}
inline void SubaccountPortfolio::_internal_set_locked_balance(const std::string& value) {
  ;


  _impl_.locked_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::_internal_mutable_locked_balance() {
  ;
  return _impl_.locked_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::release_locked_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountPortfolio.locked_balance)
  return _impl_.locked_balance_.Release();
}
inline void SubaccountPortfolio::set_allocated_locked_balance(std::string* value) {
  _impl_.locked_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.locked_balance_.IsDefault()) {
          _impl_.locked_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountPortfolio.locked_balance)
}

// string unrealized_pnl = 4 [json_name = "unrealizedPnl"];
inline void SubaccountPortfolio::clear_unrealized_pnl() {
  _impl_.unrealized_pnl_.ClearToEmpty();
}
inline const std::string& SubaccountPortfolio::unrealized_pnl() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl)
  return _internal_unrealized_pnl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountPortfolio::set_unrealized_pnl(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unrealized_pnl_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl)
}
inline std::string* SubaccountPortfolio::mutable_unrealized_pnl() {
  std::string* _s = _internal_mutable_unrealized_pnl();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl)
  return _s;
}
inline const std::string& SubaccountPortfolio::_internal_unrealized_pnl() const {
  return _impl_.unrealized_pnl_.Get();
}
inline void SubaccountPortfolio::_internal_set_unrealized_pnl(const std::string& value) {
  ;


  _impl_.unrealized_pnl_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::_internal_mutable_unrealized_pnl() {
  ;
  return _impl_.unrealized_pnl_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountPortfolio::release_unrealized_pnl() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl)
  return _impl_.unrealized_pnl_.Release();
}
inline void SubaccountPortfolio::set_allocated_unrealized_pnl(std::string* value) {
  _impl_.unrealized_pnl_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unrealized_pnl_.IsDefault()) {
          _impl_.unrealized_pnl_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountPortfolio.unrealized_pnl)
}

// -------------------------------------------------------------------

// OrderStatesRequest

// repeated string spot_order_hashes = 1 [json_name = "spotOrderHashes"];
inline int OrderStatesRequest::_internal_spot_order_hashes_size() const {
  return _impl_.spot_order_hashes_.size();
}
inline int OrderStatesRequest::spot_order_hashes_size() const {
  return _internal_spot_order_hashes_size();
}
inline void OrderStatesRequest::clear_spot_order_hashes() {
  _internal_mutable_spot_order_hashes()->Clear();
}
inline std::string* OrderStatesRequest::add_spot_order_hashes() {
  std::string* _s = _internal_add_spot_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
  return _s;
}
inline const std::string& OrderStatesRequest::spot_order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
  return _internal_spot_order_hashes(index);
}
inline std::string* OrderStatesRequest::mutable_spot_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
  return _internal_mutable_spot_order_hashes()->Mutable(index);
}
inline void OrderStatesRequest::set_spot_order_hashes(int index, const std::string& value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::set_spot_order_hashes(int index, std::string&& value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::set_spot_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::set_spot_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::set_spot_order_hashes(int index, absl::string_view value) {
  _internal_mutable_spot_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::add_spot_order_hashes(const std::string& value) {
  _internal_mutable_spot_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::add_spot_order_hashes(std::string&& value) {
  _internal_mutable_spot_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::add_spot_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_spot_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::add_spot_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_spot_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline void OrderStatesRequest::add_spot_order_hashes(absl::string_view value) {
  _internal_mutable_spot_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderStatesRequest::spot_order_hashes() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
  return _internal_spot_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderStatesRequest::mutable_spot_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.OrderStatesRequest.spot_order_hashes)
  return _internal_mutable_spot_order_hashes();
}
inline const std::string& OrderStatesRequest::_internal_spot_order_hashes(int index) const {
  return _internal_spot_order_hashes().Get(index);
}
inline std::string* OrderStatesRequest::_internal_add_spot_order_hashes() {
  return _internal_mutable_spot_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderStatesRequest::_internal_spot_order_hashes() const {
  return _impl_.spot_order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderStatesRequest::_internal_mutable_spot_order_hashes() {
  return &_impl_.spot_order_hashes_;
}

// repeated string derivative_order_hashes = 2 [json_name = "derivativeOrderHashes"];
inline int OrderStatesRequest::_internal_derivative_order_hashes_size() const {
  return _impl_.derivative_order_hashes_.size();
}
inline int OrderStatesRequest::derivative_order_hashes_size() const {
  return _internal_derivative_order_hashes_size();
}
inline void OrderStatesRequest::clear_derivative_order_hashes() {
  _internal_mutable_derivative_order_hashes()->Clear();
}
inline std::string* OrderStatesRequest::add_derivative_order_hashes() {
  std::string* _s = _internal_add_derivative_order_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
  return _s;
}
inline const std::string& OrderStatesRequest::derivative_order_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
  return _internal_derivative_order_hashes(index);
}
inline std::string* OrderStatesRequest::mutable_derivative_order_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
  return _internal_mutable_derivative_order_hashes()->Mutable(index);
}
inline void OrderStatesRequest::set_derivative_order_hashes(int index, const std::string& value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::set_derivative_order_hashes(int index, std::string&& value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::set_derivative_order_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::set_derivative_order_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::set_derivative_order_hashes(int index, absl::string_view value) {
  _internal_mutable_derivative_order_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::add_derivative_order_hashes(const std::string& value) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::add_derivative_order_hashes(std::string&& value) {
  _internal_mutable_derivative_order_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::add_derivative_order_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_derivative_order_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::add_derivative_order_hashes(const char* value, std::size_t size) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline void OrderStatesRequest::add_derivative_order_hashes(absl::string_view value) {
  _internal_mutable_derivative_order_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderStatesRequest::derivative_order_hashes() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
  return _internal_derivative_order_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* OrderStatesRequest::mutable_derivative_order_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.OrderStatesRequest.derivative_order_hashes)
  return _internal_mutable_derivative_order_hashes();
}
inline const std::string& OrderStatesRequest::_internal_derivative_order_hashes(int index) const {
  return _internal_derivative_order_hashes().Get(index);
}
inline std::string* OrderStatesRequest::_internal_add_derivative_order_hashes() {
  return _internal_mutable_derivative_order_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OrderStatesRequest::_internal_derivative_order_hashes() const {
  return _impl_.derivative_order_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OrderStatesRequest::_internal_mutable_derivative_order_hashes() {
  return &_impl_.derivative_order_hashes_;
}

// -------------------------------------------------------------------

// OrderStatesResponse

// repeated .injective_accounts_rpc.OrderStateRecord spot_order_states = 1 [json_name = "spotOrderStates"];
inline int OrderStatesResponse::_internal_spot_order_states_size() const {
  return _impl_.spot_order_states_.size();
}
inline int OrderStatesResponse::spot_order_states_size() const {
  return _internal_spot_order_states_size();
}
inline void OrderStatesResponse::clear_spot_order_states() {
  _internal_mutable_spot_order_states()->Clear();
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::mutable_spot_order_states(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStatesResponse.spot_order_states)
  return _internal_mutable_spot_order_states()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >*
OrderStatesResponse::mutable_spot_order_states() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.OrderStatesResponse.spot_order_states)
  return _internal_mutable_spot_order_states();
}
inline const ::injective_accounts_rpc::OrderStateRecord& OrderStatesResponse::_internal_spot_order_states(int index) const {
  return _internal_spot_order_states().Get(index);
}
inline const ::injective_accounts_rpc::OrderStateRecord& OrderStatesResponse::spot_order_states(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStatesResponse.spot_order_states)
  return _internal_spot_order_states(index);
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::_internal_add_spot_order_states() {
  return _internal_mutable_spot_order_states()->Add();
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::add_spot_order_states() {
  ::injective_accounts_rpc::OrderStateRecord* _add = _internal_add_spot_order_states();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesResponse.spot_order_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >&
OrderStatesResponse::spot_order_states() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.OrderStatesResponse.spot_order_states)
  return _internal_spot_order_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>&
OrderStatesResponse::_internal_spot_order_states() const {
  return _impl_.spot_order_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>*
OrderStatesResponse::_internal_mutable_spot_order_states() {
  return &_impl_.spot_order_states_;
}

// repeated .injective_accounts_rpc.OrderStateRecord derivative_order_states = 2 [json_name = "derivativeOrderStates"];
inline int OrderStatesResponse::_internal_derivative_order_states_size() const {
  return _impl_.derivative_order_states_.size();
}
inline int OrderStatesResponse::derivative_order_states_size() const {
  return _internal_derivative_order_states_size();
}
inline void OrderStatesResponse::clear_derivative_order_states() {
  _internal_mutable_derivative_order_states()->Clear();
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::mutable_derivative_order_states(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStatesResponse.derivative_order_states)
  return _internal_mutable_derivative_order_states()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >*
OrderStatesResponse::mutable_derivative_order_states() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.OrderStatesResponse.derivative_order_states)
  return _internal_mutable_derivative_order_states();
}
inline const ::injective_accounts_rpc::OrderStateRecord& OrderStatesResponse::_internal_derivative_order_states(int index) const {
  return _internal_derivative_order_states().Get(index);
}
inline const ::injective_accounts_rpc::OrderStateRecord& OrderStatesResponse::derivative_order_states(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStatesResponse.derivative_order_states)
  return _internal_derivative_order_states(index);
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::_internal_add_derivative_order_states() {
  return _internal_mutable_derivative_order_states()->Add();
}
inline ::injective_accounts_rpc::OrderStateRecord* OrderStatesResponse::add_derivative_order_states() {
  ::injective_accounts_rpc::OrderStateRecord* _add = _internal_add_derivative_order_states();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.OrderStatesResponse.derivative_order_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::OrderStateRecord >&
OrderStatesResponse::derivative_order_states() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.OrderStatesResponse.derivative_order_states)
  return _internal_derivative_order_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>&
OrderStatesResponse::_internal_derivative_order_states() const {
  return _impl_.derivative_order_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::OrderStateRecord>*
OrderStatesResponse::_internal_mutable_derivative_order_states() {
  return &_impl_.derivative_order_states_;
}

// -------------------------------------------------------------------

// OrderStateRecord

// string order_hash = 1 [json_name = "orderHash"];
inline void OrderStateRecord::clear_order_hash() {
  _impl_.order_hash_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::order_hash() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.order_hash)
  return _internal_order_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_order_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.order_hash)
}
inline std::string* OrderStateRecord::mutable_order_hash() {
  std::string* _s = _internal_mutable_order_hash();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.order_hash)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_order_hash() const {
  return _impl_.order_hash_.Get();
}
inline void OrderStateRecord::_internal_set_order_hash(const std::string& value) {
  ;


  _impl_.order_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_order_hash() {
  ;
  return _impl_.order_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_order_hash() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.order_hash)
  return _impl_.order_hash_.Release();
}
inline void OrderStateRecord::set_allocated_order_hash(std::string* value) {
  _impl_.order_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_hash_.IsDefault()) {
          _impl_.order_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.order_hash)
}

// string subaccount_id = 2 [json_name = "subaccountId"];
inline void OrderStateRecord::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.subaccount_id)
}
inline std::string* OrderStateRecord::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.subaccount_id)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void OrderStateRecord::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void OrderStateRecord::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.subaccount_id)
}

// string market_id = 3 [json_name = "marketId"];
inline void OrderStateRecord::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::market_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.market_id)
}
inline std::string* OrderStateRecord::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.market_id)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void OrderStateRecord::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.market_id)
  return _impl_.market_id_.Release();
}
inline void OrderStateRecord::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.market_id)
}

// string order_type = 4 [json_name = "orderType"];
inline void OrderStateRecord::clear_order_type() {
  _impl_.order_type_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::order_type() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_order_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.order_type)
}
inline std::string* OrderStateRecord::mutable_order_type() {
  std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.order_type)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_order_type() const {
  return _impl_.order_type_.Get();
}
inline void OrderStateRecord::_internal_set_order_type(const std::string& value) {
  ;


  _impl_.order_type_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_order_type() {
  ;
  return _impl_.order_type_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_order_type() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.order_type)
  return _impl_.order_type_.Release();
}
inline void OrderStateRecord::set_allocated_order_type(std::string* value) {
  _impl_.order_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_type_.IsDefault()) {
          _impl_.order_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.order_type)
}

// string order_side = 5 [json_name = "orderSide"];
inline void OrderStateRecord::clear_order_side() {
  _impl_.order_side_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::order_side() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.order_side)
  return _internal_order_side();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_order_side(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_side_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.order_side)
}
inline std::string* OrderStateRecord::mutable_order_side() {
  std::string* _s = _internal_mutable_order_side();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.order_side)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_order_side() const {
  return _impl_.order_side_.Get();
}
inline void OrderStateRecord::_internal_set_order_side(const std::string& value) {
  ;


  _impl_.order_side_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_order_side() {
  ;
  return _impl_.order_side_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_order_side() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.order_side)
  return _impl_.order_side_.Release();
}
inline void OrderStateRecord::set_allocated_order_side(std::string* value) {
  _impl_.order_side_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_side_.IsDefault()) {
          _impl_.order_side_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.order_side)
}

// string state = 6 [json_name = "state"];
inline void OrderStateRecord::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::state() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.state)
}
inline std::string* OrderStateRecord::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.state)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_state() const {
  return _impl_.state_.Get();
}
inline void OrderStateRecord::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_state() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.state)
  return _impl_.state_.Release();
}
inline void OrderStateRecord::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.state)
}

// string quantity_filled = 7 [json_name = "quantityFilled"];
inline void OrderStateRecord::clear_quantity_filled() {
  _impl_.quantity_filled_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::quantity_filled() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.quantity_filled)
  return _internal_quantity_filled();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_quantity_filled(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_filled_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.quantity_filled)
}
inline std::string* OrderStateRecord::mutable_quantity_filled() {
  std::string* _s = _internal_mutable_quantity_filled();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.quantity_filled)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_quantity_filled() const {
  return _impl_.quantity_filled_.Get();
}
inline void OrderStateRecord::_internal_set_quantity_filled(const std::string& value) {
  ;


  _impl_.quantity_filled_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_quantity_filled() {
  ;
  return _impl_.quantity_filled_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_quantity_filled() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.quantity_filled)
  return _impl_.quantity_filled_.Release();
}
inline void OrderStateRecord::set_allocated_quantity_filled(std::string* value) {
  _impl_.quantity_filled_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_filled_.IsDefault()) {
          _impl_.quantity_filled_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.quantity_filled)
}

// string quantity_remaining = 8 [json_name = "quantityRemaining"];
inline void OrderStateRecord::clear_quantity_remaining() {
  _impl_.quantity_remaining_.ClearToEmpty();
}
inline const std::string& OrderStateRecord::quantity_remaining() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.quantity_remaining)
  return _internal_quantity_remaining();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OrderStateRecord::set_quantity_remaining(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.quantity_remaining_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.quantity_remaining)
}
inline std::string* OrderStateRecord::mutable_quantity_remaining() {
  std::string* _s = _internal_mutable_quantity_remaining();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.OrderStateRecord.quantity_remaining)
  return _s;
}
inline const std::string& OrderStateRecord::_internal_quantity_remaining() const {
  return _impl_.quantity_remaining_.Get();
}
inline void OrderStateRecord::_internal_set_quantity_remaining(const std::string& value) {
  ;


  _impl_.quantity_remaining_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderStateRecord::_internal_mutable_quantity_remaining() {
  ;
  return _impl_.quantity_remaining_.Mutable( GetArenaForAllocation());
}
inline std::string* OrderStateRecord::release_quantity_remaining() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.OrderStateRecord.quantity_remaining)
  return _impl_.quantity_remaining_.Release();
}
inline void OrderStateRecord::set_allocated_quantity_remaining(std::string* value) {
  _impl_.quantity_remaining_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quantity_remaining_.IsDefault()) {
          _impl_.quantity_remaining_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.OrderStateRecord.quantity_remaining)
}

// sint64 created_at = 9 [json_name = "createdAt"];
inline void OrderStateRecord::clear_created_at() {
  _impl_.created_at_ = ::int64_t{0};
}
inline ::int64_t OrderStateRecord::created_at() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.created_at)
  return _internal_created_at();
}
inline void OrderStateRecord::set_created_at(::int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.created_at)
}
inline ::int64_t OrderStateRecord::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void OrderStateRecord::_internal_set_created_at(::int64_t value) {
  ;
  _impl_.created_at_ = value;
}

// sint64 updated_at = 10 [json_name = "updatedAt"];
inline void OrderStateRecord::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t OrderStateRecord::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.OrderStateRecord.updated_at)
  return _internal_updated_at();
}
inline void OrderStateRecord::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.OrderStateRecord.updated_at)
}
inline ::int64_t OrderStateRecord::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void OrderStateRecord::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// -------------------------------------------------------------------

// SubaccountsListRequest

// string account_address = 1 [json_name = "accountAddress"];
inline void SubaccountsListRequest::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& SubaccountsListRequest::account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountsListRequest.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountsListRequest::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountsListRequest.account_address)
}
inline std::string* SubaccountsListRequest::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountsListRequest.account_address)
  return _s;
}
inline const std::string& SubaccountsListRequest::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void SubaccountsListRequest::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountsListRequest::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountsListRequest::release_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountsListRequest.account_address)
  return _impl_.account_address_.Release();
}
inline void SubaccountsListRequest::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountsListRequest.account_address)
}

// -------------------------------------------------------------------

// SubaccountsListResponse

// repeated string subaccounts = 1 [json_name = "subaccounts"];
inline int SubaccountsListResponse::_internal_subaccounts_size() const {
  return _impl_.subaccounts_.size();
}
inline int SubaccountsListResponse::subaccounts_size() const {
  return _internal_subaccounts_size();
}
inline void SubaccountsListResponse::clear_subaccounts() {
  _internal_mutable_subaccounts()->Clear();
}
inline std::string* SubaccountsListResponse::add_subaccounts() {
  std::string* _s = _internal_add_subaccounts();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
  return _s;
}
inline const std::string& SubaccountsListResponse::subaccounts(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
  return _internal_subaccounts(index);
}
inline std::string* SubaccountsListResponse::mutable_subaccounts(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
  return _internal_mutable_subaccounts()->Mutable(index);
}
inline void SubaccountsListResponse::set_subaccounts(int index, const std::string& value) {
  _internal_mutable_subaccounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::set_subaccounts(int index, std::string&& value) {
  _internal_mutable_subaccounts()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::set_subaccounts(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccounts()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::set_subaccounts(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_subaccounts()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::set_subaccounts(int index, absl::string_view value) {
  _internal_mutable_subaccounts()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::add_subaccounts(const std::string& value) {
  _internal_mutable_subaccounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::add_subaccounts(std::string&& value) {
  _internal_mutable_subaccounts()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::add_subaccounts(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_subaccounts()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::add_subaccounts(const char* value, std::size_t size) {
  _internal_mutable_subaccounts()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline void SubaccountsListResponse::add_subaccounts(absl::string_view value) {
  _internal_mutable_subaccounts()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountsListResponse::subaccounts() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
  return _internal_subaccounts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SubaccountsListResponse::mutable_subaccounts() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.SubaccountsListResponse.subaccounts)
  return _internal_mutable_subaccounts();
}
inline const std::string& SubaccountsListResponse::_internal_subaccounts(int index) const {
  return _internal_subaccounts().Get(index);
}
inline std::string* SubaccountsListResponse::_internal_add_subaccounts() {
  return _internal_mutable_subaccounts()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountsListResponse::_internal_subaccounts() const {
  return _impl_.subaccounts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubaccountsListResponse::_internal_mutable_subaccounts() {
  return &_impl_.subaccounts_;
}

// -------------------------------------------------------------------

// SubaccountBalancesListRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountBalancesListRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountBalancesListRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalancesListRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id)
}
inline std::string* SubaccountBalancesListRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountBalancesListRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountBalancesListRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalancesListRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalancesListRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountBalancesListRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalancesListRequest.subaccount_id)
}

// repeated string denoms = 2 [json_name = "denoms"];
inline int SubaccountBalancesListRequest::_internal_denoms_size() const {
  return _impl_.denoms_.size();
}
inline int SubaccountBalancesListRequest::denoms_size() const {
  return _internal_denoms_size();
}
inline void SubaccountBalancesListRequest::clear_denoms() {
  _internal_mutable_denoms()->Clear();
}
inline std::string* SubaccountBalancesListRequest::add_denoms() {
  std::string* _s = _internal_add_denoms();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
  return _s;
}
inline const std::string& SubaccountBalancesListRequest::denoms(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
  return _internal_denoms(index);
}
inline std::string* SubaccountBalancesListRequest::mutable_denoms(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
  return _internal_mutable_denoms()->Mutable(index);
}
inline void SubaccountBalancesListRequest::set_denoms(int index, const std::string& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::set_denoms(int index, std::string&& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::set_denoms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::set_denoms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_denoms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::set_denoms(int index, absl::string_view value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::add_denoms(const std::string& value) {
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::add_denoms(std::string&& value) {
  _internal_mutable_denoms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::add_denoms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::add_denoms(const char* value, std::size_t size) {
  _internal_mutable_denoms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline void SubaccountBalancesListRequest::add_denoms(absl::string_view value) {
  _internal_mutable_denoms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountBalancesListRequest::denoms() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
  return _internal_denoms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SubaccountBalancesListRequest::mutable_denoms() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.SubaccountBalancesListRequest.denoms)
  return _internal_mutable_denoms();
}
inline const std::string& SubaccountBalancesListRequest::_internal_denoms(int index) const {
  return _internal_denoms().Get(index);
}
inline std::string* SubaccountBalancesListRequest::_internal_add_denoms() {
  return _internal_mutable_denoms()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountBalancesListRequest::_internal_denoms() const {
  return _impl_.denoms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubaccountBalancesListRequest::_internal_mutable_denoms() {
  return &_impl_.denoms_;
}

// -------------------------------------------------------------------

// SubaccountBalancesListResponse

// repeated .injective_accounts_rpc.SubaccountBalance balances = 1 [json_name = "balances"];
inline int SubaccountBalancesListResponse::_internal_balances_size() const {
  return _impl_.balances_.size();
}
inline int SubaccountBalancesListResponse::balances_size() const {
  return _internal_balances_size();
}
inline void SubaccountBalancesListResponse::clear_balances() {
  _internal_mutable_balances()->Clear();
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalancesListResponse::mutable_balances(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalancesListResponse.balances)
  return _internal_mutable_balances()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalance >*
SubaccountBalancesListResponse::mutable_balances() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.SubaccountBalancesListResponse.balances)
  return _internal_mutable_balances();
}
inline const ::injective_accounts_rpc::SubaccountBalance& SubaccountBalancesListResponse::_internal_balances(int index) const {
  return _internal_balances().Get(index);
}
inline const ::injective_accounts_rpc::SubaccountBalance& SubaccountBalancesListResponse::balances(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalancesListResponse.balances)
  return _internal_balances(index);
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalancesListResponse::_internal_add_balances() {
  return _internal_mutable_balances()->Add();
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalancesListResponse::add_balances() {
  ::injective_accounts_rpc::SubaccountBalance* _add = _internal_add_balances();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountBalancesListResponse.balances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalance >&
SubaccountBalancesListResponse::balances() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.SubaccountBalancesListResponse.balances)
  return _internal_balances();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalance>&
SubaccountBalancesListResponse::_internal_balances() const {
  return _impl_.balances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalance>*
SubaccountBalancesListResponse::_internal_mutable_balances() {
  return &_impl_.balances_;
}

// -------------------------------------------------------------------

// SubaccountBalance

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountBalance::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountBalance::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalance.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalance::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalance.subaccount_id)
}
inline std::string* SubaccountBalance::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalance.subaccount_id)
  return _s;
}
inline const std::string& SubaccountBalance::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountBalance::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalance::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalance::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalance.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountBalance::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalance.subaccount_id)
}

// string account_address = 2 [json_name = "accountAddress"];
inline void SubaccountBalance::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& SubaccountBalance::account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalance.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalance::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalance.account_address)
}
inline std::string* SubaccountBalance::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalance.account_address)
  return _s;
}
inline const std::string& SubaccountBalance::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void SubaccountBalance::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalance::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalance::release_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalance.account_address)
  return _impl_.account_address_.Release();
}
inline void SubaccountBalance::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalance.account_address)
}

// string denom = 3 [json_name = "denom"];
inline void SubaccountBalance::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& SubaccountBalance::denom() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalance.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalance::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalance.denom)
}
inline std::string* SubaccountBalance::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalance.denom)
  return _s;
}
inline const std::string& SubaccountBalance::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void SubaccountBalance::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalance::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalance::release_denom() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalance.denom)
  return _impl_.denom_.Release();
}
inline void SubaccountBalance::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalance.denom)
}

// .injective_accounts_rpc.SubaccountDeposit deposit = 4 [json_name = "deposit"];
inline bool SubaccountBalance::has_deposit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deposit_ != nullptr);
  return value;
}
inline void SubaccountBalance::clear_deposit() {
  if (_impl_.deposit_ != nullptr) _impl_.deposit_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::SubaccountDeposit& SubaccountBalance::_internal_deposit() const {
  const ::injective_accounts_rpc::SubaccountDeposit* p = _impl_.deposit_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::SubaccountDeposit&>(
      ::injective_accounts_rpc::_SubaccountDeposit_default_instance_);
}
inline const ::injective_accounts_rpc::SubaccountDeposit& SubaccountBalance::deposit() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalance.deposit)
  return _internal_deposit();
}
inline void SubaccountBalance::unsafe_arena_set_allocated_deposit(
    ::injective_accounts_rpc::SubaccountDeposit* deposit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deposit_);
  }
  _impl_.deposit_ = deposit;
  if (deposit) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.SubaccountBalance.deposit)
}
inline ::injective_accounts_rpc::SubaccountDeposit* SubaccountBalance::release_deposit() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountDeposit* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::SubaccountDeposit* SubaccountBalance::unsafe_arena_release_deposit() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalance.deposit)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountDeposit* temp = _impl_.deposit_;
  _impl_.deposit_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::SubaccountDeposit* SubaccountBalance::_internal_mutable_deposit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deposit_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::SubaccountDeposit>(GetArenaForAllocation());
    _impl_.deposit_ = p;
  }
  return _impl_.deposit_;
}
inline ::injective_accounts_rpc::SubaccountDeposit* SubaccountBalance::mutable_deposit() {
  ::injective_accounts_rpc::SubaccountDeposit* _msg = _internal_mutable_deposit();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalance.deposit)
  return _msg;
}
inline void SubaccountBalance::set_allocated_deposit(::injective_accounts_rpc::SubaccountDeposit* deposit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deposit_;
  }
  if (deposit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deposit);
    if (message_arena != submessage_arena) {
      deposit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deposit, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deposit_ = deposit;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalance.deposit)
}

// -------------------------------------------------------------------

// SubaccountDeposit

// string total_balance = 1 [json_name = "totalBalance"];
inline void SubaccountDeposit::clear_total_balance() {
  _impl_.total_balance_.ClearToEmpty();
}
inline const std::string& SubaccountDeposit::total_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountDeposit.total_balance)
  return _internal_total_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountDeposit::set_total_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountDeposit.total_balance)
}
inline std::string* SubaccountDeposit::mutable_total_balance() {
  std::string* _s = _internal_mutable_total_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountDeposit.total_balance)
  return _s;
}
inline const std::string& SubaccountDeposit::_internal_total_balance() const {
  return _impl_.total_balance_.Get();
}
inline void SubaccountDeposit::_internal_set_total_balance(const std::string& value) {
  ;


  _impl_.total_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::_internal_mutable_total_balance() {
  ;
  return _impl_.total_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::release_total_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountDeposit.total_balance)
  return _impl_.total_balance_.Release();
}
inline void SubaccountDeposit::set_allocated_total_balance(std::string* value) {
  _impl_.total_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_balance_.IsDefault()) {
          _impl_.total_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountDeposit.total_balance)
}

// string available_balance = 2 [json_name = "availableBalance"];
inline void SubaccountDeposit::clear_available_balance() {
  _impl_.available_balance_.ClearToEmpty();
}
inline const std::string& SubaccountDeposit::available_balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountDeposit.available_balance)
  return _internal_available_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountDeposit::set_available_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.available_balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountDeposit.available_balance)
}
inline std::string* SubaccountDeposit::mutable_available_balance() {
  std::string* _s = _internal_mutable_available_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountDeposit.available_balance)
  return _s;
}
inline const std::string& SubaccountDeposit::_internal_available_balance() const {
  return _impl_.available_balance_.Get();
}
inline void SubaccountDeposit::_internal_set_available_balance(const std::string& value) {
  ;


  _impl_.available_balance_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::_internal_mutable_available_balance() {
  ;
  return _impl_.available_balance_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountDeposit::release_available_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountDeposit.available_balance)
  return _impl_.available_balance_.Release();
}
inline void SubaccountDeposit::set_allocated_available_balance(std::string* value) {
  _impl_.available_balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.available_balance_.IsDefault()) {
          _impl_.available_balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountDeposit.available_balance)
}

// -------------------------------------------------------------------

// SubaccountBalanceRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountBalanceRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id)
}
inline std::string* SubaccountBalanceRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountBalanceRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountBalanceRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountBalanceRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceRequest.subaccount_id)
}

// string denom = 2 [json_name = "denom"];
inline void SubaccountBalanceRequest::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceRequest::denom() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceRequest.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceRequest::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceRequest.denom)
}
inline std::string* SubaccountBalanceRequest::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceRequest.denom)
  return _s;
}
inline const std::string& SubaccountBalanceRequest::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void SubaccountBalanceRequest::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceRequest::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceRequest::release_denom() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceRequest.denom)
  return _impl_.denom_.Release();
}
inline void SubaccountBalanceRequest::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceRequest.denom)
}

// -------------------------------------------------------------------

// SubaccountBalanceResponse

// .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
inline bool SubaccountBalanceResponse::has_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.balance_ != nullptr);
  return value;
}
inline void SubaccountBalanceResponse::clear_balance() {
  if (_impl_.balance_ != nullptr) _impl_.balance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::SubaccountBalance& SubaccountBalanceResponse::_internal_balance() const {
  const ::injective_accounts_rpc::SubaccountBalance* p = _impl_.balance_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::SubaccountBalance&>(
      ::injective_accounts_rpc::_SubaccountBalance_default_instance_);
}
inline const ::injective_accounts_rpc::SubaccountBalance& SubaccountBalanceResponse::balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceResponse.balance)
  return _internal_balance();
}
inline void SubaccountBalanceResponse::unsafe_arena_set_allocated_balance(
    ::injective_accounts_rpc::SubaccountBalance* balance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.balance_);
  }
  _impl_.balance_ = balance;
  if (balance) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.SubaccountBalanceResponse.balance)
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalanceResponse::release_balance() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountBalance* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalanceResponse::unsafe_arena_release_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceResponse.balance)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountBalance* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalanceResponse::_internal_mutable_balance() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalance>(GetArenaForAllocation());
    _impl_.balance_ = p;
  }
  return _impl_.balance_;
}
inline ::injective_accounts_rpc::SubaccountBalance* SubaccountBalanceResponse::mutable_balance() {
  ::injective_accounts_rpc::SubaccountBalance* _msg = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceResponse.balance)
  return _msg;
}
inline void SubaccountBalanceResponse::set_allocated_balance(::injective_accounts_rpc::SubaccountBalance* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.balance_;
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(balance);
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceResponse.balance)
}

// -------------------------------------------------------------------

// StreamSubaccountBalanceRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void StreamSubaccountBalanceRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& StreamSubaccountBalanceRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamSubaccountBalanceRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id)
}
inline std::string* StreamSubaccountBalanceRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id)
  return _s;
}
inline const std::string& StreamSubaccountBalanceRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void StreamSubaccountBalanceRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamSubaccountBalanceRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamSubaccountBalanceRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void StreamSubaccountBalanceRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.StreamSubaccountBalanceRequest.subaccount_id)
}

// repeated string denoms = 2 [json_name = "denoms"];
inline int StreamSubaccountBalanceRequest::_internal_denoms_size() const {
  return _impl_.denoms_.size();
}
inline int StreamSubaccountBalanceRequest::denoms_size() const {
  return _internal_denoms_size();
}
inline void StreamSubaccountBalanceRequest::clear_denoms() {
  _internal_mutable_denoms()->Clear();
}
inline std::string* StreamSubaccountBalanceRequest::add_denoms() {
  std::string* _s = _internal_add_denoms();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
  return _s;
}
inline const std::string& StreamSubaccountBalanceRequest::denoms(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
  return _internal_denoms(index);
}
inline std::string* StreamSubaccountBalanceRequest::mutable_denoms(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
  return _internal_mutable_denoms()->Mutable(index);
}
inline void StreamSubaccountBalanceRequest::set_denoms(int index, const std::string& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::set_denoms(int index, std::string&& value) {
  _internal_mutable_denoms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::set_denoms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::set_denoms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_denoms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::set_denoms(int index, absl::string_view value) {
  _internal_mutable_denoms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::add_denoms(const std::string& value) {
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::add_denoms(std::string&& value) {
  _internal_mutable_denoms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::add_denoms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_denoms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::add_denoms(const char* value, std::size_t size) {
  _internal_mutable_denoms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline void StreamSubaccountBalanceRequest::add_denoms(absl::string_view value) {
  _internal_mutable_denoms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamSubaccountBalanceRequest::denoms() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
  return _internal_denoms();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* StreamSubaccountBalanceRequest::mutable_denoms() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.StreamSubaccountBalanceRequest.denoms)
  return _internal_mutable_denoms();
}
inline const std::string& StreamSubaccountBalanceRequest::_internal_denoms(int index) const {
  return _internal_denoms().Get(index);
}
inline std::string* StreamSubaccountBalanceRequest::_internal_add_denoms() {
  return _internal_mutable_denoms()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamSubaccountBalanceRequest::_internal_denoms() const {
  return _impl_.denoms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamSubaccountBalanceRequest::_internal_mutable_denoms() {
  return &_impl_.denoms_;
}

// -------------------------------------------------------------------

// StreamSubaccountBalanceResponse

// .injective_accounts_rpc.SubaccountBalance balance = 1 [json_name = "balance"];
inline bool StreamSubaccountBalanceResponse::has_balance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.balance_ != nullptr);
  return value;
}
inline void StreamSubaccountBalanceResponse::clear_balance() {
  if (_impl_.balance_ != nullptr) _impl_.balance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::SubaccountBalance& StreamSubaccountBalanceResponse::_internal_balance() const {
  const ::injective_accounts_rpc::SubaccountBalance* p = _impl_.balance_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::SubaccountBalance&>(
      ::injective_accounts_rpc::_SubaccountBalance_default_instance_);
}
inline const ::injective_accounts_rpc::SubaccountBalance& StreamSubaccountBalanceResponse::balance() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.StreamSubaccountBalanceResponse.balance)
  return _internal_balance();
}
inline void StreamSubaccountBalanceResponse::unsafe_arena_set_allocated_balance(
    ::injective_accounts_rpc::SubaccountBalance* balance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.balance_);
  }
  _impl_.balance_ = balance;
  if (balance) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.StreamSubaccountBalanceResponse.balance)
}
inline ::injective_accounts_rpc::SubaccountBalance* StreamSubaccountBalanceResponse::release_balance() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountBalance* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::SubaccountBalance* StreamSubaccountBalanceResponse::unsafe_arena_release_balance() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.StreamSubaccountBalanceResponse.balance)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::SubaccountBalance* temp = _impl_.balance_;
  _impl_.balance_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::SubaccountBalance* StreamSubaccountBalanceResponse::_internal_mutable_balance() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.balance_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::SubaccountBalance>(GetArenaForAllocation());
    _impl_.balance_ = p;
  }
  return _impl_.balance_;
}
inline ::injective_accounts_rpc::SubaccountBalance* StreamSubaccountBalanceResponse::mutable_balance() {
  ::injective_accounts_rpc::SubaccountBalance* _msg = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.StreamSubaccountBalanceResponse.balance)
  return _msg;
}
inline void StreamSubaccountBalanceResponse::set_allocated_balance(::injective_accounts_rpc::SubaccountBalance* balance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.balance_;
  }
  if (balance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(balance);
    if (message_arena != submessage_arena) {
      balance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, balance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.balance_ = balance;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.StreamSubaccountBalanceResponse.balance)
}

// sint64 timestamp = 2 [json_name = "timestamp"];
inline void StreamSubaccountBalanceResponse::clear_timestamp() {
  _impl_.timestamp_ = ::int64_t{0};
}
inline ::int64_t StreamSubaccountBalanceResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.StreamSubaccountBalanceResponse.timestamp)
  return _internal_timestamp();
}
inline void StreamSubaccountBalanceResponse::set_timestamp(::int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.StreamSubaccountBalanceResponse.timestamp)
}
inline ::int64_t StreamSubaccountBalanceResponse::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline void StreamSubaccountBalanceResponse::_internal_set_timestamp(::int64_t value) {
  ;
  _impl_.timestamp_ = value;
}

// -------------------------------------------------------------------

// SubaccountHistoryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountHistoryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountHistoryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountHistoryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id)
}
inline std::string* SubaccountHistoryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountHistoryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountHistoryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountHistoryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountHistoryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountHistoryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountHistoryRequest.subaccount_id)
}

// string denom = 2 [json_name = "denom"];
inline void SubaccountHistoryRequest::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& SubaccountHistoryRequest::denom() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountHistoryRequest::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.denom)
}
inline std::string* SubaccountHistoryRequest::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountHistoryRequest.denom)
  return _s;
}
inline const std::string& SubaccountHistoryRequest::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void SubaccountHistoryRequest::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountHistoryRequest::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountHistoryRequest::release_denom() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountHistoryRequest.denom)
  return _impl_.denom_.Release();
}
inline void SubaccountHistoryRequest::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountHistoryRequest.denom)
}

// repeated string transfer_types = 3 [json_name = "transferTypes"];
inline int SubaccountHistoryRequest::_internal_transfer_types_size() const {
  return _impl_.transfer_types_.size();
}
inline int SubaccountHistoryRequest::transfer_types_size() const {
  return _internal_transfer_types_size();
}
inline void SubaccountHistoryRequest::clear_transfer_types() {
  _internal_mutable_transfer_types()->Clear();
}
inline std::string* SubaccountHistoryRequest::add_transfer_types() {
  std::string* _s = _internal_add_transfer_types();
  // @@protoc_insertion_point(field_add_mutable:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
  return _s;
}
inline const std::string& SubaccountHistoryRequest::transfer_types(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
  return _internal_transfer_types(index);
}
inline std::string* SubaccountHistoryRequest::mutable_transfer_types(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
  return _internal_mutable_transfer_types()->Mutable(index);
}
inline void SubaccountHistoryRequest::set_transfer_types(int index, const std::string& value) {
  _internal_mutable_transfer_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::set_transfer_types(int index, std::string&& value) {
  _internal_mutable_transfer_types()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::set_transfer_types(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transfer_types()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::set_transfer_types(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_transfer_types()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::set_transfer_types(int index, absl::string_view value) {
  _internal_mutable_transfer_types()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::add_transfer_types(const std::string& value) {
  _internal_mutable_transfer_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::add_transfer_types(std::string&& value) {
  _internal_mutable_transfer_types()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::add_transfer_types(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_transfer_types()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::add_transfer_types(const char* value, std::size_t size) {
  _internal_mutable_transfer_types()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline void SubaccountHistoryRequest::add_transfer_types(absl::string_view value) {
  _internal_mutable_transfer_types()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountHistoryRequest::transfer_types() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
  return _internal_transfer_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SubaccountHistoryRequest::mutable_transfer_types() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.SubaccountHistoryRequest.transfer_types)
  return _internal_mutable_transfer_types();
}
inline const std::string& SubaccountHistoryRequest::_internal_transfer_types(int index) const {
  return _internal_transfer_types().Get(index);
}
inline std::string* SubaccountHistoryRequest::_internal_add_transfer_types() {
  return _internal_mutable_transfer_types()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubaccountHistoryRequest::_internal_transfer_types() const {
  return _impl_.transfer_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubaccountHistoryRequest::_internal_mutable_transfer_types() {
  return &_impl_.transfer_types_;
}

// uint64 skip = 4 [json_name = "skip"];
inline void SubaccountHistoryRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t SubaccountHistoryRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.skip)
  return _internal_skip();
}
inline void SubaccountHistoryRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.skip)
}
inline ::uint64_t SubaccountHistoryRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void SubaccountHistoryRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint32 limit = 5 [json_name = "limit"];
inline void SubaccountHistoryRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t SubaccountHistoryRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.limit)
  return _internal_limit();
}
inline void SubaccountHistoryRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.limit)
}
inline ::int32_t SubaccountHistoryRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void SubaccountHistoryRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 end_time = 6 [json_name = "endTime"];
inline void SubaccountHistoryRequest::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
}
inline ::int64_t SubaccountHistoryRequest::end_time() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryRequest.end_time)
  return _internal_end_time();
}
inline void SubaccountHistoryRequest::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountHistoryRequest.end_time)
}
inline ::int64_t SubaccountHistoryRequest::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void SubaccountHistoryRequest::_internal_set_end_time(::int64_t value) {
  ;
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// SubaccountHistoryResponse

// repeated .injective_accounts_rpc.SubaccountBalanceTransfer transfers = 1 [json_name = "transfers"];
inline int SubaccountHistoryResponse::_internal_transfers_size() const {
  return _impl_.transfers_.size();
}
inline int SubaccountHistoryResponse::transfers_size() const {
  return _internal_transfers_size();
}
inline void SubaccountHistoryResponse::clear_transfers() {
  _internal_mutable_transfers()->Clear();
}
inline ::injective_accounts_rpc::SubaccountBalanceTransfer* SubaccountHistoryResponse::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountHistoryResponse.transfers)
  return _internal_mutable_transfers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalanceTransfer >*
SubaccountHistoryResponse::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.SubaccountHistoryResponse.transfers)
  return _internal_mutable_transfers();
}
inline const ::injective_accounts_rpc::SubaccountBalanceTransfer& SubaccountHistoryResponse::_internal_transfers(int index) const {
  return _internal_transfers().Get(index);
}
inline const ::injective_accounts_rpc::SubaccountBalanceTransfer& SubaccountHistoryResponse::transfers(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryResponse.transfers)
  return _internal_transfers(index);
}
inline ::injective_accounts_rpc::SubaccountBalanceTransfer* SubaccountHistoryResponse::_internal_add_transfers() {
  return _internal_mutable_transfers()->Add();
}
inline ::injective_accounts_rpc::SubaccountBalanceTransfer* SubaccountHistoryResponse::add_transfers() {
  ::injective_accounts_rpc::SubaccountBalanceTransfer* _add = _internal_add_transfers();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.SubaccountHistoryResponse.transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::SubaccountBalanceTransfer >&
SubaccountHistoryResponse::transfers() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.SubaccountHistoryResponse.transfers)
  return _internal_transfers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalanceTransfer>&
SubaccountHistoryResponse::_internal_transfers() const {
  return _impl_.transfers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::SubaccountBalanceTransfer>*
SubaccountHistoryResponse::_internal_mutable_transfers() {
  return &_impl_.transfers_;
}

// .injective_accounts_rpc.Paging paging = 2 [json_name = "paging"];
inline bool SubaccountHistoryResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void SubaccountHistoryResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::Paging& SubaccountHistoryResponse::_internal_paging() const {
  const ::injective_accounts_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::Paging&>(
      ::injective_accounts_rpc::_Paging_default_instance_);
}
inline const ::injective_accounts_rpc::Paging& SubaccountHistoryResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountHistoryResponse.paging)
  return _internal_paging();
}
inline void SubaccountHistoryResponse::unsafe_arena_set_allocated_paging(
    ::injective_accounts_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.SubaccountHistoryResponse.paging)
}
inline ::injective_accounts_rpc::Paging* SubaccountHistoryResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::Paging* SubaccountHistoryResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountHistoryResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::Paging* SubaccountHistoryResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_accounts_rpc::Paging* SubaccountHistoryResponse::mutable_paging() {
  ::injective_accounts_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountHistoryResponse.paging)
  return _msg;
}
inline void SubaccountHistoryResponse::set_allocated_paging(::injective_accounts_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountHistoryResponse.paging)
}

// -------------------------------------------------------------------

// SubaccountBalanceTransfer

// string transfer_type = 1 [json_name = "transferType"];
inline void SubaccountBalanceTransfer::clear_transfer_type() {
  _impl_.transfer_type_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceTransfer::transfer_type() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type)
  return _internal_transfer_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceTransfer::set_transfer_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.transfer_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type)
}
inline std::string* SubaccountBalanceTransfer::mutable_transfer_type() {
  std::string* _s = _internal_mutable_transfer_type();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type)
  return _s;
}
inline const std::string& SubaccountBalanceTransfer::_internal_transfer_type() const {
  return _impl_.transfer_type_.Get();
}
inline void SubaccountBalanceTransfer::_internal_set_transfer_type(const std::string& value) {
  ;


  _impl_.transfer_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::_internal_mutable_transfer_type() {
  ;
  return _impl_.transfer_type_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::release_transfer_type() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type)
  return _impl_.transfer_type_.Release();
}
inline void SubaccountBalanceTransfer::set_allocated_transfer_type(std::string* value) {
  _impl_.transfer_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transfer_type_.IsDefault()) {
          _impl_.transfer_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.transfer_type)
}

// string src_subaccount_id = 2 [json_name = "srcSubaccountId"];
inline void SubaccountBalanceTransfer::clear_src_subaccount_id() {
  _impl_.src_subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceTransfer::src_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id)
  return _internal_src_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceTransfer::set_src_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id)
}
inline std::string* SubaccountBalanceTransfer::mutable_src_subaccount_id() {
  std::string* _s = _internal_mutable_src_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id)
  return _s;
}
inline const std::string& SubaccountBalanceTransfer::_internal_src_subaccount_id() const {
  return _impl_.src_subaccount_id_.Get();
}
inline void SubaccountBalanceTransfer::_internal_set_src_subaccount_id(const std::string& value) {
  ;


  _impl_.src_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::_internal_mutable_src_subaccount_id() {
  ;
  return _impl_.src_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::release_src_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id)
  return _impl_.src_subaccount_id_.Release();
}
inline void SubaccountBalanceTransfer::set_allocated_src_subaccount_id(std::string* value) {
  _impl_.src_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_subaccount_id_.IsDefault()) {
          _impl_.src_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.src_subaccount_id)
}

// string src_account_address = 3 [json_name = "srcAccountAddress"];
inline void SubaccountBalanceTransfer::clear_src_account_address() {
  _impl_.src_account_address_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceTransfer::src_account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address)
  return _internal_src_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceTransfer::set_src_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address)
}
inline std::string* SubaccountBalanceTransfer::mutable_src_account_address() {
  std::string* _s = _internal_mutable_src_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address)
  return _s;
}
inline const std::string& SubaccountBalanceTransfer::_internal_src_account_address() const {
  return _impl_.src_account_address_.Get();
}
inline void SubaccountBalanceTransfer::_internal_set_src_account_address(const std::string& value) {
  ;


  _impl_.src_account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::_internal_mutable_src_account_address() {
  ;
  return _impl_.src_account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::release_src_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address)
  return _impl_.src_account_address_.Release();
}
inline void SubaccountBalanceTransfer::set_allocated_src_account_address(std::string* value) {
  _impl_.src_account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_account_address_.IsDefault()) {
          _impl_.src_account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.src_account_address)
}

// string dst_subaccount_id = 4 [json_name = "dstSubaccountId"];
inline void SubaccountBalanceTransfer::clear_dst_subaccount_id() {
  _impl_.dst_subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceTransfer::dst_subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id)
  return _internal_dst_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceTransfer::set_dst_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dst_subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id)
}
inline std::string* SubaccountBalanceTransfer::mutable_dst_subaccount_id() {
  std::string* _s = _internal_mutable_dst_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id)
  return _s;
}
inline const std::string& SubaccountBalanceTransfer::_internal_dst_subaccount_id() const {
  return _impl_.dst_subaccount_id_.Get();
}
inline void SubaccountBalanceTransfer::_internal_set_dst_subaccount_id(const std::string& value) {
  ;


  _impl_.dst_subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::_internal_mutable_dst_subaccount_id() {
  ;
  return _impl_.dst_subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::release_dst_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id)
  return _impl_.dst_subaccount_id_.Release();
}
inline void SubaccountBalanceTransfer::set_allocated_dst_subaccount_id(std::string* value) {
  _impl_.dst_subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_subaccount_id_.IsDefault()) {
          _impl_.dst_subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.dst_subaccount_id)
}

// string dst_account_address = 5 [json_name = "dstAccountAddress"];
inline void SubaccountBalanceTransfer::clear_dst_account_address() {
  _impl_.dst_account_address_.ClearToEmpty();
}
inline const std::string& SubaccountBalanceTransfer::dst_account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address)
  return _internal_dst_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountBalanceTransfer::set_dst_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dst_account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address)
}
inline std::string* SubaccountBalanceTransfer::mutable_dst_account_address() {
  std::string* _s = _internal_mutable_dst_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address)
  return _s;
}
inline const std::string& SubaccountBalanceTransfer::_internal_dst_account_address() const {
  return _impl_.dst_account_address_.Get();
}
inline void SubaccountBalanceTransfer::_internal_set_dst_account_address(const std::string& value) {
  ;


  _impl_.dst_account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::_internal_mutable_dst_account_address() {
  ;
  return _impl_.dst_account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountBalanceTransfer::release_dst_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address)
  return _impl_.dst_account_address_.Release();
}
inline void SubaccountBalanceTransfer::set_allocated_dst_account_address(std::string* value) {
  _impl_.dst_account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dst_account_address_.IsDefault()) {
          _impl_.dst_account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.dst_account_address)
}

// .injective_accounts_rpc.CosmosCoin amount = 6 [json_name = "amount"];
inline bool SubaccountBalanceTransfer::has_amount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amount_ != nullptr);
  return value;
}
inline void SubaccountBalanceTransfer::clear_amount() {
  if (_impl_.amount_ != nullptr) _impl_.amount_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_accounts_rpc::CosmosCoin& SubaccountBalanceTransfer::_internal_amount() const {
  const ::injective_accounts_rpc::CosmosCoin* p = _impl_.amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_accounts_rpc::CosmosCoin&>(
      ::injective_accounts_rpc::_CosmosCoin_default_instance_);
}
inline const ::injective_accounts_rpc::CosmosCoin& SubaccountBalanceTransfer::amount() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.amount)
  return _internal_amount();
}
inline void SubaccountBalanceTransfer::unsafe_arena_set_allocated_amount(
    ::injective_accounts_rpc::CosmosCoin* amount) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.amount_);
  }
  _impl_.amount_ = amount;
  if (amount) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.amount)
}
inline ::injective_accounts_rpc::CosmosCoin* SubaccountBalanceTransfer::release_amount() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::CosmosCoin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_accounts_rpc::CosmosCoin* SubaccountBalanceTransfer::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountBalanceTransfer.amount)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_accounts_rpc::CosmosCoin* temp = _impl_.amount_;
  _impl_.amount_ = nullptr;
  return temp;
}
inline ::injective_accounts_rpc::CosmosCoin* SubaccountBalanceTransfer::_internal_mutable_amount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_accounts_rpc::CosmosCoin>(GetArenaForAllocation());
    _impl_.amount_ = p;
  }
  return _impl_.amount_;
}
inline ::injective_accounts_rpc::CosmosCoin* SubaccountBalanceTransfer::mutable_amount() {
  ::injective_accounts_rpc::CosmosCoin* _msg = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountBalanceTransfer.amount)
  return _msg;
}
inline void SubaccountBalanceTransfer::set_allocated_amount(::injective_accounts_rpc::CosmosCoin* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(amount);
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountBalanceTransfer.amount)
}

// sint64 executed_at = 7 [json_name = "executedAt"];
inline void SubaccountBalanceTransfer::clear_executed_at() {
  _impl_.executed_at_ = ::int64_t{0};
}
inline ::int64_t SubaccountBalanceTransfer::executed_at() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountBalanceTransfer.executed_at)
  return _internal_executed_at();
}
inline void SubaccountBalanceTransfer::set_executed_at(::int64_t value) {
  _internal_set_executed_at(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountBalanceTransfer.executed_at)
}
inline ::int64_t SubaccountBalanceTransfer::_internal_executed_at() const {
  return _impl_.executed_at_;
}
inline void SubaccountBalanceTransfer::_internal_set_executed_at(::int64_t value) {
  ;
  _impl_.executed_at_ = value;
}

// -------------------------------------------------------------------

// CosmosCoin

// string denom = 1 [json_name = "denom"];
inline void CosmosCoin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& CosmosCoin::denom() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.CosmosCoin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.CosmosCoin.denom)
}
inline std::string* CosmosCoin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.CosmosCoin.denom)
  return _s;
}
inline const std::string& CosmosCoin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void CosmosCoin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_denom() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.CosmosCoin.denom)
  return _impl_.denom_.Release();
}
inline void CosmosCoin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.CosmosCoin.denom)
}

// string amount = 2 [json_name = "amount"];
inline void CosmosCoin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& CosmosCoin::amount() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.CosmosCoin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.CosmosCoin.amount)
}
inline std::string* CosmosCoin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.CosmosCoin.amount)
  return _s;
}
inline const std::string& CosmosCoin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void CosmosCoin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_amount() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.CosmosCoin.amount)
  return _impl_.amount_.Release();
}
inline void CosmosCoin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.CosmosCoin.amount)
}

// -------------------------------------------------------------------

// Paging

// sint64 total = 1 [json_name = "total"];
inline void Paging::clear_total() {
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t Paging::total() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Paging.total)
  return _internal_total();
}
inline void Paging::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Paging.total)
}
inline ::int64_t Paging::_internal_total() const {
  return _impl_.total_;
}
inline void Paging::_internal_set_total(::int64_t value) {
  ;
  _impl_.total_ = value;
}

// sint32 from = 2 [json_name = "from"];
inline void Paging::clear_from() {
  _impl_.from_ = 0;
}
inline ::int32_t Paging::from() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Paging.from)
  return _internal_from();
}
inline void Paging::set_from(::int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Paging.from)
}
inline ::int32_t Paging::_internal_from() const {
  return _impl_.from_;
}
inline void Paging::_internal_set_from(::int32_t value) {
  ;
  _impl_.from_ = value;
}

// sint32 to = 3 [json_name = "to"];
inline void Paging::clear_to() {
  _impl_.to_ = 0;
}
inline ::int32_t Paging::to() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Paging.to)
  return _internal_to();
}
inline void Paging::set_to(::int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Paging.to)
}
inline ::int32_t Paging::_internal_to() const {
  return _impl_.to_;
}
inline void Paging::_internal_set_to(::int32_t value) {
  ;
  _impl_.to_ = value;
}

// sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
inline void Paging::clear_count_by_subaccount() {
  _impl_.count_by_subaccount_ = ::int64_t{0};
}
inline ::int64_t Paging::count_by_subaccount() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Paging.count_by_subaccount)
  return _internal_count_by_subaccount();
}
inline void Paging::set_count_by_subaccount(::int64_t value) {
  _internal_set_count_by_subaccount(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Paging.count_by_subaccount)
}
inline ::int64_t Paging::_internal_count_by_subaccount() const {
  return _impl_.count_by_subaccount_;
}
inline void Paging::_internal_set_count_by_subaccount(::int64_t value) {
  ;
  _impl_.count_by_subaccount_ = value;
}

// -------------------------------------------------------------------

// SubaccountOrderSummaryRequest

// string subaccount_id = 1 [json_name = "subaccountId"];
inline void SubaccountOrderSummaryRequest::clear_subaccount_id() {
  _impl_.subaccount_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrderSummaryRequest::subaccount_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id)
  return _internal_subaccount_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderSummaryRequest::set_subaccount_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.subaccount_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id)
}
inline std::string* SubaccountOrderSummaryRequest::mutable_subaccount_id() {
  std::string* _s = _internal_mutable_subaccount_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id)
  return _s;
}
inline const std::string& SubaccountOrderSummaryRequest::_internal_subaccount_id() const {
  return _impl_.subaccount_id_.Get();
}
inline void SubaccountOrderSummaryRequest::_internal_set_subaccount_id(const std::string& value) {
  ;


  _impl_.subaccount_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::_internal_mutable_subaccount_id() {
  ;
  return _impl_.subaccount_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::release_subaccount_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id)
  return _impl_.subaccount_id_.Release();
}
inline void SubaccountOrderSummaryRequest::set_allocated_subaccount_id(std::string* value) {
  _impl_.subaccount_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subaccount_id_.IsDefault()) {
          _impl_.subaccount_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountOrderSummaryRequest.subaccount_id)
}

// string market_id = 2 [json_name = "marketId"];
inline void SubaccountOrderSummaryRequest::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& SubaccountOrderSummaryRequest::market_id() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderSummaryRequest::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id)
}
inline std::string* SubaccountOrderSummaryRequest::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id)
  return _s;
}
inline const std::string& SubaccountOrderSummaryRequest::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void SubaccountOrderSummaryRequest::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id)
  return _impl_.market_id_.Release();
}
inline void SubaccountOrderSummaryRequest::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountOrderSummaryRequest.market_id)
}

// string order_direction = 3 [json_name = "orderDirection"];
inline void SubaccountOrderSummaryRequest::clear_order_direction() {
  _impl_.order_direction_.ClearToEmpty();
}
inline const std::string& SubaccountOrderSummaryRequest::order_direction() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction)
  return _internal_order_direction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubaccountOrderSummaryRequest::set_order_direction(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.order_direction_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction)
}
inline std::string* SubaccountOrderSummaryRequest::mutable_order_direction() {
  std::string* _s = _internal_mutable_order_direction();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction)
  return _s;
}
inline const std::string& SubaccountOrderSummaryRequest::_internal_order_direction() const {
  return _impl_.order_direction_.Get();
}
inline void SubaccountOrderSummaryRequest::_internal_set_order_direction(const std::string& value) {
  ;


  _impl_.order_direction_.Set(value, GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::_internal_mutable_order_direction() {
  ;
  return _impl_.order_direction_.Mutable( GetArenaForAllocation());
}
inline std::string* SubaccountOrderSummaryRequest::release_order_direction() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction)
  return _impl_.order_direction_.Release();
}
inline void SubaccountOrderSummaryRequest::set_allocated_order_direction(std::string* value) {
  _impl_.order_direction_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.order_direction_.IsDefault()) {
          _impl_.order_direction_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.SubaccountOrderSummaryRequest.order_direction)
}

// -------------------------------------------------------------------

// SubaccountOrderSummaryResponse

// sint64 spot_orders_total = 1 [json_name = "spotOrdersTotal"];
inline void SubaccountOrderSummaryResponse::clear_spot_orders_total() {
  _impl_.spot_orders_total_ = ::int64_t{0};
}
inline ::int64_t SubaccountOrderSummaryResponse::spot_orders_total() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountOrderSummaryResponse.spot_orders_total)
  return _internal_spot_orders_total();
}
inline void SubaccountOrderSummaryResponse::set_spot_orders_total(::int64_t value) {
  _internal_set_spot_orders_total(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountOrderSummaryResponse.spot_orders_total)
}
inline ::int64_t SubaccountOrderSummaryResponse::_internal_spot_orders_total() const {
  return _impl_.spot_orders_total_;
}
inline void SubaccountOrderSummaryResponse::_internal_set_spot_orders_total(::int64_t value) {
  ;
  _impl_.spot_orders_total_ = value;
}

// sint64 derivative_orders_total = 2 [json_name = "derivativeOrdersTotal"];
inline void SubaccountOrderSummaryResponse::clear_derivative_orders_total() {
  _impl_.derivative_orders_total_ = ::int64_t{0};
}
inline ::int64_t SubaccountOrderSummaryResponse::derivative_orders_total() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.SubaccountOrderSummaryResponse.derivative_orders_total)
  return _internal_derivative_orders_total();
}
inline void SubaccountOrderSummaryResponse::set_derivative_orders_total(::int64_t value) {
  _internal_set_derivative_orders_total(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.SubaccountOrderSummaryResponse.derivative_orders_total)
}
inline ::int64_t SubaccountOrderSummaryResponse::_internal_derivative_orders_total() const {
  return _impl_.derivative_orders_total_;
}
inline void SubaccountOrderSummaryResponse::_internal_set_derivative_orders_total(::int64_t value) {
  ;
  _impl_.derivative_orders_total_ = value;
}

// -------------------------------------------------------------------

// RewardsRequest

// sint64 epoch = 1 [json_name = "epoch"];
inline void RewardsRequest::clear_epoch() {
  _impl_.epoch_ = ::int64_t{0};
}
inline ::int64_t RewardsRequest::epoch() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.RewardsRequest.epoch)
  return _internal_epoch();
}
inline void RewardsRequest::set_epoch(::int64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.RewardsRequest.epoch)
}
inline ::int64_t RewardsRequest::_internal_epoch() const {
  return _impl_.epoch_;
}
inline void RewardsRequest::_internal_set_epoch(::int64_t value) {
  ;
  _impl_.epoch_ = value;
}

// string account_address = 2 [json_name = "accountAddress"];
inline void RewardsRequest::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& RewardsRequest::account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.RewardsRequest.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RewardsRequest::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.RewardsRequest.account_address)
}
inline std::string* RewardsRequest::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.RewardsRequest.account_address)
  return _s;
}
inline const std::string& RewardsRequest::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void RewardsRequest::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* RewardsRequest::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* RewardsRequest::release_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.RewardsRequest.account_address)
  return _impl_.account_address_.Release();
}
inline void RewardsRequest::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.RewardsRequest.account_address)
}

// -------------------------------------------------------------------

// RewardsResponse

// repeated .injective_accounts_rpc.Reward rewards = 1 [json_name = "rewards"];
inline int RewardsResponse::_internal_rewards_size() const {
  return _impl_.rewards_.size();
}
inline int RewardsResponse::rewards_size() const {
  return _internal_rewards_size();
}
inline void RewardsResponse::clear_rewards() {
  _internal_mutable_rewards()->Clear();
}
inline ::injective_accounts_rpc::Reward* RewardsResponse::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.RewardsResponse.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Reward >*
RewardsResponse::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.RewardsResponse.rewards)
  return _internal_mutable_rewards();
}
inline const ::injective_accounts_rpc::Reward& RewardsResponse::_internal_rewards(int index) const {
  return _internal_rewards().Get(index);
}
inline const ::injective_accounts_rpc::Reward& RewardsResponse::rewards(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.RewardsResponse.rewards)
  return _internal_rewards(index);
}
inline ::injective_accounts_rpc::Reward* RewardsResponse::_internal_add_rewards() {
  return _internal_mutable_rewards()->Add();
}
inline ::injective_accounts_rpc::Reward* RewardsResponse::add_rewards() {
  ::injective_accounts_rpc::Reward* _add = _internal_add_rewards();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.RewardsResponse.rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Reward >&
RewardsResponse::rewards() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.RewardsResponse.rewards)
  return _internal_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Reward>&
RewardsResponse::_internal_rewards() const {
  return _impl_.rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Reward>*
RewardsResponse::_internal_mutable_rewards() {
  return &_impl_.rewards_;
}

// -------------------------------------------------------------------

// Reward

// string account_address = 1 [json_name = "accountAddress"];
inline void Reward::clear_account_address() {
  _impl_.account_address_.ClearToEmpty();
}
inline const std::string& Reward::account_address() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Reward.account_address)
  return _internal_account_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reward::set_account_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Reward.account_address)
}
inline std::string* Reward::mutable_account_address() {
  std::string* _s = _internal_mutable_account_address();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.Reward.account_address)
  return _s;
}
inline const std::string& Reward::_internal_account_address() const {
  return _impl_.account_address_.Get();
}
inline void Reward::_internal_set_account_address(const std::string& value) {
  ;


  _impl_.account_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Reward::_internal_mutable_account_address() {
  ;
  return _impl_.account_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Reward::release_account_address() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.Reward.account_address)
  return _impl_.account_address_.Release();
}
inline void Reward::set_allocated_account_address(std::string* value) {
  _impl_.account_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_address_.IsDefault()) {
          _impl_.account_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.Reward.account_address)
}

// repeated .injective_accounts_rpc.Coin rewards = 2 [json_name = "rewards"];
inline int Reward::_internal_rewards_size() const {
  return _impl_.rewards_.size();
}
inline int Reward::rewards_size() const {
  return _internal_rewards_size();
}
inline void Reward::clear_rewards() {
  _internal_mutable_rewards()->Clear();
}
inline ::injective_accounts_rpc::Coin* Reward::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.Reward.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Coin >*
Reward::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:injective_accounts_rpc.Reward.rewards)
  return _internal_mutable_rewards();
}
inline const ::injective_accounts_rpc::Coin& Reward::_internal_rewards(int index) const {
  return _internal_rewards().Get(index);
}
inline const ::injective_accounts_rpc::Coin& Reward::rewards(int index) const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Reward.rewards)
  return _internal_rewards(index);
}
inline ::injective_accounts_rpc::Coin* Reward::_internal_add_rewards() {
  return _internal_mutable_rewards()->Add();
}
inline ::injective_accounts_rpc::Coin* Reward::add_rewards() {
  ::injective_accounts_rpc::Coin* _add = _internal_add_rewards();
  // @@protoc_insertion_point(field_add:injective_accounts_rpc.Reward.rewards)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_accounts_rpc::Coin >&
Reward::rewards() const {
  // @@protoc_insertion_point(field_list:injective_accounts_rpc.Reward.rewards)
  return _internal_rewards();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Coin>&
Reward::_internal_rewards() const {
  return _impl_.rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_accounts_rpc::Coin>*
Reward::_internal_mutable_rewards() {
  return &_impl_.rewards_;
}

// sint64 distributed_at = 3 [json_name = "distributedAt"];
inline void Reward::clear_distributed_at() {
  _impl_.distributed_at_ = ::int64_t{0};
}
inline ::int64_t Reward::distributed_at() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Reward.distributed_at)
  return _internal_distributed_at();
}
inline void Reward::set_distributed_at(::int64_t value) {
  _internal_set_distributed_at(value);
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Reward.distributed_at)
}
inline ::int64_t Reward::_internal_distributed_at() const {
  return _impl_.distributed_at_;
}
inline void Reward::_internal_set_distributed_at(::int64_t value) {
  ;
  _impl_.distributed_at_ = value;
}

// -------------------------------------------------------------------

// Coin

// string denom = 1 [json_name = "denom"];
inline void Coin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& Coin::denom() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Coin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Coin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Coin.denom)
}
inline std::string* Coin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.Coin.denom)
  return _s;
}
inline const std::string& Coin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void Coin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* Coin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* Coin::release_denom() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.Coin.denom)
  return _impl_.denom_.Release();
}
inline void Coin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.Coin.denom)
}

// string amount = 2 [json_name = "amount"];
inline void Coin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& Coin::amount() const {
  // @@protoc_insertion_point(field_get:injective_accounts_rpc.Coin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Coin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_accounts_rpc.Coin.amount)
}
inline std::string* Coin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_accounts_rpc.Coin.amount)
  return _s;
}
inline const std::string& Coin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void Coin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* Coin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* Coin::release_amount() {
  // @@protoc_insertion_point(field_release:injective_accounts_rpc.Coin.amount)
  return _impl_.amount_.Release();
}
inline void Coin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_accounts_rpc.Coin.amount)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_accounts_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5faccounts_5frpc_2eproto_2epb_2eh
