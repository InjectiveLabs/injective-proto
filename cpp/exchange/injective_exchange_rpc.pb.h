// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_exchange_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexchange_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexchange_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5fexchange_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5fexchange_5frpc_2eproto;
namespace injective_exchange_rpc {
class BroadcastCosmosTxRequest;
struct BroadcastCosmosTxRequestDefaultTypeInternal;
extern BroadcastCosmosTxRequestDefaultTypeInternal _BroadcastCosmosTxRequest_default_instance_;
class BroadcastCosmosTxResponse;
struct BroadcastCosmosTxResponseDefaultTypeInternal;
extern BroadcastCosmosTxResponseDefaultTypeInternal _BroadcastCosmosTxResponse_default_instance_;
class BroadcastTxRequest;
struct BroadcastTxRequestDefaultTypeInternal;
extern BroadcastTxRequestDefaultTypeInternal _BroadcastTxRequest_default_instance_;
class BroadcastTxResponse;
struct BroadcastTxResponseDefaultTypeInternal;
extern BroadcastTxResponseDefaultTypeInternal _BroadcastTxResponse_default_instance_;
class CosmosCoin;
struct CosmosCoinDefaultTypeInternal;
extern CosmosCoinDefaultTypeInternal _CosmosCoin_default_instance_;
class CosmosPubKey;
struct CosmosPubKeyDefaultTypeInternal;
extern CosmosPubKeyDefaultTypeInternal _CosmosPubKey_default_instance_;
class CosmosTxFee;
struct CosmosTxFeeDefaultTypeInternal;
extern CosmosTxFeeDefaultTypeInternal _CosmosTxFee_default_instance_;
class GetFeePayerRequest;
struct GetFeePayerRequestDefaultTypeInternal;
extern GetFeePayerRequestDefaultTypeInternal _GetFeePayerRequest_default_instance_;
class GetFeePayerResponse;
struct GetFeePayerResponseDefaultTypeInternal;
extern GetFeePayerResponseDefaultTypeInternal _GetFeePayerResponse_default_instance_;
class GetTxRequest;
struct GetTxRequestDefaultTypeInternal;
extern GetTxRequestDefaultTypeInternal _GetTxRequest_default_instance_;
class GetTxResponse;
struct GetTxResponseDefaultTypeInternal;
extern GetTxResponseDefaultTypeInternal _GetTxResponse_default_instance_;
class PrepareCosmosTxRequest;
struct PrepareCosmosTxRequestDefaultTypeInternal;
extern PrepareCosmosTxRequestDefaultTypeInternal _PrepareCosmosTxRequest_default_instance_;
class PrepareCosmosTxResponse;
struct PrepareCosmosTxResponseDefaultTypeInternal;
extern PrepareCosmosTxResponseDefaultTypeInternal _PrepareCosmosTxResponse_default_instance_;
class PrepareTxRequest;
struct PrepareTxRequestDefaultTypeInternal;
extern PrepareTxRequestDefaultTypeInternal _PrepareTxRequest_default_instance_;
class PrepareTxResponse;
struct PrepareTxResponseDefaultTypeInternal;
extern PrepareTxResponseDefaultTypeInternal _PrepareTxResponse_default_instance_;
}  // namespace injective_exchange_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_exchange_rpc::BroadcastCosmosTxRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::BroadcastCosmosTxRequest>(Arena*);
template <>
::injective_exchange_rpc::BroadcastCosmosTxResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::BroadcastCosmosTxResponse>(Arena*);
template <>
::injective_exchange_rpc::BroadcastTxRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::BroadcastTxRequest>(Arena*);
template <>
::injective_exchange_rpc::BroadcastTxResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::BroadcastTxResponse>(Arena*);
template <>
::injective_exchange_rpc::CosmosCoin* Arena::CreateMaybeMessage<::injective_exchange_rpc::CosmosCoin>(Arena*);
template <>
::injective_exchange_rpc::CosmosPubKey* Arena::CreateMaybeMessage<::injective_exchange_rpc::CosmosPubKey>(Arena*);
template <>
::injective_exchange_rpc::CosmosTxFee* Arena::CreateMaybeMessage<::injective_exchange_rpc::CosmosTxFee>(Arena*);
template <>
::injective_exchange_rpc::GetFeePayerRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::GetFeePayerRequest>(Arena*);
template <>
::injective_exchange_rpc::GetFeePayerResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::GetFeePayerResponse>(Arena*);
template <>
::injective_exchange_rpc::GetTxRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::GetTxRequest>(Arena*);
template <>
::injective_exchange_rpc::GetTxResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::GetTxResponse>(Arena*);
template <>
::injective_exchange_rpc::PrepareCosmosTxRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::PrepareCosmosTxRequest>(Arena*);
template <>
::injective_exchange_rpc::PrepareCosmosTxResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::PrepareCosmosTxResponse>(Arena*);
template <>
::injective_exchange_rpc::PrepareTxRequest* Arena::CreateMaybeMessage<::injective_exchange_rpc::PrepareTxRequest>(Arena*);
template <>
::injective_exchange_rpc::PrepareTxResponse* Arena::CreateMaybeMessage<::injective_exchange_rpc::PrepareTxResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_exchange_rpc {

// ===================================================================


// -------------------------------------------------------------------

class GetTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.GetTxRequest) */ {
 public:
  inline GetTxRequest() : GetTxRequest(nullptr) {}
  ~GetTxRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxRequest(const GetTxRequest& from);
  GetTxRequest(GetTxRequest&& from) noexcept
    : GetTxRequest() {
    *this = ::std::move(from);
  }

  inline GetTxRequest& operator=(const GetTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxRequest& operator=(GetTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxRequest* internal_default_instance() {
    return reinterpret_cast<const GetTxRequest*>(
               &_GetTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetTxRequest& a, GetTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxRequest& from) {
    GetTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.GetTxRequest";
  }
  protected:
  explicit GetTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // string hash = 1 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.GetTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetTxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.GetTxResponse) */ {
 public:
  inline GetTxResponse() : GetTxResponse(nullptr) {}
  ~GetTxResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxResponse(const GetTxResponse& from);
  GetTxResponse(GetTxResponse&& from) noexcept
    : GetTxResponse() {
    *this = ::std::move(from);
  }

  inline GetTxResponse& operator=(const GetTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxResponse& operator=(GetTxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxResponse* internal_default_instance() {
    return reinterpret_cast<const GetTxResponse*>(
               &_GetTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetTxResponse& a, GetTxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxResponse& from) {
    GetTxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.GetTxResponse";
  }
  protected:
  explicit GetTxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 1,
    kCodespaceFieldNumber = 4,
    kDataFieldNumber = 6,
    kRawLogFieldNumber = 7,
    kTimestampFieldNumber = 8,
    kHeightFieldNumber = 2,
    kIndexFieldNumber = 3,
    kCodeFieldNumber = 5,
  };
  // string tx_hash = 1 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string codespace = 4 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // bytes data = 6 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string raw_log = 7 [json_name = "rawLog"];
  void clear_raw_log() ;
  const std::string& raw_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_log(Arg_&& arg, Args_... args);
  std::string* mutable_raw_log();
  PROTOBUF_NODISCARD std::string* release_raw_log();
  void set_allocated_raw_log(std::string* ptr);

  private:
  const std::string& _internal_raw_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_log(
      const std::string& value);
  std::string* _internal_mutable_raw_log();

  public:
  // string timestamp = 8 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // sint64 height = 2 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // uint32 index = 3 [json_name = "index"];
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // uint32 code = 5 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.GetTxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::int64_t height_;
    ::uint32_t index_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PrepareTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.PrepareTxRequest) */ {
 public:
  inline PrepareTxRequest() : PrepareTxRequest(nullptr) {}
  ~PrepareTxRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareTxRequest(const PrepareTxRequest& from);
  PrepareTxRequest(PrepareTxRequest&& from) noexcept
    : PrepareTxRequest() {
    *this = ::std::move(from);
  }

  inline PrepareTxRequest& operator=(const PrepareTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareTxRequest& operator=(PrepareTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareTxRequest* internal_default_instance() {
    return reinterpret_cast<const PrepareTxRequest*>(
               &_PrepareTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PrepareTxRequest& a, PrepareTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareTxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrepareTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrepareTxRequest& from) {
    PrepareTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.PrepareTxRequest";
  }
  protected:
  explicit PrepareTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 7,
    kSignerAddressFieldNumber = 2,
    kMemoFieldNumber = 4,
    kFeeFieldNumber = 6,
    kChainIdFieldNumber = 1,
    kSequenceFieldNumber = 3,
    kTimeoutHeightFieldNumber = 5,
  };
  // repeated bytes msgs = 7 [json_name = "msgs"];
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;

  public:
  void clear_msgs() ;
  const std::string& msgs(int index) const;
  std::string* mutable_msgs(int index);
  void set_msgs(int index, const std::string& value);
  void set_msgs(int index, std::string&& value);
  void set_msgs(int index, const char* value);
  void set_msgs(int index, const void* value, std::size_t size);
  void set_msgs(int index, absl::string_view value);
  std::string* add_msgs();
  void add_msgs(const std::string& value);
  void add_msgs(std::string&& value);
  void add_msgs(const char* value);
  void add_msgs(const void* value, std::size_t size);
  void add_msgs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_msgs();

  private:
  const std::string& _internal_msgs(int index) const;
  std::string* _internal_add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_msgs();

  public:
  // string signer_address = 2 [json_name = "signerAddress"];
  void clear_signer_address() ;
  const std::string& signer_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signer_address(Arg_&& arg, Args_... args);
  std::string* mutable_signer_address();
  PROTOBUF_NODISCARD std::string* release_signer_address();
  void set_allocated_signer_address(std::string* ptr);

  private:
  const std::string& _internal_signer_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signer_address(
      const std::string& value);
  std::string* _internal_mutable_signer_address();

  public:
  // string memo = 4 [json_name = "memo"];
  void clear_memo() ;
  const std::string& memo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memo(Arg_&& arg, Args_... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* ptr);

  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(
      const std::string& value);
  std::string* _internal_mutable_memo();

  public:
  // .injective_exchange_rpc.CosmosTxFee fee = 6 [json_name = "fee"];
  bool has_fee() const;
  void clear_fee() ;
  const ::injective_exchange_rpc::CosmosTxFee& fee() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosTxFee* release_fee();
  ::injective_exchange_rpc::CosmosTxFee* mutable_fee();
  void set_allocated_fee(::injective_exchange_rpc::CosmosTxFee* fee);
  private:
  const ::injective_exchange_rpc::CosmosTxFee& _internal_fee() const;
  ::injective_exchange_rpc::CosmosTxFee* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::injective_exchange_rpc::CosmosTxFee* fee);
  ::injective_exchange_rpc::CosmosTxFee* unsafe_arena_release_fee();
  // uint64 chain_id = 1 [json_name = "chainId"];
  void clear_chain_id() ;
  ::uint64_t chain_id() const;
  void set_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(::uint64_t value);

  public:
  // uint64 sequence = 3 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // uint64 timeout_height = 5 [json_name = "timeoutHeight"];
  void clear_timeout_height() ;
  ::uint64_t timeout_height() const;
  void set_timeout_height(::uint64_t value);

  private:
  ::uint64_t _internal_timeout_height() const;
  void _internal_set_timeout_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.PrepareTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::injective_exchange_rpc::CosmosTxFee* fee_;
    ::uint64_t chain_id_;
    ::uint64_t sequence_;
    ::uint64_t timeout_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class CosmosTxFee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.CosmosTxFee) */ {
 public:
  inline CosmosTxFee() : CosmosTxFee(nullptr) {}
  ~CosmosTxFee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CosmosTxFee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosmosTxFee(const CosmosTxFee& from);
  CosmosTxFee(CosmosTxFee&& from) noexcept
    : CosmosTxFee() {
    *this = ::std::move(from);
  }

  inline CosmosTxFee& operator=(const CosmosTxFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosmosTxFee& operator=(CosmosTxFee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosmosTxFee& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosmosTxFee* internal_default_instance() {
    return reinterpret_cast<const CosmosTxFee*>(
               &_CosmosTxFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CosmosTxFee& a, CosmosTxFee& b) {
    a.Swap(&b);
  }
  inline void Swap(CosmosTxFee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosmosTxFee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CosmosTxFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CosmosTxFee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosmosTxFee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CosmosTxFee& from) {
    CosmosTxFee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosmosTxFee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.CosmosTxFee";
  }
  protected:
  explicit CosmosTxFee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriceFieldNumber = 1,
    kGasFieldNumber = 2,
    kDelegateFeeFieldNumber = 3,
  };
  // repeated .injective_exchange_rpc.CosmosCoin price = 1 [json_name = "price"];
  int price_size() const;
  private:
  int _internal_price_size() const;

  public:
  void clear_price() ;
  ::injective_exchange_rpc::CosmosCoin* mutable_price(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_exchange_rpc::CosmosCoin >*
      mutable_price();
  private:
  const ::injective_exchange_rpc::CosmosCoin& _internal_price(int index) const;
  ::injective_exchange_rpc::CosmosCoin* _internal_add_price();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_exchange_rpc::CosmosCoin>& _internal_price() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_exchange_rpc::CosmosCoin>* _internal_mutable_price();
  public:
  const ::injective_exchange_rpc::CosmosCoin& price(int index) const;
  ::injective_exchange_rpc::CosmosCoin* add_price();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_exchange_rpc::CosmosCoin >&
      price() const;
  // uint64 gas = 2 [json_name = "gas"];
  void clear_gas() ;
  ::uint64_t gas() const;
  void set_gas(::uint64_t value);

  private:
  ::uint64_t _internal_gas() const;
  void _internal_set_gas(::uint64_t value);

  public:
  // bool delegate_fee = 3 [json_name = "delegateFee"];
  void clear_delegate_fee() ;
  bool delegate_fee() const;
  void set_delegate_fee(bool value);

  private:
  bool _internal_delegate_fee() const;
  void _internal_set_delegate_fee(bool value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.CosmosTxFee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_exchange_rpc::CosmosCoin > price_;
    ::uint64_t gas_;
    bool delegate_fee_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class CosmosCoin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.CosmosCoin) */ {
 public:
  inline CosmosCoin() : CosmosCoin(nullptr) {}
  ~CosmosCoin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CosmosCoin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosmosCoin(const CosmosCoin& from);
  CosmosCoin(CosmosCoin&& from) noexcept
    : CosmosCoin() {
    *this = ::std::move(from);
  }

  inline CosmosCoin& operator=(const CosmosCoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosmosCoin& operator=(CosmosCoin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosmosCoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosmosCoin* internal_default_instance() {
    return reinterpret_cast<const CosmosCoin*>(
               &_CosmosCoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CosmosCoin& a, CosmosCoin& b) {
    a.Swap(&b);
  }
  inline void Swap(CosmosCoin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosmosCoin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CosmosCoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CosmosCoin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosmosCoin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CosmosCoin& from) {
    CosmosCoin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosmosCoin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.CosmosCoin";
  }
  protected:
  explicit CosmosCoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.CosmosCoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PrepareTxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.PrepareTxResponse) */ {
 public:
  inline PrepareTxResponse() : PrepareTxResponse(nullptr) {}
  ~PrepareTxResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareTxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareTxResponse(const PrepareTxResponse& from);
  PrepareTxResponse(PrepareTxResponse&& from) noexcept
    : PrepareTxResponse() {
    *this = ::std::move(from);
  }

  inline PrepareTxResponse& operator=(const PrepareTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareTxResponse& operator=(PrepareTxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareTxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareTxResponse* internal_default_instance() {
    return reinterpret_cast<const PrepareTxResponse*>(
               &_PrepareTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PrepareTxResponse& a, PrepareTxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareTxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareTxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareTxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareTxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrepareTxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrepareTxResponse& from) {
    PrepareTxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareTxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.PrepareTxResponse";
  }
  protected:
  explicit PrepareTxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSignModeFieldNumber = 3,
    kPubKeyTypeFieldNumber = 4,
    kFeePayerFieldNumber = 5,
    kFeePayerSigFieldNumber = 6,
    kSequenceFieldNumber = 2,
  };
  // string data = 1 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string sign_mode = 3 [json_name = "signMode"];
  void clear_sign_mode() ;
  const std::string& sign_mode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sign_mode(Arg_&& arg, Args_... args);
  std::string* mutable_sign_mode();
  PROTOBUF_NODISCARD std::string* release_sign_mode();
  void set_allocated_sign_mode(std::string* ptr);

  private:
  const std::string& _internal_sign_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_mode(
      const std::string& value);
  std::string* _internal_mutable_sign_mode();

  public:
  // string pub_key_type = 4 [json_name = "pubKeyType"];
  void clear_pub_key_type() ;
  const std::string& pub_key_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key_type(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key_type();
  PROTOBUF_NODISCARD std::string* release_pub_key_type();
  void set_allocated_pub_key_type(std::string* ptr);

  private:
  const std::string& _internal_pub_key_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key_type(
      const std::string& value);
  std::string* _internal_mutable_pub_key_type();

  public:
  // string fee_payer = 5 [json_name = "feePayer"];
  void clear_fee_payer() ;
  const std::string& fee_payer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer();
  PROTOBUF_NODISCARD std::string* release_fee_payer();
  void set_allocated_fee_payer(std::string* ptr);

  private:
  const std::string& _internal_fee_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer(
      const std::string& value);
  std::string* _internal_mutable_fee_payer();

  public:
  // string fee_payer_sig = 6 [json_name = "feePayerSig"];
  void clear_fee_payer_sig() ;
  const std::string& fee_payer_sig() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer_sig(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer_sig();
  PROTOBUF_NODISCARD std::string* release_fee_payer_sig();
  void set_allocated_fee_payer_sig(std::string* ptr);

  private:
  const std::string& _internal_fee_payer_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer_sig(
      const std::string& value);
  std::string* _internal_mutable_fee_payer_sig();

  public:
  // uint64 sequence = 2 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.PrepareTxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_sig_;
    ::uint64_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BroadcastTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.BroadcastTxRequest) */ {
 public:
  inline BroadcastTxRequest() : BroadcastTxRequest(nullptr) {}
  ~BroadcastTxRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastTxRequest(const BroadcastTxRequest& from);
  BroadcastTxRequest(BroadcastTxRequest&& from) noexcept
    : BroadcastTxRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastTxRequest& operator=(const BroadcastTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastTxRequest& operator=(BroadcastTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastTxRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastTxRequest*>(
               &_BroadcastTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BroadcastTxRequest& a, BroadcastTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastTxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastTxRequest& from) {
    BroadcastTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.BroadcastTxRequest";
  }
  protected:
  explicit BroadcastTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 3,
    kTxFieldNumber = 2,
    kSignatureFieldNumber = 5,
    kFeePayerFieldNumber = 6,
    kFeePayerSigFieldNumber = 7,
    kModeFieldNumber = 8,
    kPubKeyFieldNumber = 4,
    kChainIdFieldNumber = 1,
  };
  // repeated bytes msgs = 3 [json_name = "msgs"];
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;

  public:
  void clear_msgs() ;
  const std::string& msgs(int index) const;
  std::string* mutable_msgs(int index);
  void set_msgs(int index, const std::string& value);
  void set_msgs(int index, std::string&& value);
  void set_msgs(int index, const char* value);
  void set_msgs(int index, const void* value, std::size_t size);
  void set_msgs(int index, absl::string_view value);
  std::string* add_msgs();
  void add_msgs(const std::string& value);
  void add_msgs(std::string&& value);
  void add_msgs(const char* value);
  void add_msgs(const void* value, std::size_t size);
  void add_msgs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_msgs();

  private:
  const std::string& _internal_msgs(int index) const;
  std::string* _internal_add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_msgs();

  public:
  // bytes tx = 2 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // string signature = 5 [json_name = "signature"];
  void clear_signature() ;
  const std::string& signature() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* ptr);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // string fee_payer = 6 [json_name = "feePayer"];
  void clear_fee_payer() ;
  const std::string& fee_payer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer();
  PROTOBUF_NODISCARD std::string* release_fee_payer();
  void set_allocated_fee_payer(std::string* ptr);

  private:
  const std::string& _internal_fee_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer(
      const std::string& value);
  std::string* _internal_mutable_fee_payer();

  public:
  // string fee_payer_sig = 7 [json_name = "feePayerSig"];
  void clear_fee_payer_sig() ;
  const std::string& fee_payer_sig() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer_sig(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer_sig();
  PROTOBUF_NODISCARD std::string* release_fee_payer_sig();
  void set_allocated_fee_payer_sig(std::string* ptr);

  private:
  const std::string& _internal_fee_payer_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer_sig(
      const std::string& value);
  std::string* _internal_mutable_fee_payer_sig();

  public:
  // string mode = 8 [json_name = "mode"];
  void clear_mode() ;
  const std::string& mode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mode(Arg_&& arg, Args_... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* ptr);

  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(
      const std::string& value);
  std::string* _internal_mutable_mode();

  public:
  // .injective_exchange_rpc.CosmosPubKey pub_key = 4 [json_name = "pubKey"];
  bool has_pub_key() const;
  void clear_pub_key() ;
  const ::injective_exchange_rpc::CosmosPubKey& pub_key() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosPubKey* release_pub_key();
  ::injective_exchange_rpc::CosmosPubKey* mutable_pub_key();
  void set_allocated_pub_key(::injective_exchange_rpc::CosmosPubKey* pub_key);
  private:
  const ::injective_exchange_rpc::CosmosPubKey& _internal_pub_key() const;
  ::injective_exchange_rpc::CosmosPubKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::injective_exchange_rpc::CosmosPubKey* pub_key);
  ::injective_exchange_rpc::CosmosPubKey* unsafe_arena_release_pub_key();
  // uint64 chain_id = 1 [json_name = "chainId"];
  void clear_chain_id() ;
  ::uint64_t chain_id() const;
  void set_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.BroadcastTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_sig_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::injective_exchange_rpc::CosmosPubKey* pub_key_;
    ::uint64_t chain_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class CosmosPubKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.CosmosPubKey) */ {
 public:
  inline CosmosPubKey() : CosmosPubKey(nullptr) {}
  ~CosmosPubKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CosmosPubKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosmosPubKey(const CosmosPubKey& from);
  CosmosPubKey(CosmosPubKey&& from) noexcept
    : CosmosPubKey() {
    *this = ::std::move(from);
  }

  inline CosmosPubKey& operator=(const CosmosPubKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosmosPubKey& operator=(CosmosPubKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosmosPubKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosmosPubKey* internal_default_instance() {
    return reinterpret_cast<const CosmosPubKey*>(
               &_CosmosPubKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CosmosPubKey& a, CosmosPubKey& b) {
    a.Swap(&b);
  }
  inline void Swap(CosmosPubKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosmosPubKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CosmosPubKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CosmosPubKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosmosPubKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CosmosPubKey& from) {
    CosmosPubKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosmosPubKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.CosmosPubKey";
  }
  protected:
  explicit CosmosPubKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string key = 2 [json_name = "key"];
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.CosmosPubKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BroadcastTxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.BroadcastTxResponse) */ {
 public:
  inline BroadcastTxResponse() : BroadcastTxResponse(nullptr) {}
  ~BroadcastTxResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastTxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastTxResponse(const BroadcastTxResponse& from);
  BroadcastTxResponse(BroadcastTxResponse&& from) noexcept
    : BroadcastTxResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastTxResponse& operator=(const BroadcastTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastTxResponse& operator=(BroadcastTxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastTxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastTxResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastTxResponse*>(
               &_BroadcastTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BroadcastTxResponse& a, BroadcastTxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastTxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastTxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastTxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastTxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastTxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastTxResponse& from) {
    BroadcastTxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastTxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.BroadcastTxResponse";
  }
  protected:
  explicit BroadcastTxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 1,
    kCodespaceFieldNumber = 4,
    kDataFieldNumber = 6,
    kRawLogFieldNumber = 7,
    kTimestampFieldNumber = 8,
    kHeightFieldNumber = 2,
    kIndexFieldNumber = 3,
    kCodeFieldNumber = 5,
  };
  // string tx_hash = 1 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string codespace = 4 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // bytes data = 6 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string raw_log = 7 [json_name = "rawLog"];
  void clear_raw_log() ;
  const std::string& raw_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_log(Arg_&& arg, Args_... args);
  std::string* mutable_raw_log();
  PROTOBUF_NODISCARD std::string* release_raw_log();
  void set_allocated_raw_log(std::string* ptr);

  private:
  const std::string& _internal_raw_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_log(
      const std::string& value);
  std::string* _internal_mutable_raw_log();

  public:
  // string timestamp = 8 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // sint64 height = 2 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // uint32 index = 3 [json_name = "index"];
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // uint32 code = 5 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.BroadcastTxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::int64_t height_;
    ::uint32_t index_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PrepareCosmosTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.PrepareCosmosTxRequest) */ {
 public:
  inline PrepareCosmosTxRequest() : PrepareCosmosTxRequest(nullptr) {}
  ~PrepareCosmosTxRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareCosmosTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareCosmosTxRequest(const PrepareCosmosTxRequest& from);
  PrepareCosmosTxRequest(PrepareCosmosTxRequest&& from) noexcept
    : PrepareCosmosTxRequest() {
    *this = ::std::move(from);
  }

  inline PrepareCosmosTxRequest& operator=(const PrepareCosmosTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareCosmosTxRequest& operator=(PrepareCosmosTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareCosmosTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareCosmosTxRequest* internal_default_instance() {
    return reinterpret_cast<const PrepareCosmosTxRequest*>(
               &_PrepareCosmosTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PrepareCosmosTxRequest& a, PrepareCosmosTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareCosmosTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareCosmosTxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareCosmosTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareCosmosTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrepareCosmosTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrepareCosmosTxRequest& from) {
    PrepareCosmosTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareCosmosTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.PrepareCosmosTxRequest";
  }
  protected:
  explicit PrepareCosmosTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgsFieldNumber = 6,
    kSenderAddressFieldNumber = 2,
    kMemoFieldNumber = 3,
    kFeeFieldNumber = 5,
    kChainIdFieldNumber = 1,
    kTimeoutHeightFieldNumber = 4,
  };
  // repeated bytes msgs = 6 [json_name = "msgs"];
  int msgs_size() const;
  private:
  int _internal_msgs_size() const;

  public:
  void clear_msgs() ;
  const std::string& msgs(int index) const;
  std::string* mutable_msgs(int index);
  void set_msgs(int index, const std::string& value);
  void set_msgs(int index, std::string&& value);
  void set_msgs(int index, const char* value);
  void set_msgs(int index, const void* value, std::size_t size);
  void set_msgs(int index, absl::string_view value);
  std::string* add_msgs();
  void add_msgs(const std::string& value);
  void add_msgs(std::string&& value);
  void add_msgs(const char* value);
  void add_msgs(const void* value, std::size_t size);
  void add_msgs(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_msgs();

  private:
  const std::string& _internal_msgs(int index) const;
  std::string* _internal_add_msgs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_msgs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_msgs();

  public:
  // string sender_address = 2 [json_name = "senderAddress"];
  void clear_sender_address() ;
  const std::string& sender_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_address(Arg_&& arg, Args_... args);
  std::string* mutable_sender_address();
  PROTOBUF_NODISCARD std::string* release_sender_address();
  void set_allocated_sender_address(std::string* ptr);

  private:
  const std::string& _internal_sender_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_address(
      const std::string& value);
  std::string* _internal_mutable_sender_address();

  public:
  // string memo = 3 [json_name = "memo"];
  void clear_memo() ;
  const std::string& memo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memo(Arg_&& arg, Args_... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* ptr);

  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(
      const std::string& value);
  std::string* _internal_mutable_memo();

  public:
  // .injective_exchange_rpc.CosmosTxFee fee = 5 [json_name = "fee"];
  bool has_fee() const;
  void clear_fee() ;
  const ::injective_exchange_rpc::CosmosTxFee& fee() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosTxFee* release_fee();
  ::injective_exchange_rpc::CosmosTxFee* mutable_fee();
  void set_allocated_fee(::injective_exchange_rpc::CosmosTxFee* fee);
  private:
  const ::injective_exchange_rpc::CosmosTxFee& _internal_fee() const;
  ::injective_exchange_rpc::CosmosTxFee* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::injective_exchange_rpc::CosmosTxFee* fee);
  ::injective_exchange_rpc::CosmosTxFee* unsafe_arena_release_fee();
  // uint64 chain_id = 1 [json_name = "chainId"];
  void clear_chain_id() ;
  ::uint64_t chain_id() const;
  void set_chain_id(::uint64_t value);

  private:
  ::uint64_t _internal_chain_id() const;
  void _internal_set_chain_id(::uint64_t value);

  public:
  // uint64 timeout_height = 4 [json_name = "timeoutHeight"];
  void clear_timeout_height() ;
  ::uint64_t timeout_height() const;
  void set_timeout_height(::uint64_t value);

  private:
  ::uint64_t _internal_timeout_height() const;
  void _internal_set_timeout_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.PrepareCosmosTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> msgs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::injective_exchange_rpc::CosmosTxFee* fee_;
    ::uint64_t chain_id_;
    ::uint64_t timeout_height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class PrepareCosmosTxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.PrepareCosmosTxResponse) */ {
 public:
  inline PrepareCosmosTxResponse() : PrepareCosmosTxResponse(nullptr) {}
  ~PrepareCosmosTxResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareCosmosTxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareCosmosTxResponse(const PrepareCosmosTxResponse& from);
  PrepareCosmosTxResponse(PrepareCosmosTxResponse&& from) noexcept
    : PrepareCosmosTxResponse() {
    *this = ::std::move(from);
  }

  inline PrepareCosmosTxResponse& operator=(const PrepareCosmosTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareCosmosTxResponse& operator=(PrepareCosmosTxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareCosmosTxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareCosmosTxResponse* internal_default_instance() {
    return reinterpret_cast<const PrepareCosmosTxResponse*>(
               &_PrepareCosmosTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PrepareCosmosTxResponse& a, PrepareCosmosTxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareCosmosTxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareCosmosTxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareCosmosTxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareCosmosTxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrepareCosmosTxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrepareCosmosTxResponse& from) {
    PrepareCosmosTxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareCosmosTxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.PrepareCosmosTxResponse";
  }
  protected:
  explicit PrepareCosmosTxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
    kSignModeFieldNumber = 2,
    kPubKeyTypeFieldNumber = 3,
    kFeePayerFieldNumber = 4,
    kFeePayerSigFieldNumber = 5,
    kFeePayerPubKeyFieldNumber = 6,
  };
  // bytes tx = 1 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // string sign_mode = 2 [json_name = "signMode"];
  void clear_sign_mode() ;
  const std::string& sign_mode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sign_mode(Arg_&& arg, Args_... args);
  std::string* mutable_sign_mode();
  PROTOBUF_NODISCARD std::string* release_sign_mode();
  void set_allocated_sign_mode(std::string* ptr);

  private:
  const std::string& _internal_sign_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_mode(
      const std::string& value);
  std::string* _internal_mutable_sign_mode();

  public:
  // string pub_key_type = 3 [json_name = "pubKeyType"];
  void clear_pub_key_type() ;
  const std::string& pub_key_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key_type(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key_type();
  PROTOBUF_NODISCARD std::string* release_pub_key_type();
  void set_allocated_pub_key_type(std::string* ptr);

  private:
  const std::string& _internal_pub_key_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key_type(
      const std::string& value);
  std::string* _internal_mutable_pub_key_type();

  public:
  // string fee_payer = 4 [json_name = "feePayer"];
  void clear_fee_payer() ;
  const std::string& fee_payer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer();
  PROTOBUF_NODISCARD std::string* release_fee_payer();
  void set_allocated_fee_payer(std::string* ptr);

  private:
  const std::string& _internal_fee_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer(
      const std::string& value);
  std::string* _internal_mutable_fee_payer();

  public:
  // string fee_payer_sig = 5 [json_name = "feePayerSig"];
  void clear_fee_payer_sig() ;
  const std::string& fee_payer_sig() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer_sig(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer_sig();
  PROTOBUF_NODISCARD std::string* release_fee_payer_sig();
  void set_allocated_fee_payer_sig(std::string* ptr);

  private:
  const std::string& _internal_fee_payer_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer_sig(
      const std::string& value);
  std::string* _internal_mutable_fee_payer_sig();

  public:
  // .injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 6 [json_name = "feePayerPubKey"];
  bool has_fee_payer_pub_key() const;
  void clear_fee_payer_pub_key() ;
  const ::injective_exchange_rpc::CosmosPubKey& fee_payer_pub_key() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosPubKey* release_fee_payer_pub_key();
  ::injective_exchange_rpc::CosmosPubKey* mutable_fee_payer_pub_key();
  void set_allocated_fee_payer_pub_key(::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key);
  private:
  const ::injective_exchange_rpc::CosmosPubKey& _internal_fee_payer_pub_key() const;
  ::injective_exchange_rpc::CosmosPubKey* _internal_mutable_fee_payer_pub_key();
  public:
  void unsafe_arena_set_allocated_fee_payer_pub_key(
      ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key);
  ::injective_exchange_rpc::CosmosPubKey* unsafe_arena_release_fee_payer_pub_key();
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.PrepareCosmosTxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_sig_;
    ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BroadcastCosmosTxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.BroadcastCosmosTxRequest) */ {
 public:
  inline BroadcastCosmosTxRequest() : BroadcastCosmosTxRequest(nullptr) {}
  ~BroadcastCosmosTxRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastCosmosTxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastCosmosTxRequest(const BroadcastCosmosTxRequest& from);
  BroadcastCosmosTxRequest(BroadcastCosmosTxRequest&& from) noexcept
    : BroadcastCosmosTxRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastCosmosTxRequest& operator=(const BroadcastCosmosTxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastCosmosTxRequest& operator=(BroadcastCosmosTxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastCosmosTxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastCosmosTxRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastCosmosTxRequest*>(
               &_BroadcastCosmosTxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BroadcastCosmosTxRequest& a, BroadcastCosmosTxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastCosmosTxRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastCosmosTxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastCosmosTxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastCosmosTxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastCosmosTxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastCosmosTxRequest& from) {
    BroadcastCosmosTxRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastCosmosTxRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.BroadcastCosmosTxRequest";
  }
  protected:
  explicit BroadcastCosmosTxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kSenderAddressFieldNumber = 4,
    kPubKeyFieldNumber = 2,
  };
  // bytes tx = 1 [json_name = "tx"];
  void clear_tx() ;
  const std::string& tx() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx(Arg_&& arg, Args_... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* ptr);

  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(
      const std::string& value);
  std::string* _internal_mutable_tx();

  public:
  // string signature = 3 [json_name = "signature"];
  void clear_signature() ;
  const std::string& signature() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* ptr);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // string sender_address = 4 [json_name = "senderAddress"];
  void clear_sender_address() ;
  const std::string& sender_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_address(Arg_&& arg, Args_... args);
  std::string* mutable_sender_address();
  PROTOBUF_NODISCARD std::string* release_sender_address();
  void set_allocated_sender_address(std::string* ptr);

  private:
  const std::string& _internal_sender_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_address(
      const std::string& value);
  std::string* _internal_mutable_sender_address();

  public:
  // .injective_exchange_rpc.CosmosPubKey pub_key = 2 [json_name = "pubKey"];
  bool has_pub_key() const;
  void clear_pub_key() ;
  const ::injective_exchange_rpc::CosmosPubKey& pub_key() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosPubKey* release_pub_key();
  ::injective_exchange_rpc::CosmosPubKey* mutable_pub_key();
  void set_allocated_pub_key(::injective_exchange_rpc::CosmosPubKey* pub_key);
  private:
  const ::injective_exchange_rpc::CosmosPubKey& _internal_pub_key() const;
  ::injective_exchange_rpc::CosmosPubKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::injective_exchange_rpc::CosmosPubKey* pub_key);
  ::injective_exchange_rpc::CosmosPubKey* unsafe_arena_release_pub_key();
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.BroadcastCosmosTxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_address_;
    ::injective_exchange_rpc::CosmosPubKey* pub_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class BroadcastCosmosTxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.BroadcastCosmosTxResponse) */ {
 public:
  inline BroadcastCosmosTxResponse() : BroadcastCosmosTxResponse(nullptr) {}
  ~BroadcastCosmosTxResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastCosmosTxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastCosmosTxResponse(const BroadcastCosmosTxResponse& from);
  BroadcastCosmosTxResponse(BroadcastCosmosTxResponse&& from) noexcept
    : BroadcastCosmosTxResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastCosmosTxResponse& operator=(const BroadcastCosmosTxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastCosmosTxResponse& operator=(BroadcastCosmosTxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastCosmosTxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastCosmosTxResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastCosmosTxResponse*>(
               &_BroadcastCosmosTxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BroadcastCosmosTxResponse& a, BroadcastCosmosTxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastCosmosTxResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastCosmosTxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastCosmosTxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastCosmosTxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastCosmosTxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastCosmosTxResponse& from) {
    BroadcastCosmosTxResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastCosmosTxResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.BroadcastCosmosTxResponse";
  }
  protected:
  explicit BroadcastCosmosTxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 1,
    kCodespaceFieldNumber = 4,
    kDataFieldNumber = 6,
    kRawLogFieldNumber = 7,
    kTimestampFieldNumber = 8,
    kHeightFieldNumber = 2,
    kIndexFieldNumber = 3,
    kCodeFieldNumber = 5,
  };
  // string tx_hash = 1 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string codespace = 4 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // bytes data = 6 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string raw_log = 7 [json_name = "rawLog"];
  void clear_raw_log() ;
  const std::string& raw_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_log(Arg_&& arg, Args_... args);
  std::string* mutable_raw_log();
  PROTOBUF_NODISCARD std::string* release_raw_log();
  void set_allocated_raw_log(std::string* ptr);

  private:
  const std::string& _internal_raw_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_log(
      const std::string& value);
  std::string* _internal_mutable_raw_log();

  public:
  // string timestamp = 8 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // sint64 height = 2 [json_name = "height"];
  void clear_height() ;
  ::int64_t height() const;
  void set_height(::int64_t value);

  private:
  ::int64_t _internal_height() const;
  void _internal_set_height(::int64_t value);

  public:
  // uint32 index = 3 [json_name = "index"];
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // uint32 code = 5 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.BroadcastCosmosTxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::int64_t height_;
    ::uint32_t index_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetFeePayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.GetFeePayerRequest) */ {
 public:
  inline GetFeePayerRequest() : GetFeePayerRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFeePayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFeePayerRequest(const GetFeePayerRequest& from);
  GetFeePayerRequest(GetFeePayerRequest&& from) noexcept
    : GetFeePayerRequest() {
    *this = ::std::move(from);
  }

  inline GetFeePayerRequest& operator=(const GetFeePayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFeePayerRequest& operator=(GetFeePayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFeePayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFeePayerRequest* internal_default_instance() {
    return reinterpret_cast<const GetFeePayerRequest*>(
               &_GetFeePayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFeePayerRequest& a, GetFeePayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFeePayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFeePayerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFeePayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFeePayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFeePayerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFeePayerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.GetFeePayerRequest";
  }
  protected:
  explicit GetFeePayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.GetFeePayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetFeePayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_exchange_rpc.GetFeePayerResponse) */ {
 public:
  inline GetFeePayerResponse() : GetFeePayerResponse(nullptr) {}
  ~GetFeePayerResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFeePayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFeePayerResponse(const GetFeePayerResponse& from);
  GetFeePayerResponse(GetFeePayerResponse&& from) noexcept
    : GetFeePayerResponse() {
    *this = ::std::move(from);
  }

  inline GetFeePayerResponse& operator=(const GetFeePayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFeePayerResponse& operator=(GetFeePayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFeePayerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFeePayerResponse* internal_default_instance() {
    return reinterpret_cast<const GetFeePayerResponse*>(
               &_GetFeePayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetFeePayerResponse& a, GetFeePayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFeePayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFeePayerResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFeePayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFeePayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFeePayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFeePayerResponse& from) {
    GetFeePayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFeePayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_exchange_rpc.GetFeePayerResponse";
  }
  protected:
  explicit GetFeePayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeePayerFieldNumber = 1,
    kFeePayerPubKeyFieldNumber = 2,
  };
  // string fee_payer = 1 [json_name = "feePayer"];
  void clear_fee_payer() ;
  const std::string& fee_payer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fee_payer(Arg_&& arg, Args_... args);
  std::string* mutable_fee_payer();
  PROTOBUF_NODISCARD std::string* release_fee_payer();
  void set_allocated_fee_payer(std::string* ptr);

  private:
  const std::string& _internal_fee_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fee_payer(
      const std::string& value);
  std::string* _internal_mutable_fee_payer();

  public:
  // .injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 2 [json_name = "feePayerPubKey"];
  bool has_fee_payer_pub_key() const;
  void clear_fee_payer_pub_key() ;
  const ::injective_exchange_rpc::CosmosPubKey& fee_payer_pub_key() const;
  PROTOBUF_NODISCARD ::injective_exchange_rpc::CosmosPubKey* release_fee_payer_pub_key();
  ::injective_exchange_rpc::CosmosPubKey* mutable_fee_payer_pub_key();
  void set_allocated_fee_payer_pub_key(::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key);
  private:
  const ::injective_exchange_rpc::CosmosPubKey& _internal_fee_payer_pub_key() const;
  ::injective_exchange_rpc::CosmosPubKey* _internal_mutable_fee_payer_pub_key();
  public:
  void unsafe_arena_set_allocated_fee_payer_pub_key(
      ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key);
  ::injective_exchange_rpc::CosmosPubKey* unsafe_arena_release_fee_payer_pub_key();
  // @@protoc_insertion_point(class_scope:injective_exchange_rpc.GetFeePayerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fee_payer_;
    ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexchange_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetTxRequest

// string hash = 1 [json_name = "hash"];
inline void GetTxRequest::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& GetTxRequest::hash() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxRequest.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxRequest::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxRequest.hash)
}
inline std::string* GetTxRequest::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxRequest.hash)
  return _s;
}
inline const std::string& GetTxRequest::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void GetTxRequest::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxRequest::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxRequest::release_hash() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxRequest.hash)
  return _impl_.hash_.Release();
}
inline void GetTxRequest::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxRequest.hash)
}

// -------------------------------------------------------------------

// GetTxResponse

// string tx_hash = 1 [json_name = "txHash"];
inline void GetTxResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& GetTxResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxResponse::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.tx_hash)
}
inline std::string* GetTxResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxResponse.tx_hash)
  return _s;
}
inline const std::string& GetTxResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void GetTxResponse::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxResponse::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void GetTxResponse::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxResponse.tx_hash)
}

// sint64 height = 2 [json_name = "height"];
inline void GetTxResponse::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t GetTxResponse::height() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.height)
  return _internal_height();
}
inline void GetTxResponse::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.height)
}
inline ::int64_t GetTxResponse::_internal_height() const {
  return _impl_.height_;
}
inline void GetTxResponse::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 index = 3 [json_name = "index"];
inline void GetTxResponse::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t GetTxResponse::index() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.index)
  return _internal_index();
}
inline void GetTxResponse::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.index)
}
inline ::uint32_t GetTxResponse::_internal_index() const {
  return _impl_.index_;
}
inline void GetTxResponse::_internal_set_index(::uint32_t value) {
  ;
  _impl_.index_ = value;
}

// string codespace = 4 [json_name = "codespace"];
inline void GetTxResponse::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& GetTxResponse::codespace() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxResponse::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.codespace)
}
inline std::string* GetTxResponse::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxResponse.codespace)
  return _s;
}
inline const std::string& GetTxResponse::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void GetTxResponse::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxResponse::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxResponse::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxResponse.codespace)
  return _impl_.codespace_.Release();
}
inline void GetTxResponse::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxResponse.codespace)
}

// uint32 code = 5 [json_name = "code"];
inline void GetTxResponse::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t GetTxResponse::code() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.code)
  return _internal_code();
}
inline void GetTxResponse::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.code)
}
inline ::uint32_t GetTxResponse::_internal_code() const {
  return _impl_.code_;
}
inline void GetTxResponse::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 6 [json_name = "data"];
inline void GetTxResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GetTxResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.data)
}
inline std::string* GetTxResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxResponse.data)
  return _s;
}
inline const std::string& GetTxResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void GetTxResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxResponse::release_data() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxResponse.data)
  return _impl_.data_.Release();
}
inline void GetTxResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxResponse.data)
}

// string raw_log = 7 [json_name = "rawLog"];
inline void GetTxResponse::clear_raw_log() {
  _impl_.raw_log_.ClearToEmpty();
}
inline const std::string& GetTxResponse::raw_log() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.raw_log)
  return _internal_raw_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxResponse::set_raw_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.raw_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.raw_log)
}
inline std::string* GetTxResponse::mutable_raw_log() {
  std::string* _s = _internal_mutable_raw_log();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxResponse.raw_log)
  return _s;
}
inline const std::string& GetTxResponse::_internal_raw_log() const {
  return _impl_.raw_log_.Get();
}
inline void GetTxResponse::_internal_set_raw_log(const std::string& value) {
  ;


  _impl_.raw_log_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxResponse::_internal_mutable_raw_log() {
  ;
  return _impl_.raw_log_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxResponse::release_raw_log() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxResponse.raw_log)
  return _impl_.raw_log_.Release();
}
inline void GetTxResponse::set_allocated_raw_log(std::string* value) {
  _impl_.raw_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_log_.IsDefault()) {
          _impl_.raw_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxResponse.raw_log)
}

// string timestamp = 8 [json_name = "timestamp"];
inline void GetTxResponse::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& GetTxResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetTxResponse.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxResponse::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetTxResponse.timestamp)
}
inline std::string* GetTxResponse::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetTxResponse.timestamp)
  return _s;
}
inline const std::string& GetTxResponse::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void GetTxResponse::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxResponse::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetTxResponse.timestamp)
  return _impl_.timestamp_.Release();
}
inline void GetTxResponse::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetTxResponse.timestamp)
}

// -------------------------------------------------------------------

// PrepareTxRequest

// uint64 chain_id = 1 [json_name = "chainId"];
inline void PrepareTxRequest::clear_chain_id() {
  _impl_.chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareTxRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.chain_id)
  return _internal_chain_id();
}
inline void PrepareTxRequest::set_chain_id(::uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.chain_id)
}
inline ::uint64_t PrepareTxRequest::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline void PrepareTxRequest::_internal_set_chain_id(::uint64_t value) {
  ;
  _impl_.chain_id_ = value;
}

// string signer_address = 2 [json_name = "signerAddress"];
inline void PrepareTxRequest::clear_signer_address() {
  _impl_.signer_address_.ClearToEmpty();
}
inline const std::string& PrepareTxRequest::signer_address() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.signer_address)
  return _internal_signer_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxRequest::set_signer_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signer_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.signer_address)
}
inline std::string* PrepareTxRequest::mutable_signer_address() {
  std::string* _s = _internal_mutable_signer_address();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxRequest.signer_address)
  return _s;
}
inline const std::string& PrepareTxRequest::_internal_signer_address() const {
  return _impl_.signer_address_.Get();
}
inline void PrepareTxRequest::_internal_set_signer_address(const std::string& value) {
  ;


  _impl_.signer_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxRequest::_internal_mutable_signer_address() {
  ;
  return _impl_.signer_address_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxRequest::release_signer_address() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxRequest.signer_address)
  return _impl_.signer_address_.Release();
}
inline void PrepareTxRequest::set_allocated_signer_address(std::string* value) {
  _impl_.signer_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signer_address_.IsDefault()) {
          _impl_.signer_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxRequest.signer_address)
}

// uint64 sequence = 3 [json_name = "sequence"];
inline void PrepareTxRequest::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareTxRequest::sequence() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.sequence)
  return _internal_sequence();
}
inline void PrepareTxRequest::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.sequence)
}
inline ::uint64_t PrepareTxRequest::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void PrepareTxRequest::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// string memo = 4 [json_name = "memo"];
inline void PrepareTxRequest::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& PrepareTxRequest::memo() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.memo)
  return _internal_memo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxRequest::set_memo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.memo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.memo)
}
inline std::string* PrepareTxRequest::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxRequest.memo)
  return _s;
}
inline const std::string& PrepareTxRequest::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void PrepareTxRequest::_internal_set_memo(const std::string& value) {
  ;


  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxRequest::_internal_mutable_memo() {
  ;
  return _impl_.memo_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxRequest::release_memo() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxRequest.memo)
  return _impl_.memo_.Release();
}
inline void PrepareTxRequest::set_allocated_memo(std::string* value) {
  _impl_.memo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memo_.IsDefault()) {
          _impl_.memo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxRequest.memo)
}

// uint64 timeout_height = 5 [json_name = "timeoutHeight"];
inline void PrepareTxRequest::clear_timeout_height() {
  _impl_.timeout_height_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareTxRequest::timeout_height() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.timeout_height)
  return _internal_timeout_height();
}
inline void PrepareTxRequest::set_timeout_height(::uint64_t value) {
  _internal_set_timeout_height(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.timeout_height)
}
inline ::uint64_t PrepareTxRequest::_internal_timeout_height() const {
  return _impl_.timeout_height_;
}
inline void PrepareTxRequest::_internal_set_timeout_height(::uint64_t value) {
  ;
  _impl_.timeout_height_ = value;
}

// .injective_exchange_rpc.CosmosTxFee fee = 6 [json_name = "fee"];
inline bool PrepareTxRequest::has_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_ != nullptr);
  return value;
}
inline void PrepareTxRequest::clear_fee() {
  if (_impl_.fee_ != nullptr) _impl_.fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosTxFee& PrepareTxRequest::_internal_fee() const {
  const ::injective_exchange_rpc::CosmosTxFee* p = _impl_.fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosTxFee&>(
      ::injective_exchange_rpc::_CosmosTxFee_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosTxFee& PrepareTxRequest::fee() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.fee)
  return _internal_fee();
}
inline void PrepareTxRequest::unsafe_arena_set_allocated_fee(
    ::injective_exchange_rpc::CosmosTxFee* fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  _impl_.fee_ = fee;
  if (fee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.PrepareTxRequest.fee)
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareTxRequest::release_fee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosTxFee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareTxRequest::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxRequest.fee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosTxFee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareTxRequest::_internal_mutable_fee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosTxFee>(GetArenaForAllocation());
    _impl_.fee_ = p;
  }
  return _impl_.fee_;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareTxRequest::mutable_fee() {
  ::injective_exchange_rpc::CosmosTxFee* _msg = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxRequest.fee)
  return _msg;
}
inline void PrepareTxRequest::set_allocated_fee(::injective_exchange_rpc::CosmosTxFee* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fee_;
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fee);
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxRequest.fee)
}

// repeated bytes msgs = 7 [json_name = "msgs"];
inline int PrepareTxRequest::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int PrepareTxRequest::msgs_size() const {
  return _internal_msgs_size();
}
inline void PrepareTxRequest::clear_msgs() {
  _internal_mutable_msgs()->Clear();
}
inline std::string* PrepareTxRequest::add_msgs() {
  std::string* _s = _internal_add_msgs();
  // @@protoc_insertion_point(field_add_mutable:injective_exchange_rpc.PrepareTxRequest.msgs)
  return _s;
}
inline const std::string& PrepareTxRequest::msgs(int index) const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxRequest.msgs)
  return _internal_msgs(index);
}
inline std::string* PrepareTxRequest::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxRequest.msgs)
  return _internal_mutable_msgs()->Mutable(index);
}
inline void PrepareTxRequest::set_msgs(int index, const std::string& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::set_msgs(int index, std::string&& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::set_msgs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::set_msgs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_msgs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::set_msgs(int index, absl::string_view value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::add_msgs(const std::string& value) {
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::add_msgs(std::string&& value) {
  _internal_mutable_msgs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::add_msgs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::add_msgs(const void* value, std::size_t size) {
  _internal_mutable_msgs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline void PrepareTxRequest::add_msgs(absl::string_view value) {
  _internal_mutable_msgs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_exchange_rpc.PrepareTxRequest.msgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PrepareTxRequest::msgs() const {
  // @@protoc_insertion_point(field_list:injective_exchange_rpc.PrepareTxRequest.msgs)
  return _internal_msgs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PrepareTxRequest::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:injective_exchange_rpc.PrepareTxRequest.msgs)
  return _internal_mutable_msgs();
}
inline const std::string& PrepareTxRequest::_internal_msgs(int index) const {
  return _internal_msgs().Get(index);
}
inline std::string* PrepareTxRequest::_internal_add_msgs() {
  return _internal_mutable_msgs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PrepareTxRequest::_internal_msgs() const {
  return _impl_.msgs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PrepareTxRequest::_internal_mutable_msgs() {
  return &_impl_.msgs_;
}

// -------------------------------------------------------------------

// CosmosTxFee

// repeated .injective_exchange_rpc.CosmosCoin price = 1 [json_name = "price"];
inline int CosmosTxFee::_internal_price_size() const {
  return _impl_.price_.size();
}
inline int CosmosTxFee::price_size() const {
  return _internal_price_size();
}
inline void CosmosTxFee::clear_price() {
  _internal_mutable_price()->Clear();
}
inline ::injective_exchange_rpc::CosmosCoin* CosmosTxFee::mutable_price(int index) {
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.CosmosTxFee.price)
  return _internal_mutable_price()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_exchange_rpc::CosmosCoin >*
CosmosTxFee::mutable_price() {
  // @@protoc_insertion_point(field_mutable_list:injective_exchange_rpc.CosmosTxFee.price)
  return _internal_mutable_price();
}
inline const ::injective_exchange_rpc::CosmosCoin& CosmosTxFee::_internal_price(int index) const {
  return _internal_price().Get(index);
}
inline const ::injective_exchange_rpc::CosmosCoin& CosmosTxFee::price(int index) const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosTxFee.price)
  return _internal_price(index);
}
inline ::injective_exchange_rpc::CosmosCoin* CosmosTxFee::_internal_add_price() {
  return _internal_mutable_price()->Add();
}
inline ::injective_exchange_rpc::CosmosCoin* CosmosTxFee::add_price() {
  ::injective_exchange_rpc::CosmosCoin* _add = _internal_add_price();
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.CosmosTxFee.price)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_exchange_rpc::CosmosCoin >&
CosmosTxFee::price() const {
  // @@protoc_insertion_point(field_list:injective_exchange_rpc.CosmosTxFee.price)
  return _internal_price();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_exchange_rpc::CosmosCoin>&
CosmosTxFee::_internal_price() const {
  return _impl_.price_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_exchange_rpc::CosmosCoin>*
CosmosTxFee::_internal_mutable_price() {
  return &_impl_.price_;
}

// uint64 gas = 2 [json_name = "gas"];
inline void CosmosTxFee::clear_gas() {
  _impl_.gas_ = ::uint64_t{0u};
}
inline ::uint64_t CosmosTxFee::gas() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosTxFee.gas)
  return _internal_gas();
}
inline void CosmosTxFee::set_gas(::uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosTxFee.gas)
}
inline ::uint64_t CosmosTxFee::_internal_gas() const {
  return _impl_.gas_;
}
inline void CosmosTxFee::_internal_set_gas(::uint64_t value) {
  ;
  _impl_.gas_ = value;
}

// bool delegate_fee = 3 [json_name = "delegateFee"];
inline void CosmosTxFee::clear_delegate_fee() {
  _impl_.delegate_fee_ = false;
}
inline bool CosmosTxFee::delegate_fee() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosTxFee.delegate_fee)
  return _internal_delegate_fee();
}
inline void CosmosTxFee::set_delegate_fee(bool value) {
  _internal_set_delegate_fee(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosTxFee.delegate_fee)
}
inline bool CosmosTxFee::_internal_delegate_fee() const {
  return _impl_.delegate_fee_;
}
inline void CosmosTxFee::_internal_set_delegate_fee(bool value) {
  ;
  _impl_.delegate_fee_ = value;
}

// -------------------------------------------------------------------

// CosmosCoin

// string denom = 1 [json_name = "denom"];
inline void CosmosCoin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& CosmosCoin::denom() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosCoin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosCoin.denom)
}
inline std::string* CosmosCoin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.CosmosCoin.denom)
  return _s;
}
inline const std::string& CosmosCoin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void CosmosCoin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_denom() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.CosmosCoin.denom)
  return _impl_.denom_.Release();
}
inline void CosmosCoin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.CosmosCoin.denom)
}

// string amount = 2 [json_name = "amount"];
inline void CosmosCoin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& CosmosCoin::amount() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosCoin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosCoin.amount)
}
inline std::string* CosmosCoin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.CosmosCoin.amount)
  return _s;
}
inline const std::string& CosmosCoin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void CosmosCoin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_amount() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.CosmosCoin.amount)
  return _impl_.amount_.Release();
}
inline void CosmosCoin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.CosmosCoin.amount)
}

// -------------------------------------------------------------------

// PrepareTxResponse

// string data = 1 [json_name = "data"];
inline void PrepareTxResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PrepareTxResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.data)
}
inline std::string* PrepareTxResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxResponse.data)
  return _s;
}
inline const std::string& PrepareTxResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void PrepareTxResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::release_data() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxResponse.data)
  return _impl_.data_.Release();
}
inline void PrepareTxResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxResponse.data)
}

// uint64 sequence = 2 [json_name = "sequence"];
inline void PrepareTxResponse::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareTxResponse::sequence() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.sequence)
  return _internal_sequence();
}
inline void PrepareTxResponse::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.sequence)
}
inline ::uint64_t PrepareTxResponse::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void PrepareTxResponse::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// string sign_mode = 3 [json_name = "signMode"];
inline void PrepareTxResponse::clear_sign_mode() {
  _impl_.sign_mode_.ClearToEmpty();
}
inline const std::string& PrepareTxResponse::sign_mode() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.sign_mode)
  return _internal_sign_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxResponse::set_sign_mode(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sign_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.sign_mode)
}
inline std::string* PrepareTxResponse::mutable_sign_mode() {
  std::string* _s = _internal_mutable_sign_mode();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxResponse.sign_mode)
  return _s;
}
inline const std::string& PrepareTxResponse::_internal_sign_mode() const {
  return _impl_.sign_mode_.Get();
}
inline void PrepareTxResponse::_internal_set_sign_mode(const std::string& value) {
  ;


  _impl_.sign_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::_internal_mutable_sign_mode() {
  ;
  return _impl_.sign_mode_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::release_sign_mode() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxResponse.sign_mode)
  return _impl_.sign_mode_.Release();
}
inline void PrepareTxResponse::set_allocated_sign_mode(std::string* value) {
  _impl_.sign_mode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sign_mode_.IsDefault()) {
          _impl_.sign_mode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxResponse.sign_mode)
}

// string pub_key_type = 4 [json_name = "pubKeyType"];
inline void PrepareTxResponse::clear_pub_key_type() {
  _impl_.pub_key_type_.ClearToEmpty();
}
inline const std::string& PrepareTxResponse::pub_key_type() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.pub_key_type)
  return _internal_pub_key_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxResponse::set_pub_key_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pub_key_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.pub_key_type)
}
inline std::string* PrepareTxResponse::mutable_pub_key_type() {
  std::string* _s = _internal_mutable_pub_key_type();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxResponse.pub_key_type)
  return _s;
}
inline const std::string& PrepareTxResponse::_internal_pub_key_type() const {
  return _impl_.pub_key_type_.Get();
}
inline void PrepareTxResponse::_internal_set_pub_key_type(const std::string& value) {
  ;


  _impl_.pub_key_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::_internal_mutable_pub_key_type() {
  ;
  return _impl_.pub_key_type_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::release_pub_key_type() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxResponse.pub_key_type)
  return _impl_.pub_key_type_.Release();
}
inline void PrepareTxResponse::set_allocated_pub_key_type(std::string* value) {
  _impl_.pub_key_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_type_.IsDefault()) {
          _impl_.pub_key_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxResponse.pub_key_type)
}

// string fee_payer = 5 [json_name = "feePayer"];
inline void PrepareTxResponse::clear_fee_payer() {
  _impl_.fee_payer_.ClearToEmpty();
}
inline const std::string& PrepareTxResponse::fee_payer() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.fee_payer)
  return _internal_fee_payer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxResponse::set_fee_payer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.fee_payer)
}
inline std::string* PrepareTxResponse::mutable_fee_payer() {
  std::string* _s = _internal_mutable_fee_payer();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxResponse.fee_payer)
  return _s;
}
inline const std::string& PrepareTxResponse::_internal_fee_payer() const {
  return _impl_.fee_payer_.Get();
}
inline void PrepareTxResponse::_internal_set_fee_payer(const std::string& value) {
  ;


  _impl_.fee_payer_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::_internal_mutable_fee_payer() {
  ;
  return _impl_.fee_payer_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::release_fee_payer() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxResponse.fee_payer)
  return _impl_.fee_payer_.Release();
}
inline void PrepareTxResponse::set_allocated_fee_payer(std::string* value) {
  _impl_.fee_payer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_.IsDefault()) {
          _impl_.fee_payer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxResponse.fee_payer)
}

// string fee_payer_sig = 6 [json_name = "feePayerSig"];
inline void PrepareTxResponse::clear_fee_payer_sig() {
  _impl_.fee_payer_sig_.ClearToEmpty();
}
inline const std::string& PrepareTxResponse::fee_payer_sig() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareTxResponse.fee_payer_sig)
  return _internal_fee_payer_sig();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareTxResponse::set_fee_payer_sig(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_sig_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareTxResponse.fee_payer_sig)
}
inline std::string* PrepareTxResponse::mutable_fee_payer_sig() {
  std::string* _s = _internal_mutable_fee_payer_sig();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareTxResponse.fee_payer_sig)
  return _s;
}
inline const std::string& PrepareTxResponse::_internal_fee_payer_sig() const {
  return _impl_.fee_payer_sig_.Get();
}
inline void PrepareTxResponse::_internal_set_fee_payer_sig(const std::string& value) {
  ;


  _impl_.fee_payer_sig_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::_internal_mutable_fee_payer_sig() {
  ;
  return _impl_.fee_payer_sig_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareTxResponse::release_fee_payer_sig() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareTxResponse.fee_payer_sig)
  return _impl_.fee_payer_sig_.Release();
}
inline void PrepareTxResponse::set_allocated_fee_payer_sig(std::string* value) {
  _impl_.fee_payer_sig_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_sig_.IsDefault()) {
          _impl_.fee_payer_sig_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareTxResponse.fee_payer_sig)
}

// -------------------------------------------------------------------

// BroadcastTxRequest

// uint64 chain_id = 1 [json_name = "chainId"];
inline void BroadcastTxRequest::clear_chain_id() {
  _impl_.chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t BroadcastTxRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.chain_id)
  return _internal_chain_id();
}
inline void BroadcastTxRequest::set_chain_id(::uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.chain_id)
}
inline ::uint64_t BroadcastTxRequest::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline void BroadcastTxRequest::_internal_set_chain_id(::uint64_t value) {
  ;
  _impl_.chain_id_ = value;
}

// bytes tx = 2 [json_name = "tx"];
inline void BroadcastTxRequest::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& BroadcastTxRequest::tx() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxRequest::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.tx)
}
inline std::string* BroadcastTxRequest::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.tx)
  return _s;
}
inline const std::string& BroadcastTxRequest::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void BroadcastTxRequest::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::release_tx() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.tx)
  return _impl_.tx_.Release();
}
inline void BroadcastTxRequest::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.tx)
}

// repeated bytes msgs = 3 [json_name = "msgs"];
inline int BroadcastTxRequest::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int BroadcastTxRequest::msgs_size() const {
  return _internal_msgs_size();
}
inline void BroadcastTxRequest::clear_msgs() {
  _internal_mutable_msgs()->Clear();
}
inline std::string* BroadcastTxRequest::add_msgs() {
  std::string* _s = _internal_add_msgs();
  // @@protoc_insertion_point(field_add_mutable:injective_exchange_rpc.BroadcastTxRequest.msgs)
  return _s;
}
inline const std::string& BroadcastTxRequest::msgs(int index) const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.msgs)
  return _internal_msgs(index);
}
inline std::string* BroadcastTxRequest::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.msgs)
  return _internal_mutable_msgs()->Mutable(index);
}
inline void BroadcastTxRequest::set_msgs(int index, const std::string& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::set_msgs(int index, std::string&& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::set_msgs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::set_msgs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_msgs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::set_msgs(int index, absl::string_view value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::add_msgs(const std::string& value) {
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::add_msgs(std::string&& value) {
  _internal_mutable_msgs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::add_msgs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::add_msgs(const void* value, std::size_t size) {
  _internal_mutable_msgs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline void BroadcastTxRequest::add_msgs(absl::string_view value) {
  _internal_mutable_msgs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_exchange_rpc.BroadcastTxRequest.msgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BroadcastTxRequest::msgs() const {
  // @@protoc_insertion_point(field_list:injective_exchange_rpc.BroadcastTxRequest.msgs)
  return _internal_msgs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BroadcastTxRequest::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:injective_exchange_rpc.BroadcastTxRequest.msgs)
  return _internal_mutable_msgs();
}
inline const std::string& BroadcastTxRequest::_internal_msgs(int index) const {
  return _internal_msgs().Get(index);
}
inline std::string* BroadcastTxRequest::_internal_add_msgs() {
  return _internal_mutable_msgs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BroadcastTxRequest::_internal_msgs() const {
  return _impl_.msgs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BroadcastTxRequest::_internal_mutable_msgs() {
  return &_impl_.msgs_;
}

// .injective_exchange_rpc.CosmosPubKey pub_key = 4 [json_name = "pubKey"];
inline bool BroadcastTxRequest::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pub_key_ != nullptr);
  return value;
}
inline void BroadcastTxRequest::clear_pub_key() {
  if (_impl_.pub_key_ != nullptr) _impl_.pub_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosPubKey& BroadcastTxRequest::_internal_pub_key() const {
  const ::injective_exchange_rpc::CosmosPubKey* p = _impl_.pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosPubKey&>(
      ::injective_exchange_rpc::_CosmosPubKey_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosPubKey& BroadcastTxRequest::pub_key() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.pub_key)
  return _internal_pub_key();
}
inline void BroadcastTxRequest::unsafe_arena_set_allocated_pub_key(
    ::injective_exchange_rpc::CosmosPubKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  _impl_.pub_key_ = pub_key;
  if (pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.BroadcastTxRequest.pub_key)
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastTxRequest::release_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastTxRequest::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastTxRequest::_internal_mutable_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosPubKey>(GetArenaForAllocation());
    _impl_.pub_key_ = p;
  }
  return _impl_.pub_key_;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastTxRequest::mutable_pub_key() {
  ::injective_exchange_rpc::CosmosPubKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.pub_key)
  return _msg;
}
inline void BroadcastTxRequest::set_allocated_pub_key(::injective_exchange_rpc::CosmosPubKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pub_key_;
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pub_key);
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.pub_key)
}

// string signature = 5 [json_name = "signature"];
inline void BroadcastTxRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& BroadcastTxRequest::signature() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxRequest::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signature_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.signature)
}
inline std::string* BroadcastTxRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.signature)
  return _s;
}
inline const std::string& BroadcastTxRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void BroadcastTxRequest::_internal_set_signature(const std::string& value) {
  ;


  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::_internal_mutable_signature() {
  ;
  return _impl_.signature_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::release_signature() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.signature)
  return _impl_.signature_.Release();
}
inline void BroadcastTxRequest::set_allocated_signature(std::string* value) {
  _impl_.signature_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.signature)
}

// string fee_payer = 6 [json_name = "feePayer"];
inline void BroadcastTxRequest::clear_fee_payer() {
  _impl_.fee_payer_.ClearToEmpty();
}
inline const std::string& BroadcastTxRequest::fee_payer() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.fee_payer)
  return _internal_fee_payer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxRequest::set_fee_payer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.fee_payer)
}
inline std::string* BroadcastTxRequest::mutable_fee_payer() {
  std::string* _s = _internal_mutable_fee_payer();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.fee_payer)
  return _s;
}
inline const std::string& BroadcastTxRequest::_internal_fee_payer() const {
  return _impl_.fee_payer_.Get();
}
inline void BroadcastTxRequest::_internal_set_fee_payer(const std::string& value) {
  ;


  _impl_.fee_payer_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::_internal_mutable_fee_payer() {
  ;
  return _impl_.fee_payer_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::release_fee_payer() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.fee_payer)
  return _impl_.fee_payer_.Release();
}
inline void BroadcastTxRequest::set_allocated_fee_payer(std::string* value) {
  _impl_.fee_payer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_.IsDefault()) {
          _impl_.fee_payer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.fee_payer)
}

// string fee_payer_sig = 7 [json_name = "feePayerSig"];
inline void BroadcastTxRequest::clear_fee_payer_sig() {
  _impl_.fee_payer_sig_.ClearToEmpty();
}
inline const std::string& BroadcastTxRequest::fee_payer_sig() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.fee_payer_sig)
  return _internal_fee_payer_sig();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxRequest::set_fee_payer_sig(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_sig_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.fee_payer_sig)
}
inline std::string* BroadcastTxRequest::mutable_fee_payer_sig() {
  std::string* _s = _internal_mutable_fee_payer_sig();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.fee_payer_sig)
  return _s;
}
inline const std::string& BroadcastTxRequest::_internal_fee_payer_sig() const {
  return _impl_.fee_payer_sig_.Get();
}
inline void BroadcastTxRequest::_internal_set_fee_payer_sig(const std::string& value) {
  ;


  _impl_.fee_payer_sig_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::_internal_mutable_fee_payer_sig() {
  ;
  return _impl_.fee_payer_sig_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::release_fee_payer_sig() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.fee_payer_sig)
  return _impl_.fee_payer_sig_.Release();
}
inline void BroadcastTxRequest::set_allocated_fee_payer_sig(std::string* value) {
  _impl_.fee_payer_sig_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_sig_.IsDefault()) {
          _impl_.fee_payer_sig_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.fee_payer_sig)
}

// string mode = 8 [json_name = "mode"];
inline void BroadcastTxRequest::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& BroadcastTxRequest::mode() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxRequest.mode)
  return _internal_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxRequest::set_mode(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxRequest.mode)
}
inline std::string* BroadcastTxRequest::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxRequest.mode)
  return _s;
}
inline const std::string& BroadcastTxRequest::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void BroadcastTxRequest::_internal_set_mode(const std::string& value) {
  ;


  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::_internal_mutable_mode() {
  ;
  return _impl_.mode_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxRequest::release_mode() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxRequest.mode)
  return _impl_.mode_.Release();
}
inline void BroadcastTxRequest::set_allocated_mode(std::string* value) {
  _impl_.mode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mode_.IsDefault()) {
          _impl_.mode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxRequest.mode)
}

// -------------------------------------------------------------------

// CosmosPubKey

// string type = 1 [json_name = "type"];
inline void CosmosPubKey::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& CosmosPubKey::type() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosPubKey.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosPubKey::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosPubKey.type)
}
inline std::string* CosmosPubKey::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.CosmosPubKey.type)
  return _s;
}
inline const std::string& CosmosPubKey::_internal_type() const {
  return _impl_.type_.Get();
}
inline void CosmosPubKey::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosPubKey::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosPubKey::release_type() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.CosmosPubKey.type)
  return _impl_.type_.Release();
}
inline void CosmosPubKey::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.CosmosPubKey.type)
}

// string key = 2 [json_name = "key"];
inline void CosmosPubKey::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CosmosPubKey::key() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.CosmosPubKey.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosPubKey::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.CosmosPubKey.key)
}
inline std::string* CosmosPubKey::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.CosmosPubKey.key)
  return _s;
}
inline const std::string& CosmosPubKey::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CosmosPubKey::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosPubKey::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosPubKey::release_key() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.CosmosPubKey.key)
  return _impl_.key_.Release();
}
inline void CosmosPubKey::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.CosmosPubKey.key)
}

// -------------------------------------------------------------------

// BroadcastTxResponse

// string tx_hash = 1 [json_name = "txHash"];
inline void BroadcastTxResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& BroadcastTxResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxResponse::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.tx_hash)
}
inline std::string* BroadcastTxResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxResponse.tx_hash)
  return _s;
}
inline const std::string& BroadcastTxResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void BroadcastTxResponse::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void BroadcastTxResponse::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxResponse.tx_hash)
}

// sint64 height = 2 [json_name = "height"];
inline void BroadcastTxResponse::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t BroadcastTxResponse::height() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.height)
  return _internal_height();
}
inline void BroadcastTxResponse::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.height)
}
inline ::int64_t BroadcastTxResponse::_internal_height() const {
  return _impl_.height_;
}
inline void BroadcastTxResponse::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 index = 3 [json_name = "index"];
inline void BroadcastTxResponse::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t BroadcastTxResponse::index() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.index)
  return _internal_index();
}
inline void BroadcastTxResponse::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.index)
}
inline ::uint32_t BroadcastTxResponse::_internal_index() const {
  return _impl_.index_;
}
inline void BroadcastTxResponse::_internal_set_index(::uint32_t value) {
  ;
  _impl_.index_ = value;
}

// string codespace = 4 [json_name = "codespace"];
inline void BroadcastTxResponse::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& BroadcastTxResponse::codespace() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxResponse::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.codespace)
}
inline std::string* BroadcastTxResponse::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxResponse.codespace)
  return _s;
}
inline const std::string& BroadcastTxResponse::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void BroadcastTxResponse::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxResponse.codespace)
  return _impl_.codespace_.Release();
}
inline void BroadcastTxResponse::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxResponse.codespace)
}

// uint32 code = 5 [json_name = "code"];
inline void BroadcastTxResponse::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t BroadcastTxResponse::code() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.code)
  return _internal_code();
}
inline void BroadcastTxResponse::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.code)
}
inline ::uint32_t BroadcastTxResponse::_internal_code() const {
  return _impl_.code_;
}
inline void BroadcastTxResponse::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 6 [json_name = "data"];
inline void BroadcastTxResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& BroadcastTxResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.data)
}
inline std::string* BroadcastTxResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxResponse.data)
  return _s;
}
inline const std::string& BroadcastTxResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void BroadcastTxResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::release_data() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxResponse.data)
  return _impl_.data_.Release();
}
inline void BroadcastTxResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxResponse.data)
}

// string raw_log = 7 [json_name = "rawLog"];
inline void BroadcastTxResponse::clear_raw_log() {
  _impl_.raw_log_.ClearToEmpty();
}
inline const std::string& BroadcastTxResponse::raw_log() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.raw_log)
  return _internal_raw_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxResponse::set_raw_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.raw_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.raw_log)
}
inline std::string* BroadcastTxResponse::mutable_raw_log() {
  std::string* _s = _internal_mutable_raw_log();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxResponse.raw_log)
  return _s;
}
inline const std::string& BroadcastTxResponse::_internal_raw_log() const {
  return _impl_.raw_log_.Get();
}
inline void BroadcastTxResponse::_internal_set_raw_log(const std::string& value) {
  ;


  _impl_.raw_log_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::_internal_mutable_raw_log() {
  ;
  return _impl_.raw_log_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::release_raw_log() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxResponse.raw_log)
  return _impl_.raw_log_.Release();
}
inline void BroadcastTxResponse::set_allocated_raw_log(std::string* value) {
  _impl_.raw_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_log_.IsDefault()) {
          _impl_.raw_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxResponse.raw_log)
}

// string timestamp = 8 [json_name = "timestamp"];
inline void BroadcastTxResponse::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& BroadcastTxResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastTxResponse.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastTxResponse::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastTxResponse.timestamp)
}
inline std::string* BroadcastTxResponse::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastTxResponse.timestamp)
  return _s;
}
inline const std::string& BroadcastTxResponse::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void BroadcastTxResponse::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastTxResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastTxResponse.timestamp)
  return _impl_.timestamp_.Release();
}
inline void BroadcastTxResponse::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastTxResponse.timestamp)
}

// -------------------------------------------------------------------

// PrepareCosmosTxRequest

// uint64 chain_id = 1 [json_name = "chainId"];
inline void PrepareCosmosTxRequest::clear_chain_id() {
  _impl_.chain_id_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareCosmosTxRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.chain_id)
  return _internal_chain_id();
}
inline void PrepareCosmosTxRequest::set_chain_id(::uint64_t value) {
  _internal_set_chain_id(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.chain_id)
}
inline ::uint64_t PrepareCosmosTxRequest::_internal_chain_id() const {
  return _impl_.chain_id_;
}
inline void PrepareCosmosTxRequest::_internal_set_chain_id(::uint64_t value) {
  ;
  _impl_.chain_id_ = value;
}

// string sender_address = 2 [json_name = "senderAddress"];
inline void PrepareCosmosTxRequest::clear_sender_address() {
  _impl_.sender_address_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxRequest::sender_address() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.sender_address)
  return _internal_sender_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxRequest::set_sender_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.sender_address)
}
inline std::string* PrepareCosmosTxRequest::mutable_sender_address() {
  std::string* _s = _internal_mutable_sender_address();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxRequest.sender_address)
  return _s;
}
inline const std::string& PrepareCosmosTxRequest::_internal_sender_address() const {
  return _impl_.sender_address_.Get();
}
inline void PrepareCosmosTxRequest::_internal_set_sender_address(const std::string& value) {
  ;


  _impl_.sender_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxRequest::_internal_mutable_sender_address() {
  ;
  return _impl_.sender_address_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxRequest::release_sender_address() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxRequest.sender_address)
  return _impl_.sender_address_.Release();
}
inline void PrepareCosmosTxRequest::set_allocated_sender_address(std::string* value) {
  _impl_.sender_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_address_.IsDefault()) {
          _impl_.sender_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxRequest.sender_address)
}

// string memo = 3 [json_name = "memo"];
inline void PrepareCosmosTxRequest::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxRequest::memo() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.memo)
  return _internal_memo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxRequest::set_memo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.memo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.memo)
}
inline std::string* PrepareCosmosTxRequest::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxRequest.memo)
  return _s;
}
inline const std::string& PrepareCosmosTxRequest::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void PrepareCosmosTxRequest::_internal_set_memo(const std::string& value) {
  ;


  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxRequest::_internal_mutable_memo() {
  ;
  return _impl_.memo_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxRequest::release_memo() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxRequest.memo)
  return _impl_.memo_.Release();
}
inline void PrepareCosmosTxRequest::set_allocated_memo(std::string* value) {
  _impl_.memo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memo_.IsDefault()) {
          _impl_.memo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxRequest.memo)
}

// uint64 timeout_height = 4 [json_name = "timeoutHeight"];
inline void PrepareCosmosTxRequest::clear_timeout_height() {
  _impl_.timeout_height_ = ::uint64_t{0u};
}
inline ::uint64_t PrepareCosmosTxRequest::timeout_height() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.timeout_height)
  return _internal_timeout_height();
}
inline void PrepareCosmosTxRequest::set_timeout_height(::uint64_t value) {
  _internal_set_timeout_height(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.timeout_height)
}
inline ::uint64_t PrepareCosmosTxRequest::_internal_timeout_height() const {
  return _impl_.timeout_height_;
}
inline void PrepareCosmosTxRequest::_internal_set_timeout_height(::uint64_t value) {
  ;
  _impl_.timeout_height_ = value;
}

// .injective_exchange_rpc.CosmosTxFee fee = 5 [json_name = "fee"];
inline bool PrepareCosmosTxRequest::has_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_ != nullptr);
  return value;
}
inline void PrepareCosmosTxRequest::clear_fee() {
  if (_impl_.fee_ != nullptr) _impl_.fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosTxFee& PrepareCosmosTxRequest::_internal_fee() const {
  const ::injective_exchange_rpc::CosmosTxFee* p = _impl_.fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosTxFee&>(
      ::injective_exchange_rpc::_CosmosTxFee_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosTxFee& PrepareCosmosTxRequest::fee() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.fee)
  return _internal_fee();
}
inline void PrepareCosmosTxRequest::unsafe_arena_set_allocated_fee(
    ::injective_exchange_rpc::CosmosTxFee* fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_);
  }
  _impl_.fee_ = fee;
  if (fee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.PrepareCosmosTxRequest.fee)
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareCosmosTxRequest::release_fee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosTxFee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareCosmosTxRequest::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxRequest.fee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosTxFee* temp = _impl_.fee_;
  _impl_.fee_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareCosmosTxRequest::_internal_mutable_fee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosTxFee>(GetArenaForAllocation());
    _impl_.fee_ = p;
  }
  return _impl_.fee_;
}
inline ::injective_exchange_rpc::CosmosTxFee* PrepareCosmosTxRequest::mutable_fee() {
  ::injective_exchange_rpc::CosmosTxFee* _msg = _internal_mutable_fee();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxRequest.fee)
  return _msg;
}
inline void PrepareCosmosTxRequest::set_allocated_fee(::injective_exchange_rpc::CosmosTxFee* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fee_;
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fee);
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxRequest.fee)
}

// repeated bytes msgs = 6 [json_name = "msgs"];
inline int PrepareCosmosTxRequest::_internal_msgs_size() const {
  return _impl_.msgs_.size();
}
inline int PrepareCosmosTxRequest::msgs_size() const {
  return _internal_msgs_size();
}
inline void PrepareCosmosTxRequest::clear_msgs() {
  _internal_mutable_msgs()->Clear();
}
inline std::string* PrepareCosmosTxRequest::add_msgs() {
  std::string* _s = _internal_add_msgs();
  // @@protoc_insertion_point(field_add_mutable:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
  return _s;
}
inline const std::string& PrepareCosmosTxRequest::msgs(int index) const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
  return _internal_msgs(index);
}
inline std::string* PrepareCosmosTxRequest::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
  return _internal_mutable_msgs()->Mutable(index);
}
inline void PrepareCosmosTxRequest::set_msgs(int index, const std::string& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::set_msgs(int index, std::string&& value) {
  _internal_mutable_msgs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::set_msgs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::set_msgs(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_msgs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::set_msgs(int index, absl::string_view value) {
  _internal_mutable_msgs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::add_msgs(const std::string& value) {
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::add_msgs(std::string&& value) {
  _internal_mutable_msgs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::add_msgs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_msgs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::add_msgs(const void* value, std::size_t size) {
  _internal_mutable_msgs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline void PrepareCosmosTxRequest::add_msgs(absl::string_view value) {
  _internal_mutable_msgs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PrepareCosmosTxRequest::msgs() const {
  // @@protoc_insertion_point(field_list:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
  return _internal_msgs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PrepareCosmosTxRequest::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:injective_exchange_rpc.PrepareCosmosTxRequest.msgs)
  return _internal_mutable_msgs();
}
inline const std::string& PrepareCosmosTxRequest::_internal_msgs(int index) const {
  return _internal_msgs().Get(index);
}
inline std::string* PrepareCosmosTxRequest::_internal_add_msgs() {
  return _internal_mutable_msgs()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PrepareCosmosTxRequest::_internal_msgs() const {
  return _impl_.msgs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PrepareCosmosTxRequest::_internal_mutable_msgs() {
  return &_impl_.msgs_;
}

// -------------------------------------------------------------------

// PrepareCosmosTxResponse

// bytes tx = 1 [json_name = "tx"];
inline void PrepareCosmosTxResponse::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxResponse::tx() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxResponse::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxResponse.tx)
}
inline std::string* PrepareCosmosTxResponse::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.tx)
  return _s;
}
inline const std::string& PrepareCosmosTxResponse::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void PrepareCosmosTxResponse::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::release_tx() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.tx)
  return _impl_.tx_.Release();
}
inline void PrepareCosmosTxResponse::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.tx)
}

// string sign_mode = 2 [json_name = "signMode"];
inline void PrepareCosmosTxResponse::clear_sign_mode() {
  _impl_.sign_mode_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxResponse::sign_mode() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.sign_mode)
  return _internal_sign_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxResponse::set_sign_mode(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sign_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxResponse.sign_mode)
}
inline std::string* PrepareCosmosTxResponse::mutable_sign_mode() {
  std::string* _s = _internal_mutable_sign_mode();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.sign_mode)
  return _s;
}
inline const std::string& PrepareCosmosTxResponse::_internal_sign_mode() const {
  return _impl_.sign_mode_.Get();
}
inline void PrepareCosmosTxResponse::_internal_set_sign_mode(const std::string& value) {
  ;


  _impl_.sign_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::_internal_mutable_sign_mode() {
  ;
  return _impl_.sign_mode_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::release_sign_mode() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.sign_mode)
  return _impl_.sign_mode_.Release();
}
inline void PrepareCosmosTxResponse::set_allocated_sign_mode(std::string* value) {
  _impl_.sign_mode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sign_mode_.IsDefault()) {
          _impl_.sign_mode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.sign_mode)
}

// string pub_key_type = 3 [json_name = "pubKeyType"];
inline void PrepareCosmosTxResponse::clear_pub_key_type() {
  _impl_.pub_key_type_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxResponse::pub_key_type() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.pub_key_type)
  return _internal_pub_key_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxResponse::set_pub_key_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pub_key_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxResponse.pub_key_type)
}
inline std::string* PrepareCosmosTxResponse::mutable_pub_key_type() {
  std::string* _s = _internal_mutable_pub_key_type();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.pub_key_type)
  return _s;
}
inline const std::string& PrepareCosmosTxResponse::_internal_pub_key_type() const {
  return _impl_.pub_key_type_.Get();
}
inline void PrepareCosmosTxResponse::_internal_set_pub_key_type(const std::string& value) {
  ;


  _impl_.pub_key_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::_internal_mutable_pub_key_type() {
  ;
  return _impl_.pub_key_type_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::release_pub_key_type() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.pub_key_type)
  return _impl_.pub_key_type_.Release();
}
inline void PrepareCosmosTxResponse::set_allocated_pub_key_type(std::string* value) {
  _impl_.pub_key_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pub_key_type_.IsDefault()) {
          _impl_.pub_key_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.pub_key_type)
}

// string fee_payer = 4 [json_name = "feePayer"];
inline void PrepareCosmosTxResponse::clear_fee_payer() {
  _impl_.fee_payer_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxResponse::fee_payer() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer)
  return _internal_fee_payer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxResponse::set_fee_payer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer)
}
inline std::string* PrepareCosmosTxResponse::mutable_fee_payer() {
  std::string* _s = _internal_mutable_fee_payer();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer)
  return _s;
}
inline const std::string& PrepareCosmosTxResponse::_internal_fee_payer() const {
  return _impl_.fee_payer_.Get();
}
inline void PrepareCosmosTxResponse::_internal_set_fee_payer(const std::string& value) {
  ;


  _impl_.fee_payer_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::_internal_mutable_fee_payer() {
  ;
  return _impl_.fee_payer_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::release_fee_payer() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer)
  return _impl_.fee_payer_.Release();
}
inline void PrepareCosmosTxResponse::set_allocated_fee_payer(std::string* value) {
  _impl_.fee_payer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_.IsDefault()) {
          _impl_.fee_payer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer)
}

// string fee_payer_sig = 5 [json_name = "feePayerSig"];
inline void PrepareCosmosTxResponse::clear_fee_payer_sig() {
  _impl_.fee_payer_sig_.ClearToEmpty();
}
inline const std::string& PrepareCosmosTxResponse::fee_payer_sig() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_sig)
  return _internal_fee_payer_sig();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PrepareCosmosTxResponse::set_fee_payer_sig(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_sig_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_sig)
}
inline std::string* PrepareCosmosTxResponse::mutable_fee_payer_sig() {
  std::string* _s = _internal_mutable_fee_payer_sig();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_sig)
  return _s;
}
inline const std::string& PrepareCosmosTxResponse::_internal_fee_payer_sig() const {
  return _impl_.fee_payer_sig_.Get();
}
inline void PrepareCosmosTxResponse::_internal_set_fee_payer_sig(const std::string& value) {
  ;


  _impl_.fee_payer_sig_.Set(value, GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::_internal_mutable_fee_payer_sig() {
  ;
  return _impl_.fee_payer_sig_.Mutable( GetArenaForAllocation());
}
inline std::string* PrepareCosmosTxResponse::release_fee_payer_sig() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_sig)
  return _impl_.fee_payer_sig_.Release();
}
inline void PrepareCosmosTxResponse::set_allocated_fee_payer_sig(std::string* value) {
  _impl_.fee_payer_sig_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_sig_.IsDefault()) {
          _impl_.fee_payer_sig_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_sig)
}

// .injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 6 [json_name = "feePayerPubKey"];
inline bool PrepareCosmosTxResponse::has_fee_payer_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_payer_pub_key_ != nullptr);
  return value;
}
inline void PrepareCosmosTxResponse::clear_fee_payer_pub_key() {
  if (_impl_.fee_payer_pub_key_ != nullptr) _impl_.fee_payer_pub_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosPubKey& PrepareCosmosTxResponse::_internal_fee_payer_pub_key() const {
  const ::injective_exchange_rpc::CosmosPubKey* p = _impl_.fee_payer_pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosPubKey&>(
      ::injective_exchange_rpc::_CosmosPubKey_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosPubKey& PrepareCosmosTxResponse::fee_payer_pub_key() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_pub_key)
  return _internal_fee_payer_pub_key();
}
inline void PrepareCosmosTxResponse::unsafe_arena_set_allocated_fee_payer_pub_key(
    ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_payer_pub_key_);
  }
  _impl_.fee_payer_pub_key_ = fee_payer_pub_key;
  if (fee_payer_pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_pub_key)
}
inline ::injective_exchange_rpc::CosmosPubKey* PrepareCosmosTxResponse::release_fee_payer_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.fee_payer_pub_key_;
  _impl_.fee_payer_pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* PrepareCosmosTxResponse::unsafe_arena_release_fee_payer_pub_key() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.fee_payer_pub_key_;
  _impl_.fee_payer_pub_key_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* PrepareCosmosTxResponse::_internal_mutable_fee_payer_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_payer_pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosPubKey>(GetArenaForAllocation());
    _impl_.fee_payer_pub_key_ = p;
  }
  return _impl_.fee_payer_pub_key_;
}
inline ::injective_exchange_rpc::CosmosPubKey* PrepareCosmosTxResponse::mutable_fee_payer_pub_key() {
  ::injective_exchange_rpc::CosmosPubKey* _msg = _internal_mutable_fee_payer_pub_key();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_pub_key)
  return _msg;
}
inline void PrepareCosmosTxResponse::set_allocated_fee_payer_pub_key(::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fee_payer_pub_key_;
  }
  if (fee_payer_pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fee_payer_pub_key);
    if (message_arena != submessage_arena) {
      fee_payer_pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee_payer_pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_payer_pub_key_ = fee_payer_pub_key;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.PrepareCosmosTxResponse.fee_payer_pub_key)
}

// -------------------------------------------------------------------

// BroadcastCosmosTxRequest

// bytes tx = 1 [json_name = "tx"];
inline void BroadcastCosmosTxRequest::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxRequest::tx() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxRequest.tx)
  return _internal_tx();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxRequest::set_tx(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxRequest.tx)
}
inline std::string* BroadcastCosmosTxRequest::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxRequest.tx)
  return _s;
}
inline const std::string& BroadcastCosmosTxRequest::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void BroadcastCosmosTxRequest::_internal_set_tx(const std::string& value) {
  ;


  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::_internal_mutable_tx() {
  ;
  return _impl_.tx_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::release_tx() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxRequest.tx)
  return _impl_.tx_.Release();
}
inline void BroadcastCosmosTxRequest::set_allocated_tx(std::string* value) {
  _impl_.tx_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_.IsDefault()) {
          _impl_.tx_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxRequest.tx)
}

// .injective_exchange_rpc.CosmosPubKey pub_key = 2 [json_name = "pubKey"];
inline bool BroadcastCosmosTxRequest::has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pub_key_ != nullptr);
  return value;
}
inline void BroadcastCosmosTxRequest::clear_pub_key() {
  if (_impl_.pub_key_ != nullptr) _impl_.pub_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosPubKey& BroadcastCosmosTxRequest::_internal_pub_key() const {
  const ::injective_exchange_rpc::CosmosPubKey* p = _impl_.pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosPubKey&>(
      ::injective_exchange_rpc::_CosmosPubKey_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosPubKey& BroadcastCosmosTxRequest::pub_key() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxRequest.pub_key)
  return _internal_pub_key();
}
inline void BroadcastCosmosTxRequest::unsafe_arena_set_allocated_pub_key(
    ::injective_exchange_rpc::CosmosPubKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pub_key_);
  }
  _impl_.pub_key_ = pub_key;
  if (pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.BroadcastCosmosTxRequest.pub_key)
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastCosmosTxRequest::release_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastCosmosTxRequest::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxRequest.pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.pub_key_;
  _impl_.pub_key_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastCosmosTxRequest::_internal_mutable_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosPubKey>(GetArenaForAllocation());
    _impl_.pub_key_ = p;
  }
  return _impl_.pub_key_;
}
inline ::injective_exchange_rpc::CosmosPubKey* BroadcastCosmosTxRequest::mutable_pub_key() {
  ::injective_exchange_rpc::CosmosPubKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxRequest.pub_key)
  return _msg;
}
inline void BroadcastCosmosTxRequest::set_allocated_pub_key(::injective_exchange_rpc::CosmosPubKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pub_key_;
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pub_key);
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxRequest.pub_key)
}

// string signature = 3 [json_name = "signature"];
inline void BroadcastCosmosTxRequest::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxRequest::signature() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxRequest.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxRequest::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signature_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxRequest.signature)
}
inline std::string* BroadcastCosmosTxRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxRequest.signature)
  return _s;
}
inline const std::string& BroadcastCosmosTxRequest::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void BroadcastCosmosTxRequest::_internal_set_signature(const std::string& value) {
  ;


  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::_internal_mutable_signature() {
  ;
  return _impl_.signature_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::release_signature() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxRequest.signature)
  return _impl_.signature_.Release();
}
inline void BroadcastCosmosTxRequest::set_allocated_signature(std::string* value) {
  _impl_.signature_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxRequest.signature)
}

// string sender_address = 4 [json_name = "senderAddress"];
inline void BroadcastCosmosTxRequest::clear_sender_address() {
  _impl_.sender_address_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxRequest::sender_address() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxRequest.sender_address)
  return _internal_sender_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxRequest::set_sender_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxRequest.sender_address)
}
inline std::string* BroadcastCosmosTxRequest::mutable_sender_address() {
  std::string* _s = _internal_mutable_sender_address();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxRequest.sender_address)
  return _s;
}
inline const std::string& BroadcastCosmosTxRequest::_internal_sender_address() const {
  return _impl_.sender_address_.Get();
}
inline void BroadcastCosmosTxRequest::_internal_set_sender_address(const std::string& value) {
  ;


  _impl_.sender_address_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::_internal_mutable_sender_address() {
  ;
  return _impl_.sender_address_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxRequest::release_sender_address() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxRequest.sender_address)
  return _impl_.sender_address_.Release();
}
inline void BroadcastCosmosTxRequest::set_allocated_sender_address(std::string* value) {
  _impl_.sender_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_address_.IsDefault()) {
          _impl_.sender_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxRequest.sender_address)
}

// -------------------------------------------------------------------

// BroadcastCosmosTxResponse

// string tx_hash = 1 [json_name = "txHash"];
inline void BroadcastCosmosTxResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxResponse::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.tx_hash)
}
inline std::string* BroadcastCosmosTxResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxResponse.tx_hash)
  return _s;
}
inline const std::string& BroadcastCosmosTxResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void BroadcastCosmosTxResponse::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void BroadcastCosmosTxResponse::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxResponse.tx_hash)
}

// sint64 height = 2 [json_name = "height"];
inline void BroadcastCosmosTxResponse::clear_height() {
  _impl_.height_ = ::int64_t{0};
}
inline ::int64_t BroadcastCosmosTxResponse::height() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.height)
  return _internal_height();
}
inline void BroadcastCosmosTxResponse::set_height(::int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.height)
}
inline ::int64_t BroadcastCosmosTxResponse::_internal_height() const {
  return _impl_.height_;
}
inline void BroadcastCosmosTxResponse::_internal_set_height(::int64_t value) {
  ;
  _impl_.height_ = value;
}

// uint32 index = 3 [json_name = "index"];
inline void BroadcastCosmosTxResponse::clear_index() {
  _impl_.index_ = 0u;
}
inline ::uint32_t BroadcastCosmosTxResponse::index() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.index)
  return _internal_index();
}
inline void BroadcastCosmosTxResponse::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.index)
}
inline ::uint32_t BroadcastCosmosTxResponse::_internal_index() const {
  return _impl_.index_;
}
inline void BroadcastCosmosTxResponse::_internal_set_index(::uint32_t value) {
  ;
  _impl_.index_ = value;
}

// string codespace = 4 [json_name = "codespace"];
inline void BroadcastCosmosTxResponse::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxResponse::codespace() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxResponse::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.codespace)
}
inline std::string* BroadcastCosmosTxResponse::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxResponse.codespace)
  return _s;
}
inline const std::string& BroadcastCosmosTxResponse::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void BroadcastCosmosTxResponse::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxResponse.codespace)
  return _impl_.codespace_.Release();
}
inline void BroadcastCosmosTxResponse::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxResponse.codespace)
}

// uint32 code = 5 [json_name = "code"];
inline void BroadcastCosmosTxResponse::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t BroadcastCosmosTxResponse::code() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.code)
  return _internal_code();
}
inline void BroadcastCosmosTxResponse::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.code)
}
inline ::uint32_t BroadcastCosmosTxResponse::_internal_code() const {
  return _impl_.code_;
}
inline void BroadcastCosmosTxResponse::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 6 [json_name = "data"];
inline void BroadcastCosmosTxResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.data)
}
inline std::string* BroadcastCosmosTxResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxResponse.data)
  return _s;
}
inline const std::string& BroadcastCosmosTxResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void BroadcastCosmosTxResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::release_data() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxResponse.data)
  return _impl_.data_.Release();
}
inline void BroadcastCosmosTxResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxResponse.data)
}

// string raw_log = 7 [json_name = "rawLog"];
inline void BroadcastCosmosTxResponse::clear_raw_log() {
  _impl_.raw_log_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxResponse::raw_log() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.raw_log)
  return _internal_raw_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxResponse::set_raw_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.raw_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.raw_log)
}
inline std::string* BroadcastCosmosTxResponse::mutable_raw_log() {
  std::string* _s = _internal_mutable_raw_log();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxResponse.raw_log)
  return _s;
}
inline const std::string& BroadcastCosmosTxResponse::_internal_raw_log() const {
  return _impl_.raw_log_.Get();
}
inline void BroadcastCosmosTxResponse::_internal_set_raw_log(const std::string& value) {
  ;


  _impl_.raw_log_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::_internal_mutable_raw_log() {
  ;
  return _impl_.raw_log_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::release_raw_log() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxResponse.raw_log)
  return _impl_.raw_log_.Release();
}
inline void BroadcastCosmosTxResponse::set_allocated_raw_log(std::string* value) {
  _impl_.raw_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_log_.IsDefault()) {
          _impl_.raw_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxResponse.raw_log)
}

// string timestamp = 8 [json_name = "timestamp"];
inline void BroadcastCosmosTxResponse::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& BroadcastCosmosTxResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.BroadcastCosmosTxResponse.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastCosmosTxResponse::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.BroadcastCosmosTxResponse.timestamp)
}
inline std::string* BroadcastCosmosTxResponse::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.BroadcastCosmosTxResponse.timestamp)
  return _s;
}
inline const std::string& BroadcastCosmosTxResponse::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void BroadcastCosmosTxResponse::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* BroadcastCosmosTxResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.BroadcastCosmosTxResponse.timestamp)
  return _impl_.timestamp_.Release();
}
inline void BroadcastCosmosTxResponse::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.BroadcastCosmosTxResponse.timestamp)
}

// -------------------------------------------------------------------

// GetFeePayerRequest

// -------------------------------------------------------------------

// GetFeePayerResponse

// string fee_payer = 1 [json_name = "feePayer"];
inline void GetFeePayerResponse::clear_fee_payer() {
  _impl_.fee_payer_.ClearToEmpty();
}
inline const std::string& GetFeePayerResponse::fee_payer() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetFeePayerResponse.fee_payer)
  return _internal_fee_payer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetFeePayerResponse::set_fee_payer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.fee_payer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_exchange_rpc.GetFeePayerResponse.fee_payer)
}
inline std::string* GetFeePayerResponse::mutable_fee_payer() {
  std::string* _s = _internal_mutable_fee_payer();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetFeePayerResponse.fee_payer)
  return _s;
}
inline const std::string& GetFeePayerResponse::_internal_fee_payer() const {
  return _impl_.fee_payer_.Get();
}
inline void GetFeePayerResponse::_internal_set_fee_payer(const std::string& value) {
  ;


  _impl_.fee_payer_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFeePayerResponse::_internal_mutable_fee_payer() {
  ;
  return _impl_.fee_payer_.Mutable( GetArenaForAllocation());
}
inline std::string* GetFeePayerResponse::release_fee_payer() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetFeePayerResponse.fee_payer)
  return _impl_.fee_payer_.Release();
}
inline void GetFeePayerResponse::set_allocated_fee_payer(std::string* value) {
  _impl_.fee_payer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fee_payer_.IsDefault()) {
          _impl_.fee_payer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetFeePayerResponse.fee_payer)
}

// .injective_exchange_rpc.CosmosPubKey fee_payer_pub_key = 2 [json_name = "feePayerPubKey"];
inline bool GetFeePayerResponse::has_fee_payer_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fee_payer_pub_key_ != nullptr);
  return value;
}
inline void GetFeePayerResponse::clear_fee_payer_pub_key() {
  if (_impl_.fee_payer_pub_key_ != nullptr) _impl_.fee_payer_pub_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_exchange_rpc::CosmosPubKey& GetFeePayerResponse::_internal_fee_payer_pub_key() const {
  const ::injective_exchange_rpc::CosmosPubKey* p = _impl_.fee_payer_pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_exchange_rpc::CosmosPubKey&>(
      ::injective_exchange_rpc::_CosmosPubKey_default_instance_);
}
inline const ::injective_exchange_rpc::CosmosPubKey& GetFeePayerResponse::fee_payer_pub_key() const {
  // @@protoc_insertion_point(field_get:injective_exchange_rpc.GetFeePayerResponse.fee_payer_pub_key)
  return _internal_fee_payer_pub_key();
}
inline void GetFeePayerResponse::unsafe_arena_set_allocated_fee_payer_pub_key(
    ::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fee_payer_pub_key_);
  }
  _impl_.fee_payer_pub_key_ = fee_payer_pub_key;
  if (fee_payer_pub_key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_exchange_rpc.GetFeePayerResponse.fee_payer_pub_key)
}
inline ::injective_exchange_rpc::CosmosPubKey* GetFeePayerResponse::release_fee_payer_pub_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.fee_payer_pub_key_;
  _impl_.fee_payer_pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* GetFeePayerResponse::unsafe_arena_release_fee_payer_pub_key() {
  // @@protoc_insertion_point(field_release:injective_exchange_rpc.GetFeePayerResponse.fee_payer_pub_key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_exchange_rpc::CosmosPubKey* temp = _impl_.fee_payer_pub_key_;
  _impl_.fee_payer_pub_key_ = nullptr;
  return temp;
}
inline ::injective_exchange_rpc::CosmosPubKey* GetFeePayerResponse::_internal_mutable_fee_payer_pub_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fee_payer_pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_exchange_rpc::CosmosPubKey>(GetArenaForAllocation());
    _impl_.fee_payer_pub_key_ = p;
  }
  return _impl_.fee_payer_pub_key_;
}
inline ::injective_exchange_rpc::CosmosPubKey* GetFeePayerResponse::mutable_fee_payer_pub_key() {
  ::injective_exchange_rpc::CosmosPubKey* _msg = _internal_mutable_fee_payer_pub_key();
  // @@protoc_insertion_point(field_mutable:injective_exchange_rpc.GetFeePayerResponse.fee_payer_pub_key)
  return _msg;
}
inline void GetFeePayerResponse::set_allocated_fee_payer_pub_key(::injective_exchange_rpc::CosmosPubKey* fee_payer_pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fee_payer_pub_key_;
  }
  if (fee_payer_pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fee_payer_pub_key);
    if (message_arena != submessage_arena) {
      fee_payer_pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee_payer_pub_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fee_payer_pub_key_ = fee_payer_pub_key;
  // @@protoc_insertion_point(field_set_allocated:injective_exchange_rpc.GetFeePayerResponse.fee_payer_pub_key)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_exchange_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexchange_5frpc_2eproto_2epb_2eh
