// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange/injective_explorer_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexplorer_5frpc_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexplorer_5frpc_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_exchange_2finjective_5fexplorer_5frpc_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_exchange_2finjective_5fexplorer_5frpc_2eproto;
namespace injective_explorer_rpc {
class BlockDetailInfo;
struct BlockDetailInfoDefaultTypeInternal;
extern BlockDetailInfoDefaultTypeInternal _BlockDetailInfo_default_instance_;
class BlockInfo;
struct BlockInfoDefaultTypeInternal;
extern BlockInfoDefaultTypeInternal _BlockInfo_default_instance_;
class Checksum;
struct ChecksumDefaultTypeInternal;
extern ChecksumDefaultTypeInternal _Checksum_default_instance_;
class ContractFund;
struct ContractFundDefaultTypeInternal;
extern ContractFundDefaultTypeInternal _ContractFund_default_instance_;
class ContractPermission;
struct ContractPermissionDefaultTypeInternal;
extern ContractPermissionDefaultTypeInternal _ContractPermission_default_instance_;
class CosmosCoin;
struct CosmosCoinDefaultTypeInternal;
extern CosmosCoinDefaultTypeInternal _CosmosCoin_default_instance_;
class Cw20MarketingInfo;
struct Cw20MarketingInfoDefaultTypeInternal;
extern Cw20MarketingInfoDefaultTypeInternal _Cw20MarketingInfo_default_instance_;
class Cw20Metadata;
struct Cw20MetadataDefaultTypeInternal;
extern Cw20MetadataDefaultTypeInternal _Cw20Metadata_default_instance_;
class Cw20TokenInfo;
struct Cw20TokenInfoDefaultTypeInternal;
extern Cw20TokenInfoDefaultTypeInternal _Cw20TokenInfo_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_AttributesEntry_DoNotUse;
struct Event_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Event_AttributesEntry_DoNotUseDefaultTypeInternal _Event_AttributesEntry_DoNotUse_default_instance_;
class GasFee;
struct GasFeeDefaultTypeInternal;
extern GasFeeDefaultTypeInternal _GasFee_default_instance_;
class GetAccountTxsRequest;
struct GetAccountTxsRequestDefaultTypeInternal;
extern GetAccountTxsRequestDefaultTypeInternal _GetAccountTxsRequest_default_instance_;
class GetAccountTxsResponse;
struct GetAccountTxsResponseDefaultTypeInternal;
extern GetAccountTxsResponseDefaultTypeInternal _GetAccountTxsResponse_default_instance_;
class GetBlockRequest;
struct GetBlockRequestDefaultTypeInternal;
extern GetBlockRequestDefaultTypeInternal _GetBlockRequest_default_instance_;
class GetBlockResponse;
struct GetBlockResponseDefaultTypeInternal;
extern GetBlockResponseDefaultTypeInternal _GetBlockResponse_default_instance_;
class GetBlocksRequest;
struct GetBlocksRequestDefaultTypeInternal;
extern GetBlocksRequestDefaultTypeInternal _GetBlocksRequest_default_instance_;
class GetBlocksResponse;
struct GetBlocksResponseDefaultTypeInternal;
extern GetBlocksResponseDefaultTypeInternal _GetBlocksResponse_default_instance_;
class GetContractTxsRequest;
struct GetContractTxsRequestDefaultTypeInternal;
extern GetContractTxsRequestDefaultTypeInternal _GetContractTxsRequest_default_instance_;
class GetContractTxsResponse;
struct GetContractTxsResponseDefaultTypeInternal;
extern GetContractTxsResponseDefaultTypeInternal _GetContractTxsResponse_default_instance_;
class GetCw20BalanceRequest;
struct GetCw20BalanceRequestDefaultTypeInternal;
extern GetCw20BalanceRequestDefaultTypeInternal _GetCw20BalanceRequest_default_instance_;
class GetCw20BalanceResponse;
struct GetCw20BalanceResponseDefaultTypeInternal;
extern GetCw20BalanceResponseDefaultTypeInternal _GetCw20BalanceResponse_default_instance_;
class GetIBCTransferTxsRequest;
struct GetIBCTransferTxsRequestDefaultTypeInternal;
extern GetIBCTransferTxsRequestDefaultTypeInternal _GetIBCTransferTxsRequest_default_instance_;
class GetIBCTransferTxsResponse;
struct GetIBCTransferTxsResponseDefaultTypeInternal;
extern GetIBCTransferTxsResponseDefaultTypeInternal _GetIBCTransferTxsResponse_default_instance_;
class GetPeggyDepositTxsRequest;
struct GetPeggyDepositTxsRequestDefaultTypeInternal;
extern GetPeggyDepositTxsRequestDefaultTypeInternal _GetPeggyDepositTxsRequest_default_instance_;
class GetPeggyDepositTxsResponse;
struct GetPeggyDepositTxsResponseDefaultTypeInternal;
extern GetPeggyDepositTxsResponseDefaultTypeInternal _GetPeggyDepositTxsResponse_default_instance_;
class GetPeggyWithdrawalTxsRequest;
struct GetPeggyWithdrawalTxsRequestDefaultTypeInternal;
extern GetPeggyWithdrawalTxsRequestDefaultTypeInternal _GetPeggyWithdrawalTxsRequest_default_instance_;
class GetPeggyWithdrawalTxsResponse;
struct GetPeggyWithdrawalTxsResponseDefaultTypeInternal;
extern GetPeggyWithdrawalTxsResponseDefaultTypeInternal _GetPeggyWithdrawalTxsResponse_default_instance_;
class GetTxByTxHashRequest;
struct GetTxByTxHashRequestDefaultTypeInternal;
extern GetTxByTxHashRequestDefaultTypeInternal _GetTxByTxHashRequest_default_instance_;
class GetTxByTxHashResponse;
struct GetTxByTxHashResponseDefaultTypeInternal;
extern GetTxByTxHashResponseDefaultTypeInternal _GetTxByTxHashResponse_default_instance_;
class GetTxsRequest;
struct GetTxsRequestDefaultTypeInternal;
extern GetTxsRequestDefaultTypeInternal _GetTxsRequest_default_instance_;
class GetTxsResponse;
struct GetTxsResponseDefaultTypeInternal;
extern GetTxsResponseDefaultTypeInternal _GetTxsResponse_default_instance_;
class GetValidatorRequest;
struct GetValidatorRequestDefaultTypeInternal;
extern GetValidatorRequestDefaultTypeInternal _GetValidatorRequest_default_instance_;
class GetValidatorResponse;
struct GetValidatorResponseDefaultTypeInternal;
extern GetValidatorResponseDefaultTypeInternal _GetValidatorResponse_default_instance_;
class GetValidatorUptimeRequest;
struct GetValidatorUptimeRequestDefaultTypeInternal;
extern GetValidatorUptimeRequestDefaultTypeInternal _GetValidatorUptimeRequest_default_instance_;
class GetValidatorUptimeResponse;
struct GetValidatorUptimeResponseDefaultTypeInternal;
extern GetValidatorUptimeResponseDefaultTypeInternal _GetValidatorUptimeResponse_default_instance_;
class GetValidatorsRequest;
struct GetValidatorsRequestDefaultTypeInternal;
extern GetValidatorsRequestDefaultTypeInternal _GetValidatorsRequest_default_instance_;
class GetValidatorsResponse;
struct GetValidatorsResponseDefaultTypeInternal;
extern GetValidatorsResponseDefaultTypeInternal _GetValidatorsResponse_default_instance_;
class GetWasmCodeByIDRequest;
struct GetWasmCodeByIDRequestDefaultTypeInternal;
extern GetWasmCodeByIDRequestDefaultTypeInternal _GetWasmCodeByIDRequest_default_instance_;
class GetWasmCodeByIDResponse;
struct GetWasmCodeByIDResponseDefaultTypeInternal;
extern GetWasmCodeByIDResponseDefaultTypeInternal _GetWasmCodeByIDResponse_default_instance_;
class GetWasmCodesRequest;
struct GetWasmCodesRequestDefaultTypeInternal;
extern GetWasmCodesRequestDefaultTypeInternal _GetWasmCodesRequest_default_instance_;
class GetWasmCodesResponse;
struct GetWasmCodesResponseDefaultTypeInternal;
extern GetWasmCodesResponseDefaultTypeInternal _GetWasmCodesResponse_default_instance_;
class GetWasmContractByAddressRequest;
struct GetWasmContractByAddressRequestDefaultTypeInternal;
extern GetWasmContractByAddressRequestDefaultTypeInternal _GetWasmContractByAddressRequest_default_instance_;
class GetWasmContractByAddressResponse;
struct GetWasmContractByAddressResponseDefaultTypeInternal;
extern GetWasmContractByAddressResponseDefaultTypeInternal _GetWasmContractByAddressResponse_default_instance_;
class GetWasmContractsRequest;
struct GetWasmContractsRequestDefaultTypeInternal;
extern GetWasmContractsRequestDefaultTypeInternal _GetWasmContractsRequest_default_instance_;
class GetWasmContractsResponse;
struct GetWasmContractsResponseDefaultTypeInternal;
extern GetWasmContractsResponseDefaultTypeInternal _GetWasmContractsResponse_default_instance_;
class IBCTransferTx;
struct IBCTransferTxDefaultTypeInternal;
extern IBCTransferTxDefaultTypeInternal _IBCTransferTx_default_instance_;
class Paging;
struct PagingDefaultTypeInternal;
extern PagingDefaultTypeInternal _Paging_default_instance_;
class PeggyDepositTx;
struct PeggyDepositTxDefaultTypeInternal;
extern PeggyDepositTxDefaultTypeInternal _PeggyDepositTx_default_instance_;
class PeggyWithdrawalTx;
struct PeggyWithdrawalTxDefaultTypeInternal;
extern PeggyWithdrawalTxDefaultTypeInternal _PeggyWithdrawalTx_default_instance_;
class Relayer;
struct RelayerDefaultTypeInternal;
extern RelayerDefaultTypeInternal _Relayer_default_instance_;
class RelayerMarkets;
struct RelayerMarketsDefaultTypeInternal;
extern RelayerMarketsDefaultTypeInternal _RelayerMarkets_default_instance_;
class RelayersRequest;
struct RelayersRequestDefaultTypeInternal;
extern RelayersRequestDefaultTypeInternal _RelayersRequest_default_instance_;
class RelayersResponse;
struct RelayersResponseDefaultTypeInternal;
extern RelayersResponseDefaultTypeInternal _RelayersResponse_default_instance_;
class Signature;
struct SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class SlashingEvent;
struct SlashingEventDefaultTypeInternal;
extern SlashingEventDefaultTypeInternal _SlashingEvent_default_instance_;
class StreamBlocksRequest;
struct StreamBlocksRequestDefaultTypeInternal;
extern StreamBlocksRequestDefaultTypeInternal _StreamBlocksRequest_default_instance_;
class StreamBlocksResponse;
struct StreamBlocksResponseDefaultTypeInternal;
extern StreamBlocksResponseDefaultTypeInternal _StreamBlocksResponse_default_instance_;
class StreamTxsRequest;
struct StreamTxsRequestDefaultTypeInternal;
extern StreamTxsRequestDefaultTypeInternal _StreamTxsRequest_default_instance_;
class StreamTxsResponse;
struct StreamTxsResponseDefaultTypeInternal;
extern StreamTxsResponseDefaultTypeInternal _StreamTxsResponse_default_instance_;
class TxData;
struct TxDataDefaultTypeInternal;
extern TxDataDefaultTypeInternal _TxData_default_instance_;
class TxDataRPC;
struct TxDataRPCDefaultTypeInternal;
extern TxDataRPCDefaultTypeInternal _TxDataRPC_default_instance_;
class TxDetailData;
struct TxDetailDataDefaultTypeInternal;
extern TxDetailDataDefaultTypeInternal _TxDetailData_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorDescription;
struct ValidatorDescriptionDefaultTypeInternal;
extern ValidatorDescriptionDefaultTypeInternal _ValidatorDescription_default_instance_;
class ValidatorUptime;
struct ValidatorUptimeDefaultTypeInternal;
extern ValidatorUptimeDefaultTypeInternal _ValidatorUptime_default_instance_;
class WasmCode;
struct WasmCodeDefaultTypeInternal;
extern WasmCodeDefaultTypeInternal _WasmCode_default_instance_;
class WasmContract;
struct WasmContractDefaultTypeInternal;
extern WasmContractDefaultTypeInternal _WasmContract_default_instance_;
class WasmCw20Balance;
struct WasmCw20BalanceDefaultTypeInternal;
extern WasmCw20BalanceDefaultTypeInternal _WasmCw20Balance_default_instance_;
}  // namespace injective_explorer_rpc
PROTOBUF_NAMESPACE_OPEN
template <>
::injective_explorer_rpc::BlockDetailInfo* Arena::CreateMaybeMessage<::injective_explorer_rpc::BlockDetailInfo>(Arena*);
template <>
::injective_explorer_rpc::BlockInfo* Arena::CreateMaybeMessage<::injective_explorer_rpc::BlockInfo>(Arena*);
template <>
::injective_explorer_rpc::Checksum* Arena::CreateMaybeMessage<::injective_explorer_rpc::Checksum>(Arena*);
template <>
::injective_explorer_rpc::ContractFund* Arena::CreateMaybeMessage<::injective_explorer_rpc::ContractFund>(Arena*);
template <>
::injective_explorer_rpc::ContractPermission* Arena::CreateMaybeMessage<::injective_explorer_rpc::ContractPermission>(Arena*);
template <>
::injective_explorer_rpc::CosmosCoin* Arena::CreateMaybeMessage<::injective_explorer_rpc::CosmosCoin>(Arena*);
template <>
::injective_explorer_rpc::Cw20MarketingInfo* Arena::CreateMaybeMessage<::injective_explorer_rpc::Cw20MarketingInfo>(Arena*);
template <>
::injective_explorer_rpc::Cw20Metadata* Arena::CreateMaybeMessage<::injective_explorer_rpc::Cw20Metadata>(Arena*);
template <>
::injective_explorer_rpc::Cw20TokenInfo* Arena::CreateMaybeMessage<::injective_explorer_rpc::Cw20TokenInfo>(Arena*);
template <>
::injective_explorer_rpc::Event* Arena::CreateMaybeMessage<::injective_explorer_rpc::Event>(Arena*);
template <>
::injective_explorer_rpc::Event_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::injective_explorer_rpc::Event_AttributesEntry_DoNotUse>(Arena*);
template <>
::injective_explorer_rpc::GasFee* Arena::CreateMaybeMessage<::injective_explorer_rpc::GasFee>(Arena*);
template <>
::injective_explorer_rpc::GetAccountTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetAccountTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetAccountTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetAccountTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetBlockRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetBlockRequest>(Arena*);
template <>
::injective_explorer_rpc::GetBlockResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetBlockResponse>(Arena*);
template <>
::injective_explorer_rpc::GetBlocksRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetBlocksRequest>(Arena*);
template <>
::injective_explorer_rpc::GetBlocksResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetBlocksResponse>(Arena*);
template <>
::injective_explorer_rpc::GetContractTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetContractTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetContractTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetContractTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetCw20BalanceRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetCw20BalanceRequest>(Arena*);
template <>
::injective_explorer_rpc::GetCw20BalanceResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetCw20BalanceResponse>(Arena*);
template <>
::injective_explorer_rpc::GetIBCTransferTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetIBCTransferTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetIBCTransferTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetIBCTransferTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetPeggyDepositTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetPeggyDepositTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetPeggyDepositTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetPeggyDepositTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetPeggyWithdrawalTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetPeggyWithdrawalTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetPeggyWithdrawalTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetPeggyWithdrawalTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetTxByTxHashRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetTxByTxHashRequest>(Arena*);
template <>
::injective_explorer_rpc::GetTxByTxHashResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetTxByTxHashResponse>(Arena*);
template <>
::injective_explorer_rpc::GetTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorRequest>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorResponse>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorUptimeRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorUptimeRequest>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorUptimeResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorUptimeResponse>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetValidatorsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetValidatorsResponse>(Arena*);
template <>
::injective_explorer_rpc::GetWasmCodeByIDRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmCodeByIDRequest>(Arena*);
template <>
::injective_explorer_rpc::GetWasmCodeByIDResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmCodeByIDResponse>(Arena*);
template <>
::injective_explorer_rpc::GetWasmCodesRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmCodesRequest>(Arena*);
template <>
::injective_explorer_rpc::GetWasmCodesResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmCodesResponse>(Arena*);
template <>
::injective_explorer_rpc::GetWasmContractByAddressRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmContractByAddressRequest>(Arena*);
template <>
::injective_explorer_rpc::GetWasmContractByAddressResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmContractByAddressResponse>(Arena*);
template <>
::injective_explorer_rpc::GetWasmContractsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmContractsRequest>(Arena*);
template <>
::injective_explorer_rpc::GetWasmContractsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::GetWasmContractsResponse>(Arena*);
template <>
::injective_explorer_rpc::IBCTransferTx* Arena::CreateMaybeMessage<::injective_explorer_rpc::IBCTransferTx>(Arena*);
template <>
::injective_explorer_rpc::Paging* Arena::CreateMaybeMessage<::injective_explorer_rpc::Paging>(Arena*);
template <>
::injective_explorer_rpc::PeggyDepositTx* Arena::CreateMaybeMessage<::injective_explorer_rpc::PeggyDepositTx>(Arena*);
template <>
::injective_explorer_rpc::PeggyWithdrawalTx* Arena::CreateMaybeMessage<::injective_explorer_rpc::PeggyWithdrawalTx>(Arena*);
template <>
::injective_explorer_rpc::Relayer* Arena::CreateMaybeMessage<::injective_explorer_rpc::Relayer>(Arena*);
template <>
::injective_explorer_rpc::RelayerMarkets* Arena::CreateMaybeMessage<::injective_explorer_rpc::RelayerMarkets>(Arena*);
template <>
::injective_explorer_rpc::RelayersRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::RelayersRequest>(Arena*);
template <>
::injective_explorer_rpc::RelayersResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::RelayersResponse>(Arena*);
template <>
::injective_explorer_rpc::Signature* Arena::CreateMaybeMessage<::injective_explorer_rpc::Signature>(Arena*);
template <>
::injective_explorer_rpc::SlashingEvent* Arena::CreateMaybeMessage<::injective_explorer_rpc::SlashingEvent>(Arena*);
template <>
::injective_explorer_rpc::StreamBlocksRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::StreamBlocksRequest>(Arena*);
template <>
::injective_explorer_rpc::StreamBlocksResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::StreamBlocksResponse>(Arena*);
template <>
::injective_explorer_rpc::StreamTxsRequest* Arena::CreateMaybeMessage<::injective_explorer_rpc::StreamTxsRequest>(Arena*);
template <>
::injective_explorer_rpc::StreamTxsResponse* Arena::CreateMaybeMessage<::injective_explorer_rpc::StreamTxsResponse>(Arena*);
template <>
::injective_explorer_rpc::TxData* Arena::CreateMaybeMessage<::injective_explorer_rpc::TxData>(Arena*);
template <>
::injective_explorer_rpc::TxDataRPC* Arena::CreateMaybeMessage<::injective_explorer_rpc::TxDataRPC>(Arena*);
template <>
::injective_explorer_rpc::TxDetailData* Arena::CreateMaybeMessage<::injective_explorer_rpc::TxDetailData>(Arena*);
template <>
::injective_explorer_rpc::Validator* Arena::CreateMaybeMessage<::injective_explorer_rpc::Validator>(Arena*);
template <>
::injective_explorer_rpc::ValidatorDescription* Arena::CreateMaybeMessage<::injective_explorer_rpc::ValidatorDescription>(Arena*);
template <>
::injective_explorer_rpc::ValidatorUptime* Arena::CreateMaybeMessage<::injective_explorer_rpc::ValidatorUptime>(Arena*);
template <>
::injective_explorer_rpc::WasmCode* Arena::CreateMaybeMessage<::injective_explorer_rpc::WasmCode>(Arena*);
template <>
::injective_explorer_rpc::WasmContract* Arena::CreateMaybeMessage<::injective_explorer_rpc::WasmContract>(Arena*);
template <>
::injective_explorer_rpc::WasmCw20Balance* Arena::CreateMaybeMessage<::injective_explorer_rpc::WasmCw20Balance>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace injective_explorer_rpc {

// ===================================================================


// -------------------------------------------------------------------

class GetAccountTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetAccountTxsRequest) */ {
 public:
  inline GetAccountTxsRequest() : GetAccountTxsRequest(nullptr) {}
  ~GetAccountTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAccountTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountTxsRequest(const GetAccountTxsRequest& from);
  GetAccountTxsRequest(GetAccountTxsRequest&& from) noexcept
    : GetAccountTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountTxsRequest& operator=(const GetAccountTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountTxsRequest& operator=(GetAccountTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountTxsRequest*>(
               &_GetAccountTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetAccountTxsRequest& a, GetAccountTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountTxsRequest& from) {
    GetAccountTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetAccountTxsRequest";
  }
  protected:
  explicit GetAccountTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kTypeFieldNumber = 6,
    kModuleFieldNumber = 7,
    kBeforeFieldNumber = 2,
    kAfterFieldNumber = 3,
    kSkipFieldNumber = 5,
    kFromNumberFieldNumber = 8,
    kToNumberFieldNumber = 9,
    kLimitFieldNumber = 4,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string type = 6 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string module = 7 [json_name = "module"];
  void clear_module() ;
  const std::string& module() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module(Arg_&& arg, Args_... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* ptr);

  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(
      const std::string& value);
  std::string* _internal_mutable_module();

  public:
  // uint64 before = 2 [json_name = "before"];
  void clear_before() ;
  ::uint64_t before() const;
  void set_before(::uint64_t value);

  private:
  ::uint64_t _internal_before() const;
  void _internal_set_before(::uint64_t value);

  public:
  // uint64 after = 3 [json_name = "after"];
  void clear_after() ;
  ::uint64_t after() const;
  void set_after(::uint64_t value);

  private:
  ::uint64_t _internal_after() const;
  void _internal_set_after(::uint64_t value);

  public:
  // uint64 skip = 5 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 from_number = 8 [json_name = "fromNumber"];
  void clear_from_number() ;
  ::int64_t from_number() const;
  void set_from_number(::int64_t value);

  private:
  ::int64_t _internal_from_number() const;
  void _internal_set_from_number(::int64_t value);

  public:
  // sint64 to_number = 9 [json_name = "toNumber"];
  void clear_to_number() ;
  ::int64_t to_number() const;
  void set_to_number(::int64_t value);

  private:
  ::int64_t _internal_to_number() const;
  void _internal_set_to_number(::int64_t value);

  public:
  // sint32 limit = 4 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetAccountTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::uint64_t before_;
    ::uint64_t after_;
    ::uint64_t skip_;
    ::int64_t from_number_;
    ::int64_t to_number_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetAccountTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetAccountTxsResponse) */ {
 public:
  inline GetAccountTxsResponse() : GetAccountTxsResponse(nullptr) {}
  ~GetAccountTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAccountTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountTxsResponse(const GetAccountTxsResponse& from);
  GetAccountTxsResponse(GetAccountTxsResponse&& from) noexcept
    : GetAccountTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountTxsResponse& operator=(const GetAccountTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountTxsResponse& operator=(GetAccountTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountTxsResponse*>(
               &_GetAccountTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetAccountTxsResponse& a, GetAccountTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAccountTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAccountTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAccountTxsResponse& from) {
    GetAccountTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetAccountTxsResponse";
  }
  protected:
  explicit GetAccountTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.TxDetailData data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::TxDetailData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::TxDetailData& _internal_data(int index) const;
  ::injective_explorer_rpc::TxDetailData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::TxDetailData& data(int index) const;
  ::injective_explorer_rpc::TxDetailData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetAccountTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Paging final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Paging) */ {
 public:
  inline Paging() : Paging(nullptr) {}
  ~Paging() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Paging(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Paging(const Paging& from);
  Paging(Paging&& from) noexcept
    : Paging() {
    *this = ::std::move(from);
  }

  inline Paging& operator=(const Paging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Paging& operator=(Paging&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Paging& default_instance() {
    return *internal_default_instance();
  }
  static inline const Paging* internal_default_instance() {
    return reinterpret_cast<const Paging*>(
               &_Paging_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Paging& a, Paging& b) {
    a.Swap(&b);
  }
  inline void Swap(Paging* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Paging* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Paging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Paging>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Paging& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Paging& from) {
    Paging::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Paging* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Paging";
  }
  protected:
  explicit Paging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalFieldNumber = 1,
    kFromFieldNumber = 2,
    kToFieldNumber = 3,
    kCountBySubaccountFieldNumber = 4,
  };
  // sint64 total = 1 [json_name = "total"];
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // sint32 from = 2 [json_name = "from"];
  void clear_from() ;
  ::int32_t from() const;
  void set_from(::int32_t value);

  private:
  ::int32_t _internal_from() const;
  void _internal_set_from(::int32_t value);

  public:
  // sint32 to = 3 [json_name = "to"];
  void clear_to() ;
  ::int32_t to() const;
  void set_to(::int32_t value);

  private:
  ::int32_t _internal_to() const;
  void _internal_set_to(::int32_t value);

  public:
  // sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
  void clear_count_by_subaccount() ;
  ::int64_t count_by_subaccount() const;
  void set_count_by_subaccount(::int64_t value);

  private:
  ::int64_t _internal_count_by_subaccount() const;
  void _internal_set_count_by_subaccount(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Paging)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t total_;
    ::int32_t from_;
    ::int32_t to_;
    ::int64_t count_by_subaccount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class TxDetailData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.TxDetailData) */ {
 public:
  inline TxDetailData() : TxDetailData(nullptr) {}
  ~TxDetailData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxDetailData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxDetailData(const TxDetailData& from);
  TxDetailData(TxDetailData&& from) noexcept
    : TxDetailData() {
    *this = ::std::move(from);
  }

  inline TxDetailData& operator=(const TxDetailData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxDetailData& operator=(TxDetailData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxDetailData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxDetailData* internal_default_instance() {
    return reinterpret_cast<const TxDetailData*>(
               &_TxDetailData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TxDetailData& a, TxDetailData& b) {
    a.Swap(&b);
  }
  inline void Swap(TxDetailData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxDetailData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxDetailData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxDetailData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxDetailData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxDetailData& from) {
    TxDetailData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxDetailData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.TxDetailData";
  }
  protected:
  explicit TxDetailData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 13,
    kSignaturesFieldNumber = 16,
    kIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 3,
    kHashFieldNumber = 4,
    kDataFieldNumber = 6,
    kInfoFieldNumber = 8,
    kCodespaceFieldNumber = 12,
    kTxTypeFieldNumber = 14,
    kMessagesFieldNumber = 15,
    kMemoFieldNumber = 17,
    kErrorLogFieldNumber = 20,
    kGasFeeFieldNumber = 11,
    kBlockNumberFieldNumber = 2,
    kGasWantedFieldNumber = 9,
    kGasUsedFieldNumber = 10,
    kTxNumberFieldNumber = 18,
    kBlockUnixTimestampFieldNumber = 19,
    kCodeFieldNumber = 5,
  };
  // repeated .injective_explorer_rpc.Event events = 13 [json_name = "events"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::injective_explorer_rpc::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Event >*
      mutable_events();
  private:
  const ::injective_explorer_rpc::Event& _internal_events(int index) const;
  ::injective_explorer_rpc::Event* _internal_add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Event>& _internal_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Event>* _internal_mutable_events();
  public:
  const ::injective_explorer_rpc::Event& events(int index) const;
  ::injective_explorer_rpc::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Event >&
      events() const;
  // repeated .injective_explorer_rpc.Signature signatures = 16 [json_name = "signatures"];
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;

  public:
  void clear_signatures() ;
  ::injective_explorer_rpc::Signature* mutable_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Signature >*
      mutable_signatures();
  private:
  const ::injective_explorer_rpc::Signature& _internal_signatures(int index) const;
  ::injective_explorer_rpc::Signature* _internal_add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Signature>& _internal_signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Signature>* _internal_mutable_signatures();
  public:
  const ::injective_explorer_rpc::Signature& signatures(int index) const;
  ::injective_explorer_rpc::Signature* add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Signature >&
      signatures() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string block_timestamp = 3 [json_name = "blockTimestamp"];
  void clear_block_timestamp() ;
  const std::string& block_timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_block_timestamp();
  PROTOBUF_NODISCARD std::string* release_block_timestamp();
  void set_allocated_block_timestamp(std::string* ptr);

  private:
  const std::string& _internal_block_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_timestamp(
      const std::string& value);
  std::string* _internal_mutable_block_timestamp();

  public:
  // string hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // bytes data = 6 [json_name = "data"];
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string info = 8 [json_name = "info"];
  void clear_info() ;
  const std::string& info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_info(Arg_&& arg, Args_... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* ptr);

  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(
      const std::string& value);
  std::string* _internal_mutable_info();

  public:
  // string codespace = 12 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // string tx_type = 14 [json_name = "txType"];
  void clear_tx_type() ;
  const std::string& tx_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_type(Arg_&& arg, Args_... args);
  std::string* mutable_tx_type();
  PROTOBUF_NODISCARD std::string* release_tx_type();
  void set_allocated_tx_type(std::string* ptr);

  private:
  const std::string& _internal_tx_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_type(
      const std::string& value);
  std::string* _internal_mutable_tx_type();

  public:
  // bytes messages = 15 [json_name = "messages"];
  void clear_messages() ;
  const std::string& messages() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(Arg_&& arg, Args_... args);
  std::string* mutable_messages();
  PROTOBUF_NODISCARD std::string* release_messages();
  void set_allocated_messages(std::string* ptr);

  private:
  const std::string& _internal_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messages(
      const std::string& value);
  std::string* _internal_mutable_messages();

  public:
  // string memo = 17 [json_name = "memo"];
  void clear_memo() ;
  const std::string& memo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_memo(Arg_&& arg, Args_... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* ptr);

  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(
      const std::string& value);
  std::string* _internal_mutable_memo();

  public:
  // string error_log = 20 [json_name = "errorLog"];
  void clear_error_log() ;
  const std::string& error_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_log(Arg_&& arg, Args_... args);
  std::string* mutable_error_log();
  PROTOBUF_NODISCARD std::string* release_error_log();
  void set_allocated_error_log(std::string* ptr);

  private:
  const std::string& _internal_error_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_log(
      const std::string& value);
  std::string* _internal_mutable_error_log();

  public:
  // .injective_explorer_rpc.GasFee gas_fee = 11 [json_name = "gasFee"];
  bool has_gas_fee() const;
  void clear_gas_fee() ;
  const ::injective_explorer_rpc::GasFee& gas_fee() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::GasFee* release_gas_fee();
  ::injective_explorer_rpc::GasFee* mutable_gas_fee();
  void set_allocated_gas_fee(::injective_explorer_rpc::GasFee* gas_fee);
  private:
  const ::injective_explorer_rpc::GasFee& _internal_gas_fee() const;
  ::injective_explorer_rpc::GasFee* _internal_mutable_gas_fee();
  public:
  void unsafe_arena_set_allocated_gas_fee(
      ::injective_explorer_rpc::GasFee* gas_fee);
  ::injective_explorer_rpc::GasFee* unsafe_arena_release_gas_fee();
  // uint64 block_number = 2 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // sint64 gas_wanted = 9 [json_name = "gasWanted"];
  void clear_gas_wanted() ;
  ::int64_t gas_wanted() const;
  void set_gas_wanted(::int64_t value);

  private:
  ::int64_t _internal_gas_wanted() const;
  void _internal_set_gas_wanted(::int64_t value);

  public:
  // sint64 gas_used = 10 [json_name = "gasUsed"];
  void clear_gas_used() ;
  ::int64_t gas_used() const;
  void set_gas_used(::int64_t value);

  private:
  ::int64_t _internal_gas_used() const;
  void _internal_set_gas_used(::int64_t value);

  public:
  // uint64 tx_number = 18 [json_name = "txNumber"];
  void clear_tx_number() ;
  ::uint64_t tx_number() const;
  void set_tx_number(::uint64_t value);

  private:
  ::uint64_t _internal_tx_number() const;
  void _internal_set_tx_number(::uint64_t value);

  public:
  // uint64 block_unix_timestamp = 19 [json_name = "blockUnixTimestamp"];
  void clear_block_unix_timestamp() ;
  ::uint64_t block_unix_timestamp() const;
  void set_block_unix_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_block_unix_timestamp() const;
  void _internal_set_block_unix_timestamp(::uint64_t value);

  public:
  // uint32 code = 5 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.TxDetailData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Event > events_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Signature > signatures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_log_;
    ::injective_explorer_rpc::GasFee* gas_fee_;
    ::uint64_t block_number_;
    ::int64_t gas_wanted_;
    ::int64_t gas_used_;
    ::uint64_t tx_number_;
    ::uint64_t block_unix_timestamp_;
    ::uint32_t code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GasFee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GasFee) */ {
 public:
  inline GasFee() : GasFee(nullptr) {}
  ~GasFee() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GasFee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GasFee(const GasFee& from);
  GasFee(GasFee&& from) noexcept
    : GasFee() {
    *this = ::std::move(from);
  }

  inline GasFee& operator=(const GasFee& from) {
    CopyFrom(from);
    return *this;
  }
  inline GasFee& operator=(GasFee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GasFee& default_instance() {
    return *internal_default_instance();
  }
  static inline const GasFee* internal_default_instance() {
    return reinterpret_cast<const GasFee*>(
               &_GasFee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GasFee& a, GasFee& b) {
    a.Swap(&b);
  }
  inline void Swap(GasFee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GasFee* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GasFee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GasFee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GasFee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GasFee& from) {
    GasFee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GasFee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GasFee";
  }
  protected:
  explicit GasFee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 1,
    kPayerFieldNumber = 3,
    kGranterFieldNumber = 4,
    kGasLimitFieldNumber = 2,
  };
  // repeated .injective_explorer_rpc.CosmosCoin amount = 1 [json_name = "amount"];
  int amount_size() const;
  private:
  int _internal_amount_size() const;

  public:
  void clear_amount() ;
  ::injective_explorer_rpc::CosmosCoin* mutable_amount(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::CosmosCoin >*
      mutable_amount();
  private:
  const ::injective_explorer_rpc::CosmosCoin& _internal_amount(int index) const;
  ::injective_explorer_rpc::CosmosCoin* _internal_add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::CosmosCoin>& _internal_amount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::CosmosCoin>* _internal_mutable_amount();
  public:
  const ::injective_explorer_rpc::CosmosCoin& amount(int index) const;
  ::injective_explorer_rpc::CosmosCoin* add_amount();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::CosmosCoin >&
      amount() const;
  // string payer = 3 [json_name = "payer"];
  void clear_payer() ;
  const std::string& payer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payer(Arg_&& arg, Args_... args);
  std::string* mutable_payer();
  PROTOBUF_NODISCARD std::string* release_payer();
  void set_allocated_payer(std::string* ptr);

  private:
  const std::string& _internal_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payer(
      const std::string& value);
  std::string* _internal_mutable_payer();

  public:
  // string granter = 4 [json_name = "granter"];
  void clear_granter() ;
  const std::string& granter() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_granter(Arg_&& arg, Args_... args);
  std::string* mutable_granter();
  PROTOBUF_NODISCARD std::string* release_granter();
  void set_allocated_granter(std::string* ptr);

  private:
  const std::string& _internal_granter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_granter(
      const std::string& value);
  std::string* _internal_mutable_granter();

  public:
  // uint64 gas_limit = 2 [json_name = "gasLimit"];
  void clear_gas_limit() ;
  ::uint64_t gas_limit() const;
  void set_gas_limit(::uint64_t value);

  private:
  ::uint64_t _internal_gas_limit() const;
  void _internal_set_gas_limit(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GasFee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::CosmosCoin > amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr granter_;
    ::uint64_t gas_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class CosmosCoin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.CosmosCoin) */ {
 public:
  inline CosmosCoin() : CosmosCoin(nullptr) {}
  ~CosmosCoin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CosmosCoin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosmosCoin(const CosmosCoin& from);
  CosmosCoin(CosmosCoin&& from) noexcept
    : CosmosCoin() {
    *this = ::std::move(from);
  }

  inline CosmosCoin& operator=(const CosmosCoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosmosCoin& operator=(CosmosCoin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosmosCoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosmosCoin* internal_default_instance() {
    return reinterpret_cast<const CosmosCoin*>(
               &_CosmosCoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CosmosCoin& a, CosmosCoin& b) {
    a.Swap(&b);
  }
  inline void Swap(CosmosCoin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosmosCoin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CosmosCoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CosmosCoin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosmosCoin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CosmosCoin& from) {
    CosmosCoin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosmosCoin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.CosmosCoin";
  }
  protected:
  explicit CosmosCoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.CosmosCoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Event_AttributesEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Event_AttributesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Event_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Event_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Event_AttributesEntry_DoNotUse& other);
  static const Event_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Event_AttributesEntry_DoNotUse*>(&_Event_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "injective_explorer_rpc.Event.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "injective_explorer_rpc.Event.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Event& from) {
    Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // map<string, string> attributes = 2 [json_name = "attributes"];
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;

  public:
  void clear_attributes() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();
  // string type = 1 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Event_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Signature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Signature) */ {
 public:
  inline Signature() : Signature(nullptr) {}
  ~Signature() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Signature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signature(const Signature& from);
  Signature(Signature&& from) noexcept
    : Signature() {
    *this = ::std::move(from);
  }

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signature& operator=(Signature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signature* internal_default_instance() {
    return reinterpret_cast<const Signature*>(
               &_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Signature& a, Signature& b) {
    a.Swap(&b);
  }
  inline void Swap(Signature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Signature& from) {
    Signature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Signature";
  }
  protected:
  explicit Signature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubkeyFieldNumber = 1,
    kAddressFieldNumber = 2,
    kSignatureFieldNumber = 4,
    kSequenceFieldNumber = 3,
  };
  // string pubkey = 1 [json_name = "pubkey"];
  void clear_pubkey() ;
  const std::string& pubkey() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pubkey(Arg_&& arg, Args_... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* ptr);

  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(
      const std::string& value);
  std::string* _internal_mutable_pubkey();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string signature = 4 [json_name = "signature"];
  void clear_signature() ;
  const std::string& signature() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* ptr);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // uint64 sequence = 3 [json_name = "sequence"];
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Signature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pubkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
    ::uint64_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetContractTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetContractTxsRequest) */ {
 public:
  inline GetContractTxsRequest() : GetContractTxsRequest(nullptr) {}
  ~GetContractTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetContractTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetContractTxsRequest(const GetContractTxsRequest& from);
  GetContractTxsRequest(GetContractTxsRequest&& from) noexcept
    : GetContractTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetContractTxsRequest& operator=(const GetContractTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetContractTxsRequest& operator=(GetContractTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetContractTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetContractTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetContractTxsRequest*>(
               &_GetContractTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetContractTxsRequest& a, GetContractTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetContractTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetContractTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetContractTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetContractTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetContractTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetContractTxsRequest& from) {
    GetContractTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetContractTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetContractTxsRequest";
  }
  protected:
  explicit GetContractTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kSkipFieldNumber = 3,
    kFromNumberFieldNumber = 4,
    kToNumberFieldNumber = 5,
    kLimitFieldNumber = 2,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // uint64 skip = 3 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 from_number = 4 [json_name = "fromNumber"];
  void clear_from_number() ;
  ::int64_t from_number() const;
  void set_from_number(::int64_t value);

  private:
  ::int64_t _internal_from_number() const;
  void _internal_set_from_number(::int64_t value);

  public:
  // sint64 to_number = 5 [json_name = "toNumber"];
  void clear_to_number() ;
  ::int64_t to_number() const;
  void set_to_number(::int64_t value);

  private:
  ::int64_t _internal_to_number() const;
  void _internal_set_to_number(::int64_t value);

  public:
  // sint32 limit = 2 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetContractTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::uint64_t skip_;
    ::int64_t from_number_;
    ::int64_t to_number_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetContractTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetContractTxsResponse) */ {
 public:
  inline GetContractTxsResponse() : GetContractTxsResponse(nullptr) {}
  ~GetContractTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetContractTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetContractTxsResponse(const GetContractTxsResponse& from);
  GetContractTxsResponse(GetContractTxsResponse&& from) noexcept
    : GetContractTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetContractTxsResponse& operator=(const GetContractTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetContractTxsResponse& operator=(GetContractTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetContractTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetContractTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetContractTxsResponse*>(
               &_GetContractTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetContractTxsResponse& a, GetContractTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetContractTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetContractTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetContractTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetContractTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetContractTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetContractTxsResponse& from) {
    GetContractTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetContractTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetContractTxsResponse";
  }
  protected:
  explicit GetContractTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.TxDetailData data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::TxDetailData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::TxDetailData& _internal_data(int index) const;
  ::injective_explorer_rpc::TxDetailData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::TxDetailData& data(int index) const;
  ::injective_explorer_rpc::TxDetailData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetContractTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetBlocksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetBlocksRequest) */ {
 public:
  inline GetBlocksRequest() : GetBlocksRequest(nullptr) {}
  ~GetBlocksRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlocksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlocksRequest(const GetBlocksRequest& from);
  GetBlocksRequest(GetBlocksRequest&& from) noexcept
    : GetBlocksRequest() {
    *this = ::std::move(from);
  }

  inline GetBlocksRequest& operator=(const GetBlocksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlocksRequest& operator=(GetBlocksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlocksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlocksRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlocksRequest*>(
               &_GetBlocksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetBlocksRequest& a, GetBlocksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlocksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlocksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlocksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlocksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlocksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlocksRequest& from) {
    GetBlocksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetBlocksRequest";
  }
  protected:
  explicit GetBlocksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeforeFieldNumber = 1,
    kAfterFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // uint64 before = 1 [json_name = "before"];
  void clear_before() ;
  ::uint64_t before() const;
  void set_before(::uint64_t value);

  private:
  ::uint64_t _internal_before() const;
  void _internal_set_before(::uint64_t value);

  public:
  // uint64 after = 2 [json_name = "after"];
  void clear_after() ;
  ::uint64_t after() const;
  void set_after(::uint64_t value);

  private:
  ::uint64_t _internal_after() const;
  void _internal_set_after(::uint64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetBlocksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t before_;
    ::uint64_t after_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetBlocksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetBlocksResponse) */ {
 public:
  inline GetBlocksResponse() : GetBlocksResponse(nullptr) {}
  ~GetBlocksResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlocksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlocksResponse(const GetBlocksResponse& from);
  GetBlocksResponse(GetBlocksResponse&& from) noexcept
    : GetBlocksResponse() {
    *this = ::std::move(from);
  }

  inline GetBlocksResponse& operator=(const GetBlocksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlocksResponse& operator=(GetBlocksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlocksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlocksResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlocksResponse*>(
               &_GetBlocksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetBlocksResponse& a, GetBlocksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlocksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlocksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlocksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlocksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlocksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlocksResponse& from) {
    GetBlocksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlocksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetBlocksResponse";
  }
  protected:
  explicit GetBlocksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.BlockInfo data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::BlockInfo* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::BlockInfo >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::BlockInfo& _internal_data(int index) const;
  ::injective_explorer_rpc::BlockInfo* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::BlockInfo>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::BlockInfo>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::BlockInfo& data(int index) const;
  ::injective_explorer_rpc::BlockInfo* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::BlockInfo >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetBlocksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::BlockInfo > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class BlockInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.BlockInfo) */ {
 public:
  inline BlockInfo() : BlockInfo(nullptr) {}
  ~BlockInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockInfo(const BlockInfo& from);
  BlockInfo(BlockInfo&& from) noexcept
    : BlockInfo() {
    *this = ::std::move(from);
  }

  inline BlockInfo& operator=(const BlockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockInfo& operator=(BlockInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockInfo* internal_default_instance() {
    return reinterpret_cast<const BlockInfo*>(
               &_BlockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BlockInfo& a, BlockInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockInfo& from) {
    BlockInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.BlockInfo";
  }
  protected:
  explicit BlockInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 8,
    kProposerFieldNumber = 2,
    kMonikerFieldNumber = 3,
    kBlockHashFieldNumber = 4,
    kParentHashFieldNumber = 5,
    kTimestampFieldNumber = 9,
    kHeightFieldNumber = 1,
    kNumPreCommitsFieldNumber = 6,
    kNumTxsFieldNumber = 7,
  };
  // repeated .injective_explorer_rpc.TxDataRPC txs = 8 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  ::injective_explorer_rpc::TxDataRPC* mutable_txs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >*
      mutable_txs();
  private:
  const ::injective_explorer_rpc::TxDataRPC& _internal_txs(int index) const;
  ::injective_explorer_rpc::TxDataRPC* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>* _internal_mutable_txs();
  public:
  const ::injective_explorer_rpc::TxDataRPC& txs(int index) const;
  ::injective_explorer_rpc::TxDataRPC* add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >&
      txs() const;
  // string proposer = 2 [json_name = "proposer"];
  void clear_proposer() ;
  const std::string& proposer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposer(Arg_&& arg, Args_... args);
  std::string* mutable_proposer();
  PROTOBUF_NODISCARD std::string* release_proposer();
  void set_allocated_proposer(std::string* ptr);

  private:
  const std::string& _internal_proposer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer(
      const std::string& value);
  std::string* _internal_mutable_proposer();

  public:
  // string moniker = 3 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string block_hash = 4 [json_name = "blockHash"];
  void clear_block_hash() ;
  const std::string& block_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_hash(Arg_&& arg, Args_... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* ptr);

  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(
      const std::string& value);
  std::string* _internal_mutable_block_hash();

  public:
  // string parent_hash = 5 [json_name = "parentHash"];
  void clear_parent_hash() ;
  const std::string& parent_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_hash(Arg_&& arg, Args_... args);
  std::string* mutable_parent_hash();
  PROTOBUF_NODISCARD std::string* release_parent_hash();
  void set_allocated_parent_hash(std::string* ptr);

  private:
  const std::string& _internal_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_hash(
      const std::string& value);
  std::string* _internal_mutable_parent_hash();

  public:
  // string timestamp = 9 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
  void clear_num_pre_commits() ;
  ::int64_t num_pre_commits() const;
  void set_num_pre_commits(::int64_t value);

  private:
  ::int64_t _internal_num_pre_commits() const;
  void _internal_set_num_pre_commits(::int64_t value);

  public:
  // sint64 num_txs = 7 [json_name = "numTxs"];
  void clear_num_txs() ;
  ::int64_t num_txs() const;
  void set_num_txs(::int64_t value);

  private:
  ::int64_t _internal_num_txs() const;
  void _internal_set_num_txs(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.BlockInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC > txs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::uint64_t height_;
    ::int64_t num_pre_commits_;
    ::int64_t num_txs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class TxDataRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.TxDataRPC) */ {
 public:
  inline TxDataRPC() : TxDataRPC(nullptr) {}
  ~TxDataRPC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxDataRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxDataRPC(const TxDataRPC& from);
  TxDataRPC(TxDataRPC&& from) noexcept
    : TxDataRPC() {
    *this = ::std::move(from);
  }

  inline TxDataRPC& operator=(const TxDataRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxDataRPC& operator=(TxDataRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxDataRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxDataRPC* internal_default_instance() {
    return reinterpret_cast<const TxDataRPC*>(
               &_TxDataRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TxDataRPC& a, TxDataRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(TxDataRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxDataRPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxDataRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxDataRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxDataRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxDataRPC& from) {
    TxDataRPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxDataRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.TxDataRPC";
  }
  protected:
  explicit TxDataRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 3,
    kHashFieldNumber = 4,
    kCodespaceFieldNumber = 5,
    kMessagesFieldNumber = 6,
    kErrorLogFieldNumber = 8,
    kBlockNumberFieldNumber = 2,
    kTxNumberFieldNumber = 7,
    kCodeFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string block_timestamp = 3 [json_name = "blockTimestamp"];
  void clear_block_timestamp() ;
  const std::string& block_timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_block_timestamp();
  PROTOBUF_NODISCARD std::string* release_block_timestamp();
  void set_allocated_block_timestamp(std::string* ptr);

  private:
  const std::string& _internal_block_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_timestamp(
      const std::string& value);
  std::string* _internal_mutable_block_timestamp();

  public:
  // string hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // string codespace = 5 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // string messages = 6 [json_name = "messages"];
  void clear_messages() ;
  const std::string& messages() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(Arg_&& arg, Args_... args);
  std::string* mutable_messages();
  PROTOBUF_NODISCARD std::string* release_messages();
  void set_allocated_messages(std::string* ptr);

  private:
  const std::string& _internal_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messages(
      const std::string& value);
  std::string* _internal_mutable_messages();

  public:
  // string error_log = 8 [json_name = "errorLog"];
  void clear_error_log() ;
  const std::string& error_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_log(Arg_&& arg, Args_... args);
  std::string* mutable_error_log();
  PROTOBUF_NODISCARD std::string* release_error_log();
  void set_allocated_error_log(std::string* ptr);

  private:
  const std::string& _internal_error_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_log(
      const std::string& value);
  std::string* _internal_mutable_error_log();

  public:
  // uint64 block_number = 2 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 tx_number = 7 [json_name = "txNumber"];
  void clear_tx_number() ;
  ::uint64_t tx_number() const;
  void set_tx_number(::uint64_t value);

  private:
  ::uint64_t _internal_tx_number() const;
  void _internal_set_tx_number(::uint64_t value);

  public:
  // uint32 code = 9 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.TxDataRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_log_;
    ::uint64_t block_number_;
    ::uint64_t tx_number_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetBlockRequest) */ {
 public:
  inline GetBlockRequest() : GetBlockRequest(nullptr) {}
  ~GetBlockRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockRequest(const GetBlockRequest& from);
  GetBlockRequest(GetBlockRequest&& from) noexcept
    : GetBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockRequest& operator=(const GetBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockRequest& operator=(GetBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockRequest*>(
               &_GetBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetBlockRequest& a, GetBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockRequest& from) {
    GetBlockRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetBlockRequest";
  }
  protected:
  explicit GetBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetBlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetBlockResponse) */ {
 public:
  inline GetBlockResponse() : GetBlockResponse(nullptr) {}
  ~GetBlockResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockResponse(const GetBlockResponse& from);
  GetBlockResponse(GetBlockResponse&& from) noexcept
    : GetBlockResponse() {
    *this = ::std::move(from);
  }

  inline GetBlockResponse& operator=(const GetBlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockResponse& operator=(GetBlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockResponse* internal_default_instance() {
    return reinterpret_cast<const GetBlockResponse*>(
               &_GetBlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetBlockResponse& a, GetBlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockResponse& from) {
    GetBlockResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetBlockResponse";
  }
  protected:
  explicit GetBlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kErrmsgFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string s = 1 [json_name = "s"];
  void clear_s() ;
  const std::string& s() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // string errmsg = 2 [json_name = "errmsg"];
  void clear_errmsg() ;
  const std::string& errmsg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errmsg(Arg_&& arg, Args_... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* ptr);

  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(
      const std::string& value);
  std::string* _internal_mutable_errmsg();

  public:
  // .injective_explorer_rpc.BlockDetailInfo data = 3 [json_name = "data"];
  bool has_data() const;
  void clear_data() ;
  const ::injective_explorer_rpc::BlockDetailInfo& data() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::BlockDetailInfo* release_data();
  ::injective_explorer_rpc::BlockDetailInfo* mutable_data();
  void set_allocated_data(::injective_explorer_rpc::BlockDetailInfo* data);
  private:
  const ::injective_explorer_rpc::BlockDetailInfo& _internal_data() const;
  ::injective_explorer_rpc::BlockDetailInfo* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::injective_explorer_rpc::BlockDetailInfo* data);
  ::injective_explorer_rpc::BlockDetailInfo* unsafe_arena_release_data();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetBlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
    ::injective_explorer_rpc::BlockDetailInfo* data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class BlockDetailInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.BlockDetailInfo) */ {
 public:
  inline BlockDetailInfo() : BlockDetailInfo(nullptr) {}
  ~BlockDetailInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BlockDetailInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockDetailInfo(const BlockDetailInfo& from);
  BlockDetailInfo(BlockDetailInfo&& from) noexcept
    : BlockDetailInfo() {
    *this = ::std::move(from);
  }

  inline BlockDetailInfo& operator=(const BlockDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockDetailInfo& operator=(BlockDetailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockDetailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockDetailInfo* internal_default_instance() {
    return reinterpret_cast<const BlockDetailInfo*>(
               &_BlockDetailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BlockDetailInfo& a, BlockDetailInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockDetailInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockDetailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockDetailInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockDetailInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockDetailInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockDetailInfo& from) {
    BlockDetailInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockDetailInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.BlockDetailInfo";
  }
  protected:
  explicit BlockDetailInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 9,
    kProposerFieldNumber = 2,
    kMonikerFieldNumber = 3,
    kBlockHashFieldNumber = 4,
    kParentHashFieldNumber = 5,
    kTimestampFieldNumber = 10,
    kHeightFieldNumber = 1,
    kNumPreCommitsFieldNumber = 6,
    kNumTxsFieldNumber = 7,
    kTotalTxsFieldNumber = 8,
  };
  // repeated .injective_explorer_rpc.TxData txs = 9 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  ::injective_explorer_rpc::TxData* mutable_txs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >*
      mutable_txs();
  private:
  const ::injective_explorer_rpc::TxData& _internal_txs(int index) const;
  ::injective_explorer_rpc::TxData* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>* _internal_mutable_txs();
  public:
  const ::injective_explorer_rpc::TxData& txs(int index) const;
  ::injective_explorer_rpc::TxData* add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >&
      txs() const;
  // string proposer = 2 [json_name = "proposer"];
  void clear_proposer() ;
  const std::string& proposer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposer(Arg_&& arg, Args_... args);
  std::string* mutable_proposer();
  PROTOBUF_NODISCARD std::string* release_proposer();
  void set_allocated_proposer(std::string* ptr);

  private:
  const std::string& _internal_proposer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer(
      const std::string& value);
  std::string* _internal_mutable_proposer();

  public:
  // string moniker = 3 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string block_hash = 4 [json_name = "blockHash"];
  void clear_block_hash() ;
  const std::string& block_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_hash(Arg_&& arg, Args_... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* ptr);

  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(
      const std::string& value);
  std::string* _internal_mutable_block_hash();

  public:
  // string parent_hash = 5 [json_name = "parentHash"];
  void clear_parent_hash() ;
  const std::string& parent_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_hash(Arg_&& arg, Args_... args);
  std::string* mutable_parent_hash();
  PROTOBUF_NODISCARD std::string* release_parent_hash();
  void set_allocated_parent_hash(std::string* ptr);

  private:
  const std::string& _internal_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_hash(
      const std::string& value);
  std::string* _internal_mutable_parent_hash();

  public:
  // string timestamp = 10 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
  void clear_num_pre_commits() ;
  ::int64_t num_pre_commits() const;
  void set_num_pre_commits(::int64_t value);

  private:
  ::int64_t _internal_num_pre_commits() const;
  void _internal_set_num_pre_commits(::int64_t value);

  public:
  // sint64 num_txs = 7 [json_name = "numTxs"];
  void clear_num_txs() ;
  ::int64_t num_txs() const;
  void set_num_txs(::int64_t value);

  private:
  ::int64_t _internal_num_txs() const;
  void _internal_set_num_txs(::int64_t value);

  public:
  // sint64 total_txs = 8 [json_name = "totalTxs"];
  void clear_total_txs() ;
  ::int64_t total_txs() const;
  void set_total_txs(::int64_t value);

  private:
  ::int64_t _internal_total_txs() const;
  void _internal_set_total_txs(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.BlockDetailInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData > txs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::uint64_t height_;
    ::int64_t num_pre_commits_;
    ::int64_t num_txs_;
    ::int64_t total_txs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class TxData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.TxData) */ {
 public:
  inline TxData() : TxData(nullptr) {}
  ~TxData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxData(const TxData& from);
  TxData(TxData&& from) noexcept
    : TxData() {
    *this = ::std::move(from);
  }

  inline TxData& operator=(const TxData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxData& operator=(TxData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxData* internal_default_instance() {
    return reinterpret_cast<const TxData*>(
               &_TxData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TxData& a, TxData& b) {
    a.Swap(&b);
  }
  inline void Swap(TxData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxData& from) {
    TxData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.TxData";
  }
  protected:
  explicit TxData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 3,
    kHashFieldNumber = 4,
    kCodespaceFieldNumber = 5,
    kMessagesFieldNumber = 6,
    kErrorLogFieldNumber = 8,
    kBlockNumberFieldNumber = 2,
    kTxNumberFieldNumber = 7,
    kCodeFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string block_timestamp = 3 [json_name = "blockTimestamp"];
  void clear_block_timestamp() ;
  const std::string& block_timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_block_timestamp();
  PROTOBUF_NODISCARD std::string* release_block_timestamp();
  void set_allocated_block_timestamp(std::string* ptr);

  private:
  const std::string& _internal_block_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_timestamp(
      const std::string& value);
  std::string* _internal_mutable_block_timestamp();

  public:
  // string hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // string codespace = 5 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // bytes messages = 6 [json_name = "messages"];
  void clear_messages() ;
  const std::string& messages() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(Arg_&& arg, Args_... args);
  std::string* mutable_messages();
  PROTOBUF_NODISCARD std::string* release_messages();
  void set_allocated_messages(std::string* ptr);

  private:
  const std::string& _internal_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messages(
      const std::string& value);
  std::string* _internal_mutable_messages();

  public:
  // string error_log = 8 [json_name = "errorLog"];
  void clear_error_log() ;
  const std::string& error_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_log(Arg_&& arg, Args_... args);
  std::string* mutable_error_log();
  PROTOBUF_NODISCARD std::string* release_error_log();
  void set_allocated_error_log(std::string* ptr);

  private:
  const std::string& _internal_error_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_log(
      const std::string& value);
  std::string* _internal_mutable_error_log();

  public:
  // uint64 block_number = 2 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 tx_number = 7 [json_name = "txNumber"];
  void clear_tx_number() ;
  ::uint64_t tx_number() const;
  void set_tx_number(::uint64_t value);

  private:
  ::uint64_t _internal_tx_number() const;
  void _internal_set_tx_number(::uint64_t value);

  public:
  // uint32 code = 9 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.TxData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_log_;
    ::uint64_t block_number_;
    ::uint64_t tx_number_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorsRequest) */ {
 public:
  inline GetValidatorsRequest() : GetValidatorsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorsRequest(const GetValidatorsRequest& from);
  GetValidatorsRequest(GetValidatorsRequest&& from) noexcept
    : GetValidatorsRequest() {
    *this = ::std::move(from);
  }

  inline GetValidatorsRequest& operator=(const GetValidatorsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorsRequest& operator=(GetValidatorsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorsRequest* internal_default_instance() {
    return reinterpret_cast<const GetValidatorsRequest*>(
               &_GetValidatorsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetValidatorsRequest& a, GetValidatorsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetValidatorsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetValidatorsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorsRequest";
  }
  protected:
  explicit GetValidatorsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorsResponse) */ {
 public:
  inline GetValidatorsResponse() : GetValidatorsResponse(nullptr) {}
  ~GetValidatorsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorsResponse(const GetValidatorsResponse& from);
  GetValidatorsResponse(GetValidatorsResponse&& from) noexcept
    : GetValidatorsResponse() {
    *this = ::std::move(from);
  }

  inline GetValidatorsResponse& operator=(const GetValidatorsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorsResponse& operator=(GetValidatorsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorsResponse* internal_default_instance() {
    return reinterpret_cast<const GetValidatorsResponse*>(
               &_GetValidatorsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetValidatorsResponse& a, GetValidatorsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValidatorsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValidatorsResponse& from) {
    GetValidatorsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValidatorsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorsResponse";
  }
  protected:
  explicit GetValidatorsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kSFieldNumber = 1,
    kErrmsgFieldNumber = 2,
  };
  // repeated .injective_explorer_rpc.Validator data = 3 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::Validator* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Validator >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::Validator& _internal_data(int index) const;
  ::injective_explorer_rpc::Validator* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Validator>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Validator>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::Validator& data(int index) const;
  ::injective_explorer_rpc::Validator* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Validator >&
      data() const;
  // string s = 1 [json_name = "s"];
  void clear_s() ;
  const std::string& s() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // string errmsg = 2 [json_name = "errmsg"];
  void clear_errmsg() ;
  const std::string& errmsg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errmsg(Arg_&& arg, Args_... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* ptr);

  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(
      const std::string& value);
  std::string* _internal_mutable_errmsg();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Validator > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Validator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Validator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Validator(const Validator& from);
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }
  inline void Swap(Validator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Validator& from) {
    Validator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Validator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Validator";
  }
  protected:
  explicit Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUptimesFieldNumber = 20,
    kSlashingEventsFieldNumber = 21,
    kIdFieldNumber = 1,
    kMonikerFieldNumber = 2,
    kOperatorAddressFieldNumber = 3,
    kConsensusAddressFieldNumber = 4,
    kTokensFieldNumber = 7,
    kDelegatorSharesFieldNumber = 8,
    kUnbondingTimeFieldNumber = 11,
    kCommissionRateFieldNumber = 12,
    kCommissionMaxRateFieldNumber = 13,
    kCommissionMaxChangeRateFieldNumber = 14,
    kCommissionUpdateTimeFieldNumber = 15,
    kTimestampFieldNumber = 19,
    kDescriptionFieldNumber = 9,
    kJailedFieldNumber = 5,
    kStatusFieldNumber = 6,
    kUnbondingHeightFieldNumber = 10,
    kProposedFieldNumber = 16,
    kSignedFieldNumber = 17,
    kMissedFieldNumber = 18,
    kUptimePercentageFieldNumber = 22,
  };
  // repeated .injective_explorer_rpc.ValidatorUptime uptimes = 20 [json_name = "uptimes"];
  int uptimes_size() const;
  private:
  int _internal_uptimes_size() const;

  public:
  void clear_uptimes() ;
  ::injective_explorer_rpc::ValidatorUptime* mutable_uptimes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >*
      mutable_uptimes();
  private:
  const ::injective_explorer_rpc::ValidatorUptime& _internal_uptimes(int index) const;
  ::injective_explorer_rpc::ValidatorUptime* _internal_add_uptimes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>& _internal_uptimes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>* _internal_mutable_uptimes();
  public:
  const ::injective_explorer_rpc::ValidatorUptime& uptimes(int index) const;
  ::injective_explorer_rpc::ValidatorUptime* add_uptimes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >&
      uptimes() const;
  // repeated .injective_explorer_rpc.SlashingEvent slashing_events = 21 [json_name = "slashingEvents"];
  int slashing_events_size() const;
  private:
  int _internal_slashing_events_size() const;

  public:
  void clear_slashing_events() ;
  ::injective_explorer_rpc::SlashingEvent* mutable_slashing_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::SlashingEvent >*
      mutable_slashing_events();
  private:
  const ::injective_explorer_rpc::SlashingEvent& _internal_slashing_events(int index) const;
  ::injective_explorer_rpc::SlashingEvent* _internal_add_slashing_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::SlashingEvent>& _internal_slashing_events() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::SlashingEvent>* _internal_mutable_slashing_events();
  public:
  const ::injective_explorer_rpc::SlashingEvent& slashing_events(int index) const;
  ::injective_explorer_rpc::SlashingEvent* add_slashing_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::SlashingEvent >&
      slashing_events() const;
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string moniker = 2 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string operator_address = 3 [json_name = "operatorAddress"];
  void clear_operator_address() ;
  const std::string& operator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_address(Arg_&& arg, Args_... args);
  std::string* mutable_operator_address();
  PROTOBUF_NODISCARD std::string* release_operator_address();
  void set_allocated_operator_address(std::string* ptr);

  private:
  const std::string& _internal_operator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_address(
      const std::string& value);
  std::string* _internal_mutable_operator_address();

  public:
  // string consensus_address = 4 [json_name = "consensusAddress"];
  void clear_consensus_address() ;
  const std::string& consensus_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_consensus_address(Arg_&& arg, Args_... args);
  std::string* mutable_consensus_address();
  PROTOBUF_NODISCARD std::string* release_consensus_address();
  void set_allocated_consensus_address(std::string* ptr);

  private:
  const std::string& _internal_consensus_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consensus_address(
      const std::string& value);
  std::string* _internal_mutable_consensus_address();

  public:
  // string tokens = 7 [json_name = "tokens"];
  void clear_tokens() ;
  const std::string& tokens() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tokens(Arg_&& arg, Args_... args);
  std::string* mutable_tokens();
  PROTOBUF_NODISCARD std::string* release_tokens();
  void set_allocated_tokens(std::string* ptr);

  private:
  const std::string& _internal_tokens() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tokens(
      const std::string& value);
  std::string* _internal_mutable_tokens();

  public:
  // string delegator_shares = 8 [json_name = "delegatorShares"];
  void clear_delegator_shares() ;
  const std::string& delegator_shares() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_delegator_shares(Arg_&& arg, Args_... args);
  std::string* mutable_delegator_shares();
  PROTOBUF_NODISCARD std::string* release_delegator_shares();
  void set_allocated_delegator_shares(std::string* ptr);

  private:
  const std::string& _internal_delegator_shares() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delegator_shares(
      const std::string& value);
  std::string* _internal_mutable_delegator_shares();

  public:
  // string unbonding_time = 11 [json_name = "unbondingTime"];
  void clear_unbonding_time() ;
  const std::string& unbonding_time() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_unbonding_time(Arg_&& arg, Args_... args);
  std::string* mutable_unbonding_time();
  PROTOBUF_NODISCARD std::string* release_unbonding_time();
  void set_allocated_unbonding_time(std::string* ptr);

  private:
  const std::string& _internal_unbonding_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unbonding_time(
      const std::string& value);
  std::string* _internal_mutable_unbonding_time();

  public:
  // string commission_rate = 12 [json_name = "commissionRate"];
  void clear_commission_rate() ;
  const std::string& commission_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commission_rate(Arg_&& arg, Args_... args);
  std::string* mutable_commission_rate();
  PROTOBUF_NODISCARD std::string* release_commission_rate();
  void set_allocated_commission_rate(std::string* ptr);

  private:
  const std::string& _internal_commission_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commission_rate(
      const std::string& value);
  std::string* _internal_mutable_commission_rate();

  public:
  // string commission_max_rate = 13 [json_name = "commissionMaxRate"];
  void clear_commission_max_rate() ;
  const std::string& commission_max_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commission_max_rate(Arg_&& arg, Args_... args);
  std::string* mutable_commission_max_rate();
  PROTOBUF_NODISCARD std::string* release_commission_max_rate();
  void set_allocated_commission_max_rate(std::string* ptr);

  private:
  const std::string& _internal_commission_max_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commission_max_rate(
      const std::string& value);
  std::string* _internal_mutable_commission_max_rate();

  public:
  // string commission_max_change_rate = 14 [json_name = "commissionMaxChangeRate"];
  void clear_commission_max_change_rate() ;
  const std::string& commission_max_change_rate() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commission_max_change_rate(Arg_&& arg, Args_... args);
  std::string* mutable_commission_max_change_rate();
  PROTOBUF_NODISCARD std::string* release_commission_max_change_rate();
  void set_allocated_commission_max_change_rate(std::string* ptr);

  private:
  const std::string& _internal_commission_max_change_rate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commission_max_change_rate(
      const std::string& value);
  std::string* _internal_mutable_commission_max_change_rate();

  public:
  // string commission_update_time = 15 [json_name = "commissionUpdateTime"];
  void clear_commission_update_time() ;
  const std::string& commission_update_time() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_commission_update_time(Arg_&& arg, Args_... args);
  std::string* mutable_commission_update_time();
  PROTOBUF_NODISCARD std::string* release_commission_update_time();
  void set_allocated_commission_update_time(std::string* ptr);

  private:
  const std::string& _internal_commission_update_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commission_update_time(
      const std::string& value);
  std::string* _internal_mutable_commission_update_time();

  public:
  // string timestamp = 19 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // .injective_explorer_rpc.ValidatorDescription description = 9 [json_name = "description"];
  bool has_description() const;
  void clear_description() ;
  const ::injective_explorer_rpc::ValidatorDescription& description() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::ValidatorDescription* release_description();
  ::injective_explorer_rpc::ValidatorDescription* mutable_description();
  void set_allocated_description(::injective_explorer_rpc::ValidatorDescription* description);
  private:
  const ::injective_explorer_rpc::ValidatorDescription& _internal_description() const;
  ::injective_explorer_rpc::ValidatorDescription* _internal_mutable_description();
  public:
  void unsafe_arena_set_allocated_description(
      ::injective_explorer_rpc::ValidatorDescription* description);
  ::injective_explorer_rpc::ValidatorDescription* unsafe_arena_release_description();
  // bool jailed = 5 [json_name = "jailed"];
  void clear_jailed() ;
  bool jailed() const;
  void set_jailed(bool value);

  private:
  bool _internal_jailed() const;
  void _internal_set_jailed(bool value);

  public:
  // sint32 status = 6 [json_name = "status"];
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // sint64 unbonding_height = 10 [json_name = "unbondingHeight"];
  void clear_unbonding_height() ;
  ::int64_t unbonding_height() const;
  void set_unbonding_height(::int64_t value);

  private:
  ::int64_t _internal_unbonding_height() const;
  void _internal_set_unbonding_height(::int64_t value);

  public:
  // uint64 proposed = 16 [json_name = "proposed"];
  void clear_proposed() ;
  ::uint64_t proposed() const;
  void set_proposed(::uint64_t value);

  private:
  ::uint64_t _internal_proposed() const;
  void _internal_set_proposed(::uint64_t value);

  public:
  // uint64 signed = 17 [json_name = "signed"];
  void clear_signed_() ;
  ::uint64_t signed_() const;
  void set_signed_(::uint64_t value);

  private:
  ::uint64_t _internal_signed_() const;
  void _internal_set_signed_(::uint64_t value);

  public:
  // uint64 missed = 18 [json_name = "missed"];
  void clear_missed() ;
  ::uint64_t missed() const;
  void set_missed(::uint64_t value);

  private:
  ::uint64_t _internal_missed() const;
  void _internal_set_missed(::uint64_t value);

  public:
  // double uptime_percentage = 22 [json_name = "uptimePercentage"];
  void clear_uptime_percentage() ;
  double uptime_percentage() const;
  void set_uptime_percentage(double value);

  private:
  double _internal_uptime_percentage() const;
  void _internal_set_uptime_percentage(double value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Validator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime > uptimes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::SlashingEvent > slashing_events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consensus_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tokens_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delegator_shares_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unbonding_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commission_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commission_max_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commission_max_change_rate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commission_update_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::injective_explorer_rpc::ValidatorDescription* description_;
    bool jailed_;
    ::int32_t status_;
    ::int64_t unbonding_height_;
    ::uint64_t proposed_;
    ::uint64_t signed__;
    ::uint64_t missed_;
    double uptime_percentage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class ValidatorDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.ValidatorDescription) */ {
 public:
  inline ValidatorDescription() : ValidatorDescription(nullptr) {}
  ~ValidatorDescription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorDescription(const ValidatorDescription& from);
  ValidatorDescription(ValidatorDescription&& from) noexcept
    : ValidatorDescription() {
    *this = ::std::move(from);
  }

  inline ValidatorDescription& operator=(const ValidatorDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorDescription& operator=(ValidatorDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorDescription* internal_default_instance() {
    return reinterpret_cast<const ValidatorDescription*>(
               &_ValidatorDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ValidatorDescription& a, ValidatorDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorDescription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorDescription& from) {
    ValidatorDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.ValidatorDescription";
  }
  protected:
  explicit ValidatorDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonikerFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kWebsiteFieldNumber = 3,
    kSecurityContactFieldNumber = 4,
    kDetailsFieldNumber = 5,
  };
  // string moniker = 1 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string identity = 2 [json_name = "identity"];
  void clear_identity() ;
  const std::string& identity() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity(Arg_&& arg, Args_... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* ptr);

  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(
      const std::string& value);
  std::string* _internal_mutable_identity();

  public:
  // string website = 3 [json_name = "website"];
  void clear_website() ;
  const std::string& website() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_website(Arg_&& arg, Args_... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* ptr);

  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(
      const std::string& value);
  std::string* _internal_mutable_website();

  public:
  // string security_contact = 4 [json_name = "securityContact"];
  void clear_security_contact() ;
  const std::string& security_contact() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_security_contact(Arg_&& arg, Args_... args);
  std::string* mutable_security_contact();
  PROTOBUF_NODISCARD std::string* release_security_contact();
  void set_allocated_security_contact(std::string* ptr);

  private:
  const std::string& _internal_security_contact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_contact(
      const std::string& value);
  std::string* _internal_mutable_security_contact();

  public:
  // string details = 5 [json_name = "details"];
  void clear_details() ;
  const std::string& details() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_details(Arg_&& arg, Args_... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* ptr);

  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(
      const std::string& value);
  std::string* _internal_mutable_details();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.ValidatorDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_contact_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class ValidatorUptime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.ValidatorUptime) */ {
 public:
  inline ValidatorUptime() : ValidatorUptime(nullptr) {}
  ~ValidatorUptime() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidatorUptime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorUptime(const ValidatorUptime& from);
  ValidatorUptime(ValidatorUptime&& from) noexcept
    : ValidatorUptime() {
    *this = ::std::move(from);
  }

  inline ValidatorUptime& operator=(const ValidatorUptime& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorUptime& operator=(ValidatorUptime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorUptime& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorUptime* internal_default_instance() {
    return reinterpret_cast<const ValidatorUptime*>(
               &_ValidatorUptime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ValidatorUptime& a, ValidatorUptime& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorUptime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorUptime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorUptime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorUptime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorUptime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidatorUptime& from) {
    ValidatorUptime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorUptime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.ValidatorUptime";
  }
  protected:
  explicit ValidatorUptime(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kBlockNumberFieldNumber = 1,
  };
  // string status = 2 [json_name = "status"];
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // uint64 block_number = 1 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.ValidatorUptime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::uint64_t block_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class SlashingEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.SlashingEvent) */ {
 public:
  inline SlashingEvent() : SlashingEvent(nullptr) {}
  ~SlashingEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SlashingEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SlashingEvent(const SlashingEvent& from);
  SlashingEvent(SlashingEvent&& from) noexcept
    : SlashingEvent() {
    *this = ::std::move(from);
  }

  inline SlashingEvent& operator=(const SlashingEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlashingEvent& operator=(SlashingEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlashingEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlashingEvent* internal_default_instance() {
    return reinterpret_cast<const SlashingEvent*>(
               &_SlashingEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SlashingEvent& a, SlashingEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SlashingEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlashingEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SlashingEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SlashingEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SlashingEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SlashingEvent& from) {
    SlashingEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlashingEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.SlashingEvent";
  }
  protected:
  explicit SlashingEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockTimestampFieldNumber = 2,
    kAddressFieldNumber = 3,
    kReasonFieldNumber = 5,
    kJailedFieldNumber = 6,
    kBlockNumberFieldNumber = 1,
    kPowerFieldNumber = 4,
    kMissedBlocksFieldNumber = 7,
  };
  // string block_timestamp = 2 [json_name = "blockTimestamp"];
  void clear_block_timestamp() ;
  const std::string& block_timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_block_timestamp();
  PROTOBUF_NODISCARD std::string* release_block_timestamp();
  void set_allocated_block_timestamp(std::string* ptr);

  private:
  const std::string& _internal_block_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_timestamp(
      const std::string& value);
  std::string* _internal_mutable_block_timestamp();

  public:
  // string address = 3 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string reason = 5 [json_name = "reason"];
  void clear_reason() ;
  const std::string& reason() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* ptr);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // string jailed = 6 [json_name = "jailed"];
  void clear_jailed() ;
  const std::string& jailed() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jailed(Arg_&& arg, Args_... args);
  std::string* mutable_jailed();
  PROTOBUF_NODISCARD std::string* release_jailed();
  void set_allocated_jailed(std::string* ptr);

  private:
  const std::string& _internal_jailed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jailed(
      const std::string& value);
  std::string* _internal_mutable_jailed();

  public:
  // uint64 block_number = 1 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 power = 4 [json_name = "power"];
  void clear_power() ;
  ::uint64_t power() const;
  void set_power(::uint64_t value);

  private:
  ::uint64_t _internal_power() const;
  void _internal_set_power(::uint64_t value);

  public:
  // uint64 missed_blocks = 7 [json_name = "missedBlocks"];
  void clear_missed_blocks() ;
  ::uint64_t missed_blocks() const;
  void set_missed_blocks(::uint64_t value);

  private:
  ::uint64_t _internal_missed_blocks() const;
  void _internal_set_missed_blocks(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.SlashingEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jailed_;
    ::uint64_t block_number_;
    ::uint64_t power_;
    ::uint64_t missed_blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorRequest) */ {
 public:
  inline GetValidatorRequest() : GetValidatorRequest(nullptr) {}
  ~GetValidatorRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorRequest(const GetValidatorRequest& from);
  GetValidatorRequest(GetValidatorRequest&& from) noexcept
    : GetValidatorRequest() {
    *this = ::std::move(from);
  }

  inline GetValidatorRequest& operator=(const GetValidatorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorRequest& operator=(GetValidatorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorRequest* internal_default_instance() {
    return reinterpret_cast<const GetValidatorRequest*>(
               &_GetValidatorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetValidatorRequest& a, GetValidatorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValidatorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValidatorRequest& from) {
    GetValidatorRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValidatorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorRequest";
  }
  protected:
  explicit GetValidatorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorResponse) */ {
 public:
  inline GetValidatorResponse() : GetValidatorResponse(nullptr) {}
  ~GetValidatorResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorResponse(const GetValidatorResponse& from);
  GetValidatorResponse(GetValidatorResponse&& from) noexcept
    : GetValidatorResponse() {
    *this = ::std::move(from);
  }

  inline GetValidatorResponse& operator=(const GetValidatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorResponse& operator=(GetValidatorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorResponse* internal_default_instance() {
    return reinterpret_cast<const GetValidatorResponse*>(
               &_GetValidatorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetValidatorResponse& a, GetValidatorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValidatorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValidatorResponse& from) {
    GetValidatorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValidatorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorResponse";
  }
  protected:
  explicit GetValidatorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kErrmsgFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string s = 1 [json_name = "s"];
  void clear_s() ;
  const std::string& s() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // string errmsg = 2 [json_name = "errmsg"];
  void clear_errmsg() ;
  const std::string& errmsg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errmsg(Arg_&& arg, Args_... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* ptr);

  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(
      const std::string& value);
  std::string* _internal_mutable_errmsg();

  public:
  // .injective_explorer_rpc.Validator data = 3 [json_name = "data"];
  bool has_data() const;
  void clear_data() ;
  const ::injective_explorer_rpc::Validator& data() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Validator* release_data();
  ::injective_explorer_rpc::Validator* mutable_data();
  void set_allocated_data(::injective_explorer_rpc::Validator* data);
  private:
  const ::injective_explorer_rpc::Validator& _internal_data() const;
  ::injective_explorer_rpc::Validator* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::injective_explorer_rpc::Validator* data);
  ::injective_explorer_rpc::Validator* unsafe_arena_release_data();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
    ::injective_explorer_rpc::Validator* data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorUptimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorUptimeRequest) */ {
 public:
  inline GetValidatorUptimeRequest() : GetValidatorUptimeRequest(nullptr) {}
  ~GetValidatorUptimeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorUptimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorUptimeRequest(const GetValidatorUptimeRequest& from);
  GetValidatorUptimeRequest(GetValidatorUptimeRequest&& from) noexcept
    : GetValidatorUptimeRequest() {
    *this = ::std::move(from);
  }

  inline GetValidatorUptimeRequest& operator=(const GetValidatorUptimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorUptimeRequest& operator=(GetValidatorUptimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorUptimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorUptimeRequest* internal_default_instance() {
    return reinterpret_cast<const GetValidatorUptimeRequest*>(
               &_GetValidatorUptimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetValidatorUptimeRequest& a, GetValidatorUptimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorUptimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorUptimeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorUptimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorUptimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValidatorUptimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValidatorUptimeRequest& from) {
    GetValidatorUptimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValidatorUptimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorUptimeRequest";
  }
  protected:
  explicit GetValidatorUptimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorUptimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetValidatorUptimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetValidatorUptimeResponse) */ {
 public:
  inline GetValidatorUptimeResponse() : GetValidatorUptimeResponse(nullptr) {}
  ~GetValidatorUptimeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetValidatorUptimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetValidatorUptimeResponse(const GetValidatorUptimeResponse& from);
  GetValidatorUptimeResponse(GetValidatorUptimeResponse&& from) noexcept
    : GetValidatorUptimeResponse() {
    *this = ::std::move(from);
  }

  inline GetValidatorUptimeResponse& operator=(const GetValidatorUptimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetValidatorUptimeResponse& operator=(GetValidatorUptimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetValidatorUptimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetValidatorUptimeResponse* internal_default_instance() {
    return reinterpret_cast<const GetValidatorUptimeResponse*>(
               &_GetValidatorUptimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetValidatorUptimeResponse& a, GetValidatorUptimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetValidatorUptimeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetValidatorUptimeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetValidatorUptimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetValidatorUptimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetValidatorUptimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetValidatorUptimeResponse& from) {
    GetValidatorUptimeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetValidatorUptimeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetValidatorUptimeResponse";
  }
  protected:
  explicit GetValidatorUptimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kSFieldNumber = 1,
    kErrmsgFieldNumber = 2,
  };
  // repeated .injective_explorer_rpc.ValidatorUptime data = 3 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::ValidatorUptime* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::ValidatorUptime& _internal_data(int index) const;
  ::injective_explorer_rpc::ValidatorUptime* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::ValidatorUptime& data(int index) const;
  ::injective_explorer_rpc::ValidatorUptime* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >&
      data() const;
  // string s = 1 [json_name = "s"];
  void clear_s() ;
  const std::string& s() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // string errmsg = 2 [json_name = "errmsg"];
  void clear_errmsg() ;
  const std::string& errmsg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errmsg(Arg_&& arg, Args_... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* ptr);

  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(
      const std::string& value);
  std::string* _internal_mutable_errmsg();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetValidatorUptimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime > data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetTxsRequest) */ {
 public:
  inline GetTxsRequest() : GetTxsRequest(nullptr) {}
  ~GetTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxsRequest(const GetTxsRequest& from);
  GetTxsRequest(GetTxsRequest&& from) noexcept
    : GetTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetTxsRequest& operator=(const GetTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxsRequest& operator=(GetTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTxsRequest*>(
               &_GetTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetTxsRequest& a, GetTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxsRequest& from) {
    GetTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetTxsRequest";
  }
  protected:
  explicit GetTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 5,
    kModuleFieldNumber = 6,
    kBeforeFieldNumber = 1,
    kAfterFieldNumber = 2,
    kSkipFieldNumber = 4,
    kFromNumberFieldNumber = 7,
    kToNumberFieldNumber = 8,
    kLimitFieldNumber = 3,
  };
  // string type = 5 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string module = 6 [json_name = "module"];
  void clear_module() ;
  const std::string& module() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_module(Arg_&& arg, Args_... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* ptr);

  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(
      const std::string& value);
  std::string* _internal_mutable_module();

  public:
  // uint64 before = 1 [json_name = "before"];
  void clear_before() ;
  ::uint64_t before() const;
  void set_before(::uint64_t value);

  private:
  ::uint64_t _internal_before() const;
  void _internal_set_before(::uint64_t value);

  public:
  // uint64 after = 2 [json_name = "after"];
  void clear_after() ;
  ::uint64_t after() const;
  void set_after(::uint64_t value);

  private:
  ::uint64_t _internal_after() const;
  void _internal_set_after(::uint64_t value);

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint64 from_number = 7 [json_name = "fromNumber"];
  void clear_from_number() ;
  ::int64_t from_number() const;
  void set_from_number(::int64_t value);

  private:
  ::int64_t _internal_from_number() const;
  void _internal_set_from_number(::int64_t value);

  public:
  // sint64 to_number = 8 [json_name = "toNumber"];
  void clear_to_number() ;
  ::int64_t to_number() const;
  void set_to_number(::int64_t value);

  private:
  ::int64_t _internal_to_number() const;
  void _internal_set_to_number(::int64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::uint64_t before_;
    ::uint64_t after_;
    ::uint64_t skip_;
    ::int64_t from_number_;
    ::int64_t to_number_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetTxsResponse) */ {
 public:
  inline GetTxsResponse() : GetTxsResponse(nullptr) {}
  ~GetTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxsResponse(const GetTxsResponse& from);
  GetTxsResponse(GetTxsResponse&& from) noexcept
    : GetTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetTxsResponse& operator=(const GetTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxsResponse& operator=(GetTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTxsResponse*>(
               &_GetTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetTxsResponse& a, GetTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxsResponse& from) {
    GetTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetTxsResponse";
  }
  protected:
  explicit GetTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.TxData data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::TxData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::TxData& _internal_data(int index) const;
  ::injective_explorer_rpc::TxData* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::TxData& data(int index) const;
  ::injective_explorer_rpc::TxData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetTxByTxHashRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetTxByTxHashRequest) */ {
 public:
  inline GetTxByTxHashRequest() : GetTxByTxHashRequest(nullptr) {}
  ~GetTxByTxHashRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxByTxHashRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxByTxHashRequest(const GetTxByTxHashRequest& from);
  GetTxByTxHashRequest(GetTxByTxHashRequest&& from) noexcept
    : GetTxByTxHashRequest() {
    *this = ::std::move(from);
  }

  inline GetTxByTxHashRequest& operator=(const GetTxByTxHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxByTxHashRequest& operator=(GetTxByTxHashRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxByTxHashRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxByTxHashRequest* internal_default_instance() {
    return reinterpret_cast<const GetTxByTxHashRequest*>(
               &_GetTxByTxHashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetTxByTxHashRequest& a, GetTxByTxHashRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxByTxHashRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxByTxHashRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxByTxHashRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxByTxHashRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxByTxHashRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxByTxHashRequest& from) {
    GetTxByTxHashRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxByTxHashRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetTxByTxHashRequest";
  }
  protected:
  explicit GetTxByTxHashRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // string hash = 1 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetTxByTxHashRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetTxByTxHashResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetTxByTxHashResponse) */ {
 public:
  inline GetTxByTxHashResponse() : GetTxByTxHashResponse(nullptr) {}
  ~GetTxByTxHashResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTxByTxHashResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxByTxHashResponse(const GetTxByTxHashResponse& from);
  GetTxByTxHashResponse(GetTxByTxHashResponse&& from) noexcept
    : GetTxByTxHashResponse() {
    *this = ::std::move(from);
  }

  inline GetTxByTxHashResponse& operator=(const GetTxByTxHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxByTxHashResponse& operator=(GetTxByTxHashResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxByTxHashResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxByTxHashResponse* internal_default_instance() {
    return reinterpret_cast<const GetTxByTxHashResponse*>(
               &_GetTxByTxHashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetTxByTxHashResponse& a, GetTxByTxHashResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxByTxHashResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxByTxHashResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxByTxHashResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxByTxHashResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxByTxHashResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxByTxHashResponse& from) {
    GetTxByTxHashResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxByTxHashResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetTxByTxHashResponse";
  }
  protected:
  explicit GetTxByTxHashResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kErrmsgFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // string s = 1 [json_name = "s"];
  void clear_s() ;
  const std::string& s() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* ptr);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // string errmsg = 2 [json_name = "errmsg"];
  void clear_errmsg() ;
  const std::string& errmsg() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errmsg(Arg_&& arg, Args_... args);
  std::string* mutable_errmsg();
  PROTOBUF_NODISCARD std::string* release_errmsg();
  void set_allocated_errmsg(std::string* ptr);

  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(
      const std::string& value);
  std::string* _internal_mutable_errmsg();

  public:
  // .injective_explorer_rpc.TxDetailData data = 3 [json_name = "data"];
  bool has_data() const;
  void clear_data() ;
  const ::injective_explorer_rpc::TxDetailData& data() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::TxDetailData* release_data();
  ::injective_explorer_rpc::TxDetailData* mutable_data();
  void set_allocated_data(::injective_explorer_rpc::TxDetailData* data);
  private:
  const ::injective_explorer_rpc::TxDetailData& _internal_data() const;
  ::injective_explorer_rpc::TxDetailData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::injective_explorer_rpc::TxDetailData* data);
  ::injective_explorer_rpc::TxDetailData* unsafe_arena_release_data();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetTxByTxHashResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
    ::injective_explorer_rpc::TxDetailData* data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetPeggyDepositTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetPeggyDepositTxsRequest) */ {
 public:
  inline GetPeggyDepositTxsRequest() : GetPeggyDepositTxsRequest(nullptr) {}
  ~GetPeggyDepositTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPeggyDepositTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeggyDepositTxsRequest(const GetPeggyDepositTxsRequest& from);
  GetPeggyDepositTxsRequest(GetPeggyDepositTxsRequest&& from) noexcept
    : GetPeggyDepositTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetPeggyDepositTxsRequest& operator=(const GetPeggyDepositTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeggyDepositTxsRequest& operator=(GetPeggyDepositTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeggyDepositTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeggyDepositTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPeggyDepositTxsRequest*>(
               &_GetPeggyDepositTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetPeggyDepositTxsRequest& a, GetPeggyDepositTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeggyDepositTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeggyDepositTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeggyDepositTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeggyDepositTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPeggyDepositTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPeggyDepositTxsRequest& from) {
    GetPeggyDepositTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeggyDepositTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetPeggyDepositTxsRequest";
  }
  protected:
  explicit GetPeggyDepositTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kSkipFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetPeggyDepositTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetPeggyDepositTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetPeggyDepositTxsResponse) */ {
 public:
  inline GetPeggyDepositTxsResponse() : GetPeggyDepositTxsResponse(nullptr) {}
  ~GetPeggyDepositTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPeggyDepositTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeggyDepositTxsResponse(const GetPeggyDepositTxsResponse& from);
  GetPeggyDepositTxsResponse(GetPeggyDepositTxsResponse&& from) noexcept
    : GetPeggyDepositTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetPeggyDepositTxsResponse& operator=(const GetPeggyDepositTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeggyDepositTxsResponse& operator=(GetPeggyDepositTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeggyDepositTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeggyDepositTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPeggyDepositTxsResponse*>(
               &_GetPeggyDepositTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetPeggyDepositTxsResponse& a, GetPeggyDepositTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeggyDepositTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeggyDepositTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeggyDepositTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeggyDepositTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPeggyDepositTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPeggyDepositTxsResponse& from) {
    GetPeggyDepositTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeggyDepositTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetPeggyDepositTxsResponse";
  }
  protected:
  explicit GetPeggyDepositTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.PeggyDepositTx field = 1 [json_name = "field"];
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::injective_explorer_rpc::PeggyDepositTx* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyDepositTx >*
      mutable_field();
  private:
  const ::injective_explorer_rpc::PeggyDepositTx& _internal_field(int index) const;
  ::injective_explorer_rpc::PeggyDepositTx* _internal_add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyDepositTx>& _internal_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyDepositTx>* _internal_mutable_field();
  public:
  const ::injective_explorer_rpc::PeggyDepositTx& field(int index) const;
  ::injective_explorer_rpc::PeggyDepositTx* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyDepositTx >&
      field() const;
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetPeggyDepositTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyDepositTx > field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class PeggyDepositTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.PeggyDepositTx) */ {
 public:
  inline PeggyDepositTx() : PeggyDepositTx(nullptr) {}
  ~PeggyDepositTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PeggyDepositTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeggyDepositTx(const PeggyDepositTx& from);
  PeggyDepositTx(PeggyDepositTx&& from) noexcept
    : PeggyDepositTx() {
    *this = ::std::move(from);
  }

  inline PeggyDepositTx& operator=(const PeggyDepositTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeggyDepositTx& operator=(PeggyDepositTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeggyDepositTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeggyDepositTx* internal_default_instance() {
    return reinterpret_cast<const PeggyDepositTx*>(
               &_PeggyDepositTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PeggyDepositTx& a, PeggyDepositTx& b) {
    a.Swap(&b);
  }
  inline void Swap(PeggyDepositTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeggyDepositTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeggyDepositTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeggyDepositTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeggyDepositTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeggyDepositTx& from) {
    PeggyDepositTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeggyDepositTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.PeggyDepositTx";
  }
  protected:
  explicit PeggyDepositTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashesFieldNumber = 10,
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kAmountFieldNumber = 5,
    kDenomFieldNumber = 6,
    kOrchestratorAddressFieldNumber = 7,
    kStateFieldNumber = 8,
    kCreatedAtFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
    kEventNonceFieldNumber = 3,
    kEventHeightFieldNumber = 4,
    kClaimTypeFieldNumber = 9,
  };
  // repeated string tx_hashes = 10 [json_name = "txHashes"];
  int tx_hashes_size() const;
  private:
  int _internal_tx_hashes_size() const;

  public:
  void clear_tx_hashes() ;
  const std::string& tx_hashes(int index) const;
  std::string* mutable_tx_hashes(int index);
  void set_tx_hashes(int index, const std::string& value);
  void set_tx_hashes(int index, std::string&& value);
  void set_tx_hashes(int index, const char* value);
  void set_tx_hashes(int index, const char* value, std::size_t size);
  void set_tx_hashes(int index, absl::string_view value);
  std::string* add_tx_hashes();
  void add_tx_hashes(const std::string& value);
  void add_tx_hashes(std::string&& value);
  void add_tx_hashes(const char* value);
  void add_tx_hashes(const char* value, std::size_t size);
  void add_tx_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tx_hashes();

  private:
  const std::string& _internal_tx_hashes(int index) const;
  std::string* _internal_add_tx_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_tx_hashes();

  public:
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // string amount = 5 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string denom = 6 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string orchestrator_address = 7 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // string state = 8 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string created_at = 11 [json_name = "createdAt"];
  void clear_created_at() ;
  const std::string& created_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* ptr);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string updated_at = 12 [json_name = "updatedAt"];
  void clear_updated_at() ;
  const std::string& updated_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_at(Arg_&& arg, Args_... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* ptr);

  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(
      const std::string& value);
  std::string* _internal_mutable_updated_at();

  public:
  // uint64 event_nonce = 3 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 4 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // sint32 claim_type = 9 [json_name = "claimType"];
  void clear_claim_type() ;
  ::int32_t claim_type() const;
  void set_claim_type(::int32_t value);

  private:
  ::int32_t _internal_claim_type() const;
  void _internal_set_claim_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.PeggyDepositTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tx_hashes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    ::int32_t claim_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetPeggyWithdrawalTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest) */ {
 public:
  inline GetPeggyWithdrawalTxsRequest() : GetPeggyWithdrawalTxsRequest(nullptr) {}
  ~GetPeggyWithdrawalTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPeggyWithdrawalTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeggyWithdrawalTxsRequest(const GetPeggyWithdrawalTxsRequest& from);
  GetPeggyWithdrawalTxsRequest(GetPeggyWithdrawalTxsRequest&& from) noexcept
    : GetPeggyWithdrawalTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetPeggyWithdrawalTxsRequest& operator=(const GetPeggyWithdrawalTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeggyWithdrawalTxsRequest& operator=(GetPeggyWithdrawalTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeggyWithdrawalTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeggyWithdrawalTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetPeggyWithdrawalTxsRequest*>(
               &_GetPeggyWithdrawalTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetPeggyWithdrawalTxsRequest& a, GetPeggyWithdrawalTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeggyWithdrawalTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeggyWithdrawalTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeggyWithdrawalTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeggyWithdrawalTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPeggyWithdrawalTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPeggyWithdrawalTxsRequest& from) {
    GetPeggyWithdrawalTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeggyWithdrawalTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetPeggyWithdrawalTxsRequest";
  }
  protected:
  explicit GetPeggyWithdrawalTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kSkipFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // uint64 skip = 4 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 3 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetPeggyWithdrawalTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse) */ {
 public:
  inline GetPeggyWithdrawalTxsResponse() : GetPeggyWithdrawalTxsResponse(nullptr) {}
  ~GetPeggyWithdrawalTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPeggyWithdrawalTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPeggyWithdrawalTxsResponse(const GetPeggyWithdrawalTxsResponse& from);
  GetPeggyWithdrawalTxsResponse(GetPeggyWithdrawalTxsResponse&& from) noexcept
    : GetPeggyWithdrawalTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetPeggyWithdrawalTxsResponse& operator=(const GetPeggyWithdrawalTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPeggyWithdrawalTxsResponse& operator=(GetPeggyWithdrawalTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPeggyWithdrawalTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPeggyWithdrawalTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetPeggyWithdrawalTxsResponse*>(
               &_GetPeggyWithdrawalTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetPeggyWithdrawalTxsResponse& a, GetPeggyWithdrawalTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPeggyWithdrawalTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPeggyWithdrawalTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPeggyWithdrawalTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPeggyWithdrawalTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPeggyWithdrawalTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPeggyWithdrawalTxsResponse& from) {
    GetPeggyWithdrawalTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPeggyWithdrawalTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetPeggyWithdrawalTxsResponse";
  }
  protected:
  explicit GetPeggyWithdrawalTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.PeggyWithdrawalTx field = 1 [json_name = "field"];
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::injective_explorer_rpc::PeggyWithdrawalTx* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyWithdrawalTx >*
      mutable_field();
  private:
  const ::injective_explorer_rpc::PeggyWithdrawalTx& _internal_field(int index) const;
  ::injective_explorer_rpc::PeggyWithdrawalTx* _internal_add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyWithdrawalTx>& _internal_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyWithdrawalTx>* _internal_mutable_field();
  public:
  const ::injective_explorer_rpc::PeggyWithdrawalTx& field(int index) const;
  ::injective_explorer_rpc::PeggyWithdrawalTx* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyWithdrawalTx >&
      field() const;
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyWithdrawalTx > field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class PeggyWithdrawalTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.PeggyWithdrawalTx) */ {
 public:
  inline PeggyWithdrawalTx() : PeggyWithdrawalTx(nullptr) {}
  ~PeggyWithdrawalTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PeggyWithdrawalTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeggyWithdrawalTx(const PeggyWithdrawalTx& from);
  PeggyWithdrawalTx(PeggyWithdrawalTx&& from) noexcept
    : PeggyWithdrawalTx() {
    *this = ::std::move(from);
  }

  inline PeggyWithdrawalTx& operator=(const PeggyWithdrawalTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeggyWithdrawalTx& operator=(PeggyWithdrawalTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeggyWithdrawalTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeggyWithdrawalTx* internal_default_instance() {
    return reinterpret_cast<const PeggyWithdrawalTx*>(
               &_PeggyWithdrawalTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(PeggyWithdrawalTx& a, PeggyWithdrawalTx& b) {
    a.Swap(&b);
  }
  inline void Swap(PeggyWithdrawalTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeggyWithdrawalTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeggyWithdrawalTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeggyWithdrawalTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeggyWithdrawalTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeggyWithdrawalTx& from) {
    PeggyWithdrawalTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeggyWithdrawalTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.PeggyWithdrawalTx";
  }
  protected:
  explicit PeggyWithdrawalTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashesFieldNumber = 14,
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kAmountFieldNumber = 3,
    kDenomFieldNumber = 4,
    kBridgeFeeFieldNumber = 5,
    kOrchestratorAddressFieldNumber = 9,
    kStateFieldNumber = 12,
    kCreatedAtFieldNumber = 15,
    kUpdatedAtFieldNumber = 16,
    kOutgoingTxIdFieldNumber = 6,
    kBatchTimeoutFieldNumber = 7,
    kBatchNonceFieldNumber = 8,
    kEventNonceFieldNumber = 10,
    kEventHeightFieldNumber = 11,
    kClaimTypeFieldNumber = 13,
  };
  // repeated string tx_hashes = 14 [json_name = "txHashes"];
  int tx_hashes_size() const;
  private:
  int _internal_tx_hashes_size() const;

  public:
  void clear_tx_hashes() ;
  const std::string& tx_hashes(int index) const;
  std::string* mutable_tx_hashes(int index);
  void set_tx_hashes(int index, const std::string& value);
  void set_tx_hashes(int index, std::string&& value);
  void set_tx_hashes(int index, const char* value);
  void set_tx_hashes(int index, const char* value, std::size_t size);
  void set_tx_hashes(int index, absl::string_view value);
  std::string* add_tx_hashes();
  void add_tx_hashes(const std::string& value);
  void add_tx_hashes(std::string&& value);
  void add_tx_hashes(const char* value);
  void add_tx_hashes(const char* value, std::size_t size);
  void add_tx_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tx_hashes();

  private:
  const std::string& _internal_tx_hashes(int index) const;
  std::string* _internal_add_tx_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_tx_hashes();

  public:
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // string amount = 3 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string denom = 4 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string bridge_fee = 5 [json_name = "bridgeFee"];
  void clear_bridge_fee() ;
  const std::string& bridge_fee() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bridge_fee(Arg_&& arg, Args_... args);
  std::string* mutable_bridge_fee();
  PROTOBUF_NODISCARD std::string* release_bridge_fee();
  void set_allocated_bridge_fee(std::string* ptr);

  private:
  const std::string& _internal_bridge_fee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bridge_fee(
      const std::string& value);
  std::string* _internal_mutable_bridge_fee();

  public:
  // string orchestrator_address = 9 [json_name = "orchestratorAddress"];
  void clear_orchestrator_address() ;
  const std::string& orchestrator_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orchestrator_address(Arg_&& arg, Args_... args);
  std::string* mutable_orchestrator_address();
  PROTOBUF_NODISCARD std::string* release_orchestrator_address();
  void set_allocated_orchestrator_address(std::string* ptr);

  private:
  const std::string& _internal_orchestrator_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orchestrator_address(
      const std::string& value);
  std::string* _internal_mutable_orchestrator_address();

  public:
  // string state = 12 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string created_at = 15 [json_name = "createdAt"];
  void clear_created_at() ;
  const std::string& created_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* ptr);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string updated_at = 16 [json_name = "updatedAt"];
  void clear_updated_at() ;
  const std::string& updated_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_at(Arg_&& arg, Args_... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* ptr);

  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(
      const std::string& value);
  std::string* _internal_mutable_updated_at();

  public:
  // uint64 outgoing_tx_id = 6 [json_name = "outgoingTxId"];
  void clear_outgoing_tx_id() ;
  ::uint64_t outgoing_tx_id() const;
  void set_outgoing_tx_id(::uint64_t value);

  private:
  ::uint64_t _internal_outgoing_tx_id() const;
  void _internal_set_outgoing_tx_id(::uint64_t value);

  public:
  // uint64 batch_timeout = 7 [json_name = "batchTimeout"];
  void clear_batch_timeout() ;
  ::uint64_t batch_timeout() const;
  void set_batch_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_batch_timeout() const;
  void _internal_set_batch_timeout(::uint64_t value);

  public:
  // uint64 batch_nonce = 8 [json_name = "batchNonce"];
  void clear_batch_nonce() ;
  ::uint64_t batch_nonce() const;
  void set_batch_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_batch_nonce() const;
  void _internal_set_batch_nonce(::uint64_t value);

  public:
  // uint64 event_nonce = 10 [json_name = "eventNonce"];
  void clear_event_nonce() ;
  ::uint64_t event_nonce() const;
  void set_event_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_event_nonce() const;
  void _internal_set_event_nonce(::uint64_t value);

  public:
  // uint64 event_height = 11 [json_name = "eventHeight"];
  void clear_event_height() ;
  ::uint64_t event_height() const;
  void set_event_height(::uint64_t value);

  private:
  ::uint64_t _internal_event_height() const;
  void _internal_set_event_height(::uint64_t value);

  public:
  // sint32 claim_type = 13 [json_name = "claimType"];
  void clear_claim_type() ;
  ::int32_t claim_type() const;
  void set_claim_type(::int32_t value);

  private:
  ::int32_t _internal_claim_type() const;
  void _internal_set_claim_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.PeggyWithdrawalTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tx_hashes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bridge_fee_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr orchestrator_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
    ::uint64_t outgoing_tx_id_;
    ::uint64_t batch_timeout_;
    ::uint64_t batch_nonce_;
    ::uint64_t event_nonce_;
    ::uint64_t event_height_;
    ::int32_t claim_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetIBCTransferTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetIBCTransferTxsRequest) */ {
 public:
  inline GetIBCTransferTxsRequest() : GetIBCTransferTxsRequest(nullptr) {}
  ~GetIBCTransferTxsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetIBCTransferTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIBCTransferTxsRequest(const GetIBCTransferTxsRequest& from);
  GetIBCTransferTxsRequest(GetIBCTransferTxsRequest&& from) noexcept
    : GetIBCTransferTxsRequest() {
    *this = ::std::move(from);
  }

  inline GetIBCTransferTxsRequest& operator=(const GetIBCTransferTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIBCTransferTxsRequest& operator=(GetIBCTransferTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIBCTransferTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIBCTransferTxsRequest* internal_default_instance() {
    return reinterpret_cast<const GetIBCTransferTxsRequest*>(
               &_GetIBCTransferTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetIBCTransferTxsRequest& a, GetIBCTransferTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIBCTransferTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIBCTransferTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIBCTransferTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIBCTransferTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIBCTransferTxsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIBCTransferTxsRequest& from) {
    GetIBCTransferTxsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIBCTransferTxsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetIBCTransferTxsRequest";
  }
  protected:
  explicit GetIBCTransferTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kSrcChannelFieldNumber = 3,
    kSrcPortFieldNumber = 4,
    kDestChannelFieldNumber = 5,
    kDestPortFieldNumber = 6,
    kSkipFieldNumber = 8,
    kLimitFieldNumber = 7,
  };
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // string src_channel = 3 [json_name = "srcChannel"];
  void clear_src_channel() ;
  const std::string& src_channel() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_channel(Arg_&& arg, Args_... args);
  std::string* mutable_src_channel();
  PROTOBUF_NODISCARD std::string* release_src_channel();
  void set_allocated_src_channel(std::string* ptr);

  private:
  const std::string& _internal_src_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_channel(
      const std::string& value);
  std::string* _internal_mutable_src_channel();

  public:
  // string src_port = 4 [json_name = "srcPort"];
  void clear_src_port() ;
  const std::string& src_port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_port(Arg_&& arg, Args_... args);
  std::string* mutable_src_port();
  PROTOBUF_NODISCARD std::string* release_src_port();
  void set_allocated_src_port(std::string* ptr);

  private:
  const std::string& _internal_src_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_port(
      const std::string& value);
  std::string* _internal_mutable_src_port();

  public:
  // string dest_channel = 5 [json_name = "destChannel"];
  void clear_dest_channel() ;
  const std::string& dest_channel() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dest_channel(Arg_&& arg, Args_... args);
  std::string* mutable_dest_channel();
  PROTOBUF_NODISCARD std::string* release_dest_channel();
  void set_allocated_dest_channel(std::string* ptr);

  private:
  const std::string& _internal_dest_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest_channel(
      const std::string& value);
  std::string* _internal_mutable_dest_channel();

  public:
  // string dest_port = 6 [json_name = "destPort"];
  void clear_dest_port() ;
  const std::string& dest_port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dest_port(Arg_&& arg, Args_... args);
  std::string* mutable_dest_port();
  PROTOBUF_NODISCARD std::string* release_dest_port();
  void set_allocated_dest_port(std::string* ptr);

  private:
  const std::string& _internal_dest_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dest_port(
      const std::string& value);
  std::string* _internal_mutable_dest_port();

  public:
  // uint64 skip = 8 [json_name = "skip"];
  void clear_skip() ;
  ::uint64_t skip() const;
  void set_skip(::uint64_t value);

  private:
  ::uint64_t _internal_skip() const;
  void _internal_set_skip(::uint64_t value);

  public:
  // sint32 limit = 7 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetIBCTransferTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dest_port_;
    ::uint64_t skip_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetIBCTransferTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetIBCTransferTxsResponse) */ {
 public:
  inline GetIBCTransferTxsResponse() : GetIBCTransferTxsResponse(nullptr) {}
  ~GetIBCTransferTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetIBCTransferTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIBCTransferTxsResponse(const GetIBCTransferTxsResponse& from);
  GetIBCTransferTxsResponse(GetIBCTransferTxsResponse&& from) noexcept
    : GetIBCTransferTxsResponse() {
    *this = ::std::move(from);
  }

  inline GetIBCTransferTxsResponse& operator=(const GetIBCTransferTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIBCTransferTxsResponse& operator=(GetIBCTransferTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIBCTransferTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIBCTransferTxsResponse* internal_default_instance() {
    return reinterpret_cast<const GetIBCTransferTxsResponse*>(
               &_GetIBCTransferTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetIBCTransferTxsResponse& a, GetIBCTransferTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIBCTransferTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIBCTransferTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIBCTransferTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIBCTransferTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIBCTransferTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIBCTransferTxsResponse& from) {
    GetIBCTransferTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIBCTransferTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetIBCTransferTxsResponse";
  }
  protected:
  explicit GetIBCTransferTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.IBCTransferTx field = 1 [json_name = "field"];
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::injective_explorer_rpc::IBCTransferTx* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::IBCTransferTx >*
      mutable_field();
  private:
  const ::injective_explorer_rpc::IBCTransferTx& _internal_field(int index) const;
  ::injective_explorer_rpc::IBCTransferTx* _internal_add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::IBCTransferTx>& _internal_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::IBCTransferTx>* _internal_mutable_field();
  public:
  const ::injective_explorer_rpc::IBCTransferTx& field(int index) const;
  ::injective_explorer_rpc::IBCTransferTx* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::IBCTransferTx >&
      field() const;
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetIBCTransferTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::IBCTransferTx > field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class IBCTransferTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.IBCTransferTx) */ {
 public:
  inline IBCTransferTx() : IBCTransferTx(nullptr) {}
  ~IBCTransferTx() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IBCTransferTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IBCTransferTx(const IBCTransferTx& from);
  IBCTransferTx(IBCTransferTx&& from) noexcept
    : IBCTransferTx() {
    *this = ::std::move(from);
  }

  inline IBCTransferTx& operator=(const IBCTransferTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline IBCTransferTx& operator=(IBCTransferTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IBCTransferTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const IBCTransferTx* internal_default_instance() {
    return reinterpret_cast<const IBCTransferTx*>(
               &_IBCTransferTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(IBCTransferTx& a, IBCTransferTx& b) {
    a.Swap(&b);
  }
  inline void Swap(IBCTransferTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IBCTransferTx* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IBCTransferTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IBCTransferTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IBCTransferTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IBCTransferTx& from) {
    IBCTransferTx::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IBCTransferTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.IBCTransferTx";
  }
  protected:
  explicit IBCTransferTx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashesFieldNumber = 14,
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
    kSourcePortFieldNumber = 3,
    kSourceChannelFieldNumber = 4,
    kDestinationPortFieldNumber = 5,
    kDestinationChannelFieldNumber = 6,
    kAmountFieldNumber = 7,
    kDenomFieldNumber = 8,
    kTimeoutHeightFieldNumber = 9,
    kDataHexFieldNumber = 12,
    kStateFieldNumber = 13,
    kCreatedAtFieldNumber = 15,
    kUpdatedAtFieldNumber = 16,
    kTimeoutTimestampFieldNumber = 10,
    kPacketSequenceFieldNumber = 11,
  };
  // repeated string tx_hashes = 14 [json_name = "txHashes"];
  int tx_hashes_size() const;
  private:
  int _internal_tx_hashes_size() const;

  public:
  void clear_tx_hashes() ;
  const std::string& tx_hashes(int index) const;
  std::string* mutable_tx_hashes(int index);
  void set_tx_hashes(int index, const std::string& value);
  void set_tx_hashes(int index, std::string&& value);
  void set_tx_hashes(int index, const char* value);
  void set_tx_hashes(int index, const char* value, std::size_t size);
  void set_tx_hashes(int index, absl::string_view value);
  std::string* add_tx_hashes();
  void add_tx_hashes(const std::string& value);
  void add_tx_hashes(std::string&& value);
  void add_tx_hashes(const char* value);
  void add_tx_hashes(const char* value, std::size_t size);
  void add_tx_hashes(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tx_hashes();

  private:
  const std::string& _internal_tx_hashes(int index) const;
  std::string* _internal_add_tx_hashes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_tx_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_tx_hashes();

  public:
  // string sender = 1 [json_name = "sender"];
  void clear_sender() ;
  const std::string& sender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* ptr);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // string receiver = 2 [json_name = "receiver"];
  void clear_receiver() ;
  const std::string& receiver() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receiver(Arg_&& arg, Args_... args);
  std::string* mutable_receiver();
  PROTOBUF_NODISCARD std::string* release_receiver();
  void set_allocated_receiver(std::string* ptr);

  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(
      const std::string& value);
  std::string* _internal_mutable_receiver();

  public:
  // string source_port = 3 [json_name = "sourcePort"];
  void clear_source_port() ;
  const std::string& source_port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_port(Arg_&& arg, Args_... args);
  std::string* mutable_source_port();
  PROTOBUF_NODISCARD std::string* release_source_port();
  void set_allocated_source_port(std::string* ptr);

  private:
  const std::string& _internal_source_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_port(
      const std::string& value);
  std::string* _internal_mutable_source_port();

  public:
  // string source_channel = 4 [json_name = "sourceChannel"];
  void clear_source_channel() ;
  const std::string& source_channel() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_channel(Arg_&& arg, Args_... args);
  std::string* mutable_source_channel();
  PROTOBUF_NODISCARD std::string* release_source_channel();
  void set_allocated_source_channel(std::string* ptr);

  private:
  const std::string& _internal_source_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_channel(
      const std::string& value);
  std::string* _internal_mutable_source_channel();

  public:
  // string destination_port = 5 [json_name = "destinationPort"];
  void clear_destination_port() ;
  const std::string& destination_port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_port(Arg_&& arg, Args_... args);
  std::string* mutable_destination_port();
  PROTOBUF_NODISCARD std::string* release_destination_port();
  void set_allocated_destination_port(std::string* ptr);

  private:
  const std::string& _internal_destination_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_port(
      const std::string& value);
  std::string* _internal_mutable_destination_port();

  public:
  // string destination_channel = 6 [json_name = "destinationChannel"];
  void clear_destination_channel() ;
  const std::string& destination_channel() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_destination_channel(Arg_&& arg, Args_... args);
  std::string* mutable_destination_channel();
  PROTOBUF_NODISCARD std::string* release_destination_channel();
  void set_allocated_destination_channel(std::string* ptr);

  private:
  const std::string& _internal_destination_channel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination_channel(
      const std::string& value);
  std::string* _internal_mutable_destination_channel();

  public:
  // string amount = 7 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // string denom = 8 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string timeout_height = 9 [json_name = "timeoutHeight"];
  void clear_timeout_height() ;
  const std::string& timeout_height() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timeout_height(Arg_&& arg, Args_... args);
  std::string* mutable_timeout_height();
  PROTOBUF_NODISCARD std::string* release_timeout_height();
  void set_allocated_timeout_height(std::string* ptr);

  private:
  const std::string& _internal_timeout_height() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timeout_height(
      const std::string& value);
  std::string* _internal_mutable_timeout_height();

  public:
  // bytes data_hex = 12 [json_name = "dataHex"];
  void clear_data_hex() ;
  const std::string& data_hex() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_hex(Arg_&& arg, Args_... args);
  std::string* mutable_data_hex();
  PROTOBUF_NODISCARD std::string* release_data_hex();
  void set_allocated_data_hex(std::string* ptr);

  private:
  const std::string& _internal_data_hex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_hex(
      const std::string& value);
  std::string* _internal_mutable_data_hex();

  public:
  // string state = 13 [json_name = "state"];
  void clear_state() ;
  const std::string& state() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // string created_at = 15 [json_name = "createdAt"];
  void clear_created_at() ;
  const std::string& created_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_created_at(Arg_&& arg, Args_... args);
  std::string* mutable_created_at();
  PROTOBUF_NODISCARD std::string* release_created_at();
  void set_allocated_created_at(std::string* ptr);

  private:
  const std::string& _internal_created_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_at(
      const std::string& value);
  std::string* _internal_mutable_created_at();

  public:
  // string updated_at = 16 [json_name = "updatedAt"];
  void clear_updated_at() ;
  const std::string& updated_at() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_updated_at(Arg_&& arg, Args_... args);
  std::string* mutable_updated_at();
  PROTOBUF_NODISCARD std::string* release_updated_at();
  void set_allocated_updated_at(std::string* ptr);

  private:
  const std::string& _internal_updated_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_at(
      const std::string& value);
  std::string* _internal_mutable_updated_at();

  public:
  // uint64 timeout_timestamp = 10 [json_name = "timeoutTimestamp"];
  void clear_timeout_timestamp() ;
  ::uint64_t timeout_timestamp() const;
  void set_timeout_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timeout_timestamp() const;
  void _internal_set_timeout_timestamp(::uint64_t value);

  public:
  // uint64 packet_sequence = 11 [json_name = "packetSequence"];
  void clear_packet_sequence() ;
  ::uint64_t packet_sequence() const;
  void set_packet_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_packet_sequence() const;
  void _internal_set_packet_sequence(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.IBCTransferTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tx_hashes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_channel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeout_height_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_hex_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_at_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_at_;
    ::uint64_t timeout_timestamp_;
    ::uint64_t packet_sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmCodesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmCodesRequest) */ {
 public:
  inline GetWasmCodesRequest() : GetWasmCodesRequest(nullptr) {}
  ~GetWasmCodesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmCodesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmCodesRequest(const GetWasmCodesRequest& from);
  GetWasmCodesRequest(GetWasmCodesRequest&& from) noexcept
    : GetWasmCodesRequest() {
    *this = ::std::move(from);
  }

  inline GetWasmCodesRequest& operator=(const GetWasmCodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmCodesRequest& operator=(GetWasmCodesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmCodesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmCodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetWasmCodesRequest*>(
               &_GetWasmCodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetWasmCodesRequest& a, GetWasmCodesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmCodesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmCodesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmCodesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmCodesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmCodesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmCodesRequest& from) {
    GetWasmCodesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmCodesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmCodesRequest";
  }
  protected:
  explicit GetWasmCodesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromNumberFieldNumber = 2,
    kToNumberFieldNumber = 3,
    kLimitFieldNumber = 1,
  };
  // sint64 from_number = 2 [json_name = "fromNumber"];
  void clear_from_number() ;
  ::int64_t from_number() const;
  void set_from_number(::int64_t value);

  private:
  ::int64_t _internal_from_number() const;
  void _internal_set_from_number(::int64_t value);

  public:
  // sint64 to_number = 3 [json_name = "toNumber"];
  void clear_to_number() ;
  ::int64_t to_number() const;
  void set_to_number(::int64_t value);

  private:
  ::int64_t _internal_to_number() const;
  void _internal_set_to_number(::int64_t value);

  public:
  // sint32 limit = 1 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmCodesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t from_number_;
    ::int64_t to_number_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmCodesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmCodesResponse) */ {
 public:
  inline GetWasmCodesResponse() : GetWasmCodesResponse(nullptr) {}
  ~GetWasmCodesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmCodesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmCodesResponse(const GetWasmCodesResponse& from);
  GetWasmCodesResponse(GetWasmCodesResponse&& from) noexcept
    : GetWasmCodesResponse() {
    *this = ::std::move(from);
  }

  inline GetWasmCodesResponse& operator=(const GetWasmCodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmCodesResponse& operator=(GetWasmCodesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmCodesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmCodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetWasmCodesResponse*>(
               &_GetWasmCodesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(GetWasmCodesResponse& a, GetWasmCodesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmCodesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmCodesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmCodesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmCodesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmCodesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmCodesResponse& from) {
    GetWasmCodesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmCodesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmCodesResponse";
  }
  protected:
  explicit GetWasmCodesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.WasmCode data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::WasmCode* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCode >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::WasmCode& _internal_data(int index) const;
  ::injective_explorer_rpc::WasmCode* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCode>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCode>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::WasmCode& data(int index) const;
  ::injective_explorer_rpc::WasmCode* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCode >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmCodesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCode > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class WasmCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.WasmCode) */ {
 public:
  inline WasmCode() : WasmCode(nullptr) {}
  ~WasmCode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WasmCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WasmCode(const WasmCode& from);
  WasmCode(WasmCode&& from) noexcept
    : WasmCode() {
    *this = ::std::move(from);
  }

  inline WasmCode& operator=(const WasmCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline WasmCode& operator=(WasmCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WasmCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const WasmCode* internal_default_instance() {
    return reinterpret_cast<const WasmCode*>(
               &_WasmCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(WasmCode& a, WasmCode& b) {
    a.Swap(&b);
  }
  inline void Swap(WasmCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WasmCode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WasmCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WasmCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WasmCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WasmCode& from) {
    WasmCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WasmCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.WasmCode";
  }
  protected:
  explicit WasmCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 2,
    kContractTypeFieldNumber = 5,
    kVersionFieldNumber = 6,
    kCodeSchemaFieldNumber = 8,
    kCodeViewFieldNumber = 9,
    kCreatorFieldNumber = 11,
    kChecksumFieldNumber = 3,
    kPermissionFieldNumber = 7,
    kCodeIdFieldNumber = 1,
    kCreatedAtFieldNumber = 4,
    kInstantiatesFieldNumber = 10,
    kCodeNumberFieldNumber = 12,
    kProposalIdFieldNumber = 13,
  };
  // string tx_hash = 2 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string contract_type = 5 [json_name = "contractType"];
  void clear_contract_type() ;
  const std::string& contract_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_type(Arg_&& arg, Args_... args);
  std::string* mutable_contract_type();
  PROTOBUF_NODISCARD std::string* release_contract_type();
  void set_allocated_contract_type(std::string* ptr);

  private:
  const std::string& _internal_contract_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_type(
      const std::string& value);
  std::string* _internal_mutable_contract_type();

  public:
  // string version = 6 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string code_schema = 8 [json_name = "codeSchema"];
  void clear_code_schema() ;
  const std::string& code_schema() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_schema(Arg_&& arg, Args_... args);
  std::string* mutable_code_schema();
  PROTOBUF_NODISCARD std::string* release_code_schema();
  void set_allocated_code_schema(std::string* ptr);

  private:
  const std::string& _internal_code_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_schema(
      const std::string& value);
  std::string* _internal_mutable_code_schema();

  public:
  // string code_view = 9 [json_name = "codeView"];
  void clear_code_view() ;
  const std::string& code_view() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_view(Arg_&& arg, Args_... args);
  std::string* mutable_code_view();
  PROTOBUF_NODISCARD std::string* release_code_view();
  void set_allocated_code_view(std::string* ptr);

  private:
  const std::string& _internal_code_view() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_view(
      const std::string& value);
  std::string* _internal_mutable_code_view();

  public:
  // string creator = 11 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // .injective_explorer_rpc.Checksum checksum = 3 [json_name = "checksum"];
  bool has_checksum() const;
  void clear_checksum() ;
  const ::injective_explorer_rpc::Checksum& checksum() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Checksum* release_checksum();
  ::injective_explorer_rpc::Checksum* mutable_checksum();
  void set_allocated_checksum(::injective_explorer_rpc::Checksum* checksum);
  private:
  const ::injective_explorer_rpc::Checksum& _internal_checksum() const;
  ::injective_explorer_rpc::Checksum* _internal_mutable_checksum();
  public:
  void unsafe_arena_set_allocated_checksum(
      ::injective_explorer_rpc::Checksum* checksum);
  ::injective_explorer_rpc::Checksum* unsafe_arena_release_checksum();
  // .injective_explorer_rpc.ContractPermission permission = 7 [json_name = "permission"];
  bool has_permission() const;
  void clear_permission() ;
  const ::injective_explorer_rpc::ContractPermission& permission() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::ContractPermission* release_permission();
  ::injective_explorer_rpc::ContractPermission* mutable_permission();
  void set_allocated_permission(::injective_explorer_rpc::ContractPermission* permission);
  private:
  const ::injective_explorer_rpc::ContractPermission& _internal_permission() const;
  ::injective_explorer_rpc::ContractPermission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::injective_explorer_rpc::ContractPermission* permission);
  ::injective_explorer_rpc::ContractPermission* unsafe_arena_release_permission();
  // uint64 code_id = 1 [json_name = "codeId"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // uint64 created_at = 4 [json_name = "createdAt"];
  void clear_created_at() ;
  ::uint64_t created_at() const;
  void set_created_at(::uint64_t value);

  private:
  ::uint64_t _internal_created_at() const;
  void _internal_set_created_at(::uint64_t value);

  public:
  // uint64 instantiates = 10 [json_name = "instantiates"];
  void clear_instantiates() ;
  ::uint64_t instantiates() const;
  void set_instantiates(::uint64_t value);

  private:
  ::uint64_t _internal_instantiates() const;
  void _internal_set_instantiates(::uint64_t value);

  public:
  // sint64 code_number = 12 [json_name = "codeNumber"];
  void clear_code_number() ;
  ::int64_t code_number() const;
  void set_code_number(::int64_t value);

  private:
  ::int64_t _internal_code_number() const;
  void _internal_set_code_number(::int64_t value);

  public:
  // sint64 proposal_id = 13 [json_name = "proposalId"];
  void clear_proposal_id() ;
  ::int64_t proposal_id() const;
  void set_proposal_id(::int64_t value);

  private:
  ::int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.WasmCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_view_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::injective_explorer_rpc::Checksum* checksum_;
    ::injective_explorer_rpc::ContractPermission* permission_;
    ::uint64_t code_id_;
    ::uint64_t created_at_;
    ::uint64_t instantiates_;
    ::int64_t code_number_;
    ::int64_t proposal_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Checksum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Checksum) */ {
 public:
  inline Checksum() : Checksum(nullptr) {}
  ~Checksum() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Checksum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Checksum(const Checksum& from);
  Checksum(Checksum&& from) noexcept
    : Checksum() {
    *this = ::std::move(from);
  }

  inline Checksum& operator=(const Checksum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Checksum& operator=(Checksum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Checksum& default_instance() {
    return *internal_default_instance();
  }
  static inline const Checksum* internal_default_instance() {
    return reinterpret_cast<const Checksum*>(
               &_Checksum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Checksum& a, Checksum& b) {
    a.Swap(&b);
  }
  inline void Swap(Checksum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Checksum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Checksum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Checksum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Checksum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Checksum& from) {
    Checksum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Checksum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Checksum";
  }
  protected:
  explicit Checksum(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string algorithm = 1 [json_name = "algorithm"];
  void clear_algorithm() ;
  const std::string& algorithm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_algorithm(Arg_&& arg, Args_... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* ptr);

  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(
      const std::string& value);
  std::string* _internal_mutable_algorithm();

  public:
  // string hash = 2 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Checksum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class ContractPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.ContractPermission) */ {
 public:
  inline ContractPermission() : ContractPermission(nullptr) {}
  ~ContractPermission() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractPermission(const ContractPermission& from);
  ContractPermission(ContractPermission&& from) noexcept
    : ContractPermission() {
    *this = ::std::move(from);
  }

  inline ContractPermission& operator=(const ContractPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractPermission& operator=(ContractPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractPermission* internal_default_instance() {
    return reinterpret_cast<const ContractPermission*>(
               &_ContractPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ContractPermission& a, ContractPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractPermission* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractPermission& from) {
    ContractPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.ContractPermission";
  }
  protected:
  explicit ContractPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kAccessTypeFieldNumber = 1,
  };
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // sint32 access_type = 1 [json_name = "accessType"];
  void clear_access_type() ;
  ::int32_t access_type() const;
  void set_access_type(::int32_t value);

  private:
  ::int32_t _internal_access_type() const;
  void _internal_set_access_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.ContractPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::int32_t access_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmCodeByIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmCodeByIDRequest) */ {
 public:
  inline GetWasmCodeByIDRequest() : GetWasmCodeByIDRequest(nullptr) {}
  ~GetWasmCodeByIDRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmCodeByIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmCodeByIDRequest(const GetWasmCodeByIDRequest& from);
  GetWasmCodeByIDRequest(GetWasmCodeByIDRequest&& from) noexcept
    : GetWasmCodeByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetWasmCodeByIDRequest& operator=(const GetWasmCodeByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmCodeByIDRequest& operator=(GetWasmCodeByIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmCodeByIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmCodeByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetWasmCodeByIDRequest*>(
               &_GetWasmCodeByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(GetWasmCodeByIDRequest& a, GetWasmCodeByIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmCodeByIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmCodeByIDRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmCodeByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmCodeByIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmCodeByIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmCodeByIDRequest& from) {
    GetWasmCodeByIDRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmCodeByIDRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmCodeByIDRequest";
  }
  protected:
  explicit GetWasmCodeByIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdFieldNumber = 1,
  };
  // sint64 code_id = 1 [json_name = "codeId"];
  void clear_code_id() ;
  ::int64_t code_id() const;
  void set_code_id(::int64_t value);

  private:
  ::int64_t _internal_code_id() const;
  void _internal_set_code_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmCodeByIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t code_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmCodeByIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmCodeByIDResponse) */ {
 public:
  inline GetWasmCodeByIDResponse() : GetWasmCodeByIDResponse(nullptr) {}
  ~GetWasmCodeByIDResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmCodeByIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmCodeByIDResponse(const GetWasmCodeByIDResponse& from);
  GetWasmCodeByIDResponse(GetWasmCodeByIDResponse&& from) noexcept
    : GetWasmCodeByIDResponse() {
    *this = ::std::move(from);
  }

  inline GetWasmCodeByIDResponse& operator=(const GetWasmCodeByIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmCodeByIDResponse& operator=(GetWasmCodeByIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmCodeByIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmCodeByIDResponse* internal_default_instance() {
    return reinterpret_cast<const GetWasmCodeByIDResponse*>(
               &_GetWasmCodeByIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetWasmCodeByIDResponse& a, GetWasmCodeByIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmCodeByIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmCodeByIDResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmCodeByIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmCodeByIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmCodeByIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmCodeByIDResponse& from) {
    GetWasmCodeByIDResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmCodeByIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmCodeByIDResponse";
  }
  protected:
  explicit GetWasmCodeByIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxHashFieldNumber = 2,
    kContractTypeFieldNumber = 5,
    kVersionFieldNumber = 6,
    kCodeSchemaFieldNumber = 8,
    kCodeViewFieldNumber = 9,
    kCreatorFieldNumber = 11,
    kChecksumFieldNumber = 3,
    kPermissionFieldNumber = 7,
    kCodeIdFieldNumber = 1,
    kCreatedAtFieldNumber = 4,
    kInstantiatesFieldNumber = 10,
    kCodeNumberFieldNumber = 12,
    kProposalIdFieldNumber = 13,
  };
  // string tx_hash = 2 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string contract_type = 5 [json_name = "contractType"];
  void clear_contract_type() ;
  const std::string& contract_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_type(Arg_&& arg, Args_... args);
  std::string* mutable_contract_type();
  PROTOBUF_NODISCARD std::string* release_contract_type();
  void set_allocated_contract_type(std::string* ptr);

  private:
  const std::string& _internal_contract_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_type(
      const std::string& value);
  std::string* _internal_mutable_contract_type();

  public:
  // string version = 6 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string code_schema = 8 [json_name = "codeSchema"];
  void clear_code_schema() ;
  const std::string& code_schema() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_schema(Arg_&& arg, Args_... args);
  std::string* mutable_code_schema();
  PROTOBUF_NODISCARD std::string* release_code_schema();
  void set_allocated_code_schema(std::string* ptr);

  private:
  const std::string& _internal_code_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_schema(
      const std::string& value);
  std::string* _internal_mutable_code_schema();

  public:
  // string code_view = 9 [json_name = "codeView"];
  void clear_code_view() ;
  const std::string& code_view() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code_view(Arg_&& arg, Args_... args);
  std::string* mutable_code_view();
  PROTOBUF_NODISCARD std::string* release_code_view();
  void set_allocated_code_view(std::string* ptr);

  private:
  const std::string& _internal_code_view() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code_view(
      const std::string& value);
  std::string* _internal_mutable_code_view();

  public:
  // string creator = 11 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // .injective_explorer_rpc.Checksum checksum = 3 [json_name = "checksum"];
  bool has_checksum() const;
  void clear_checksum() ;
  const ::injective_explorer_rpc::Checksum& checksum() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Checksum* release_checksum();
  ::injective_explorer_rpc::Checksum* mutable_checksum();
  void set_allocated_checksum(::injective_explorer_rpc::Checksum* checksum);
  private:
  const ::injective_explorer_rpc::Checksum& _internal_checksum() const;
  ::injective_explorer_rpc::Checksum* _internal_mutable_checksum();
  public:
  void unsafe_arena_set_allocated_checksum(
      ::injective_explorer_rpc::Checksum* checksum);
  ::injective_explorer_rpc::Checksum* unsafe_arena_release_checksum();
  // .injective_explorer_rpc.ContractPermission permission = 7 [json_name = "permission"];
  bool has_permission() const;
  void clear_permission() ;
  const ::injective_explorer_rpc::ContractPermission& permission() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::ContractPermission* release_permission();
  ::injective_explorer_rpc::ContractPermission* mutable_permission();
  void set_allocated_permission(::injective_explorer_rpc::ContractPermission* permission);
  private:
  const ::injective_explorer_rpc::ContractPermission& _internal_permission() const;
  ::injective_explorer_rpc::ContractPermission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::injective_explorer_rpc::ContractPermission* permission);
  ::injective_explorer_rpc::ContractPermission* unsafe_arena_release_permission();
  // uint64 code_id = 1 [json_name = "codeId"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // uint64 created_at = 4 [json_name = "createdAt"];
  void clear_created_at() ;
  ::uint64_t created_at() const;
  void set_created_at(::uint64_t value);

  private:
  ::uint64_t _internal_created_at() const;
  void _internal_set_created_at(::uint64_t value);

  public:
  // uint64 instantiates = 10 [json_name = "instantiates"];
  void clear_instantiates() ;
  ::uint64_t instantiates() const;
  void set_instantiates(::uint64_t value);

  private:
  ::uint64_t _internal_instantiates() const;
  void _internal_set_instantiates(::uint64_t value);

  public:
  // sint64 code_number = 12 [json_name = "codeNumber"];
  void clear_code_number() ;
  ::int64_t code_number() const;
  void set_code_number(::int64_t value);

  private:
  ::int64_t _internal_code_number() const;
  void _internal_set_code_number(::int64_t value);

  public:
  // sint64 proposal_id = 13 [json_name = "proposalId"];
  void clear_proposal_id() ;
  ::int64_t proposal_id() const;
  void set_proposal_id(::int64_t value);

  private:
  ::int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmCodeByIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_view_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::injective_explorer_rpc::Checksum* checksum_;
    ::injective_explorer_rpc::ContractPermission* permission_;
    ::uint64_t code_id_;
    ::uint64_t created_at_;
    ::uint64_t instantiates_;
    ::int64_t code_number_;
    ::int64_t proposal_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmContractsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmContractsRequest) */ {
 public:
  inline GetWasmContractsRequest() : GetWasmContractsRequest(nullptr) {}
  ~GetWasmContractsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmContractsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmContractsRequest(const GetWasmContractsRequest& from);
  GetWasmContractsRequest(GetWasmContractsRequest&& from) noexcept
    : GetWasmContractsRequest() {
    *this = ::std::move(from);
  }

  inline GetWasmContractsRequest& operator=(const GetWasmContractsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmContractsRequest& operator=(GetWasmContractsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmContractsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmContractsRequest* internal_default_instance() {
    return reinterpret_cast<const GetWasmContractsRequest*>(
               &_GetWasmContractsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetWasmContractsRequest& a, GetWasmContractsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmContractsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmContractsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmContractsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmContractsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmContractsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmContractsRequest& from) {
    GetWasmContractsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmContractsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmContractsRequest";
  }
  protected:
  explicit GetWasmContractsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeIdFieldNumber = 2,
    kFromNumberFieldNumber = 3,
    kLimitFieldNumber = 1,
    kAssetsOnlyFieldNumber = 5,
    kToNumberFieldNumber = 4,
    kSkipFieldNumber = 6,
  };
  // sint64 code_id = 2 [json_name = "codeId"];
  void clear_code_id() ;
  ::int64_t code_id() const;
  void set_code_id(::int64_t value);

  private:
  ::int64_t _internal_code_id() const;
  void _internal_set_code_id(::int64_t value);

  public:
  // sint64 from_number = 3 [json_name = "fromNumber"];
  void clear_from_number() ;
  ::int64_t from_number() const;
  void set_from_number(::int64_t value);

  private:
  ::int64_t _internal_from_number() const;
  void _internal_set_from_number(::int64_t value);

  public:
  // sint32 limit = 1 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // bool assets_only = 5 [json_name = "assetsOnly"];
  void clear_assets_only() ;
  bool assets_only() const;
  void set_assets_only(bool value);

  private:
  bool _internal_assets_only() const;
  void _internal_set_assets_only(bool value);

  public:
  // sint64 to_number = 4 [json_name = "toNumber"];
  void clear_to_number() ;
  ::int64_t to_number() const;
  void set_to_number(::int64_t value);

  private:
  ::int64_t _internal_to_number() const;
  void _internal_set_to_number(::int64_t value);

  public:
  // sint64 skip = 6 [json_name = "skip"];
  void clear_skip() ;
  ::int64_t skip() const;
  void set_skip(::int64_t value);

  private:
  ::int64_t _internal_skip() const;
  void _internal_set_skip(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmContractsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int64_t code_id_;
    ::int64_t from_number_;
    ::int32_t limit_;
    bool assets_only_;
    ::int64_t to_number_;
    ::int64_t skip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmContractsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmContractsResponse) */ {
 public:
  inline GetWasmContractsResponse() : GetWasmContractsResponse(nullptr) {}
  ~GetWasmContractsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmContractsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmContractsResponse(const GetWasmContractsResponse& from);
  GetWasmContractsResponse(GetWasmContractsResponse&& from) noexcept
    : GetWasmContractsResponse() {
    *this = ::std::move(from);
  }

  inline GetWasmContractsResponse& operator=(const GetWasmContractsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmContractsResponse& operator=(GetWasmContractsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmContractsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmContractsResponse* internal_default_instance() {
    return reinterpret_cast<const GetWasmContractsResponse*>(
               &_GetWasmContractsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(GetWasmContractsResponse& a, GetWasmContractsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmContractsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmContractsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmContractsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmContractsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmContractsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmContractsResponse& from) {
    GetWasmContractsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmContractsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmContractsResponse";
  }
  protected:
  explicit GetWasmContractsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPagingFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.WasmContract data = 2 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::injective_explorer_rpc::WasmContract* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmContract >*
      mutable_data();
  private:
  const ::injective_explorer_rpc::WasmContract& _internal_data(int index) const;
  ::injective_explorer_rpc::WasmContract* _internal_add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmContract>& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmContract>* _internal_mutable_data();
  public:
  const ::injective_explorer_rpc::WasmContract& data(int index) const;
  ::injective_explorer_rpc::WasmContract* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmContract >&
      data() const;
  // .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
  bool has_paging() const;
  void clear_paging() ;
  const ::injective_explorer_rpc::Paging& paging() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Paging* release_paging();
  ::injective_explorer_rpc::Paging* mutable_paging();
  void set_allocated_paging(::injective_explorer_rpc::Paging* paging);
  private:
  const ::injective_explorer_rpc::Paging& _internal_paging() const;
  ::injective_explorer_rpc::Paging* _internal_mutable_paging();
  public:
  void unsafe_arena_set_allocated_paging(
      ::injective_explorer_rpc::Paging* paging);
  ::injective_explorer_rpc::Paging* unsafe_arena_release_paging();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmContractsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmContract > data_;
    ::injective_explorer_rpc::Paging* paging_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class WasmContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.WasmContract) */ {
 public:
  inline WasmContract() : WasmContract(nullptr) {}
  ~WasmContract() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WasmContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WasmContract(const WasmContract& from);
  WasmContract(WasmContract&& from) noexcept
    : WasmContract() {
    *this = ::std::move(from);
  }

  inline WasmContract& operator=(const WasmContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline WasmContract& operator=(WasmContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WasmContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const WasmContract* internal_default_instance() {
    return reinterpret_cast<const WasmContract*>(
               &_WasmContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(WasmContract& a, WasmContract& b) {
    a.Swap(&b);
  }
  inline void Swap(WasmContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WasmContract* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WasmContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WasmContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WasmContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WasmContract& from) {
    WasmContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WasmContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.WasmContract";
  }
  protected:
  explicit WasmContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 9,
    kLabelFieldNumber = 1,
    kAddressFieldNumber = 2,
    kTxHashFieldNumber = 3,
    kCreatorFieldNumber = 4,
    kInitMessageFieldNumber = 7,
    kAdminFieldNumber = 11,
    kCurrentMigrateMessageFieldNumber = 12,
    kVersionFieldNumber = 14,
    kTypeFieldNumber = 15,
    kCw20MetadataFieldNumber = 16,
    kExecutesFieldNumber = 5,
    kInstantiatedAtFieldNumber = 6,
    kLastExecutedAtFieldNumber = 8,
    kCodeIdFieldNumber = 10,
    kContractNumberFieldNumber = 13,
    kProposalIdFieldNumber = 17,
  };
  // repeated .injective_explorer_rpc.ContractFund funds = 9 [json_name = "funds"];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::injective_explorer_rpc::ContractFund* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >*
      mutable_funds();
  private:
  const ::injective_explorer_rpc::ContractFund& _internal_funds(int index) const;
  ::injective_explorer_rpc::ContractFund* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>* _internal_mutable_funds();
  public:
  const ::injective_explorer_rpc::ContractFund& funds(int index) const;
  ::injective_explorer_rpc::ContractFund* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >&
      funds() const;
  // string label = 1 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string tx_hash = 3 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string creator = 4 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // string init_message = 7 [json_name = "initMessage"];
  void clear_init_message() ;
  const std::string& init_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_init_message(Arg_&& arg, Args_... args);
  std::string* mutable_init_message();
  PROTOBUF_NODISCARD std::string* release_init_message();
  void set_allocated_init_message(std::string* ptr);

  private:
  const std::string& _internal_init_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_message(
      const std::string& value);
  std::string* _internal_mutable_init_message();

  public:
  // string admin = 11 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string current_migrate_message = 12 [json_name = "currentMigrateMessage"];
  void clear_current_migrate_message() ;
  const std::string& current_migrate_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_migrate_message(Arg_&& arg, Args_... args);
  std::string* mutable_current_migrate_message();
  PROTOBUF_NODISCARD std::string* release_current_migrate_message();
  void set_allocated_current_migrate_message(std::string* ptr);

  private:
  const std::string& _internal_current_migrate_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_migrate_message(
      const std::string& value);
  std::string* _internal_mutable_current_migrate_message();

  public:
  // string version = 14 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string type = 15 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16 [json_name = "cw20Metadata"];
  bool has_cw20_metadata() const;
  void clear_cw20_metadata() ;
  const ::injective_explorer_rpc::Cw20Metadata& cw20_metadata() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Cw20Metadata* release_cw20_metadata();
  ::injective_explorer_rpc::Cw20Metadata* mutable_cw20_metadata();
  void set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  private:
  const ::injective_explorer_rpc::Cw20Metadata& _internal_cw20_metadata() const;
  ::injective_explorer_rpc::Cw20Metadata* _internal_mutable_cw20_metadata();
  public:
  void unsafe_arena_set_allocated_cw20_metadata(
      ::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  ::injective_explorer_rpc::Cw20Metadata* unsafe_arena_release_cw20_metadata();
  // uint64 executes = 5 [json_name = "executes"];
  void clear_executes() ;
  ::uint64_t executes() const;
  void set_executes(::uint64_t value);

  private:
  ::uint64_t _internal_executes() const;
  void _internal_set_executes(::uint64_t value);

  public:
  // uint64 instantiated_at = 6 [json_name = "instantiatedAt"];
  void clear_instantiated_at() ;
  ::uint64_t instantiated_at() const;
  void set_instantiated_at(::uint64_t value);

  private:
  ::uint64_t _internal_instantiated_at() const;
  void _internal_set_instantiated_at(::uint64_t value);

  public:
  // uint64 last_executed_at = 8 [json_name = "lastExecutedAt"];
  void clear_last_executed_at() ;
  ::uint64_t last_executed_at() const;
  void set_last_executed_at(::uint64_t value);

  private:
  ::uint64_t _internal_last_executed_at() const;
  void _internal_set_last_executed_at(::uint64_t value);

  public:
  // uint64 code_id = 10 [json_name = "codeId"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // sint64 contract_number = 13 [json_name = "contractNumber"];
  void clear_contract_number() ;
  ::int64_t contract_number() const;
  void set_contract_number(::int64_t value);

  private:
  ::int64_t _internal_contract_number() const;
  void _internal_set_contract_number(::int64_t value);

  public:
  // sint64 proposal_id = 17 [json_name = "proposalId"];
  void clear_proposal_id() ;
  ::int64_t proposal_id() const;
  void set_proposal_id(::int64_t value);

  private:
  ::int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.WasmContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_migrate_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata_;
    ::uint64_t executes_;
    ::uint64_t instantiated_at_;
    ::uint64_t last_executed_at_;
    ::uint64_t code_id_;
    ::int64_t contract_number_;
    ::int64_t proposal_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class ContractFund final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.ContractFund) */ {
 public:
  inline ContractFund() : ContractFund(nullptr) {}
  ~ContractFund() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContractFund(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContractFund(const ContractFund& from);
  ContractFund(ContractFund&& from) noexcept
    : ContractFund() {
    *this = ::std::move(from);
  }

  inline ContractFund& operator=(const ContractFund& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContractFund& operator=(ContractFund&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContractFund& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContractFund* internal_default_instance() {
    return reinterpret_cast<const ContractFund*>(
               &_ContractFund_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ContractFund& a, ContractFund& b) {
    a.Swap(&b);
  }
  inline void Swap(ContractFund* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContractFund* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContractFund* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContractFund>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContractFund& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContractFund& from) {
    ContractFund::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractFund* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.ContractFund";
  }
  protected:
  explicit ContractFund(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenomFieldNumber = 1,
    kAmountFieldNumber = 2,
  };
  // string denom = 1 [json_name = "denom"];
  void clear_denom() ;
  const std::string& denom() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denom(Arg_&& arg, Args_... args);
  std::string* mutable_denom();
  PROTOBUF_NODISCARD std::string* release_denom();
  void set_allocated_denom(std::string* ptr);

  private:
  const std::string& _internal_denom() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denom(
      const std::string& value);
  std::string* _internal_mutable_denom();

  public:
  // string amount = 2 [json_name = "amount"];
  void clear_amount() ;
  const std::string& amount() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_amount(Arg_&& arg, Args_... args);
  std::string* mutable_amount();
  PROTOBUF_NODISCARD std::string* release_amount();
  void set_allocated_amount(std::string* ptr);

  private:
  const std::string& _internal_amount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amount(
      const std::string& value);
  std::string* _internal_mutable_amount();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.ContractFund)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denom_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Cw20Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Cw20Metadata) */ {
 public:
  inline Cw20Metadata() : Cw20Metadata(nullptr) {}
  ~Cw20Metadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cw20Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cw20Metadata(const Cw20Metadata& from);
  Cw20Metadata(Cw20Metadata&& from) noexcept
    : Cw20Metadata() {
    *this = ::std::move(from);
  }

  inline Cw20Metadata& operator=(const Cw20Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cw20Metadata& operator=(Cw20Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cw20Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cw20Metadata* internal_default_instance() {
    return reinterpret_cast<const Cw20Metadata*>(
               &_Cw20Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Cw20Metadata& a, Cw20Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Cw20Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cw20Metadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cw20Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cw20Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cw20Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cw20Metadata& from) {
    Cw20Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cw20Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Cw20Metadata";
  }
  protected:
  explicit Cw20Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenInfoFieldNumber = 1,
    kMarketingInfoFieldNumber = 2,
  };
  // .injective_explorer_rpc.Cw20TokenInfo token_info = 1 [json_name = "tokenInfo"];
  bool has_token_info() const;
  void clear_token_info() ;
  const ::injective_explorer_rpc::Cw20TokenInfo& token_info() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Cw20TokenInfo* release_token_info();
  ::injective_explorer_rpc::Cw20TokenInfo* mutable_token_info();
  void set_allocated_token_info(::injective_explorer_rpc::Cw20TokenInfo* token_info);
  private:
  const ::injective_explorer_rpc::Cw20TokenInfo& _internal_token_info() const;
  ::injective_explorer_rpc::Cw20TokenInfo* _internal_mutable_token_info();
  public:
  void unsafe_arena_set_allocated_token_info(
      ::injective_explorer_rpc::Cw20TokenInfo* token_info);
  ::injective_explorer_rpc::Cw20TokenInfo* unsafe_arena_release_token_info();
  // .injective_explorer_rpc.Cw20MarketingInfo marketing_info = 2 [json_name = "marketingInfo"];
  bool has_marketing_info() const;
  void clear_marketing_info() ;
  const ::injective_explorer_rpc::Cw20MarketingInfo& marketing_info() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Cw20MarketingInfo* release_marketing_info();
  ::injective_explorer_rpc::Cw20MarketingInfo* mutable_marketing_info();
  void set_allocated_marketing_info(::injective_explorer_rpc::Cw20MarketingInfo* marketing_info);
  private:
  const ::injective_explorer_rpc::Cw20MarketingInfo& _internal_marketing_info() const;
  ::injective_explorer_rpc::Cw20MarketingInfo* _internal_mutable_marketing_info();
  public:
  void unsafe_arena_set_allocated_marketing_info(
      ::injective_explorer_rpc::Cw20MarketingInfo* marketing_info);
  ::injective_explorer_rpc::Cw20MarketingInfo* unsafe_arena_release_marketing_info();
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Cw20Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::injective_explorer_rpc::Cw20TokenInfo* token_info_;
    ::injective_explorer_rpc::Cw20MarketingInfo* marketing_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Cw20TokenInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Cw20TokenInfo) */ {
 public:
  inline Cw20TokenInfo() : Cw20TokenInfo(nullptr) {}
  ~Cw20TokenInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cw20TokenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cw20TokenInfo(const Cw20TokenInfo& from);
  Cw20TokenInfo(Cw20TokenInfo&& from) noexcept
    : Cw20TokenInfo() {
    *this = ::std::move(from);
  }

  inline Cw20TokenInfo& operator=(const Cw20TokenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cw20TokenInfo& operator=(Cw20TokenInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cw20TokenInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cw20TokenInfo* internal_default_instance() {
    return reinterpret_cast<const Cw20TokenInfo*>(
               &_Cw20TokenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Cw20TokenInfo& a, Cw20TokenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Cw20TokenInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cw20TokenInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cw20TokenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cw20TokenInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cw20TokenInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cw20TokenInfo& from) {
    Cw20TokenInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cw20TokenInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Cw20TokenInfo";
  }
  protected:
  explicit Cw20TokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kTotalSupplyFieldNumber = 4,
    kDecimalsFieldNumber = 3,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string symbol = 2 [json_name = "symbol"];
  void clear_symbol() ;
  const std::string& symbol() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* ptr);

  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(
      const std::string& value);
  std::string* _internal_mutable_symbol();

  public:
  // string total_supply = 4 [json_name = "totalSupply"];
  void clear_total_supply() ;
  const std::string& total_supply() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_supply(Arg_&& arg, Args_... args);
  std::string* mutable_total_supply();
  PROTOBUF_NODISCARD std::string* release_total_supply();
  void set_allocated_total_supply(std::string* ptr);

  private:
  const std::string& _internal_total_supply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_supply(
      const std::string& value);
  std::string* _internal_mutable_total_supply();

  public:
  // sint64 decimals = 3 [json_name = "decimals"];
  void clear_decimals() ;
  ::int64_t decimals() const;
  void set_decimals(::int64_t value);

  private:
  ::int64_t _internal_decimals() const;
  void _internal_set_decimals(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Cw20TokenInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_supply_;
    ::int64_t decimals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Cw20MarketingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Cw20MarketingInfo) */ {
 public:
  inline Cw20MarketingInfo() : Cw20MarketingInfo(nullptr) {}
  ~Cw20MarketingInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Cw20MarketingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cw20MarketingInfo(const Cw20MarketingInfo& from);
  Cw20MarketingInfo(Cw20MarketingInfo&& from) noexcept
    : Cw20MarketingInfo() {
    *this = ::std::move(from);
  }

  inline Cw20MarketingInfo& operator=(const Cw20MarketingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cw20MarketingInfo& operator=(Cw20MarketingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cw20MarketingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cw20MarketingInfo* internal_default_instance() {
    return reinterpret_cast<const Cw20MarketingInfo*>(
               &_Cw20MarketingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(Cw20MarketingInfo& a, Cw20MarketingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Cw20MarketingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cw20MarketingInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cw20MarketingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cw20MarketingInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cw20MarketingInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cw20MarketingInfo& from) {
    Cw20MarketingInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cw20MarketingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Cw20MarketingInfo";
  }
  protected:
  explicit Cw20MarketingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kLogoFieldNumber = 3,
    kMarketingFieldNumber = 4,
  };
  // string project = 1 [json_name = "project"];
  void clear_project() ;
  const std::string& project() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_project(Arg_&& arg, Args_... args);
  std::string* mutable_project();
  PROTOBUF_NODISCARD std::string* release_project();
  void set_allocated_project(std::string* ptr);

  private:
  const std::string& _internal_project() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project(
      const std::string& value);
  std::string* _internal_mutable_project();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string logo = 3 [json_name = "logo"];
  void clear_logo() ;
  const std::string& logo() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logo(Arg_&& arg, Args_... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* ptr);

  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(
      const std::string& value);
  std::string* _internal_mutable_logo();

  public:
  // bytes marketing = 4 [json_name = "marketing"];
  void clear_marketing() ;
  const std::string& marketing() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marketing(Arg_&& arg, Args_... args);
  std::string* mutable_marketing();
  PROTOBUF_NODISCARD std::string* release_marketing();
  void set_allocated_marketing(std::string* ptr);

  private:
  const std::string& _internal_marketing() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marketing(
      const std::string& value);
  std::string* _internal_mutable_marketing();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Cw20MarketingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr marketing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmContractByAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmContractByAddressRequest) */ {
 public:
  inline GetWasmContractByAddressRequest() : GetWasmContractByAddressRequest(nullptr) {}
  ~GetWasmContractByAddressRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmContractByAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmContractByAddressRequest(const GetWasmContractByAddressRequest& from);
  GetWasmContractByAddressRequest(GetWasmContractByAddressRequest&& from) noexcept
    : GetWasmContractByAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetWasmContractByAddressRequest& operator=(const GetWasmContractByAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmContractByAddressRequest& operator=(GetWasmContractByAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmContractByAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmContractByAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetWasmContractByAddressRequest*>(
               &_GetWasmContractByAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(GetWasmContractByAddressRequest& a, GetWasmContractByAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmContractByAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmContractByAddressRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmContractByAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmContractByAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmContractByAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmContractByAddressRequest& from) {
    GetWasmContractByAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmContractByAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmContractByAddressRequest";
  }
  protected:
  explicit GetWasmContractByAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractAddressFieldNumber = 1,
  };
  // string contract_address = 1 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmContractByAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetWasmContractByAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetWasmContractByAddressResponse) */ {
 public:
  inline GetWasmContractByAddressResponse() : GetWasmContractByAddressResponse(nullptr) {}
  ~GetWasmContractByAddressResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetWasmContractByAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWasmContractByAddressResponse(const GetWasmContractByAddressResponse& from);
  GetWasmContractByAddressResponse(GetWasmContractByAddressResponse&& from) noexcept
    : GetWasmContractByAddressResponse() {
    *this = ::std::move(from);
  }

  inline GetWasmContractByAddressResponse& operator=(const GetWasmContractByAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWasmContractByAddressResponse& operator=(GetWasmContractByAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWasmContractByAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWasmContractByAddressResponse* internal_default_instance() {
    return reinterpret_cast<const GetWasmContractByAddressResponse*>(
               &_GetWasmContractByAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(GetWasmContractByAddressResponse& a, GetWasmContractByAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWasmContractByAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWasmContractByAddressResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWasmContractByAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWasmContractByAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWasmContractByAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWasmContractByAddressResponse& from) {
    GetWasmContractByAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWasmContractByAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetWasmContractByAddressResponse";
  }
  protected:
  explicit GetWasmContractByAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFundsFieldNumber = 9,
    kLabelFieldNumber = 1,
    kAddressFieldNumber = 2,
    kTxHashFieldNumber = 3,
    kCreatorFieldNumber = 4,
    kInitMessageFieldNumber = 7,
    kAdminFieldNumber = 11,
    kCurrentMigrateMessageFieldNumber = 12,
    kVersionFieldNumber = 14,
    kTypeFieldNumber = 15,
    kCw20MetadataFieldNumber = 16,
    kExecutesFieldNumber = 5,
    kInstantiatedAtFieldNumber = 6,
    kLastExecutedAtFieldNumber = 8,
    kCodeIdFieldNumber = 10,
    kContractNumberFieldNumber = 13,
    kProposalIdFieldNumber = 17,
  };
  // repeated .injective_explorer_rpc.ContractFund funds = 9 [json_name = "funds"];
  int funds_size() const;
  private:
  int _internal_funds_size() const;

  public:
  void clear_funds() ;
  ::injective_explorer_rpc::ContractFund* mutable_funds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >*
      mutable_funds();
  private:
  const ::injective_explorer_rpc::ContractFund& _internal_funds(int index) const;
  ::injective_explorer_rpc::ContractFund* _internal_add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>& _internal_funds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>* _internal_mutable_funds();
  public:
  const ::injective_explorer_rpc::ContractFund& funds(int index) const;
  ::injective_explorer_rpc::ContractFund* add_funds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >&
      funds() const;
  // string label = 1 [json_name = "label"];
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // string address = 2 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string tx_hash = 3 [json_name = "txHash"];
  void clear_tx_hash() ;
  const std::string& tx_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tx_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* ptr);

  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

  public:
  // string creator = 4 [json_name = "creator"];
  void clear_creator() ;
  const std::string& creator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_creator(Arg_&& arg, Args_... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* ptr);

  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(
      const std::string& value);
  std::string* _internal_mutable_creator();

  public:
  // string init_message = 7 [json_name = "initMessage"];
  void clear_init_message() ;
  const std::string& init_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_init_message(Arg_&& arg, Args_... args);
  std::string* mutable_init_message();
  PROTOBUF_NODISCARD std::string* release_init_message();
  void set_allocated_init_message(std::string* ptr);

  private:
  const std::string& _internal_init_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_message(
      const std::string& value);
  std::string* _internal_mutable_init_message();

  public:
  // string admin = 11 [json_name = "admin"];
  void clear_admin() ;
  const std::string& admin() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin(Arg_&& arg, Args_... args);
  std::string* mutable_admin();
  PROTOBUF_NODISCARD std::string* release_admin();
  void set_allocated_admin(std::string* ptr);

  private:
  const std::string& _internal_admin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin(
      const std::string& value);
  std::string* _internal_mutable_admin();

  public:
  // string current_migrate_message = 12 [json_name = "currentMigrateMessage"];
  void clear_current_migrate_message() ;
  const std::string& current_migrate_message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_migrate_message(Arg_&& arg, Args_... args);
  std::string* mutable_current_migrate_message();
  PROTOBUF_NODISCARD std::string* release_current_migrate_message();
  void set_allocated_current_migrate_message(std::string* ptr);

  private:
  const std::string& _internal_current_migrate_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_migrate_message(
      const std::string& value);
  std::string* _internal_mutable_current_migrate_message();

  public:
  // string version = 14 [json_name = "version"];
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string type = 15 [json_name = "type"];
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16 [json_name = "cw20Metadata"];
  bool has_cw20_metadata() const;
  void clear_cw20_metadata() ;
  const ::injective_explorer_rpc::Cw20Metadata& cw20_metadata() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Cw20Metadata* release_cw20_metadata();
  ::injective_explorer_rpc::Cw20Metadata* mutable_cw20_metadata();
  void set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  private:
  const ::injective_explorer_rpc::Cw20Metadata& _internal_cw20_metadata() const;
  ::injective_explorer_rpc::Cw20Metadata* _internal_mutable_cw20_metadata();
  public:
  void unsafe_arena_set_allocated_cw20_metadata(
      ::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  ::injective_explorer_rpc::Cw20Metadata* unsafe_arena_release_cw20_metadata();
  // uint64 executes = 5 [json_name = "executes"];
  void clear_executes() ;
  ::uint64_t executes() const;
  void set_executes(::uint64_t value);

  private:
  ::uint64_t _internal_executes() const;
  void _internal_set_executes(::uint64_t value);

  public:
  // uint64 instantiated_at = 6 [json_name = "instantiatedAt"];
  void clear_instantiated_at() ;
  ::uint64_t instantiated_at() const;
  void set_instantiated_at(::uint64_t value);

  private:
  ::uint64_t _internal_instantiated_at() const;
  void _internal_set_instantiated_at(::uint64_t value);

  public:
  // uint64 last_executed_at = 8 [json_name = "lastExecutedAt"];
  void clear_last_executed_at() ;
  ::uint64_t last_executed_at() const;
  void set_last_executed_at(::uint64_t value);

  private:
  ::uint64_t _internal_last_executed_at() const;
  void _internal_set_last_executed_at(::uint64_t value);

  public:
  // uint64 code_id = 10 [json_name = "codeId"];
  void clear_code_id() ;
  ::uint64_t code_id() const;
  void set_code_id(::uint64_t value);

  private:
  ::uint64_t _internal_code_id() const;
  void _internal_set_code_id(::uint64_t value);

  public:
  // sint64 contract_number = 13 [json_name = "contractNumber"];
  void clear_contract_number() ;
  ::int64_t contract_number() const;
  void set_contract_number(::int64_t value);

  private:
  ::int64_t _internal_contract_number() const;
  void _internal_set_contract_number(::int64_t value);

  public:
  // sint64 proposal_id = 17 [json_name = "proposalId"];
  void clear_proposal_id() ;
  ::int64_t proposal_id() const;
  void set_proposal_id(::int64_t value);

  private:
  ::int64_t _internal_proposal_id() const;
  void _internal_set_proposal_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetWasmContractByAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund > funds_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_migrate_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata_;
    ::uint64_t executes_;
    ::uint64_t instantiated_at_;
    ::uint64_t last_executed_at_;
    ::uint64_t code_id_;
    ::int64_t contract_number_;
    ::int64_t proposal_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetCw20BalanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetCw20BalanceRequest) */ {
 public:
  inline GetCw20BalanceRequest() : GetCw20BalanceRequest(nullptr) {}
  ~GetCw20BalanceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCw20BalanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCw20BalanceRequest(const GetCw20BalanceRequest& from);
  GetCw20BalanceRequest(GetCw20BalanceRequest&& from) noexcept
    : GetCw20BalanceRequest() {
    *this = ::std::move(from);
  }

  inline GetCw20BalanceRequest& operator=(const GetCw20BalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCw20BalanceRequest& operator=(GetCw20BalanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCw20BalanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCw20BalanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetCw20BalanceRequest*>(
               &_GetCw20BalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(GetCw20BalanceRequest& a, GetCw20BalanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCw20BalanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCw20BalanceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCw20BalanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCw20BalanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCw20BalanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCw20BalanceRequest& from) {
    GetCw20BalanceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCw20BalanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetCw20BalanceRequest";
  }
  protected:
  explicit GetCw20BalanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // string address = 1 [json_name = "address"];
  void clear_address() ;
  const std::string& address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* ptr);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // sint32 limit = 2 [json_name = "limit"];
  void clear_limit() ;
  ::int32_t limit() const;
  void set_limit(::int32_t value);

  private:
  ::int32_t _internal_limit() const;
  void _internal_set_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetCw20BalanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class GetCw20BalanceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.GetCw20BalanceResponse) */ {
 public:
  inline GetCw20BalanceResponse() : GetCw20BalanceResponse(nullptr) {}
  ~GetCw20BalanceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCw20BalanceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCw20BalanceResponse(const GetCw20BalanceResponse& from);
  GetCw20BalanceResponse(GetCw20BalanceResponse&& from) noexcept
    : GetCw20BalanceResponse() {
    *this = ::std::move(from);
  }

  inline GetCw20BalanceResponse& operator=(const GetCw20BalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCw20BalanceResponse& operator=(GetCw20BalanceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCw20BalanceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCw20BalanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetCw20BalanceResponse*>(
               &_GetCw20BalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(GetCw20BalanceResponse& a, GetCw20BalanceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCw20BalanceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCw20BalanceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCw20BalanceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCw20BalanceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCw20BalanceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCw20BalanceResponse& from) {
    GetCw20BalanceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCw20BalanceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.GetCw20BalanceResponse";
  }
  protected:
  explicit GetCw20BalanceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.WasmCw20Balance field = 1 [json_name = "field"];
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::injective_explorer_rpc::WasmCw20Balance* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCw20Balance >*
      mutable_field();
  private:
  const ::injective_explorer_rpc::WasmCw20Balance& _internal_field(int index) const;
  ::injective_explorer_rpc::WasmCw20Balance* _internal_add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCw20Balance>& _internal_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCw20Balance>* _internal_mutable_field();
  public:
  const ::injective_explorer_rpc::WasmCw20Balance& field(int index) const;
  ::injective_explorer_rpc::WasmCw20Balance* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCw20Balance >&
      field() const;
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.GetCw20BalanceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCw20Balance > field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class WasmCw20Balance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.WasmCw20Balance) */ {
 public:
  inline WasmCw20Balance() : WasmCw20Balance(nullptr) {}
  ~WasmCw20Balance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WasmCw20Balance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WasmCw20Balance(const WasmCw20Balance& from);
  WasmCw20Balance(WasmCw20Balance&& from) noexcept
    : WasmCw20Balance() {
    *this = ::std::move(from);
  }

  inline WasmCw20Balance& operator=(const WasmCw20Balance& from) {
    CopyFrom(from);
    return *this;
  }
  inline WasmCw20Balance& operator=(WasmCw20Balance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WasmCw20Balance& default_instance() {
    return *internal_default_instance();
  }
  static inline const WasmCw20Balance* internal_default_instance() {
    return reinterpret_cast<const WasmCw20Balance*>(
               &_WasmCw20Balance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(WasmCw20Balance& a, WasmCw20Balance& b) {
    a.Swap(&b);
  }
  inline void Swap(WasmCw20Balance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WasmCw20Balance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WasmCw20Balance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WasmCw20Balance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WasmCw20Balance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WasmCw20Balance& from) {
    WasmCw20Balance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WasmCw20Balance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.WasmCw20Balance";
  }
  protected:
  explicit WasmCw20Balance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractAddressFieldNumber = 1,
    kAccountFieldNumber = 2,
    kBalanceFieldNumber = 3,
    kCw20MetadataFieldNumber = 5,
    kUpdatedAtFieldNumber = 4,
  };
  // string contract_address = 1 [json_name = "contractAddress"];
  void clear_contract_address() ;
  const std::string& contract_address() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contract_address(Arg_&& arg, Args_... args);
  std::string* mutable_contract_address();
  PROTOBUF_NODISCARD std::string* release_contract_address();
  void set_allocated_contract_address(std::string* ptr);

  private:
  const std::string& _internal_contract_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contract_address(
      const std::string& value);
  std::string* _internal_mutable_contract_address();

  public:
  // string account = 2 [json_name = "account"];
  void clear_account() ;
  const std::string& account() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* ptr);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // string balance = 3 [json_name = "balance"];
  void clear_balance() ;
  const std::string& balance() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_balance(Arg_&& arg, Args_... args);
  std::string* mutable_balance();
  PROTOBUF_NODISCARD std::string* release_balance();
  void set_allocated_balance(std::string* ptr);

  private:
  const std::string& _internal_balance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_balance(
      const std::string& value);
  std::string* _internal_mutable_balance();

  public:
  // .injective_explorer_rpc.Cw20Metadata cw20_metadata = 5 [json_name = "cw20Metadata"];
  bool has_cw20_metadata() const;
  void clear_cw20_metadata() ;
  const ::injective_explorer_rpc::Cw20Metadata& cw20_metadata() const;
  PROTOBUF_NODISCARD ::injective_explorer_rpc::Cw20Metadata* release_cw20_metadata();
  ::injective_explorer_rpc::Cw20Metadata* mutable_cw20_metadata();
  void set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  private:
  const ::injective_explorer_rpc::Cw20Metadata& _internal_cw20_metadata() const;
  ::injective_explorer_rpc::Cw20Metadata* _internal_mutable_cw20_metadata();
  public:
  void unsafe_arena_set_allocated_cw20_metadata(
      ::injective_explorer_rpc::Cw20Metadata* cw20_metadata);
  ::injective_explorer_rpc::Cw20Metadata* unsafe_arena_release_cw20_metadata();
  // sint64 updated_at = 4 [json_name = "updatedAt"];
  void clear_updated_at() ;
  ::int64_t updated_at() const;
  void set_updated_at(::int64_t value);

  private:
  ::int64_t _internal_updated_at() const;
  void _internal_set_updated_at(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.WasmCw20Balance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contract_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr balance_;
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata_;
    ::int64_t updated_at_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class RelayersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.RelayersRequest) */ {
 public:
  inline RelayersRequest() : RelayersRequest(nullptr) {}
  ~RelayersRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelayersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayersRequest(const RelayersRequest& from);
  RelayersRequest(RelayersRequest&& from) noexcept
    : RelayersRequest() {
    *this = ::std::move(from);
  }

  inline RelayersRequest& operator=(const RelayersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayersRequest& operator=(RelayersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayersRequest* internal_default_instance() {
    return reinterpret_cast<const RelayersRequest*>(
               &_RelayersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(RelayersRequest& a, RelayersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayersRequest& from) {
    RelayersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.RelayersRequest";
  }
  protected:
  explicit RelayersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketIDsFieldNumber = 1,
  };
  // repeated string market_i_ds = 1 [json_name = "marketIDs"];
  int market_i_ds_size() const;
  private:
  int _internal_market_i_ds_size() const;

  public:
  void clear_market_i_ds() ;
  const std::string& market_i_ds(int index) const;
  std::string* mutable_market_i_ds(int index);
  void set_market_i_ds(int index, const std::string& value);
  void set_market_i_ds(int index, std::string&& value);
  void set_market_i_ds(int index, const char* value);
  void set_market_i_ds(int index, const char* value, std::size_t size);
  void set_market_i_ds(int index, absl::string_view value);
  std::string* add_market_i_ds();
  void add_market_i_ds(const std::string& value);
  void add_market_i_ds(std::string&& value);
  void add_market_i_ds(const char* value);
  void add_market_i_ds(const char* value, std::size_t size);
  void add_market_i_ds(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& market_i_ds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_market_i_ds();

  private:
  const std::string& _internal_market_i_ds(int index) const;
  std::string* _internal_add_market_i_ds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_market_i_ds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_market_i_ds();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.RelayersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> market_i_ds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class RelayersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.RelayersResponse) */ {
 public:
  inline RelayersResponse() : RelayersResponse(nullptr) {}
  ~RelayersResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelayersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayersResponse(const RelayersResponse& from);
  RelayersResponse(RelayersResponse&& from) noexcept
    : RelayersResponse() {
    *this = ::std::move(from);
  }

  inline RelayersResponse& operator=(const RelayersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayersResponse& operator=(RelayersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayersResponse* internal_default_instance() {
    return reinterpret_cast<const RelayersResponse*>(
               &_RelayersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(RelayersResponse& a, RelayersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayersResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayersResponse& from) {
    RelayersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.RelayersResponse";
  }
  protected:
  explicit RelayersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.RelayerMarkets field = 1 [json_name = "field"];
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::injective_explorer_rpc::RelayerMarkets* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::RelayerMarkets >*
      mutable_field();
  private:
  const ::injective_explorer_rpc::RelayerMarkets& _internal_field(int index) const;
  ::injective_explorer_rpc::RelayerMarkets* _internal_add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::RelayerMarkets>& _internal_field() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::RelayerMarkets>* _internal_mutable_field();
  public:
  const ::injective_explorer_rpc::RelayerMarkets& field(int index) const;
  ::injective_explorer_rpc::RelayerMarkets* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::RelayerMarkets >&
      field() const;
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.RelayersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::RelayerMarkets > field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class RelayerMarkets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.RelayerMarkets) */ {
 public:
  inline RelayerMarkets() : RelayerMarkets(nullptr) {}
  ~RelayerMarkets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RelayerMarkets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelayerMarkets(const RelayerMarkets& from);
  RelayerMarkets(RelayerMarkets&& from) noexcept
    : RelayerMarkets() {
    *this = ::std::move(from);
  }

  inline RelayerMarkets& operator=(const RelayerMarkets& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelayerMarkets& operator=(RelayerMarkets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelayerMarkets& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelayerMarkets* internal_default_instance() {
    return reinterpret_cast<const RelayerMarkets*>(
               &_RelayerMarkets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(RelayerMarkets& a, RelayerMarkets& b) {
    a.Swap(&b);
  }
  inline void Swap(RelayerMarkets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelayerMarkets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelayerMarkets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelayerMarkets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelayerMarkets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelayerMarkets& from) {
    RelayerMarkets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayerMarkets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.RelayerMarkets";
  }
  protected:
  explicit RelayerMarkets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayersFieldNumber = 2,
    kMarketIdFieldNumber = 1,
  };
  // repeated .injective_explorer_rpc.Relayer relayers = 2 [json_name = "relayers"];
  int relayers_size() const;
  private:
  int _internal_relayers_size() const;

  public:
  void clear_relayers() ;
  ::injective_explorer_rpc::Relayer* mutable_relayers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Relayer >*
      mutable_relayers();
  private:
  const ::injective_explorer_rpc::Relayer& _internal_relayers(int index) const;
  ::injective_explorer_rpc::Relayer* _internal_add_relayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Relayer>& _internal_relayers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Relayer>* _internal_mutable_relayers();
  public:
  const ::injective_explorer_rpc::Relayer& relayers(int index) const;
  ::injective_explorer_rpc::Relayer* add_relayers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Relayer >&
      relayers() const;
  // string market_id = 1 [json_name = "marketId"];
  void clear_market_id() ;
  const std::string& market_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_market_id(Arg_&& arg, Args_... args);
  std::string* mutable_market_id();
  PROTOBUF_NODISCARD std::string* release_market_id();
  void set_allocated_market_id(std::string* ptr);

  private:
  const std::string& _internal_market_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_market_id(
      const std::string& value);
  std::string* _internal_mutable_market_id();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.RelayerMarkets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Relayer > relayers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr market_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class Relayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.Relayer) */ {
 public:
  inline Relayer() : Relayer(nullptr) {}
  ~Relayer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Relayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Relayer(const Relayer& from);
  Relayer(Relayer&& from) noexcept
    : Relayer() {
    *this = ::std::move(from);
  }

  inline Relayer& operator=(const Relayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relayer& operator=(Relayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relayer* internal_default_instance() {
    return reinterpret_cast<const Relayer*>(
               &_Relayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Relayer& a, Relayer& b) {
    a.Swap(&b);
  }
  inline void Swap(Relayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relayer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Relayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Relayer& from) {
    Relayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.Relayer";
  }
  protected:
  explicit Relayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCtaFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string cta = 2 [json_name = "cta"];
  void clear_cta() ;
  const std::string& cta() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cta(Arg_&& arg, Args_... args);
  std::string* mutable_cta();
  PROTOBUF_NODISCARD std::string* release_cta();
  void set_allocated_cta(std::string* ptr);

  private:
  const std::string& _internal_cta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cta(
      const std::string& value);
  std::string* _internal_mutable_cta();

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.Relayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTxsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.StreamTxsRequest) */ {
 public:
  inline StreamTxsRequest() : StreamTxsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTxsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTxsRequest(const StreamTxsRequest& from);
  StreamTxsRequest(StreamTxsRequest&& from) noexcept
    : StreamTxsRequest() {
    *this = ::std::move(from);
  }

  inline StreamTxsRequest& operator=(const StreamTxsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTxsRequest& operator=(StreamTxsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTxsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTxsRequest* internal_default_instance() {
    return reinterpret_cast<const StreamTxsRequest*>(
               &_StreamTxsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(StreamTxsRequest& a, StreamTxsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTxsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTxsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTxsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTxsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StreamTxsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StreamTxsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.StreamTxsRequest";
  }
  protected:
  explicit StreamTxsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.StreamTxsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamTxsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.StreamTxsResponse) */ {
 public:
  inline StreamTxsResponse() : StreamTxsResponse(nullptr) {}
  ~StreamTxsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamTxsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTxsResponse(const StreamTxsResponse& from);
  StreamTxsResponse(StreamTxsResponse&& from) noexcept
    : StreamTxsResponse() {
    *this = ::std::move(from);
  }

  inline StreamTxsResponse& operator=(const StreamTxsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTxsResponse& operator=(StreamTxsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTxsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTxsResponse* internal_default_instance() {
    return reinterpret_cast<const StreamTxsResponse*>(
               &_StreamTxsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(StreamTxsResponse& a, StreamTxsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTxsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTxsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamTxsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamTxsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamTxsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamTxsResponse& from) {
    StreamTxsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTxsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.StreamTxsResponse";
  }
  protected:
  explicit StreamTxsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 3,
    kHashFieldNumber = 4,
    kCodespaceFieldNumber = 5,
    kMessagesFieldNumber = 6,
    kErrorLogFieldNumber = 8,
    kBlockNumberFieldNumber = 2,
    kTxNumberFieldNumber = 7,
    kCodeFieldNumber = 9,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string block_timestamp = 3 [json_name = "blockTimestamp"];
  void clear_block_timestamp() ;
  const std::string& block_timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_block_timestamp();
  PROTOBUF_NODISCARD std::string* release_block_timestamp();
  void set_allocated_block_timestamp(std::string* ptr);

  private:
  const std::string& _internal_block_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_timestamp(
      const std::string& value);
  std::string* _internal_mutable_block_timestamp();

  public:
  // string hash = 4 [json_name = "hash"];
  void clear_hash() ;
  const std::string& hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // string codespace = 5 [json_name = "codespace"];
  void clear_codespace() ;
  const std::string& codespace() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codespace(Arg_&& arg, Args_... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* ptr);

  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(
      const std::string& value);
  std::string* _internal_mutable_codespace();

  public:
  // string messages = 6 [json_name = "messages"];
  void clear_messages() ;
  const std::string& messages() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_messages(Arg_&& arg, Args_... args);
  std::string* mutable_messages();
  PROTOBUF_NODISCARD std::string* release_messages();
  void set_allocated_messages(std::string* ptr);

  private:
  const std::string& _internal_messages() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messages(
      const std::string& value);
  std::string* _internal_mutable_messages();

  public:
  // string error_log = 8 [json_name = "errorLog"];
  void clear_error_log() ;
  const std::string& error_log() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_log(Arg_&& arg, Args_... args);
  std::string* mutable_error_log();
  PROTOBUF_NODISCARD std::string* release_error_log();
  void set_allocated_error_log(std::string* ptr);

  private:
  const std::string& _internal_error_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_log(
      const std::string& value);
  std::string* _internal_mutable_error_log();

  public:
  // uint64 block_number = 2 [json_name = "blockNumber"];
  void clear_block_number() ;
  ::uint64_t block_number() const;
  void set_block_number(::uint64_t value);

  private:
  ::uint64_t _internal_block_number() const;
  void _internal_set_block_number(::uint64_t value);

  public:
  // uint64 tx_number = 7 [json_name = "txNumber"];
  void clear_tx_number() ;
  ::uint64_t tx_number() const;
  void set_tx_number(::uint64_t value);

  private:
  ::uint64_t _internal_tx_number() const;
  void _internal_set_tx_number(::uint64_t value);

  public:
  // uint32 code = 9 [json_name = "code"];
  void clear_code() ;
  ::uint32_t code() const;
  void set_code(::uint32_t value);

  private:
  ::uint32_t _internal_code() const;
  void _internal_set_code(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.StreamTxsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_timestamp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_log_;
    ::uint64_t block_number_;
    ::uint64_t tx_number_;
    ::uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamBlocksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.StreamBlocksRequest) */ {
 public:
  inline StreamBlocksRequest() : StreamBlocksRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBlocksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamBlocksRequest(const StreamBlocksRequest& from);
  StreamBlocksRequest(StreamBlocksRequest&& from) noexcept
    : StreamBlocksRequest() {
    *this = ::std::move(from);
  }

  inline StreamBlocksRequest& operator=(const StreamBlocksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBlocksRequest& operator=(StreamBlocksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBlocksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBlocksRequest* internal_default_instance() {
    return reinterpret_cast<const StreamBlocksRequest*>(
               &_StreamBlocksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(StreamBlocksRequest& a, StreamBlocksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBlocksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBlocksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBlocksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBlocksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StreamBlocksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StreamBlocksRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.StreamBlocksRequest";
  }
  protected:
  explicit StreamBlocksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.StreamBlocksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};// -------------------------------------------------------------------

class StreamBlocksResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:injective_explorer_rpc.StreamBlocksResponse) */ {
 public:
  inline StreamBlocksResponse() : StreamBlocksResponse(nullptr) {}
  ~StreamBlocksResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreamBlocksResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamBlocksResponse(const StreamBlocksResponse& from);
  StreamBlocksResponse(StreamBlocksResponse&& from) noexcept
    : StreamBlocksResponse() {
    *this = ::std::move(from);
  }

  inline StreamBlocksResponse& operator=(const StreamBlocksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamBlocksResponse& operator=(StreamBlocksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamBlocksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamBlocksResponse* internal_default_instance() {
    return reinterpret_cast<const StreamBlocksResponse*>(
               &_StreamBlocksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(StreamBlocksResponse& a, StreamBlocksResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamBlocksResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamBlocksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamBlocksResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamBlocksResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamBlocksResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamBlocksResponse& from) {
    StreamBlocksResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamBlocksResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "injective_explorer_rpc.StreamBlocksResponse";
  }
  protected:
  explicit StreamBlocksResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxsFieldNumber = 8,
    kProposerFieldNumber = 2,
    kMonikerFieldNumber = 3,
    kBlockHashFieldNumber = 4,
    kParentHashFieldNumber = 5,
    kTimestampFieldNumber = 9,
    kHeightFieldNumber = 1,
    kNumPreCommitsFieldNumber = 6,
    kNumTxsFieldNumber = 7,
  };
  // repeated .injective_explorer_rpc.TxDataRPC txs = 8 [json_name = "txs"];
  int txs_size() const;
  private:
  int _internal_txs_size() const;

  public:
  void clear_txs() ;
  ::injective_explorer_rpc::TxDataRPC* mutable_txs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >*
      mutable_txs();
  private:
  const ::injective_explorer_rpc::TxDataRPC& _internal_txs(int index) const;
  ::injective_explorer_rpc::TxDataRPC* _internal_add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>& _internal_txs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>* _internal_mutable_txs();
  public:
  const ::injective_explorer_rpc::TxDataRPC& txs(int index) const;
  ::injective_explorer_rpc::TxDataRPC* add_txs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >&
      txs() const;
  // string proposer = 2 [json_name = "proposer"];
  void clear_proposer() ;
  const std::string& proposer() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proposer(Arg_&& arg, Args_... args);
  std::string* mutable_proposer();
  PROTOBUF_NODISCARD std::string* release_proposer();
  void set_allocated_proposer(std::string* ptr);

  private:
  const std::string& _internal_proposer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proposer(
      const std::string& value);
  std::string* _internal_mutable_proposer();

  public:
  // string moniker = 3 [json_name = "moniker"];
  void clear_moniker() ;
  const std::string& moniker() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_moniker(Arg_&& arg, Args_... args);
  std::string* mutable_moniker();
  PROTOBUF_NODISCARD std::string* release_moniker();
  void set_allocated_moniker(std::string* ptr);

  private:
  const std::string& _internal_moniker() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_moniker(
      const std::string& value);
  std::string* _internal_mutable_moniker();

  public:
  // string block_hash = 4 [json_name = "blockHash"];
  void clear_block_hash() ;
  const std::string& block_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_block_hash(Arg_&& arg, Args_... args);
  std::string* mutable_block_hash();
  PROTOBUF_NODISCARD std::string* release_block_hash();
  void set_allocated_block_hash(std::string* ptr);

  private:
  const std::string& _internal_block_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_hash(
      const std::string& value);
  std::string* _internal_mutable_block_hash();

  public:
  // string parent_hash = 5 [json_name = "parentHash"];
  void clear_parent_hash() ;
  const std::string& parent_hash() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_hash(Arg_&& arg, Args_... args);
  std::string* mutable_parent_hash();
  PROTOBUF_NODISCARD std::string* release_parent_hash();
  void set_allocated_parent_hash(std::string* ptr);

  private:
  const std::string& _internal_parent_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_hash(
      const std::string& value);
  std::string* _internal_mutable_parent_hash();

  public:
  // string timestamp = 9 [json_name = "timestamp"];
  void clear_timestamp() ;
  const std::string& timestamp() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* ptr);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // uint64 height = 1 [json_name = "height"];
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
  void clear_num_pre_commits() ;
  ::int64_t num_pre_commits() const;
  void set_num_pre_commits(::int64_t value);

  private:
  ::int64_t _internal_num_pre_commits() const;
  void _internal_set_num_pre_commits(::int64_t value);

  public:
  // sint64 num_txs = 7 [json_name = "numTxs"];
  void clear_num_txs() ;
  ::int64_t num_txs() const;
  void set_num_txs(::int64_t value);

  private:
  ::int64_t _internal_num_txs() const;
  void _internal_set_num_txs(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:injective_explorer_rpc.StreamBlocksResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC > txs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proposer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr moniker_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
    ::uint64_t height_;
    ::int64_t num_pre_commits_;
    ::int64_t num_txs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_exchange_2finjective_5fexplorer_5frpc_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetAccountTxsRequest

// string address = 1 [json_name = "address"];
inline void GetAccountTxsRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetAccountTxsRequest::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAccountTxsRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.address)
}
inline std::string* GetAccountTxsRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetAccountTxsRequest.address)
  return _s;
}
inline const std::string& GetAccountTxsRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetAccountTxsRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetAccountTxsRequest.address)
  return _impl_.address_.Release();
}
inline void GetAccountTxsRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetAccountTxsRequest.address)
}

// uint64 before = 2 [json_name = "before"];
inline void GetAccountTxsRequest::clear_before() {
  _impl_.before_ = ::uint64_t{0u};
}
inline ::uint64_t GetAccountTxsRequest::before() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.before)
  return _internal_before();
}
inline void GetAccountTxsRequest::set_before(::uint64_t value) {
  _internal_set_before(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.before)
}
inline ::uint64_t GetAccountTxsRequest::_internal_before() const {
  return _impl_.before_;
}
inline void GetAccountTxsRequest::_internal_set_before(::uint64_t value) {
  ;
  _impl_.before_ = value;
}

// uint64 after = 3 [json_name = "after"];
inline void GetAccountTxsRequest::clear_after() {
  _impl_.after_ = ::uint64_t{0u};
}
inline ::uint64_t GetAccountTxsRequest::after() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.after)
  return _internal_after();
}
inline void GetAccountTxsRequest::set_after(::uint64_t value) {
  _internal_set_after(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.after)
}
inline ::uint64_t GetAccountTxsRequest::_internal_after() const {
  return _impl_.after_;
}
inline void GetAccountTxsRequest::_internal_set_after(::uint64_t value) {
  ;
  _impl_.after_ = value;
}

// sint32 limit = 4 [json_name = "limit"];
inline void GetAccountTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetAccountTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.limit)
  return _internal_limit();
}
inline void GetAccountTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.limit)
}
inline ::int32_t GetAccountTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetAccountTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 5 [json_name = "skip"];
inline void GetAccountTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetAccountTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.skip)
  return _internal_skip();
}
inline void GetAccountTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.skip)
}
inline ::uint64_t GetAccountTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetAccountTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// string type = 6 [json_name = "type"];
inline void GetAccountTxsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GetAccountTxsRequest::type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAccountTxsRequest::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.type)
}
inline std::string* GetAccountTxsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetAccountTxsRequest.type)
  return _s;
}
inline const std::string& GetAccountTxsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GetAccountTxsRequest::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::release_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetAccountTxsRequest.type)
  return _impl_.type_.Release();
}
inline void GetAccountTxsRequest::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetAccountTxsRequest.type)
}

// string module = 7 [json_name = "module"];
inline void GetAccountTxsRequest::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& GetAccountTxsRequest::module() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.module)
  return _internal_module();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAccountTxsRequest::set_module(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.module_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.module)
}
inline std::string* GetAccountTxsRequest::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetAccountTxsRequest.module)
  return _s;
}
inline const std::string& GetAccountTxsRequest::_internal_module() const {
  return _impl_.module_.Get();
}
inline void GetAccountTxsRequest::_internal_set_module(const std::string& value) {
  ;


  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::_internal_mutable_module() {
  ;
  return _impl_.module_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAccountTxsRequest::release_module() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetAccountTxsRequest.module)
  return _impl_.module_.Release();
}
inline void GetAccountTxsRequest::set_allocated_module(std::string* value) {
  _impl_.module_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_.IsDefault()) {
          _impl_.module_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetAccountTxsRequest.module)
}

// sint64 from_number = 8 [json_name = "fromNumber"];
inline void GetAccountTxsRequest::clear_from_number() {
  _impl_.from_number_ = ::int64_t{0};
}
inline ::int64_t GetAccountTxsRequest::from_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.from_number)
  return _internal_from_number();
}
inline void GetAccountTxsRequest::set_from_number(::int64_t value) {
  _internal_set_from_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.from_number)
}
inline ::int64_t GetAccountTxsRequest::_internal_from_number() const {
  return _impl_.from_number_;
}
inline void GetAccountTxsRequest::_internal_set_from_number(::int64_t value) {
  ;
  _impl_.from_number_ = value;
}

// sint64 to_number = 9 [json_name = "toNumber"];
inline void GetAccountTxsRequest::clear_to_number() {
  _impl_.to_number_ = ::int64_t{0};
}
inline ::int64_t GetAccountTxsRequest::to_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsRequest.to_number)
  return _internal_to_number();
}
inline void GetAccountTxsRequest::set_to_number(::int64_t value) {
  _internal_set_to_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetAccountTxsRequest.to_number)
}
inline ::int64_t GetAccountTxsRequest::_internal_to_number() const {
  return _impl_.to_number_;
}
inline void GetAccountTxsRequest::_internal_set_to_number(::int64_t value) {
  ;
  _impl_.to_number_ = value;
}

// -------------------------------------------------------------------

// GetAccountTxsResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetAccountTxsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetAccountTxsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetAccountTxsResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetAccountTxsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsResponse.paging)
  return _internal_paging();
}
inline void GetAccountTxsResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetAccountTxsResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetAccountTxsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetAccountTxsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetAccountTxsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetAccountTxsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetAccountTxsResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetAccountTxsResponse.paging)
  return _msg;
}
inline void GetAccountTxsResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetAccountTxsResponse.paging)
}

// repeated .injective_explorer_rpc.TxDetailData data = 2 [json_name = "data"];
inline int GetAccountTxsResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetAccountTxsResponse::data_size() const {
  return _internal_data_size();
}
inline void GetAccountTxsResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::TxDetailData* GetAccountTxsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetAccountTxsResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >*
GetAccountTxsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetAccountTxsResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::TxDetailData& GetAccountTxsResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::TxDetailData& GetAccountTxsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetAccountTxsResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::TxDetailData* GetAccountTxsResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::TxDetailData* GetAccountTxsResponse::add_data() {
  ::injective_explorer_rpc::TxDetailData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetAccountTxsResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >&
GetAccountTxsResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetAccountTxsResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>&
GetAccountTxsResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>*
GetAccountTxsResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// Paging

// sint64 total = 1 [json_name = "total"];
inline void Paging::clear_total() {
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t Paging::total() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Paging.total)
  return _internal_total();
}
inline void Paging::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Paging.total)
}
inline ::int64_t Paging::_internal_total() const {
  return _impl_.total_;
}
inline void Paging::_internal_set_total(::int64_t value) {
  ;
  _impl_.total_ = value;
}

// sint32 from = 2 [json_name = "from"];
inline void Paging::clear_from() {
  _impl_.from_ = 0;
}
inline ::int32_t Paging::from() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Paging.from)
  return _internal_from();
}
inline void Paging::set_from(::int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Paging.from)
}
inline ::int32_t Paging::_internal_from() const {
  return _impl_.from_;
}
inline void Paging::_internal_set_from(::int32_t value) {
  ;
  _impl_.from_ = value;
}

// sint32 to = 3 [json_name = "to"];
inline void Paging::clear_to() {
  _impl_.to_ = 0;
}
inline ::int32_t Paging::to() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Paging.to)
  return _internal_to();
}
inline void Paging::set_to(::int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Paging.to)
}
inline ::int32_t Paging::_internal_to() const {
  return _impl_.to_;
}
inline void Paging::_internal_set_to(::int32_t value) {
  ;
  _impl_.to_ = value;
}

// sint64 count_by_subaccount = 4 [json_name = "countBySubaccount"];
inline void Paging::clear_count_by_subaccount() {
  _impl_.count_by_subaccount_ = ::int64_t{0};
}
inline ::int64_t Paging::count_by_subaccount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Paging.count_by_subaccount)
  return _internal_count_by_subaccount();
}
inline void Paging::set_count_by_subaccount(::int64_t value) {
  _internal_set_count_by_subaccount(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Paging.count_by_subaccount)
}
inline ::int64_t Paging::_internal_count_by_subaccount() const {
  return _impl_.count_by_subaccount_;
}
inline void Paging::_internal_set_count_by_subaccount(::int64_t value) {
  ;
  _impl_.count_by_subaccount_ = value;
}

// -------------------------------------------------------------------

// TxDetailData

// string id = 1 [json_name = "id"];
inline void TxDetailData::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TxDetailData::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.id)
}
inline std::string* TxDetailData::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.id)
  return _s;
}
inline const std::string& TxDetailData::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TxDetailData::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.id)
  return _impl_.id_.Release();
}
inline void TxDetailData::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.id)
}

// uint64 block_number = 2 [json_name = "blockNumber"];
inline void TxDetailData::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxDetailData::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.block_number)
  return _internal_block_number();
}
inline void TxDetailData::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.block_number)
}
inline ::uint64_t TxDetailData::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void TxDetailData::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string block_timestamp = 3 [json_name = "blockTimestamp"];
inline void TxDetailData::clear_block_timestamp() {
  _impl_.block_timestamp_.ClearToEmpty();
}
inline const std::string& TxDetailData::block_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.block_timestamp)
  return _internal_block_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_block_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.block_timestamp)
}
inline std::string* TxDetailData::mutable_block_timestamp() {
  std::string* _s = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.block_timestamp)
  return _s;
}
inline const std::string& TxDetailData::_internal_block_timestamp() const {
  return _impl_.block_timestamp_.Get();
}
inline void TxDetailData::_internal_set_block_timestamp(const std::string& value) {
  ;


  _impl_.block_timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_block_timestamp() {
  ;
  return _impl_.block_timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_block_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.block_timestamp)
  return _impl_.block_timestamp_.Release();
}
inline void TxDetailData::set_allocated_block_timestamp(std::string* value) {
  _impl_.block_timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_timestamp_.IsDefault()) {
          _impl_.block_timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.block_timestamp)
}

// string hash = 4 [json_name = "hash"];
inline void TxDetailData::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TxDetailData::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.hash)
}
inline std::string* TxDetailData::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.hash)
  return _s;
}
inline const std::string& TxDetailData::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TxDetailData::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.hash)
  return _impl_.hash_.Release();
}
inline void TxDetailData::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.hash)
}

// uint32 code = 5 [json_name = "code"];
inline void TxDetailData::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t TxDetailData::code() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.code)
  return _internal_code();
}
inline void TxDetailData::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.code)
}
inline ::uint32_t TxDetailData::_internal_code() const {
  return _impl_.code_;
}
inline void TxDetailData::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// bytes data = 6 [json_name = "data"];
inline void TxDetailData::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TxDetailData::data() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.data)
}
inline std::string* TxDetailData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.data)
  return _s;
}
inline const std::string& TxDetailData::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TxDetailData::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_data() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.data)
  return _impl_.data_.Release();
}
inline void TxDetailData::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.data)
}

// string info = 8 [json_name = "info"];
inline void TxDetailData::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& TxDetailData::info() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.info)
  return _internal_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_info(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.info_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.info)
}
inline std::string* TxDetailData::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.info)
  return _s;
}
inline const std::string& TxDetailData::_internal_info() const {
  return _impl_.info_.Get();
}
inline void TxDetailData::_internal_set_info(const std::string& value) {
  ;


  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_info() {
  ;
  return _impl_.info_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_info() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.info)
  return _impl_.info_.Release();
}
inline void TxDetailData::set_allocated_info(std::string* value) {
  _impl_.info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.info_.IsDefault()) {
          _impl_.info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.info)
}

// sint64 gas_wanted = 9 [json_name = "gasWanted"];
inline void TxDetailData::clear_gas_wanted() {
  _impl_.gas_wanted_ = ::int64_t{0};
}
inline ::int64_t TxDetailData::gas_wanted() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.gas_wanted)
  return _internal_gas_wanted();
}
inline void TxDetailData::set_gas_wanted(::int64_t value) {
  _internal_set_gas_wanted(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.gas_wanted)
}
inline ::int64_t TxDetailData::_internal_gas_wanted() const {
  return _impl_.gas_wanted_;
}
inline void TxDetailData::_internal_set_gas_wanted(::int64_t value) {
  ;
  _impl_.gas_wanted_ = value;
}

// sint64 gas_used = 10 [json_name = "gasUsed"];
inline void TxDetailData::clear_gas_used() {
  _impl_.gas_used_ = ::int64_t{0};
}
inline ::int64_t TxDetailData::gas_used() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.gas_used)
  return _internal_gas_used();
}
inline void TxDetailData::set_gas_used(::int64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.gas_used)
}
inline ::int64_t TxDetailData::_internal_gas_used() const {
  return _impl_.gas_used_;
}
inline void TxDetailData::_internal_set_gas_used(::int64_t value) {
  ;
  _impl_.gas_used_ = value;
}

// .injective_explorer_rpc.GasFee gas_fee = 11 [json_name = "gasFee"];
inline bool TxDetailData::has_gas_fee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gas_fee_ != nullptr);
  return value;
}
inline void TxDetailData::clear_gas_fee() {
  if (_impl_.gas_fee_ != nullptr) _impl_.gas_fee_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::GasFee& TxDetailData::_internal_gas_fee() const {
  const ::injective_explorer_rpc::GasFee* p = _impl_.gas_fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::GasFee&>(
      ::injective_explorer_rpc::_GasFee_default_instance_);
}
inline const ::injective_explorer_rpc::GasFee& TxDetailData::gas_fee() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.gas_fee)
  return _internal_gas_fee();
}
inline void TxDetailData::unsafe_arena_set_allocated_gas_fee(
    ::injective_explorer_rpc::GasFee* gas_fee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gas_fee_);
  }
  _impl_.gas_fee_ = gas_fee;
  if (gas_fee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.TxDetailData.gas_fee)
}
inline ::injective_explorer_rpc::GasFee* TxDetailData::release_gas_fee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::GasFee* temp = _impl_.gas_fee_;
  _impl_.gas_fee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::GasFee* TxDetailData::unsafe_arena_release_gas_fee() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.gas_fee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::GasFee* temp = _impl_.gas_fee_;
  _impl_.gas_fee_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::GasFee* TxDetailData::_internal_mutable_gas_fee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.gas_fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::GasFee>(GetArenaForAllocation());
    _impl_.gas_fee_ = p;
  }
  return _impl_.gas_fee_;
}
inline ::injective_explorer_rpc::GasFee* TxDetailData::mutable_gas_fee() {
  ::injective_explorer_rpc::GasFee* _msg = _internal_mutable_gas_fee();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.gas_fee)
  return _msg;
}
inline void TxDetailData::set_allocated_gas_fee(::injective_explorer_rpc::GasFee* gas_fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gas_fee_;
  }
  if (gas_fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gas_fee);
    if (message_arena != submessage_arena) {
      gas_fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gas_fee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gas_fee_ = gas_fee;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.gas_fee)
}

// string codespace = 12 [json_name = "codespace"];
inline void TxDetailData::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& TxDetailData::codespace() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.codespace)
}
inline std::string* TxDetailData::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.codespace)
  return _s;
}
inline const std::string& TxDetailData::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void TxDetailData::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.codespace)
  return _impl_.codespace_.Release();
}
inline void TxDetailData::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.codespace)
}

// repeated .injective_explorer_rpc.Event events = 13 [json_name = "events"];
inline int TxDetailData::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int TxDetailData::events_size() const {
  return _internal_events_size();
}
inline void TxDetailData::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::injective_explorer_rpc::Event* TxDetailData::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Event >*
TxDetailData::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.TxDetailData.events)
  return _internal_mutable_events();
}
inline const ::injective_explorer_rpc::Event& TxDetailData::_internal_events(int index) const {
  return _internal_events().Get(index);
}
inline const ::injective_explorer_rpc::Event& TxDetailData::events(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.events)
  return _internal_events(index);
}
inline ::injective_explorer_rpc::Event* TxDetailData::_internal_add_events() {
  return _internal_mutable_events()->Add();
}
inline ::injective_explorer_rpc::Event* TxDetailData::add_events() {
  ::injective_explorer_rpc::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.TxDetailData.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Event >&
TxDetailData::events() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.TxDetailData.events)
  return _internal_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Event>&
TxDetailData::_internal_events() const {
  return _impl_.events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Event>*
TxDetailData::_internal_mutable_events() {
  return &_impl_.events_;
}

// string tx_type = 14 [json_name = "txType"];
inline void TxDetailData::clear_tx_type() {
  _impl_.tx_type_.ClearToEmpty();
}
inline const std::string& TxDetailData::tx_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.tx_type)
  return _internal_tx_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_tx_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.tx_type)
}
inline std::string* TxDetailData::mutable_tx_type() {
  std::string* _s = _internal_mutable_tx_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.tx_type)
  return _s;
}
inline const std::string& TxDetailData::_internal_tx_type() const {
  return _impl_.tx_type_.Get();
}
inline void TxDetailData::_internal_set_tx_type(const std::string& value) {
  ;


  _impl_.tx_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_tx_type() {
  ;
  return _impl_.tx_type_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_tx_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.tx_type)
  return _impl_.tx_type_.Release();
}
inline void TxDetailData::set_allocated_tx_type(std::string* value) {
  _impl_.tx_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_type_.IsDefault()) {
          _impl_.tx_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.tx_type)
}

// bytes messages = 15 [json_name = "messages"];
inline void TxDetailData::clear_messages() {
  _impl_.messages_.ClearToEmpty();
}
inline const std::string& TxDetailData::messages() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.messages)
  return _internal_messages();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_messages(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.messages_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.messages)
}
inline std::string* TxDetailData::mutable_messages() {
  std::string* _s = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.messages)
  return _s;
}
inline const std::string& TxDetailData::_internal_messages() const {
  return _impl_.messages_.Get();
}
inline void TxDetailData::_internal_set_messages(const std::string& value) {
  ;


  _impl_.messages_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_messages() {
  ;
  return _impl_.messages_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_messages() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.messages)
  return _impl_.messages_.Release();
}
inline void TxDetailData::set_allocated_messages(std::string* value) {
  _impl_.messages_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messages_.IsDefault()) {
          _impl_.messages_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.messages)
}

// repeated .injective_explorer_rpc.Signature signatures = 16 [json_name = "signatures"];
inline int TxDetailData::_internal_signatures_size() const {
  return _impl_.signatures_.size();
}
inline int TxDetailData::signatures_size() const {
  return _internal_signatures_size();
}
inline void TxDetailData::clear_signatures() {
  _internal_mutable_signatures()->Clear();
}
inline ::injective_explorer_rpc::Signature* TxDetailData::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.signatures)
  return _internal_mutable_signatures()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Signature >*
TxDetailData::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.TxDetailData.signatures)
  return _internal_mutable_signatures();
}
inline const ::injective_explorer_rpc::Signature& TxDetailData::_internal_signatures(int index) const {
  return _internal_signatures().Get(index);
}
inline const ::injective_explorer_rpc::Signature& TxDetailData::signatures(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.signatures)
  return _internal_signatures(index);
}
inline ::injective_explorer_rpc::Signature* TxDetailData::_internal_add_signatures() {
  return _internal_mutable_signatures()->Add();
}
inline ::injective_explorer_rpc::Signature* TxDetailData::add_signatures() {
  ::injective_explorer_rpc::Signature* _add = _internal_add_signatures();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.TxDetailData.signatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Signature >&
TxDetailData::signatures() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.TxDetailData.signatures)
  return _internal_signatures();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Signature>&
TxDetailData::_internal_signatures() const {
  return _impl_.signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Signature>*
TxDetailData::_internal_mutable_signatures() {
  return &_impl_.signatures_;
}

// string memo = 17 [json_name = "memo"];
inline void TxDetailData::clear_memo() {
  _impl_.memo_.ClearToEmpty();
}
inline const std::string& TxDetailData::memo() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.memo)
  return _internal_memo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_memo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.memo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.memo)
}
inline std::string* TxDetailData::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.memo)
  return _s;
}
inline const std::string& TxDetailData::_internal_memo() const {
  return _impl_.memo_.Get();
}
inline void TxDetailData::_internal_set_memo(const std::string& value) {
  ;


  _impl_.memo_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_memo() {
  ;
  return _impl_.memo_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_memo() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.memo)
  return _impl_.memo_.Release();
}
inline void TxDetailData::set_allocated_memo(std::string* value) {
  _impl_.memo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.memo_.IsDefault()) {
          _impl_.memo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.memo)
}

// uint64 tx_number = 18 [json_name = "txNumber"];
inline void TxDetailData::clear_tx_number() {
  _impl_.tx_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxDetailData::tx_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.tx_number)
  return _internal_tx_number();
}
inline void TxDetailData::set_tx_number(::uint64_t value) {
  _internal_set_tx_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.tx_number)
}
inline ::uint64_t TxDetailData::_internal_tx_number() const {
  return _impl_.tx_number_;
}
inline void TxDetailData::_internal_set_tx_number(::uint64_t value) {
  ;
  _impl_.tx_number_ = value;
}

// uint64 block_unix_timestamp = 19 [json_name = "blockUnixTimestamp"];
inline void TxDetailData::clear_block_unix_timestamp() {
  _impl_.block_unix_timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t TxDetailData::block_unix_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.block_unix_timestamp)
  return _internal_block_unix_timestamp();
}
inline void TxDetailData::set_block_unix_timestamp(::uint64_t value) {
  _internal_set_block_unix_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.block_unix_timestamp)
}
inline ::uint64_t TxDetailData::_internal_block_unix_timestamp() const {
  return _impl_.block_unix_timestamp_;
}
inline void TxDetailData::_internal_set_block_unix_timestamp(::uint64_t value) {
  ;
  _impl_.block_unix_timestamp_ = value;
}

// string error_log = 20 [json_name = "errorLog"];
inline void TxDetailData::clear_error_log() {
  _impl_.error_log_.ClearToEmpty();
}
inline const std::string& TxDetailData::error_log() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDetailData.error_log)
  return _internal_error_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDetailData::set_error_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDetailData.error_log)
}
inline std::string* TxDetailData::mutable_error_log() {
  std::string* _s = _internal_mutable_error_log();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDetailData.error_log)
  return _s;
}
inline const std::string& TxDetailData::_internal_error_log() const {
  return _impl_.error_log_.Get();
}
inline void TxDetailData::_internal_set_error_log(const std::string& value) {
  ;


  _impl_.error_log_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDetailData::_internal_mutable_error_log() {
  ;
  return _impl_.error_log_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDetailData::release_error_log() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDetailData.error_log)
  return _impl_.error_log_.Release();
}
inline void TxDetailData::set_allocated_error_log(std::string* value) {
  _impl_.error_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_log_.IsDefault()) {
          _impl_.error_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDetailData.error_log)
}

// -------------------------------------------------------------------

// GasFee

// repeated .injective_explorer_rpc.CosmosCoin amount = 1 [json_name = "amount"];
inline int GasFee::_internal_amount_size() const {
  return _impl_.amount_.size();
}
inline int GasFee::amount_size() const {
  return _internal_amount_size();
}
inline void GasFee::clear_amount() {
  _internal_mutable_amount()->Clear();
}
inline ::injective_explorer_rpc::CosmosCoin* GasFee::mutable_amount(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GasFee.amount)
  return _internal_mutable_amount()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::CosmosCoin >*
GasFee::mutable_amount() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GasFee.amount)
  return _internal_mutable_amount();
}
inline const ::injective_explorer_rpc::CosmosCoin& GasFee::_internal_amount(int index) const {
  return _internal_amount().Get(index);
}
inline const ::injective_explorer_rpc::CosmosCoin& GasFee::amount(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GasFee.amount)
  return _internal_amount(index);
}
inline ::injective_explorer_rpc::CosmosCoin* GasFee::_internal_add_amount() {
  return _internal_mutable_amount()->Add();
}
inline ::injective_explorer_rpc::CosmosCoin* GasFee::add_amount() {
  ::injective_explorer_rpc::CosmosCoin* _add = _internal_add_amount();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GasFee.amount)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::CosmosCoin >&
GasFee::amount() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GasFee.amount)
  return _internal_amount();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::CosmosCoin>&
GasFee::_internal_amount() const {
  return _impl_.amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::CosmosCoin>*
GasFee::_internal_mutable_amount() {
  return &_impl_.amount_;
}

// uint64 gas_limit = 2 [json_name = "gasLimit"];
inline void GasFee::clear_gas_limit() {
  _impl_.gas_limit_ = ::uint64_t{0u};
}
inline ::uint64_t GasFee::gas_limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GasFee.gas_limit)
  return _internal_gas_limit();
}
inline void GasFee::set_gas_limit(::uint64_t value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GasFee.gas_limit)
}
inline ::uint64_t GasFee::_internal_gas_limit() const {
  return _impl_.gas_limit_;
}
inline void GasFee::_internal_set_gas_limit(::uint64_t value) {
  ;
  _impl_.gas_limit_ = value;
}

// string payer = 3 [json_name = "payer"];
inline void GasFee::clear_payer() {
  _impl_.payer_.ClearToEmpty();
}
inline const std::string& GasFee::payer() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GasFee.payer)
  return _internal_payer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GasFee::set_payer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.payer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GasFee.payer)
}
inline std::string* GasFee::mutable_payer() {
  std::string* _s = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GasFee.payer)
  return _s;
}
inline const std::string& GasFee::_internal_payer() const {
  return _impl_.payer_.Get();
}
inline void GasFee::_internal_set_payer(const std::string& value) {
  ;


  _impl_.payer_.Set(value, GetArenaForAllocation());
}
inline std::string* GasFee::_internal_mutable_payer() {
  ;
  return _impl_.payer_.Mutable( GetArenaForAllocation());
}
inline std::string* GasFee::release_payer() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GasFee.payer)
  return _impl_.payer_.Release();
}
inline void GasFee::set_allocated_payer(std::string* value) {
  _impl_.payer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payer_.IsDefault()) {
          _impl_.payer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GasFee.payer)
}

// string granter = 4 [json_name = "granter"];
inline void GasFee::clear_granter() {
  _impl_.granter_.ClearToEmpty();
}
inline const std::string& GasFee::granter() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GasFee.granter)
  return _internal_granter();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GasFee::set_granter(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.granter_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GasFee.granter)
}
inline std::string* GasFee::mutable_granter() {
  std::string* _s = _internal_mutable_granter();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GasFee.granter)
  return _s;
}
inline const std::string& GasFee::_internal_granter() const {
  return _impl_.granter_.Get();
}
inline void GasFee::_internal_set_granter(const std::string& value) {
  ;


  _impl_.granter_.Set(value, GetArenaForAllocation());
}
inline std::string* GasFee::_internal_mutable_granter() {
  ;
  return _impl_.granter_.Mutable( GetArenaForAllocation());
}
inline std::string* GasFee::release_granter() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GasFee.granter)
  return _impl_.granter_.Release();
}
inline void GasFee::set_allocated_granter(std::string* value) {
  _impl_.granter_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.granter_.IsDefault()) {
          _impl_.granter_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GasFee.granter)
}

// -------------------------------------------------------------------

// CosmosCoin

// string denom = 1 [json_name = "denom"];
inline void CosmosCoin::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& CosmosCoin::denom() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.CosmosCoin.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.CosmosCoin.denom)
}
inline std::string* CosmosCoin::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.CosmosCoin.denom)
  return _s;
}
inline const std::string& CosmosCoin::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void CosmosCoin::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_denom() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.CosmosCoin.denom)
  return _impl_.denom_.Release();
}
inline void CosmosCoin::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.CosmosCoin.denom)
}

// string amount = 2 [json_name = "amount"];
inline void CosmosCoin::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& CosmosCoin::amount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.CosmosCoin.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CosmosCoin::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.CosmosCoin.amount)
}
inline std::string* CosmosCoin::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.CosmosCoin.amount)
  return _s;
}
inline const std::string& CosmosCoin::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void CosmosCoin::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* CosmosCoin::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* CosmosCoin::release_amount() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.CosmosCoin.amount)
  return _impl_.amount_.Release();
}
inline void CosmosCoin::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.CosmosCoin.amount)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Event

// string type = 1 [json_name = "type"];
inline void Event::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Event.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Event.type)
  return _impl_.type_.Release();
}
inline void Event::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Event.type)
}

// map<string, string> attributes = 2 [json_name = "attributes"];
inline int Event::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Event::attributes_size() const {
  return _internal_attributes_size();
}
inline void Event::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::attributes() const {
  // @@protoc_insertion_point(field_map:injective_explorer_rpc.Event.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:injective_explorer_rpc.Event.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// Signature

// string pubkey = 1 [json_name = "pubkey"];
inline void Signature::clear_pubkey() {
  _impl_.pubkey_.ClearToEmpty();
}
inline const std::string& Signature::pubkey() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Signature.pubkey)
  return _internal_pubkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Signature::set_pubkey(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.pubkey_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Signature.pubkey)
}
inline std::string* Signature::mutable_pubkey() {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Signature.pubkey)
  return _s;
}
inline const std::string& Signature::_internal_pubkey() const {
  return _impl_.pubkey_.Get();
}
inline void Signature::_internal_set_pubkey(const std::string& value) {
  ;


  _impl_.pubkey_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_pubkey() {
  ;
  return _impl_.pubkey_.Mutable( GetArenaForAllocation());
}
inline std::string* Signature::release_pubkey() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Signature.pubkey)
  return _impl_.pubkey_.Release();
}
inline void Signature::set_allocated_pubkey(std::string* value) {
  _impl_.pubkey_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pubkey_.IsDefault()) {
          _impl_.pubkey_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Signature.pubkey)
}

// string address = 2 [json_name = "address"];
inline void Signature::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& Signature::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Signature.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Signature::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Signature.address)
}
inline std::string* Signature::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Signature.address)
  return _s;
}
inline const std::string& Signature::_internal_address() const {
  return _impl_.address_.Get();
}
inline void Signature::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* Signature::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Signature.address)
  return _impl_.address_.Release();
}
inline void Signature::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Signature.address)
}

// uint64 sequence = 3 [json_name = "sequence"];
inline void Signature::clear_sequence() {
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t Signature::sequence() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Signature.sequence)
  return _internal_sequence();
}
inline void Signature::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Signature.sequence)
}
inline ::uint64_t Signature::_internal_sequence() const {
  return _impl_.sequence_;
}
inline void Signature::_internal_set_sequence(::uint64_t value) {
  ;
  _impl_.sequence_ = value;
}

// string signature = 4 [json_name = "signature"];
inline void Signature::clear_signature() {
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& Signature::signature() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Signature.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Signature::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.signature_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Signature.signature)
}
inline std::string* Signature::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Signature.signature)
  return _s;
}
inline const std::string& Signature::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void Signature::_internal_set_signature(const std::string& value) {
  ;


  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* Signature::_internal_mutable_signature() {
  ;
  return _impl_.signature_.Mutable( GetArenaForAllocation());
}
inline std::string* Signature::release_signature() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Signature.signature)
  return _impl_.signature_.Release();
}
inline void Signature::set_allocated_signature(std::string* value) {
  _impl_.signature_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Signature.signature)
}

// -------------------------------------------------------------------

// GetContractTxsRequest

// string address = 1 [json_name = "address"];
inline void GetContractTxsRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetContractTxsRequest::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetContractTxsRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetContractTxsRequest.address)
}
inline std::string* GetContractTxsRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetContractTxsRequest.address)
  return _s;
}
inline const std::string& GetContractTxsRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetContractTxsRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetContractTxsRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetContractTxsRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetContractTxsRequest.address)
  return _impl_.address_.Release();
}
inline void GetContractTxsRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetContractTxsRequest.address)
}

// sint32 limit = 2 [json_name = "limit"];
inline void GetContractTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetContractTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsRequest.limit)
  return _internal_limit();
}
inline void GetContractTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetContractTxsRequest.limit)
}
inline ::int32_t GetContractTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetContractTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 3 [json_name = "skip"];
inline void GetContractTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetContractTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsRequest.skip)
  return _internal_skip();
}
inline void GetContractTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetContractTxsRequest.skip)
}
inline ::uint64_t GetContractTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetContractTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// sint64 from_number = 4 [json_name = "fromNumber"];
inline void GetContractTxsRequest::clear_from_number() {
  _impl_.from_number_ = ::int64_t{0};
}
inline ::int64_t GetContractTxsRequest::from_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsRequest.from_number)
  return _internal_from_number();
}
inline void GetContractTxsRequest::set_from_number(::int64_t value) {
  _internal_set_from_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetContractTxsRequest.from_number)
}
inline ::int64_t GetContractTxsRequest::_internal_from_number() const {
  return _impl_.from_number_;
}
inline void GetContractTxsRequest::_internal_set_from_number(::int64_t value) {
  ;
  _impl_.from_number_ = value;
}

// sint64 to_number = 5 [json_name = "toNumber"];
inline void GetContractTxsRequest::clear_to_number() {
  _impl_.to_number_ = ::int64_t{0};
}
inline ::int64_t GetContractTxsRequest::to_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsRequest.to_number)
  return _internal_to_number();
}
inline void GetContractTxsRequest::set_to_number(::int64_t value) {
  _internal_set_to_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetContractTxsRequest.to_number)
}
inline ::int64_t GetContractTxsRequest::_internal_to_number() const {
  return _impl_.to_number_;
}
inline void GetContractTxsRequest::_internal_set_to_number(::int64_t value) {
  ;
  _impl_.to_number_ = value;
}

// -------------------------------------------------------------------

// GetContractTxsResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetContractTxsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetContractTxsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetContractTxsResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetContractTxsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsResponse.paging)
  return _internal_paging();
}
inline void GetContractTxsResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetContractTxsResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetContractTxsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetContractTxsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetContractTxsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetContractTxsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetContractTxsResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetContractTxsResponse.paging)
  return _msg;
}
inline void GetContractTxsResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetContractTxsResponse.paging)
}

// repeated .injective_explorer_rpc.TxDetailData data = 2 [json_name = "data"];
inline int GetContractTxsResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetContractTxsResponse::data_size() const {
  return _internal_data_size();
}
inline void GetContractTxsResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::TxDetailData* GetContractTxsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetContractTxsResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >*
GetContractTxsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetContractTxsResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::TxDetailData& GetContractTxsResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::TxDetailData& GetContractTxsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetContractTxsResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::TxDetailData* GetContractTxsResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::TxDetailData* GetContractTxsResponse::add_data() {
  ::injective_explorer_rpc::TxDetailData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetContractTxsResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDetailData >&
GetContractTxsResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetContractTxsResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>&
GetContractTxsResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDetailData>*
GetContractTxsResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// GetBlocksRequest

// uint64 before = 1 [json_name = "before"];
inline void GetBlocksRequest::clear_before() {
  _impl_.before_ = ::uint64_t{0u};
}
inline ::uint64_t GetBlocksRequest::before() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlocksRequest.before)
  return _internal_before();
}
inline void GetBlocksRequest::set_before(::uint64_t value) {
  _internal_set_before(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlocksRequest.before)
}
inline ::uint64_t GetBlocksRequest::_internal_before() const {
  return _impl_.before_;
}
inline void GetBlocksRequest::_internal_set_before(::uint64_t value) {
  ;
  _impl_.before_ = value;
}

// uint64 after = 2 [json_name = "after"];
inline void GetBlocksRequest::clear_after() {
  _impl_.after_ = ::uint64_t{0u};
}
inline ::uint64_t GetBlocksRequest::after() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlocksRequest.after)
  return _internal_after();
}
inline void GetBlocksRequest::set_after(::uint64_t value) {
  _internal_set_after(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlocksRequest.after)
}
inline ::uint64_t GetBlocksRequest::_internal_after() const {
  return _impl_.after_;
}
inline void GetBlocksRequest::_internal_set_after(::uint64_t value) {
  ;
  _impl_.after_ = value;
}

// sint32 limit = 3 [json_name = "limit"];
inline void GetBlocksRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetBlocksRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlocksRequest.limit)
  return _internal_limit();
}
inline void GetBlocksRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlocksRequest.limit)
}
inline ::int32_t GetBlocksRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetBlocksRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// GetBlocksResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetBlocksResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetBlocksResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetBlocksResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetBlocksResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlocksResponse.paging)
  return _internal_paging();
}
inline void GetBlocksResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetBlocksResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetBlocksResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetBlocksResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetBlocksResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetBlocksResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetBlocksResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlocksResponse.paging)
  return _msg;
}
inline void GetBlocksResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetBlocksResponse.paging)
}

// repeated .injective_explorer_rpc.BlockInfo data = 2 [json_name = "data"];
inline int GetBlocksResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetBlocksResponse::data_size() const {
  return _internal_data_size();
}
inline void GetBlocksResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::BlockInfo* GetBlocksResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlocksResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::BlockInfo >*
GetBlocksResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetBlocksResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::BlockInfo& GetBlocksResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::BlockInfo& GetBlocksResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlocksResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::BlockInfo* GetBlocksResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::BlockInfo* GetBlocksResponse::add_data() {
  ::injective_explorer_rpc::BlockInfo* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetBlocksResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::BlockInfo >&
GetBlocksResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetBlocksResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::BlockInfo>&
GetBlocksResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::BlockInfo>*
GetBlocksResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// BlockInfo

// uint64 height = 1 [json_name = "height"];
inline void BlockInfo::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t BlockInfo::height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.height)
  return _internal_height();
}
inline void BlockInfo::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.height)
}
inline ::uint64_t BlockInfo::_internal_height() const {
  return _impl_.height_;
}
inline void BlockInfo::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// string proposer = 2 [json_name = "proposer"];
inline void BlockInfo::clear_proposer() {
  _impl_.proposer_.ClearToEmpty();
}
inline const std::string& BlockInfo::proposer() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.proposer)
  return _internal_proposer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockInfo::set_proposer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.proposer)
}
inline std::string* BlockInfo::mutable_proposer() {
  std::string* _s = _internal_mutable_proposer();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.proposer)
  return _s;
}
inline const std::string& BlockInfo::_internal_proposer() const {
  return _impl_.proposer_.Get();
}
inline void BlockInfo::_internal_set_proposer(const std::string& value) {
  ;


  _impl_.proposer_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_proposer() {
  ;
  return _impl_.proposer_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockInfo::release_proposer() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockInfo.proposer)
  return _impl_.proposer_.Release();
}
inline void BlockInfo::set_allocated_proposer(std::string* value) {
  _impl_.proposer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposer_.IsDefault()) {
          _impl_.proposer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockInfo.proposer)
}

// string moniker = 3 [json_name = "moniker"];
inline void BlockInfo::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& BlockInfo::moniker() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockInfo::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.moniker)
}
inline std::string* BlockInfo::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.moniker)
  return _s;
}
inline const std::string& BlockInfo::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void BlockInfo::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockInfo::release_moniker() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockInfo.moniker)
  return _impl_.moniker_.Release();
}
inline void BlockInfo::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockInfo.moniker)
}

// string block_hash = 4 [json_name = "blockHash"];
inline void BlockInfo::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& BlockInfo::block_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.block_hash)
  return _internal_block_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockInfo::set_block_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.block_hash)
}
inline std::string* BlockInfo::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.block_hash)
  return _s;
}
inline const std::string& BlockInfo::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void BlockInfo::_internal_set_block_hash(const std::string& value) {
  ;


  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_block_hash() {
  ;
  return _impl_.block_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockInfo::release_block_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockInfo.block_hash)
  return _impl_.block_hash_.Release();
}
inline void BlockInfo::set_allocated_block_hash(std::string* value) {
  _impl_.block_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_hash_.IsDefault()) {
          _impl_.block_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockInfo.block_hash)
}

// string parent_hash = 5 [json_name = "parentHash"];
inline void BlockInfo::clear_parent_hash() {
  _impl_.parent_hash_.ClearToEmpty();
}
inline const std::string& BlockInfo::parent_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.parent_hash)
  return _internal_parent_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockInfo::set_parent_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.parent_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.parent_hash)
}
inline std::string* BlockInfo::mutable_parent_hash() {
  std::string* _s = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.parent_hash)
  return _s;
}
inline const std::string& BlockInfo::_internal_parent_hash() const {
  return _impl_.parent_hash_.Get();
}
inline void BlockInfo::_internal_set_parent_hash(const std::string& value) {
  ;


  _impl_.parent_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_parent_hash() {
  ;
  return _impl_.parent_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockInfo::release_parent_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockInfo.parent_hash)
  return _impl_.parent_hash_.Release();
}
inline void BlockInfo::set_allocated_parent_hash(std::string* value) {
  _impl_.parent_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_hash_.IsDefault()) {
          _impl_.parent_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockInfo.parent_hash)
}

// sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
inline void BlockInfo::clear_num_pre_commits() {
  _impl_.num_pre_commits_ = ::int64_t{0};
}
inline ::int64_t BlockInfo::num_pre_commits() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.num_pre_commits)
  return _internal_num_pre_commits();
}
inline void BlockInfo::set_num_pre_commits(::int64_t value) {
  _internal_set_num_pre_commits(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.num_pre_commits)
}
inline ::int64_t BlockInfo::_internal_num_pre_commits() const {
  return _impl_.num_pre_commits_;
}
inline void BlockInfo::_internal_set_num_pre_commits(::int64_t value) {
  ;
  _impl_.num_pre_commits_ = value;
}

// sint64 num_txs = 7 [json_name = "numTxs"];
inline void BlockInfo::clear_num_txs() {
  _impl_.num_txs_ = ::int64_t{0};
}
inline ::int64_t BlockInfo::num_txs() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.num_txs)
  return _internal_num_txs();
}
inline void BlockInfo::set_num_txs(::int64_t value) {
  _internal_set_num_txs(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.num_txs)
}
inline ::int64_t BlockInfo::_internal_num_txs() const {
  return _impl_.num_txs_;
}
inline void BlockInfo::_internal_set_num_txs(::int64_t value) {
  ;
  _impl_.num_txs_ = value;
}

// repeated .injective_explorer_rpc.TxDataRPC txs = 8 [json_name = "txs"];
inline int BlockInfo::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int BlockInfo::txs_size() const {
  return _internal_txs_size();
}
inline void BlockInfo::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline ::injective_explorer_rpc::TxDataRPC* BlockInfo::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >*
BlockInfo::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.BlockInfo.txs)
  return _internal_mutable_txs();
}
inline const ::injective_explorer_rpc::TxDataRPC& BlockInfo::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline const ::injective_explorer_rpc::TxDataRPC& BlockInfo::txs(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.txs)
  return _internal_txs(index);
}
inline ::injective_explorer_rpc::TxDataRPC* BlockInfo::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline ::injective_explorer_rpc::TxDataRPC* BlockInfo::add_txs() {
  ::injective_explorer_rpc::TxDataRPC* _add = _internal_add_txs();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.BlockInfo.txs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >&
BlockInfo::txs() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.BlockInfo.txs)
  return _internal_txs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>&
BlockInfo::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>*
BlockInfo::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// string timestamp = 9 [json_name = "timestamp"];
inline void BlockInfo::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& BlockInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockInfo.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockInfo::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockInfo.timestamp)
}
inline std::string* BlockInfo::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockInfo.timestamp)
  return _s;
}
inline const std::string& BlockInfo::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void BlockInfo::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockInfo::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockInfo::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockInfo.timestamp)
  return _impl_.timestamp_.Release();
}
inline void BlockInfo::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockInfo.timestamp)
}

// -------------------------------------------------------------------

// TxDataRPC

// string id = 1 [json_name = "id"];
inline void TxDataRPC::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TxDataRPC::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.id)
}
inline std::string* TxDataRPC::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.id)
  return _s;
}
inline const std::string& TxDataRPC::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TxDataRPC::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.id)
  return _impl_.id_.Release();
}
inline void TxDataRPC::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.id)
}

// uint64 block_number = 2 [json_name = "blockNumber"];
inline void TxDataRPC::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxDataRPC::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.block_number)
  return _internal_block_number();
}
inline void TxDataRPC::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.block_number)
}
inline ::uint64_t TxDataRPC::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void TxDataRPC::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string block_timestamp = 3 [json_name = "blockTimestamp"];
inline void TxDataRPC::clear_block_timestamp() {
  _impl_.block_timestamp_.ClearToEmpty();
}
inline const std::string& TxDataRPC::block_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.block_timestamp)
  return _internal_block_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_block_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.block_timestamp)
}
inline std::string* TxDataRPC::mutable_block_timestamp() {
  std::string* _s = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.block_timestamp)
  return _s;
}
inline const std::string& TxDataRPC::_internal_block_timestamp() const {
  return _impl_.block_timestamp_.Get();
}
inline void TxDataRPC::_internal_set_block_timestamp(const std::string& value) {
  ;


  _impl_.block_timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_block_timestamp() {
  ;
  return _impl_.block_timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_block_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.block_timestamp)
  return _impl_.block_timestamp_.Release();
}
inline void TxDataRPC::set_allocated_block_timestamp(std::string* value) {
  _impl_.block_timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_timestamp_.IsDefault()) {
          _impl_.block_timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.block_timestamp)
}

// string hash = 4 [json_name = "hash"];
inline void TxDataRPC::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TxDataRPC::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.hash)
}
inline std::string* TxDataRPC::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.hash)
  return _s;
}
inline const std::string& TxDataRPC::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TxDataRPC::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.hash)
  return _impl_.hash_.Release();
}
inline void TxDataRPC::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.hash)
}

// string codespace = 5 [json_name = "codespace"];
inline void TxDataRPC::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& TxDataRPC::codespace() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.codespace)
}
inline std::string* TxDataRPC::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.codespace)
  return _s;
}
inline const std::string& TxDataRPC::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void TxDataRPC::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.codespace)
  return _impl_.codespace_.Release();
}
inline void TxDataRPC::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.codespace)
}

// string messages = 6 [json_name = "messages"];
inline void TxDataRPC::clear_messages() {
  _impl_.messages_.ClearToEmpty();
}
inline const std::string& TxDataRPC::messages() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.messages)
  return _internal_messages();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_messages(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.messages_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.messages)
}
inline std::string* TxDataRPC::mutable_messages() {
  std::string* _s = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.messages)
  return _s;
}
inline const std::string& TxDataRPC::_internal_messages() const {
  return _impl_.messages_.Get();
}
inline void TxDataRPC::_internal_set_messages(const std::string& value) {
  ;


  _impl_.messages_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_messages() {
  ;
  return _impl_.messages_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_messages() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.messages)
  return _impl_.messages_.Release();
}
inline void TxDataRPC::set_allocated_messages(std::string* value) {
  _impl_.messages_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messages_.IsDefault()) {
          _impl_.messages_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.messages)
}

// uint64 tx_number = 7 [json_name = "txNumber"];
inline void TxDataRPC::clear_tx_number() {
  _impl_.tx_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxDataRPC::tx_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.tx_number)
  return _internal_tx_number();
}
inline void TxDataRPC::set_tx_number(::uint64_t value) {
  _internal_set_tx_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.tx_number)
}
inline ::uint64_t TxDataRPC::_internal_tx_number() const {
  return _impl_.tx_number_;
}
inline void TxDataRPC::_internal_set_tx_number(::uint64_t value) {
  ;
  _impl_.tx_number_ = value;
}

// string error_log = 8 [json_name = "errorLog"];
inline void TxDataRPC::clear_error_log() {
  _impl_.error_log_.ClearToEmpty();
}
inline const std::string& TxDataRPC::error_log() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.error_log)
  return _internal_error_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxDataRPC::set_error_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.error_log)
}
inline std::string* TxDataRPC::mutable_error_log() {
  std::string* _s = _internal_mutable_error_log();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxDataRPC.error_log)
  return _s;
}
inline const std::string& TxDataRPC::_internal_error_log() const {
  return _impl_.error_log_.Get();
}
inline void TxDataRPC::_internal_set_error_log(const std::string& value) {
  ;


  _impl_.error_log_.Set(value, GetArenaForAllocation());
}
inline std::string* TxDataRPC::_internal_mutable_error_log() {
  ;
  return _impl_.error_log_.Mutable( GetArenaForAllocation());
}
inline std::string* TxDataRPC::release_error_log() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxDataRPC.error_log)
  return _impl_.error_log_.Release();
}
inline void TxDataRPC::set_allocated_error_log(std::string* value) {
  _impl_.error_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_log_.IsDefault()) {
          _impl_.error_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxDataRPC.error_log)
}

// uint32 code = 9 [json_name = "code"];
inline void TxDataRPC::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t TxDataRPC::code() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxDataRPC.code)
  return _internal_code();
}
inline void TxDataRPC::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxDataRPC.code)
}
inline ::uint32_t TxDataRPC::_internal_code() const {
  return _impl_.code_;
}
inline void TxDataRPC::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// -------------------------------------------------------------------

// GetBlockRequest

// string id = 1 [json_name = "id"];
inline void GetBlockRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetBlockRequest::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlockRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlockRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlockRequest.id)
}
inline std::string* GetBlockRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlockRequest.id)
  return _s;
}
inline const std::string& GetBlockRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetBlockRequest::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockRequest::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetBlockRequest::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetBlockRequest.id)
  return _impl_.id_.Release();
}
inline void GetBlockRequest::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetBlockRequest.id)
}

// -------------------------------------------------------------------

// GetBlockResponse

// string s = 1 [json_name = "s"];
inline void GetBlockResponse::clear_s() {
  _impl_.s_.ClearToEmpty();
}
inline const std::string& GetBlockResponse::s() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlockResponse.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlockResponse::set_s(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlockResponse.s)
}
inline std::string* GetBlockResponse::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlockResponse.s)
  return _s;
}
inline const std::string& GetBlockResponse::_internal_s() const {
  return _impl_.s_.Get();
}
inline void GetBlockResponse::_internal_set_s(const std::string& value) {
  ;


  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockResponse::_internal_mutable_s() {
  ;
  return _impl_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* GetBlockResponse::release_s() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetBlockResponse.s)
  return _impl_.s_.Release();
}
inline void GetBlockResponse::set_allocated_s(std::string* value) {
  _impl_.s_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetBlockResponse.s)
}

// string errmsg = 2 [json_name = "errmsg"];
inline void GetBlockResponse::clear_errmsg() {
  _impl_.errmsg_.ClearToEmpty();
}
inline const std::string& GetBlockResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlockResponse.errmsg)
  return _internal_errmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetBlockResponse::set_errmsg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.errmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetBlockResponse.errmsg)
}
inline std::string* GetBlockResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlockResponse.errmsg)
  return _s;
}
inline const std::string& GetBlockResponse::_internal_errmsg() const {
  return _impl_.errmsg_.Get();
}
inline void GetBlockResponse::_internal_set_errmsg(const std::string& value) {
  ;


  _impl_.errmsg_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockResponse::_internal_mutable_errmsg() {
  ;
  return _impl_.errmsg_.Mutable( GetArenaForAllocation());
}
inline std::string* GetBlockResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetBlockResponse.errmsg)
  return _impl_.errmsg_.Release();
}
inline void GetBlockResponse::set_allocated_errmsg(std::string* value) {
  _impl_.errmsg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errmsg_.IsDefault()) {
          _impl_.errmsg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetBlockResponse.errmsg)
}

// .injective_explorer_rpc.BlockDetailInfo data = 3 [json_name = "data"];
inline bool GetBlockResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void GetBlockResponse::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::BlockDetailInfo& GetBlockResponse::_internal_data() const {
  const ::injective_explorer_rpc::BlockDetailInfo* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::BlockDetailInfo&>(
      ::injective_explorer_rpc::_BlockDetailInfo_default_instance_);
}
inline const ::injective_explorer_rpc::BlockDetailInfo& GetBlockResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetBlockResponse.data)
  return _internal_data();
}
inline void GetBlockResponse::unsafe_arena_set_allocated_data(
    ::injective_explorer_rpc::BlockDetailInfo* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetBlockResponse.data)
}
inline ::injective_explorer_rpc::BlockDetailInfo* GetBlockResponse::release_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::BlockDetailInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::BlockDetailInfo* GetBlockResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetBlockResponse.data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::BlockDetailInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::BlockDetailInfo* GetBlockResponse::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::BlockDetailInfo>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::injective_explorer_rpc::BlockDetailInfo* GetBlockResponse::mutable_data() {
  ::injective_explorer_rpc::BlockDetailInfo* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetBlockResponse.data)
  return _msg;
}
inline void GetBlockResponse::set_allocated_data(::injective_explorer_rpc::BlockDetailInfo* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetBlockResponse.data)
}

// -------------------------------------------------------------------

// BlockDetailInfo

// uint64 height = 1 [json_name = "height"];
inline void BlockDetailInfo::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t BlockDetailInfo::height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.height)
  return _internal_height();
}
inline void BlockDetailInfo::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.height)
}
inline ::uint64_t BlockDetailInfo::_internal_height() const {
  return _impl_.height_;
}
inline void BlockDetailInfo::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// string proposer = 2 [json_name = "proposer"];
inline void BlockDetailInfo::clear_proposer() {
  _impl_.proposer_.ClearToEmpty();
}
inline const std::string& BlockDetailInfo::proposer() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.proposer)
  return _internal_proposer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockDetailInfo::set_proposer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.proposer)
}
inline std::string* BlockDetailInfo::mutable_proposer() {
  std::string* _s = _internal_mutable_proposer();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.proposer)
  return _s;
}
inline const std::string& BlockDetailInfo::_internal_proposer() const {
  return _impl_.proposer_.Get();
}
inline void BlockDetailInfo::_internal_set_proposer(const std::string& value) {
  ;


  _impl_.proposer_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::_internal_mutable_proposer() {
  ;
  return _impl_.proposer_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::release_proposer() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockDetailInfo.proposer)
  return _impl_.proposer_.Release();
}
inline void BlockDetailInfo::set_allocated_proposer(std::string* value) {
  _impl_.proposer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposer_.IsDefault()) {
          _impl_.proposer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockDetailInfo.proposer)
}

// string moniker = 3 [json_name = "moniker"];
inline void BlockDetailInfo::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& BlockDetailInfo::moniker() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockDetailInfo::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.moniker)
}
inline std::string* BlockDetailInfo::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.moniker)
  return _s;
}
inline const std::string& BlockDetailInfo::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void BlockDetailInfo::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::release_moniker() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockDetailInfo.moniker)
  return _impl_.moniker_.Release();
}
inline void BlockDetailInfo::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockDetailInfo.moniker)
}

// string block_hash = 4 [json_name = "blockHash"];
inline void BlockDetailInfo::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& BlockDetailInfo::block_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.block_hash)
  return _internal_block_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockDetailInfo::set_block_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.block_hash)
}
inline std::string* BlockDetailInfo::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.block_hash)
  return _s;
}
inline const std::string& BlockDetailInfo::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void BlockDetailInfo::_internal_set_block_hash(const std::string& value) {
  ;


  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::_internal_mutable_block_hash() {
  ;
  return _impl_.block_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::release_block_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockDetailInfo.block_hash)
  return _impl_.block_hash_.Release();
}
inline void BlockDetailInfo::set_allocated_block_hash(std::string* value) {
  _impl_.block_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_hash_.IsDefault()) {
          _impl_.block_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockDetailInfo.block_hash)
}

// string parent_hash = 5 [json_name = "parentHash"];
inline void BlockDetailInfo::clear_parent_hash() {
  _impl_.parent_hash_.ClearToEmpty();
}
inline const std::string& BlockDetailInfo::parent_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.parent_hash)
  return _internal_parent_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockDetailInfo::set_parent_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.parent_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.parent_hash)
}
inline std::string* BlockDetailInfo::mutable_parent_hash() {
  std::string* _s = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.parent_hash)
  return _s;
}
inline const std::string& BlockDetailInfo::_internal_parent_hash() const {
  return _impl_.parent_hash_.Get();
}
inline void BlockDetailInfo::_internal_set_parent_hash(const std::string& value) {
  ;


  _impl_.parent_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::_internal_mutable_parent_hash() {
  ;
  return _impl_.parent_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::release_parent_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockDetailInfo.parent_hash)
  return _impl_.parent_hash_.Release();
}
inline void BlockDetailInfo::set_allocated_parent_hash(std::string* value) {
  _impl_.parent_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_hash_.IsDefault()) {
          _impl_.parent_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockDetailInfo.parent_hash)
}

// sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
inline void BlockDetailInfo::clear_num_pre_commits() {
  _impl_.num_pre_commits_ = ::int64_t{0};
}
inline ::int64_t BlockDetailInfo::num_pre_commits() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.num_pre_commits)
  return _internal_num_pre_commits();
}
inline void BlockDetailInfo::set_num_pre_commits(::int64_t value) {
  _internal_set_num_pre_commits(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.num_pre_commits)
}
inline ::int64_t BlockDetailInfo::_internal_num_pre_commits() const {
  return _impl_.num_pre_commits_;
}
inline void BlockDetailInfo::_internal_set_num_pre_commits(::int64_t value) {
  ;
  _impl_.num_pre_commits_ = value;
}

// sint64 num_txs = 7 [json_name = "numTxs"];
inline void BlockDetailInfo::clear_num_txs() {
  _impl_.num_txs_ = ::int64_t{0};
}
inline ::int64_t BlockDetailInfo::num_txs() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.num_txs)
  return _internal_num_txs();
}
inline void BlockDetailInfo::set_num_txs(::int64_t value) {
  _internal_set_num_txs(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.num_txs)
}
inline ::int64_t BlockDetailInfo::_internal_num_txs() const {
  return _impl_.num_txs_;
}
inline void BlockDetailInfo::_internal_set_num_txs(::int64_t value) {
  ;
  _impl_.num_txs_ = value;
}

// sint64 total_txs = 8 [json_name = "totalTxs"];
inline void BlockDetailInfo::clear_total_txs() {
  _impl_.total_txs_ = ::int64_t{0};
}
inline ::int64_t BlockDetailInfo::total_txs() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.total_txs)
  return _internal_total_txs();
}
inline void BlockDetailInfo::set_total_txs(::int64_t value) {
  _internal_set_total_txs(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.total_txs)
}
inline ::int64_t BlockDetailInfo::_internal_total_txs() const {
  return _impl_.total_txs_;
}
inline void BlockDetailInfo::_internal_set_total_txs(::int64_t value) {
  ;
  _impl_.total_txs_ = value;
}

// repeated .injective_explorer_rpc.TxData txs = 9 [json_name = "txs"];
inline int BlockDetailInfo::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int BlockDetailInfo::txs_size() const {
  return _internal_txs_size();
}
inline void BlockDetailInfo::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline ::injective_explorer_rpc::TxData* BlockDetailInfo::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >*
BlockDetailInfo::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.BlockDetailInfo.txs)
  return _internal_mutable_txs();
}
inline const ::injective_explorer_rpc::TxData& BlockDetailInfo::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline const ::injective_explorer_rpc::TxData& BlockDetailInfo::txs(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.txs)
  return _internal_txs(index);
}
inline ::injective_explorer_rpc::TxData* BlockDetailInfo::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline ::injective_explorer_rpc::TxData* BlockDetailInfo::add_txs() {
  ::injective_explorer_rpc::TxData* _add = _internal_add_txs();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.BlockDetailInfo.txs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >&
BlockDetailInfo::txs() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.BlockDetailInfo.txs)
  return _internal_txs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>&
BlockDetailInfo::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>*
BlockDetailInfo::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// string timestamp = 10 [json_name = "timestamp"];
inline void BlockDetailInfo::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& BlockDetailInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.BlockDetailInfo.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockDetailInfo::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.BlockDetailInfo.timestamp)
}
inline std::string* BlockDetailInfo::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.BlockDetailInfo.timestamp)
  return _s;
}
inline const std::string& BlockDetailInfo::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void BlockDetailInfo::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* BlockDetailInfo::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.BlockDetailInfo.timestamp)
  return _impl_.timestamp_.Release();
}
inline void BlockDetailInfo::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.BlockDetailInfo.timestamp)
}

// -------------------------------------------------------------------

// TxData

// string id = 1 [json_name = "id"];
inline void TxData::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TxData::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.id)
}
inline std::string* TxData::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.id)
  return _s;
}
inline const std::string& TxData::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TxData::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.id)
  return _impl_.id_.Release();
}
inline void TxData::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.id)
}

// uint64 block_number = 2 [json_name = "blockNumber"];
inline void TxData::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxData::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.block_number)
  return _internal_block_number();
}
inline void TxData::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.block_number)
}
inline ::uint64_t TxData::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void TxData::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string block_timestamp = 3 [json_name = "blockTimestamp"];
inline void TxData::clear_block_timestamp() {
  _impl_.block_timestamp_.ClearToEmpty();
}
inline const std::string& TxData::block_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.block_timestamp)
  return _internal_block_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_block_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.block_timestamp)
}
inline std::string* TxData::mutable_block_timestamp() {
  std::string* _s = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.block_timestamp)
  return _s;
}
inline const std::string& TxData::_internal_block_timestamp() const {
  return _impl_.block_timestamp_.Get();
}
inline void TxData::_internal_set_block_timestamp(const std::string& value) {
  ;


  _impl_.block_timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_block_timestamp() {
  ;
  return _impl_.block_timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_block_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.block_timestamp)
  return _impl_.block_timestamp_.Release();
}
inline void TxData::set_allocated_block_timestamp(std::string* value) {
  _impl_.block_timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_timestamp_.IsDefault()) {
          _impl_.block_timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.block_timestamp)
}

// string hash = 4 [json_name = "hash"];
inline void TxData::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TxData::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.hash)
}
inline std::string* TxData::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.hash)
  return _s;
}
inline const std::string& TxData::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TxData::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.hash)
  return _impl_.hash_.Release();
}
inline void TxData::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.hash)
}

// string codespace = 5 [json_name = "codespace"];
inline void TxData::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& TxData::codespace() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.codespace)
}
inline std::string* TxData::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.codespace)
  return _s;
}
inline const std::string& TxData::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void TxData::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.codespace)
  return _impl_.codespace_.Release();
}
inline void TxData::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.codespace)
}

// bytes messages = 6 [json_name = "messages"];
inline void TxData::clear_messages() {
  _impl_.messages_.ClearToEmpty();
}
inline const std::string& TxData::messages() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.messages)
  return _internal_messages();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_messages(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.messages_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.messages)
}
inline std::string* TxData::mutable_messages() {
  std::string* _s = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.messages)
  return _s;
}
inline const std::string& TxData::_internal_messages() const {
  return _impl_.messages_.Get();
}
inline void TxData::_internal_set_messages(const std::string& value) {
  ;


  _impl_.messages_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_messages() {
  ;
  return _impl_.messages_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_messages() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.messages)
  return _impl_.messages_.Release();
}
inline void TxData::set_allocated_messages(std::string* value) {
  _impl_.messages_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messages_.IsDefault()) {
          _impl_.messages_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.messages)
}

// uint64 tx_number = 7 [json_name = "txNumber"];
inline void TxData::clear_tx_number() {
  _impl_.tx_number_ = ::uint64_t{0u};
}
inline ::uint64_t TxData::tx_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.tx_number)
  return _internal_tx_number();
}
inline void TxData::set_tx_number(::uint64_t value) {
  _internal_set_tx_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.tx_number)
}
inline ::uint64_t TxData::_internal_tx_number() const {
  return _impl_.tx_number_;
}
inline void TxData::_internal_set_tx_number(::uint64_t value) {
  ;
  _impl_.tx_number_ = value;
}

// string error_log = 8 [json_name = "errorLog"];
inline void TxData::clear_error_log() {
  _impl_.error_log_.ClearToEmpty();
}
inline const std::string& TxData::error_log() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.error_log)
  return _internal_error_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxData::set_error_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.error_log)
}
inline std::string* TxData::mutable_error_log() {
  std::string* _s = _internal_mutable_error_log();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.TxData.error_log)
  return _s;
}
inline const std::string& TxData::_internal_error_log() const {
  return _impl_.error_log_.Get();
}
inline void TxData::_internal_set_error_log(const std::string& value) {
  ;


  _impl_.error_log_.Set(value, GetArenaForAllocation());
}
inline std::string* TxData::_internal_mutable_error_log() {
  ;
  return _impl_.error_log_.Mutable( GetArenaForAllocation());
}
inline std::string* TxData::release_error_log() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.TxData.error_log)
  return _impl_.error_log_.Release();
}
inline void TxData::set_allocated_error_log(std::string* value) {
  _impl_.error_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_log_.IsDefault()) {
          _impl_.error_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.TxData.error_log)
}

// uint32 code = 9 [json_name = "code"];
inline void TxData::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t TxData::code() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.TxData.code)
  return _internal_code();
}
inline void TxData::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.TxData.code)
}
inline ::uint32_t TxData::_internal_code() const {
  return _impl_.code_;
}
inline void TxData::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// -------------------------------------------------------------------

// GetValidatorsRequest

// -------------------------------------------------------------------

// GetValidatorsResponse

// string s = 1 [json_name = "s"];
inline void GetValidatorsResponse::clear_s() {
  _impl_.s_.ClearToEmpty();
}
inline const std::string& GetValidatorsResponse::s() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorsResponse.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorsResponse::set_s(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorsResponse.s)
}
inline std::string* GetValidatorsResponse::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorsResponse.s)
  return _s;
}
inline const std::string& GetValidatorsResponse::_internal_s() const {
  return _impl_.s_.Get();
}
inline void GetValidatorsResponse::_internal_set_s(const std::string& value) {
  ;


  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorsResponse::_internal_mutable_s() {
  ;
  return _impl_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorsResponse::release_s() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorsResponse.s)
  return _impl_.s_.Release();
}
inline void GetValidatorsResponse::set_allocated_s(std::string* value) {
  _impl_.s_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorsResponse.s)
}

// string errmsg = 2 [json_name = "errmsg"];
inline void GetValidatorsResponse::clear_errmsg() {
  _impl_.errmsg_.ClearToEmpty();
}
inline const std::string& GetValidatorsResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorsResponse.errmsg)
  return _internal_errmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorsResponse::set_errmsg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.errmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorsResponse.errmsg)
}
inline std::string* GetValidatorsResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorsResponse.errmsg)
  return _s;
}
inline const std::string& GetValidatorsResponse::_internal_errmsg() const {
  return _impl_.errmsg_.Get();
}
inline void GetValidatorsResponse::_internal_set_errmsg(const std::string& value) {
  ;


  _impl_.errmsg_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorsResponse::_internal_mutable_errmsg() {
  ;
  return _impl_.errmsg_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorsResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorsResponse.errmsg)
  return _impl_.errmsg_.Release();
}
inline void GetValidatorsResponse::set_allocated_errmsg(std::string* value) {
  _impl_.errmsg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errmsg_.IsDefault()) {
          _impl_.errmsg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorsResponse.errmsg)
}

// repeated .injective_explorer_rpc.Validator data = 3 [json_name = "data"];
inline int GetValidatorsResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetValidatorsResponse::data_size() const {
  return _internal_data_size();
}
inline void GetValidatorsResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::Validator* GetValidatorsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorsResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Validator >*
GetValidatorsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetValidatorsResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::Validator& GetValidatorsResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::Validator& GetValidatorsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorsResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::Validator* GetValidatorsResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::Validator* GetValidatorsResponse::add_data() {
  ::injective_explorer_rpc::Validator* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetValidatorsResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Validator >&
GetValidatorsResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetValidatorsResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Validator>&
GetValidatorsResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Validator>*
GetValidatorsResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// Validator

// string id = 1 [json_name = "id"];
inline void Validator::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Validator::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.id)
}
inline std::string* Validator::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.id)
  return _s;
}
inline const std::string& Validator::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Validator::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.id)
  return _impl_.id_.Release();
}
inline void Validator::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.id)
}

// string moniker = 2 [json_name = "moniker"];
inline void Validator::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& Validator::moniker() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.moniker)
}
inline std::string* Validator::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.moniker)
  return _s;
}
inline const std::string& Validator::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void Validator::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_moniker() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.moniker)
  return _impl_.moniker_.Release();
}
inline void Validator::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.moniker)
}

// string operator_address = 3 [json_name = "operatorAddress"];
inline void Validator::clear_operator_address() {
  _impl_.operator_address_.ClearToEmpty();
}
inline const std::string& Validator::operator_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.operator_address)
  return _internal_operator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_operator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.operator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.operator_address)
}
inline std::string* Validator::mutable_operator_address() {
  std::string* _s = _internal_mutable_operator_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.operator_address)
  return _s;
}
inline const std::string& Validator::_internal_operator_address() const {
  return _impl_.operator_address_.Get();
}
inline void Validator::_internal_set_operator_address(const std::string& value) {
  ;


  _impl_.operator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_operator_address() {
  ;
  return _impl_.operator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_operator_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.operator_address)
  return _impl_.operator_address_.Release();
}
inline void Validator::set_allocated_operator_address(std::string* value) {
  _impl_.operator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_address_.IsDefault()) {
          _impl_.operator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.operator_address)
}

// string consensus_address = 4 [json_name = "consensusAddress"];
inline void Validator::clear_consensus_address() {
  _impl_.consensus_address_.ClearToEmpty();
}
inline const std::string& Validator::consensus_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.consensus_address)
  return _internal_consensus_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_consensus_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.consensus_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.consensus_address)
}
inline std::string* Validator::mutable_consensus_address() {
  std::string* _s = _internal_mutable_consensus_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.consensus_address)
  return _s;
}
inline const std::string& Validator::_internal_consensus_address() const {
  return _impl_.consensus_address_.Get();
}
inline void Validator::_internal_set_consensus_address(const std::string& value) {
  ;


  _impl_.consensus_address_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_consensus_address() {
  ;
  return _impl_.consensus_address_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_consensus_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.consensus_address)
  return _impl_.consensus_address_.Release();
}
inline void Validator::set_allocated_consensus_address(std::string* value) {
  _impl_.consensus_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.consensus_address_.IsDefault()) {
          _impl_.consensus_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.consensus_address)
}

// bool jailed = 5 [json_name = "jailed"];
inline void Validator::clear_jailed() {
  _impl_.jailed_ = false;
}
inline bool Validator::jailed() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.jailed)
  return _internal_jailed();
}
inline void Validator::set_jailed(bool value) {
  _internal_set_jailed(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.jailed)
}
inline bool Validator::_internal_jailed() const {
  return _impl_.jailed_;
}
inline void Validator::_internal_set_jailed(bool value) {
  ;
  _impl_.jailed_ = value;
}

// sint32 status = 6 [json_name = "status"];
inline void Validator::clear_status() {
  _impl_.status_ = 0;
}
inline ::int32_t Validator::status() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.status)
  return _internal_status();
}
inline void Validator::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.status)
}
inline ::int32_t Validator::_internal_status() const {
  return _impl_.status_;
}
inline void Validator::_internal_set_status(::int32_t value) {
  ;
  _impl_.status_ = value;
}

// string tokens = 7 [json_name = "tokens"];
inline void Validator::clear_tokens() {
  _impl_.tokens_.ClearToEmpty();
}
inline const std::string& Validator::tokens() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.tokens)
  return _internal_tokens();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_tokens(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tokens_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.tokens)
}
inline std::string* Validator::mutable_tokens() {
  std::string* _s = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.tokens)
  return _s;
}
inline const std::string& Validator::_internal_tokens() const {
  return _impl_.tokens_.Get();
}
inline void Validator::_internal_set_tokens(const std::string& value) {
  ;


  _impl_.tokens_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_tokens() {
  ;
  return _impl_.tokens_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_tokens() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.tokens)
  return _impl_.tokens_.Release();
}
inline void Validator::set_allocated_tokens(std::string* value) {
  _impl_.tokens_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tokens_.IsDefault()) {
          _impl_.tokens_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.tokens)
}

// string delegator_shares = 8 [json_name = "delegatorShares"];
inline void Validator::clear_delegator_shares() {
  _impl_.delegator_shares_.ClearToEmpty();
}
inline const std::string& Validator::delegator_shares() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.delegator_shares)
  return _internal_delegator_shares();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_delegator_shares(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.delegator_shares_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.delegator_shares)
}
inline std::string* Validator::mutable_delegator_shares() {
  std::string* _s = _internal_mutable_delegator_shares();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.delegator_shares)
  return _s;
}
inline const std::string& Validator::_internal_delegator_shares() const {
  return _impl_.delegator_shares_.Get();
}
inline void Validator::_internal_set_delegator_shares(const std::string& value) {
  ;


  _impl_.delegator_shares_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_delegator_shares() {
  ;
  return _impl_.delegator_shares_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_delegator_shares() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.delegator_shares)
  return _impl_.delegator_shares_.Release();
}
inline void Validator::set_allocated_delegator_shares(std::string* value) {
  _impl_.delegator_shares_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.delegator_shares_.IsDefault()) {
          _impl_.delegator_shares_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.delegator_shares)
}

// .injective_explorer_rpc.ValidatorDescription description = 9 [json_name = "description"];
inline bool Validator::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_ != nullptr);
  return value;
}
inline void Validator::clear_description() {
  if (_impl_.description_ != nullptr) _impl_.description_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::ValidatorDescription& Validator::_internal_description() const {
  const ::injective_explorer_rpc::ValidatorDescription* p = _impl_.description_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::ValidatorDescription&>(
      ::injective_explorer_rpc::_ValidatorDescription_default_instance_);
}
inline const ::injective_explorer_rpc::ValidatorDescription& Validator::description() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.description)
  return _internal_description();
}
inline void Validator::unsafe_arena_set_allocated_description(
    ::injective_explorer_rpc::ValidatorDescription* description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.description_);
  }
  _impl_.description_ = description;
  if (description) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.Validator.description)
}
inline ::injective_explorer_rpc::ValidatorDescription* Validator::release_description() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::ValidatorDescription* temp = _impl_.description_;
  _impl_.description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::ValidatorDescription* Validator::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.description)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::ValidatorDescription* temp = _impl_.description_;
  _impl_.description_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::ValidatorDescription* Validator::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.description_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::ValidatorDescription>(GetArenaForAllocation());
    _impl_.description_ = p;
  }
  return _impl_.description_;
}
inline ::injective_explorer_rpc::ValidatorDescription* Validator::mutable_description() {
  ::injective_explorer_rpc::ValidatorDescription* _msg = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.description)
  return _msg;
}
inline void Validator::set_allocated_description(::injective_explorer_rpc::ValidatorDescription* description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.description_;
  }
  if (description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(description);
    if (message_arena != submessage_arena) {
      description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, description, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_ = description;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.description)
}

// sint64 unbonding_height = 10 [json_name = "unbondingHeight"];
inline void Validator::clear_unbonding_height() {
  _impl_.unbonding_height_ = ::int64_t{0};
}
inline ::int64_t Validator::unbonding_height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.unbonding_height)
  return _internal_unbonding_height();
}
inline void Validator::set_unbonding_height(::int64_t value) {
  _internal_set_unbonding_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.unbonding_height)
}
inline ::int64_t Validator::_internal_unbonding_height() const {
  return _impl_.unbonding_height_;
}
inline void Validator::_internal_set_unbonding_height(::int64_t value) {
  ;
  _impl_.unbonding_height_ = value;
}

// string unbonding_time = 11 [json_name = "unbondingTime"];
inline void Validator::clear_unbonding_time() {
  _impl_.unbonding_time_.ClearToEmpty();
}
inline const std::string& Validator::unbonding_time() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.unbonding_time)
  return _internal_unbonding_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_unbonding_time(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.unbonding_time_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.unbonding_time)
}
inline std::string* Validator::mutable_unbonding_time() {
  std::string* _s = _internal_mutable_unbonding_time();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.unbonding_time)
  return _s;
}
inline const std::string& Validator::_internal_unbonding_time() const {
  return _impl_.unbonding_time_.Get();
}
inline void Validator::_internal_set_unbonding_time(const std::string& value) {
  ;


  _impl_.unbonding_time_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_unbonding_time() {
  ;
  return _impl_.unbonding_time_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_unbonding_time() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.unbonding_time)
  return _impl_.unbonding_time_.Release();
}
inline void Validator::set_allocated_unbonding_time(std::string* value) {
  _impl_.unbonding_time_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.unbonding_time_.IsDefault()) {
          _impl_.unbonding_time_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.unbonding_time)
}

// string commission_rate = 12 [json_name = "commissionRate"];
inline void Validator::clear_commission_rate() {
  _impl_.commission_rate_.ClearToEmpty();
}
inline const std::string& Validator::commission_rate() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.commission_rate)
  return _internal_commission_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_commission_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.commission_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.commission_rate)
}
inline std::string* Validator::mutable_commission_rate() {
  std::string* _s = _internal_mutable_commission_rate();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.commission_rate)
  return _s;
}
inline const std::string& Validator::_internal_commission_rate() const {
  return _impl_.commission_rate_.Get();
}
inline void Validator::_internal_set_commission_rate(const std::string& value) {
  ;


  _impl_.commission_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_commission_rate() {
  ;
  return _impl_.commission_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_commission_rate() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.commission_rate)
  return _impl_.commission_rate_.Release();
}
inline void Validator::set_allocated_commission_rate(std::string* value) {
  _impl_.commission_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commission_rate_.IsDefault()) {
          _impl_.commission_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.commission_rate)
}

// string commission_max_rate = 13 [json_name = "commissionMaxRate"];
inline void Validator::clear_commission_max_rate() {
  _impl_.commission_max_rate_.ClearToEmpty();
}
inline const std::string& Validator::commission_max_rate() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.commission_max_rate)
  return _internal_commission_max_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_commission_max_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.commission_max_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.commission_max_rate)
}
inline std::string* Validator::mutable_commission_max_rate() {
  std::string* _s = _internal_mutable_commission_max_rate();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.commission_max_rate)
  return _s;
}
inline const std::string& Validator::_internal_commission_max_rate() const {
  return _impl_.commission_max_rate_.Get();
}
inline void Validator::_internal_set_commission_max_rate(const std::string& value) {
  ;


  _impl_.commission_max_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_commission_max_rate() {
  ;
  return _impl_.commission_max_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_commission_max_rate() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.commission_max_rate)
  return _impl_.commission_max_rate_.Release();
}
inline void Validator::set_allocated_commission_max_rate(std::string* value) {
  _impl_.commission_max_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commission_max_rate_.IsDefault()) {
          _impl_.commission_max_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.commission_max_rate)
}

// string commission_max_change_rate = 14 [json_name = "commissionMaxChangeRate"];
inline void Validator::clear_commission_max_change_rate() {
  _impl_.commission_max_change_rate_.ClearToEmpty();
}
inline const std::string& Validator::commission_max_change_rate() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.commission_max_change_rate)
  return _internal_commission_max_change_rate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_commission_max_change_rate(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.commission_max_change_rate_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.commission_max_change_rate)
}
inline std::string* Validator::mutable_commission_max_change_rate() {
  std::string* _s = _internal_mutable_commission_max_change_rate();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.commission_max_change_rate)
  return _s;
}
inline const std::string& Validator::_internal_commission_max_change_rate() const {
  return _impl_.commission_max_change_rate_.Get();
}
inline void Validator::_internal_set_commission_max_change_rate(const std::string& value) {
  ;


  _impl_.commission_max_change_rate_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_commission_max_change_rate() {
  ;
  return _impl_.commission_max_change_rate_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_commission_max_change_rate() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.commission_max_change_rate)
  return _impl_.commission_max_change_rate_.Release();
}
inline void Validator::set_allocated_commission_max_change_rate(std::string* value) {
  _impl_.commission_max_change_rate_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commission_max_change_rate_.IsDefault()) {
          _impl_.commission_max_change_rate_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.commission_max_change_rate)
}

// string commission_update_time = 15 [json_name = "commissionUpdateTime"];
inline void Validator::clear_commission_update_time() {
  _impl_.commission_update_time_.ClearToEmpty();
}
inline const std::string& Validator::commission_update_time() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.commission_update_time)
  return _internal_commission_update_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_commission_update_time(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.commission_update_time_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.commission_update_time)
}
inline std::string* Validator::mutable_commission_update_time() {
  std::string* _s = _internal_mutable_commission_update_time();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.commission_update_time)
  return _s;
}
inline const std::string& Validator::_internal_commission_update_time() const {
  return _impl_.commission_update_time_.Get();
}
inline void Validator::_internal_set_commission_update_time(const std::string& value) {
  ;


  _impl_.commission_update_time_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_commission_update_time() {
  ;
  return _impl_.commission_update_time_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_commission_update_time() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.commission_update_time)
  return _impl_.commission_update_time_.Release();
}
inline void Validator::set_allocated_commission_update_time(std::string* value) {
  _impl_.commission_update_time_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.commission_update_time_.IsDefault()) {
          _impl_.commission_update_time_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.commission_update_time)
}

// uint64 proposed = 16 [json_name = "proposed"];
inline void Validator::clear_proposed() {
  _impl_.proposed_ = ::uint64_t{0u};
}
inline ::uint64_t Validator::proposed() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.proposed)
  return _internal_proposed();
}
inline void Validator::set_proposed(::uint64_t value) {
  _internal_set_proposed(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.proposed)
}
inline ::uint64_t Validator::_internal_proposed() const {
  return _impl_.proposed_;
}
inline void Validator::_internal_set_proposed(::uint64_t value) {
  ;
  _impl_.proposed_ = value;
}

// uint64 signed = 17 [json_name = "signed"];
inline void Validator::clear_signed_() {
  _impl_.signed__ = ::uint64_t{0u};
}
inline ::uint64_t Validator::signed_() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.signed)
  return _internal_signed_();
}
inline void Validator::set_signed_(::uint64_t value) {
  _internal_set_signed_(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.signed)
}
inline ::uint64_t Validator::_internal_signed_() const {
  return _impl_.signed__;
}
inline void Validator::_internal_set_signed_(::uint64_t value) {
  ;
  _impl_.signed__ = value;
}

// uint64 missed = 18 [json_name = "missed"];
inline void Validator::clear_missed() {
  _impl_.missed_ = ::uint64_t{0u};
}
inline ::uint64_t Validator::missed() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.missed)
  return _internal_missed();
}
inline void Validator::set_missed(::uint64_t value) {
  _internal_set_missed(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.missed)
}
inline ::uint64_t Validator::_internal_missed() const {
  return _impl_.missed_;
}
inline void Validator::_internal_set_missed(::uint64_t value) {
  ;
  _impl_.missed_ = value;
}

// string timestamp = 19 [json_name = "timestamp"];
inline void Validator::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& Validator::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Validator::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.timestamp)
}
inline std::string* Validator::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.timestamp)
  return _s;
}
inline const std::string& Validator::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void Validator::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* Validator::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Validator.timestamp)
  return _impl_.timestamp_.Release();
}
inline void Validator::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Validator.timestamp)
}

// repeated .injective_explorer_rpc.ValidatorUptime uptimes = 20 [json_name = "uptimes"];
inline int Validator::_internal_uptimes_size() const {
  return _impl_.uptimes_.size();
}
inline int Validator::uptimes_size() const {
  return _internal_uptimes_size();
}
inline void Validator::clear_uptimes() {
  _internal_mutable_uptimes()->Clear();
}
inline ::injective_explorer_rpc::ValidatorUptime* Validator::mutable_uptimes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.uptimes)
  return _internal_mutable_uptimes()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >*
Validator::mutable_uptimes() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.Validator.uptimes)
  return _internal_mutable_uptimes();
}
inline const ::injective_explorer_rpc::ValidatorUptime& Validator::_internal_uptimes(int index) const {
  return _internal_uptimes().Get(index);
}
inline const ::injective_explorer_rpc::ValidatorUptime& Validator::uptimes(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.uptimes)
  return _internal_uptimes(index);
}
inline ::injective_explorer_rpc::ValidatorUptime* Validator::_internal_add_uptimes() {
  return _internal_mutable_uptimes()->Add();
}
inline ::injective_explorer_rpc::ValidatorUptime* Validator::add_uptimes() {
  ::injective_explorer_rpc::ValidatorUptime* _add = _internal_add_uptimes();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.Validator.uptimes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >&
Validator::uptimes() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.Validator.uptimes)
  return _internal_uptimes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>&
Validator::_internal_uptimes() const {
  return _impl_.uptimes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>*
Validator::_internal_mutable_uptimes() {
  return &_impl_.uptimes_;
}

// repeated .injective_explorer_rpc.SlashingEvent slashing_events = 21 [json_name = "slashingEvents"];
inline int Validator::_internal_slashing_events_size() const {
  return _impl_.slashing_events_.size();
}
inline int Validator::slashing_events_size() const {
  return _internal_slashing_events_size();
}
inline void Validator::clear_slashing_events() {
  _internal_mutable_slashing_events()->Clear();
}
inline ::injective_explorer_rpc::SlashingEvent* Validator::mutable_slashing_events(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Validator.slashing_events)
  return _internal_mutable_slashing_events()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::SlashingEvent >*
Validator::mutable_slashing_events() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.Validator.slashing_events)
  return _internal_mutable_slashing_events();
}
inline const ::injective_explorer_rpc::SlashingEvent& Validator::_internal_slashing_events(int index) const {
  return _internal_slashing_events().Get(index);
}
inline const ::injective_explorer_rpc::SlashingEvent& Validator::slashing_events(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.slashing_events)
  return _internal_slashing_events(index);
}
inline ::injective_explorer_rpc::SlashingEvent* Validator::_internal_add_slashing_events() {
  return _internal_mutable_slashing_events()->Add();
}
inline ::injective_explorer_rpc::SlashingEvent* Validator::add_slashing_events() {
  ::injective_explorer_rpc::SlashingEvent* _add = _internal_add_slashing_events();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.Validator.slashing_events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::SlashingEvent >&
Validator::slashing_events() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.Validator.slashing_events)
  return _internal_slashing_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::SlashingEvent>&
Validator::_internal_slashing_events() const {
  return _impl_.slashing_events_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::SlashingEvent>*
Validator::_internal_mutable_slashing_events() {
  return &_impl_.slashing_events_;
}

// double uptime_percentage = 22 [json_name = "uptimePercentage"];
inline void Validator::clear_uptime_percentage() {
  _impl_.uptime_percentage_ = 0;
}
inline double Validator::uptime_percentage() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Validator.uptime_percentage)
  return _internal_uptime_percentage();
}
inline void Validator::set_uptime_percentage(double value) {
  _internal_set_uptime_percentage(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Validator.uptime_percentage)
}
inline double Validator::_internal_uptime_percentage() const {
  return _impl_.uptime_percentage_;
}
inline void Validator::_internal_set_uptime_percentage(double value) {
  ;
  _impl_.uptime_percentage_ = value;
}

// -------------------------------------------------------------------

// ValidatorDescription

// string moniker = 1 [json_name = "moniker"];
inline void ValidatorDescription::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& ValidatorDescription::moniker() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorDescription.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorDescription::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorDescription.moniker)
}
inline std::string* ValidatorDescription::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorDescription.moniker)
  return _s;
}
inline const std::string& ValidatorDescription::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void ValidatorDescription::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorDescription::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorDescription::release_moniker() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorDescription.moniker)
  return _impl_.moniker_.Release();
}
inline void ValidatorDescription::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorDescription.moniker)
}

// string identity = 2 [json_name = "identity"];
inline void ValidatorDescription::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& ValidatorDescription::identity() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorDescription.identity)
  return _internal_identity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorDescription::set_identity(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.identity_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorDescription.identity)
}
inline std::string* ValidatorDescription::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorDescription.identity)
  return _s;
}
inline const std::string& ValidatorDescription::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void ValidatorDescription::_internal_set_identity(const std::string& value) {
  ;


  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorDescription::_internal_mutable_identity() {
  ;
  return _impl_.identity_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorDescription::release_identity() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorDescription.identity)
  return _impl_.identity_.Release();
}
inline void ValidatorDescription::set_allocated_identity(std::string* value) {
  _impl_.identity_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identity_.IsDefault()) {
          _impl_.identity_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorDescription.identity)
}

// string website = 3 [json_name = "website"];
inline void ValidatorDescription::clear_website() {
  _impl_.website_.ClearToEmpty();
}
inline const std::string& ValidatorDescription::website() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorDescription.website)
  return _internal_website();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorDescription::set_website(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.website_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorDescription.website)
}
inline std::string* ValidatorDescription::mutable_website() {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorDescription.website)
  return _s;
}
inline const std::string& ValidatorDescription::_internal_website() const {
  return _impl_.website_.Get();
}
inline void ValidatorDescription::_internal_set_website(const std::string& value) {
  ;


  _impl_.website_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorDescription::_internal_mutable_website() {
  ;
  return _impl_.website_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorDescription::release_website() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorDescription.website)
  return _impl_.website_.Release();
}
inline void ValidatorDescription::set_allocated_website(std::string* value) {
  _impl_.website_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.website_.IsDefault()) {
          _impl_.website_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorDescription.website)
}

// string security_contact = 4 [json_name = "securityContact"];
inline void ValidatorDescription::clear_security_contact() {
  _impl_.security_contact_.ClearToEmpty();
}
inline const std::string& ValidatorDescription::security_contact() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorDescription.security_contact)
  return _internal_security_contact();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorDescription::set_security_contact(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.security_contact_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorDescription.security_contact)
}
inline std::string* ValidatorDescription::mutable_security_contact() {
  std::string* _s = _internal_mutable_security_contact();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorDescription.security_contact)
  return _s;
}
inline const std::string& ValidatorDescription::_internal_security_contact() const {
  return _impl_.security_contact_.Get();
}
inline void ValidatorDescription::_internal_set_security_contact(const std::string& value) {
  ;


  _impl_.security_contact_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorDescription::_internal_mutable_security_contact() {
  ;
  return _impl_.security_contact_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorDescription::release_security_contact() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorDescription.security_contact)
  return _impl_.security_contact_.Release();
}
inline void ValidatorDescription::set_allocated_security_contact(std::string* value) {
  _impl_.security_contact_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.security_contact_.IsDefault()) {
          _impl_.security_contact_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorDescription.security_contact)
}

// string details = 5 [json_name = "details"];
inline void ValidatorDescription::clear_details() {
  _impl_.details_.ClearToEmpty();
}
inline const std::string& ValidatorDescription::details() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorDescription.details)
  return _internal_details();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorDescription::set_details(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.details_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorDescription.details)
}
inline std::string* ValidatorDescription::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorDescription.details)
  return _s;
}
inline const std::string& ValidatorDescription::_internal_details() const {
  return _impl_.details_.Get();
}
inline void ValidatorDescription::_internal_set_details(const std::string& value) {
  ;


  _impl_.details_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorDescription::_internal_mutable_details() {
  ;
  return _impl_.details_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorDescription::release_details() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorDescription.details)
  return _impl_.details_.Release();
}
inline void ValidatorDescription::set_allocated_details(std::string* value) {
  _impl_.details_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.details_.IsDefault()) {
          _impl_.details_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorDescription.details)
}

// -------------------------------------------------------------------

// ValidatorUptime

// uint64 block_number = 1 [json_name = "blockNumber"];
inline void ValidatorUptime::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t ValidatorUptime::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorUptime.block_number)
  return _internal_block_number();
}
inline void ValidatorUptime::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorUptime.block_number)
}
inline ::uint64_t ValidatorUptime::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void ValidatorUptime::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string status = 2 [json_name = "status"];
inline void ValidatorUptime::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ValidatorUptime::status() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ValidatorUptime.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidatorUptime::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ValidatorUptime.status)
}
inline std::string* ValidatorUptime::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ValidatorUptime.status)
  return _s;
}
inline const std::string& ValidatorUptime::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ValidatorUptime::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidatorUptime::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* ValidatorUptime::release_status() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ValidatorUptime.status)
  return _impl_.status_.Release();
}
inline void ValidatorUptime::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ValidatorUptime.status)
}

// -------------------------------------------------------------------

// SlashingEvent

// uint64 block_number = 1 [json_name = "blockNumber"];
inline void SlashingEvent::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t SlashingEvent::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.block_number)
  return _internal_block_number();
}
inline void SlashingEvent::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.block_number)
}
inline ::uint64_t SlashingEvent::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void SlashingEvent::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string block_timestamp = 2 [json_name = "blockTimestamp"];
inline void SlashingEvent::clear_block_timestamp() {
  _impl_.block_timestamp_.ClearToEmpty();
}
inline const std::string& SlashingEvent::block_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.block_timestamp)
  return _internal_block_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SlashingEvent::set_block_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.block_timestamp)
}
inline std::string* SlashingEvent::mutable_block_timestamp() {
  std::string* _s = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.SlashingEvent.block_timestamp)
  return _s;
}
inline const std::string& SlashingEvent::_internal_block_timestamp() const {
  return _impl_.block_timestamp_.Get();
}
inline void SlashingEvent::_internal_set_block_timestamp(const std::string& value) {
  ;


  _impl_.block_timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* SlashingEvent::_internal_mutable_block_timestamp() {
  ;
  return _impl_.block_timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* SlashingEvent::release_block_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.SlashingEvent.block_timestamp)
  return _impl_.block_timestamp_.Release();
}
inline void SlashingEvent::set_allocated_block_timestamp(std::string* value) {
  _impl_.block_timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_timestamp_.IsDefault()) {
          _impl_.block_timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.SlashingEvent.block_timestamp)
}

// string address = 3 [json_name = "address"];
inline void SlashingEvent::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& SlashingEvent::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SlashingEvent::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.address)
}
inline std::string* SlashingEvent::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.SlashingEvent.address)
  return _s;
}
inline const std::string& SlashingEvent::_internal_address() const {
  return _impl_.address_.Get();
}
inline void SlashingEvent::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* SlashingEvent::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* SlashingEvent::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.SlashingEvent.address)
  return _impl_.address_.Release();
}
inline void SlashingEvent::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.SlashingEvent.address)
}

// uint64 power = 4 [json_name = "power"];
inline void SlashingEvent::clear_power() {
  _impl_.power_ = ::uint64_t{0u};
}
inline ::uint64_t SlashingEvent::power() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.power)
  return _internal_power();
}
inline void SlashingEvent::set_power(::uint64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.power)
}
inline ::uint64_t SlashingEvent::_internal_power() const {
  return _impl_.power_;
}
inline void SlashingEvent::_internal_set_power(::uint64_t value) {
  ;
  _impl_.power_ = value;
}

// string reason = 5 [json_name = "reason"];
inline void SlashingEvent::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& SlashingEvent::reason() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SlashingEvent::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.reason)
}
inline std::string* SlashingEvent::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.SlashingEvent.reason)
  return _s;
}
inline const std::string& SlashingEvent::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void SlashingEvent::_internal_set_reason(const std::string& value) {
  ;


  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* SlashingEvent::_internal_mutable_reason() {
  ;
  return _impl_.reason_.Mutable( GetArenaForAllocation());
}
inline std::string* SlashingEvent::release_reason() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.SlashingEvent.reason)
  return _impl_.reason_.Release();
}
inline void SlashingEvent::set_allocated_reason(std::string* value) {
  _impl_.reason_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.SlashingEvent.reason)
}

// string jailed = 6 [json_name = "jailed"];
inline void SlashingEvent::clear_jailed() {
  _impl_.jailed_.ClearToEmpty();
}
inline const std::string& SlashingEvent::jailed() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.jailed)
  return _internal_jailed();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SlashingEvent::set_jailed(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.jailed_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.jailed)
}
inline std::string* SlashingEvent::mutable_jailed() {
  std::string* _s = _internal_mutable_jailed();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.SlashingEvent.jailed)
  return _s;
}
inline const std::string& SlashingEvent::_internal_jailed() const {
  return _impl_.jailed_.Get();
}
inline void SlashingEvent::_internal_set_jailed(const std::string& value) {
  ;


  _impl_.jailed_.Set(value, GetArenaForAllocation());
}
inline std::string* SlashingEvent::_internal_mutable_jailed() {
  ;
  return _impl_.jailed_.Mutable( GetArenaForAllocation());
}
inline std::string* SlashingEvent::release_jailed() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.SlashingEvent.jailed)
  return _impl_.jailed_.Release();
}
inline void SlashingEvent::set_allocated_jailed(std::string* value) {
  _impl_.jailed_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jailed_.IsDefault()) {
          _impl_.jailed_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.SlashingEvent.jailed)
}

// uint64 missed_blocks = 7 [json_name = "missedBlocks"];
inline void SlashingEvent::clear_missed_blocks() {
  _impl_.missed_blocks_ = ::uint64_t{0u};
}
inline ::uint64_t SlashingEvent::missed_blocks() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.SlashingEvent.missed_blocks)
  return _internal_missed_blocks();
}
inline void SlashingEvent::set_missed_blocks(::uint64_t value) {
  _internal_set_missed_blocks(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.SlashingEvent.missed_blocks)
}
inline ::uint64_t SlashingEvent::_internal_missed_blocks() const {
  return _impl_.missed_blocks_;
}
inline void SlashingEvent::_internal_set_missed_blocks(::uint64_t value) {
  ;
  _impl_.missed_blocks_ = value;
}

// -------------------------------------------------------------------

// GetValidatorRequest

// string address = 1 [json_name = "address"];
inline void GetValidatorRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetValidatorRequest::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorRequest.address)
}
inline std::string* GetValidatorRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorRequest.address)
  return _s;
}
inline const std::string& GetValidatorRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetValidatorRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorRequest.address)
  return _impl_.address_.Release();
}
inline void GetValidatorRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorRequest.address)
}

// -------------------------------------------------------------------

// GetValidatorResponse

// string s = 1 [json_name = "s"];
inline void GetValidatorResponse::clear_s() {
  _impl_.s_.ClearToEmpty();
}
inline const std::string& GetValidatorResponse::s() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorResponse.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorResponse::set_s(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorResponse.s)
}
inline std::string* GetValidatorResponse::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorResponse.s)
  return _s;
}
inline const std::string& GetValidatorResponse::_internal_s() const {
  return _impl_.s_.Get();
}
inline void GetValidatorResponse::_internal_set_s(const std::string& value) {
  ;


  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorResponse::_internal_mutable_s() {
  ;
  return _impl_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorResponse::release_s() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorResponse.s)
  return _impl_.s_.Release();
}
inline void GetValidatorResponse::set_allocated_s(std::string* value) {
  _impl_.s_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorResponse.s)
}

// string errmsg = 2 [json_name = "errmsg"];
inline void GetValidatorResponse::clear_errmsg() {
  _impl_.errmsg_.ClearToEmpty();
}
inline const std::string& GetValidatorResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorResponse.errmsg)
  return _internal_errmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorResponse::set_errmsg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.errmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorResponse.errmsg)
}
inline std::string* GetValidatorResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorResponse.errmsg)
  return _s;
}
inline const std::string& GetValidatorResponse::_internal_errmsg() const {
  return _impl_.errmsg_.Get();
}
inline void GetValidatorResponse::_internal_set_errmsg(const std::string& value) {
  ;


  _impl_.errmsg_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorResponse::_internal_mutable_errmsg() {
  ;
  return _impl_.errmsg_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorResponse.errmsg)
  return _impl_.errmsg_.Release();
}
inline void GetValidatorResponse::set_allocated_errmsg(std::string* value) {
  _impl_.errmsg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errmsg_.IsDefault()) {
          _impl_.errmsg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorResponse.errmsg)
}

// .injective_explorer_rpc.Validator data = 3 [json_name = "data"];
inline bool GetValidatorResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void GetValidatorResponse::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Validator& GetValidatorResponse::_internal_data() const {
  const ::injective_explorer_rpc::Validator* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Validator&>(
      ::injective_explorer_rpc::_Validator_default_instance_);
}
inline const ::injective_explorer_rpc::Validator& GetValidatorResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorResponse.data)
  return _internal_data();
}
inline void GetValidatorResponse::unsafe_arena_set_allocated_data(
    ::injective_explorer_rpc::Validator* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetValidatorResponse.data)
}
inline ::injective_explorer_rpc::Validator* GetValidatorResponse::release_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Validator* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Validator* GetValidatorResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorResponse.data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Validator* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Validator* GetValidatorResponse::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Validator>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::injective_explorer_rpc::Validator* GetValidatorResponse::mutable_data() {
  ::injective_explorer_rpc::Validator* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorResponse.data)
  return _msg;
}
inline void GetValidatorResponse::set_allocated_data(::injective_explorer_rpc::Validator* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorResponse.data)
}

// -------------------------------------------------------------------

// GetValidatorUptimeRequest

// string address = 1 [json_name = "address"];
inline void GetValidatorUptimeRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetValidatorUptimeRequest::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorUptimeRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorUptimeRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorUptimeRequest.address)
}
inline std::string* GetValidatorUptimeRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorUptimeRequest.address)
  return _s;
}
inline const std::string& GetValidatorUptimeRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetValidatorUptimeRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorUptimeRequest.address)
  return _impl_.address_.Release();
}
inline void GetValidatorUptimeRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorUptimeRequest.address)
}

// -------------------------------------------------------------------

// GetValidatorUptimeResponse

// string s = 1 [json_name = "s"];
inline void GetValidatorUptimeResponse::clear_s() {
  _impl_.s_.ClearToEmpty();
}
inline const std::string& GetValidatorUptimeResponse::s() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorUptimeResponse.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorUptimeResponse::set_s(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorUptimeResponse.s)
}
inline std::string* GetValidatorUptimeResponse::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorUptimeResponse.s)
  return _s;
}
inline const std::string& GetValidatorUptimeResponse::_internal_s() const {
  return _impl_.s_.Get();
}
inline void GetValidatorUptimeResponse::_internal_set_s(const std::string& value) {
  ;


  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeResponse::_internal_mutable_s() {
  ;
  return _impl_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeResponse::release_s() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorUptimeResponse.s)
  return _impl_.s_.Release();
}
inline void GetValidatorUptimeResponse::set_allocated_s(std::string* value) {
  _impl_.s_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorUptimeResponse.s)
}

// string errmsg = 2 [json_name = "errmsg"];
inline void GetValidatorUptimeResponse::clear_errmsg() {
  _impl_.errmsg_.ClearToEmpty();
}
inline const std::string& GetValidatorUptimeResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorUptimeResponse.errmsg)
  return _internal_errmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetValidatorUptimeResponse::set_errmsg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.errmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetValidatorUptimeResponse.errmsg)
}
inline std::string* GetValidatorUptimeResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorUptimeResponse.errmsg)
  return _s;
}
inline const std::string& GetValidatorUptimeResponse::_internal_errmsg() const {
  return _impl_.errmsg_.Get();
}
inline void GetValidatorUptimeResponse::_internal_set_errmsg(const std::string& value) {
  ;


  _impl_.errmsg_.Set(value, GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeResponse::_internal_mutable_errmsg() {
  ;
  return _impl_.errmsg_.Mutable( GetArenaForAllocation());
}
inline std::string* GetValidatorUptimeResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetValidatorUptimeResponse.errmsg)
  return _impl_.errmsg_.Release();
}
inline void GetValidatorUptimeResponse::set_allocated_errmsg(std::string* value) {
  _impl_.errmsg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errmsg_.IsDefault()) {
          _impl_.errmsg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetValidatorUptimeResponse.errmsg)
}

// repeated .injective_explorer_rpc.ValidatorUptime data = 3 [json_name = "data"];
inline int GetValidatorUptimeResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetValidatorUptimeResponse::data_size() const {
  return _internal_data_size();
}
inline void GetValidatorUptimeResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::ValidatorUptime* GetValidatorUptimeResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetValidatorUptimeResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >*
GetValidatorUptimeResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetValidatorUptimeResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::ValidatorUptime& GetValidatorUptimeResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::ValidatorUptime& GetValidatorUptimeResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetValidatorUptimeResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::ValidatorUptime* GetValidatorUptimeResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::ValidatorUptime* GetValidatorUptimeResponse::add_data() {
  ::injective_explorer_rpc::ValidatorUptime* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetValidatorUptimeResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ValidatorUptime >&
GetValidatorUptimeResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetValidatorUptimeResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>&
GetValidatorUptimeResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ValidatorUptime>*
GetValidatorUptimeResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// GetTxsRequest

// uint64 before = 1 [json_name = "before"];
inline void GetTxsRequest::clear_before() {
  _impl_.before_ = ::uint64_t{0u};
}
inline ::uint64_t GetTxsRequest::before() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.before)
  return _internal_before();
}
inline void GetTxsRequest::set_before(::uint64_t value) {
  _internal_set_before(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.before)
}
inline ::uint64_t GetTxsRequest::_internal_before() const {
  return _impl_.before_;
}
inline void GetTxsRequest::_internal_set_before(::uint64_t value) {
  ;
  _impl_.before_ = value;
}

// uint64 after = 2 [json_name = "after"];
inline void GetTxsRequest::clear_after() {
  _impl_.after_ = ::uint64_t{0u};
}
inline ::uint64_t GetTxsRequest::after() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.after)
  return _internal_after();
}
inline void GetTxsRequest::set_after(::uint64_t value) {
  _internal_set_after(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.after)
}
inline ::uint64_t GetTxsRequest::_internal_after() const {
  return _impl_.after_;
}
inline void GetTxsRequest::_internal_set_after(::uint64_t value) {
  ;
  _impl_.after_ = value;
}

// sint32 limit = 3 [json_name = "limit"];
inline void GetTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.limit)
  return _internal_limit();
}
inline void GetTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.limit)
}
inline ::int32_t GetTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 4 [json_name = "skip"];
inline void GetTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.skip)
  return _internal_skip();
}
inline void GetTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.skip)
}
inline ::uint64_t GetTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// string type = 5 [json_name = "type"];
inline void GetTxsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GetTxsRequest::type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxsRequest::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.type)
}
inline std::string* GetTxsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxsRequest.type)
  return _s;
}
inline const std::string& GetTxsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GetTxsRequest::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxsRequest::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxsRequest::release_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxsRequest.type)
  return _impl_.type_.Release();
}
inline void GetTxsRequest::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxsRequest.type)
}

// string module = 6 [json_name = "module"];
inline void GetTxsRequest::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& GetTxsRequest::module() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.module)
  return _internal_module();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxsRequest::set_module(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.module_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.module)
}
inline std::string* GetTxsRequest::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxsRequest.module)
  return _s;
}
inline const std::string& GetTxsRequest::_internal_module() const {
  return _impl_.module_.Get();
}
inline void GetTxsRequest::_internal_set_module(const std::string& value) {
  ;


  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxsRequest::_internal_mutable_module() {
  ;
  return _impl_.module_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxsRequest::release_module() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxsRequest.module)
  return _impl_.module_.Release();
}
inline void GetTxsRequest::set_allocated_module(std::string* value) {
  _impl_.module_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.module_.IsDefault()) {
          _impl_.module_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxsRequest.module)
}

// sint64 from_number = 7 [json_name = "fromNumber"];
inline void GetTxsRequest::clear_from_number() {
  _impl_.from_number_ = ::int64_t{0};
}
inline ::int64_t GetTxsRequest::from_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.from_number)
  return _internal_from_number();
}
inline void GetTxsRequest::set_from_number(::int64_t value) {
  _internal_set_from_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.from_number)
}
inline ::int64_t GetTxsRequest::_internal_from_number() const {
  return _impl_.from_number_;
}
inline void GetTxsRequest::_internal_set_from_number(::int64_t value) {
  ;
  _impl_.from_number_ = value;
}

// sint64 to_number = 8 [json_name = "toNumber"];
inline void GetTxsRequest::clear_to_number() {
  _impl_.to_number_ = ::int64_t{0};
}
inline ::int64_t GetTxsRequest::to_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsRequest.to_number)
  return _internal_to_number();
}
inline void GetTxsRequest::set_to_number(::int64_t value) {
  _internal_set_to_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxsRequest.to_number)
}
inline ::int64_t GetTxsRequest::_internal_to_number() const {
  return _impl_.to_number_;
}
inline void GetTxsRequest::_internal_set_to_number(::int64_t value) {
  ;
  _impl_.to_number_ = value;
}

// -------------------------------------------------------------------

// GetTxsResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetTxsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetTxsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetTxsResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetTxsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsResponse.paging)
  return _internal_paging();
}
inline void GetTxsResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetTxsResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetTxsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetTxsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetTxsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetTxsResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxsResponse.paging)
  return _msg;
}
inline void GetTxsResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxsResponse.paging)
}

// repeated .injective_explorer_rpc.TxData data = 2 [json_name = "data"];
inline int GetTxsResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetTxsResponse::data_size() const {
  return _internal_data_size();
}
inline void GetTxsResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::TxData* GetTxsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxsResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >*
GetTxsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetTxsResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::TxData& GetTxsResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::TxData& GetTxsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxsResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::TxData* GetTxsResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::TxData* GetTxsResponse::add_data() {
  ::injective_explorer_rpc::TxData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetTxsResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxData >&
GetTxsResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetTxsResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>&
GetTxsResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxData>*
GetTxsResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// GetTxByTxHashRequest

// string hash = 1 [json_name = "hash"];
inline void GetTxByTxHashRequest::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& GetTxByTxHashRequest::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxByTxHashRequest.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxByTxHashRequest::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxByTxHashRequest.hash)
}
inline std::string* GetTxByTxHashRequest::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxByTxHashRequest.hash)
  return _s;
}
inline const std::string& GetTxByTxHashRequest::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void GetTxByTxHashRequest::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxByTxHashRequest::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxByTxHashRequest::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxByTxHashRequest.hash)
  return _impl_.hash_.Release();
}
inline void GetTxByTxHashRequest::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxByTxHashRequest.hash)
}

// -------------------------------------------------------------------

// GetTxByTxHashResponse

// string s = 1 [json_name = "s"];
inline void GetTxByTxHashResponse::clear_s() {
  _impl_.s_.ClearToEmpty();
}
inline const std::string& GetTxByTxHashResponse::s() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxByTxHashResponse.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxByTxHashResponse::set_s(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.s_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxByTxHashResponse.s)
}
inline std::string* GetTxByTxHashResponse::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxByTxHashResponse.s)
  return _s;
}
inline const std::string& GetTxByTxHashResponse::_internal_s() const {
  return _impl_.s_.Get();
}
inline void GetTxByTxHashResponse::_internal_set_s(const std::string& value) {
  ;


  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxByTxHashResponse::_internal_mutable_s() {
  ;
  return _impl_.s_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxByTxHashResponse::release_s() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxByTxHashResponse.s)
  return _impl_.s_.Release();
}
inline void GetTxByTxHashResponse::set_allocated_s(std::string* value) {
  _impl_.s_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxByTxHashResponse.s)
}

// string errmsg = 2 [json_name = "errmsg"];
inline void GetTxByTxHashResponse::clear_errmsg() {
  _impl_.errmsg_.ClearToEmpty();
}
inline const std::string& GetTxByTxHashResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxByTxHashResponse.errmsg)
  return _internal_errmsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetTxByTxHashResponse::set_errmsg(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.errmsg_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetTxByTxHashResponse.errmsg)
}
inline std::string* GetTxByTxHashResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxByTxHashResponse.errmsg)
  return _s;
}
inline const std::string& GetTxByTxHashResponse::_internal_errmsg() const {
  return _impl_.errmsg_.Get();
}
inline void GetTxByTxHashResponse::_internal_set_errmsg(const std::string& value) {
  ;


  _impl_.errmsg_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxByTxHashResponse::_internal_mutable_errmsg() {
  ;
  return _impl_.errmsg_.Mutable( GetArenaForAllocation());
}
inline std::string* GetTxByTxHashResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxByTxHashResponse.errmsg)
  return _impl_.errmsg_.Release();
}
inline void GetTxByTxHashResponse::set_allocated_errmsg(std::string* value) {
  _impl_.errmsg_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errmsg_.IsDefault()) {
          _impl_.errmsg_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxByTxHashResponse.errmsg)
}

// .injective_explorer_rpc.TxDetailData data = 3 [json_name = "data"];
inline bool GetTxByTxHashResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void GetTxByTxHashResponse::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::TxDetailData& GetTxByTxHashResponse::_internal_data() const {
  const ::injective_explorer_rpc::TxDetailData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::TxDetailData&>(
      ::injective_explorer_rpc::_TxDetailData_default_instance_);
}
inline const ::injective_explorer_rpc::TxDetailData& GetTxByTxHashResponse::data() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetTxByTxHashResponse.data)
  return _internal_data();
}
inline void GetTxByTxHashResponse::unsafe_arena_set_allocated_data(
    ::injective_explorer_rpc::TxDetailData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetTxByTxHashResponse.data)
}
inline ::injective_explorer_rpc::TxDetailData* GetTxByTxHashResponse::release_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::TxDetailData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::TxDetailData* GetTxByTxHashResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetTxByTxHashResponse.data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::TxDetailData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::TxDetailData* GetTxByTxHashResponse::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::TxDetailData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::injective_explorer_rpc::TxDetailData* GetTxByTxHashResponse::mutable_data() {
  ::injective_explorer_rpc::TxDetailData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetTxByTxHashResponse.data)
  return _msg;
}
inline void GetTxByTxHashResponse::set_allocated_data(::injective_explorer_rpc::TxDetailData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetTxByTxHashResponse.data)
}

// -------------------------------------------------------------------

// GetPeggyDepositTxsRequest

// string sender = 1 [json_name = "sender"];
inline void GetPeggyDepositTxsRequest::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& GetPeggyDepositTxsRequest::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyDepositTxsRequest.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPeggyDepositTxsRequest::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyDepositTxsRequest.sender)
}
inline std::string* GetPeggyDepositTxsRequest::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyDepositTxsRequest.sender)
  return _s;
}
inline const std::string& GetPeggyDepositTxsRequest::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void GetPeggyDepositTxsRequest::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPeggyDepositTxsRequest::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* GetPeggyDepositTxsRequest::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetPeggyDepositTxsRequest.sender)
  return _impl_.sender_.Release();
}
inline void GetPeggyDepositTxsRequest::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetPeggyDepositTxsRequest.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void GetPeggyDepositTxsRequest::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& GetPeggyDepositTxsRequest::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyDepositTxsRequest.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPeggyDepositTxsRequest::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyDepositTxsRequest.receiver)
}
inline std::string* GetPeggyDepositTxsRequest::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyDepositTxsRequest.receiver)
  return _s;
}
inline const std::string& GetPeggyDepositTxsRequest::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void GetPeggyDepositTxsRequest::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPeggyDepositTxsRequest::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* GetPeggyDepositTxsRequest::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetPeggyDepositTxsRequest.receiver)
  return _impl_.receiver_.Release();
}
inline void GetPeggyDepositTxsRequest::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetPeggyDepositTxsRequest.receiver)
}

// sint32 limit = 3 [json_name = "limit"];
inline void GetPeggyDepositTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetPeggyDepositTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyDepositTxsRequest.limit)
  return _internal_limit();
}
inline void GetPeggyDepositTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyDepositTxsRequest.limit)
}
inline ::int32_t GetPeggyDepositTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetPeggyDepositTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 4 [json_name = "skip"];
inline void GetPeggyDepositTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetPeggyDepositTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyDepositTxsRequest.skip)
  return _internal_skip();
}
inline void GetPeggyDepositTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyDepositTxsRequest.skip)
}
inline ::uint64_t GetPeggyDepositTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetPeggyDepositTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// -------------------------------------------------------------------

// GetPeggyDepositTxsResponse

// repeated .injective_explorer_rpc.PeggyDepositTx field = 1 [json_name = "field"];
inline int GetPeggyDepositTxsResponse::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int GetPeggyDepositTxsResponse::field_size() const {
  return _internal_field_size();
}
inline void GetPeggyDepositTxsResponse::clear_field() {
  _internal_mutable_field()->Clear();
}
inline ::injective_explorer_rpc::PeggyDepositTx* GetPeggyDepositTxsResponse::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyDepositTxsResponse.field)
  return _internal_mutable_field()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyDepositTx >*
GetPeggyDepositTxsResponse::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetPeggyDepositTxsResponse.field)
  return _internal_mutable_field();
}
inline const ::injective_explorer_rpc::PeggyDepositTx& GetPeggyDepositTxsResponse::_internal_field(int index) const {
  return _internal_field().Get(index);
}
inline const ::injective_explorer_rpc::PeggyDepositTx& GetPeggyDepositTxsResponse::field(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyDepositTxsResponse.field)
  return _internal_field(index);
}
inline ::injective_explorer_rpc::PeggyDepositTx* GetPeggyDepositTxsResponse::_internal_add_field() {
  return _internal_mutable_field()->Add();
}
inline ::injective_explorer_rpc::PeggyDepositTx* GetPeggyDepositTxsResponse::add_field() {
  ::injective_explorer_rpc::PeggyDepositTx* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetPeggyDepositTxsResponse.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyDepositTx >&
GetPeggyDepositTxsResponse::field() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetPeggyDepositTxsResponse.field)
  return _internal_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyDepositTx>&
GetPeggyDepositTxsResponse::_internal_field() const {
  return _impl_.field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyDepositTx>*
GetPeggyDepositTxsResponse::_internal_mutable_field() {
  return &_impl_.field_;
}

// -------------------------------------------------------------------

// PeggyDepositTx

// string sender = 1 [json_name = "sender"];
inline void PeggyDepositTx::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.sender)
}
inline std::string* PeggyDepositTx::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.sender)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PeggyDepositTx::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.sender)
  return _impl_.sender_.Release();
}
inline void PeggyDepositTx::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void PeggyDepositTx::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.receiver)
}
inline std::string* PeggyDepositTx::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.receiver)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void PeggyDepositTx::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.receiver)
  return _impl_.receiver_.Release();
}
inline void PeggyDepositTx::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.receiver)
}

// uint64 event_nonce = 3 [json_name = "eventNonce"];
inline void PeggyDepositTx::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyDepositTx::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.event_nonce)
  return _internal_event_nonce();
}
inline void PeggyDepositTx::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.event_nonce)
}
inline ::uint64_t PeggyDepositTx::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void PeggyDepositTx::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 4 [json_name = "eventHeight"];
inline void PeggyDepositTx::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyDepositTx::event_height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.event_height)
  return _internal_event_height();
}
inline void PeggyDepositTx::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.event_height)
}
inline ::uint64_t PeggyDepositTx::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void PeggyDepositTx::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// string amount = 5 [json_name = "amount"];
inline void PeggyDepositTx::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::amount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.amount)
}
inline std::string* PeggyDepositTx::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.amount)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void PeggyDepositTx::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_amount() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.amount)
  return _impl_.amount_.Release();
}
inline void PeggyDepositTx::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.amount)
}

// string denom = 6 [json_name = "denom"];
inline void PeggyDepositTx::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::denom() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.denom)
}
inline std::string* PeggyDepositTx::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.denom)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void PeggyDepositTx::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_denom() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.denom)
  return _impl_.denom_.Release();
}
inline void PeggyDepositTx::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.denom)
}

// string orchestrator_address = 7 [json_name = "orchestratorAddress"];
inline void PeggyDepositTx::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.orchestrator_address)
}
inline std::string* PeggyDepositTx::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.orchestrator_address)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void PeggyDepositTx::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void PeggyDepositTx::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.orchestrator_address)
}

// string state = 8 [json_name = "state"];
inline void PeggyDepositTx::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::state() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.state)
}
inline std::string* PeggyDepositTx::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.state)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_state() const {
  return _impl_.state_.Get();
}
inline void PeggyDepositTx::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_state() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.state)
  return _impl_.state_.Release();
}
inline void PeggyDepositTx::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.state)
}

// sint32 claim_type = 9 [json_name = "claimType"];
inline void PeggyDepositTx::clear_claim_type() {
  _impl_.claim_type_ = 0;
}
inline ::int32_t PeggyDepositTx::claim_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.claim_type)
  return _internal_claim_type();
}
inline void PeggyDepositTx::set_claim_type(::int32_t value) {
  _internal_set_claim_type(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.claim_type)
}
inline ::int32_t PeggyDepositTx::_internal_claim_type() const {
  return _impl_.claim_type_;
}
inline void PeggyDepositTx::_internal_set_claim_type(::int32_t value) {
  ;
  _impl_.claim_type_ = value;
}

// repeated string tx_hashes = 10 [json_name = "txHashes"];
inline int PeggyDepositTx::_internal_tx_hashes_size() const {
  return _impl_.tx_hashes_.size();
}
inline int PeggyDepositTx::tx_hashes_size() const {
  return _internal_tx_hashes_size();
}
inline void PeggyDepositTx::clear_tx_hashes() {
  _internal_mutable_tx_hashes()->Clear();
}
inline std::string* PeggyDepositTx::add_tx_hashes() {
  std::string* _s = _internal_add_tx_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
  return _s;
}
inline const std::string& PeggyDepositTx::tx_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
  return _internal_tx_hashes(index);
}
inline std::string* PeggyDepositTx::mutable_tx_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
  return _internal_mutable_tx_hashes()->Mutable(index);
}
inline void PeggyDepositTx::set_tx_hashes(int index, const std::string& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::set_tx_hashes(int index, std::string&& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::set_tx_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::set_tx_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::set_tx_hashes(int index, absl::string_view value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::add_tx_hashes(const std::string& value) {
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::add_tx_hashes(std::string&& value) {
  _internal_mutable_tx_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::add_tx_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::add_tx_hashes(const char* value, std::size_t size) {
  _internal_mutable_tx_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline void PeggyDepositTx::add_tx_hashes(absl::string_view value) {
  _internal_mutable_tx_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeggyDepositTx::tx_hashes() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
  return _internal_tx_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PeggyDepositTx::mutable_tx_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.PeggyDepositTx.tx_hashes)
  return _internal_mutable_tx_hashes();
}
inline const std::string& PeggyDepositTx::_internal_tx_hashes(int index) const {
  return _internal_tx_hashes().Get(index);
}
inline std::string* PeggyDepositTx::_internal_add_tx_hashes() {
  return _internal_mutable_tx_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeggyDepositTx::_internal_tx_hashes() const {
  return _impl_.tx_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeggyDepositTx::_internal_mutable_tx_hashes() {
  return &_impl_.tx_hashes_;
}

// string created_at = 11 [json_name = "createdAt"];
inline void PeggyDepositTx::clear_created_at() {
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::created_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.created_at)
}
inline std::string* PeggyDepositTx::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.created_at)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_created_at() const {
  return _impl_.created_at_.Get();
}
inline void PeggyDepositTx::_internal_set_created_at(const std::string& value) {
  ;


  _impl_.created_at_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_created_at() {
  ;
  return _impl_.created_at_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_created_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.created_at)
  return _impl_.created_at_.Release();
}
inline void PeggyDepositTx::set_allocated_created_at(std::string* value) {
  _impl_.created_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.created_at_.IsDefault()) {
          _impl_.created_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.created_at)
}

// string updated_at = 12 [json_name = "updatedAt"];
inline void PeggyDepositTx::clear_updated_at() {
  _impl_.updated_at_.ClearToEmpty();
}
inline const std::string& PeggyDepositTx::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyDepositTx.updated_at)
  return _internal_updated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyDepositTx::set_updated_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.updated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyDepositTx.updated_at)
}
inline std::string* PeggyDepositTx::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyDepositTx.updated_at)
  return _s;
}
inline const std::string& PeggyDepositTx::_internal_updated_at() const {
  return _impl_.updated_at_.Get();
}
inline void PeggyDepositTx::_internal_set_updated_at(const std::string& value) {
  ;


  _impl_.updated_at_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::_internal_mutable_updated_at() {
  ;
  return _impl_.updated_at_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyDepositTx::release_updated_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyDepositTx.updated_at)
  return _impl_.updated_at_.Release();
}
inline void PeggyDepositTx::set_allocated_updated_at(std::string* value) {
  _impl_.updated_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.updated_at_.IsDefault()) {
          _impl_.updated_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyDepositTx.updated_at)
}

// -------------------------------------------------------------------

// GetPeggyWithdrawalTxsRequest

// string sender = 1 [json_name = "sender"];
inline void GetPeggyWithdrawalTxsRequest::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& GetPeggyWithdrawalTxsRequest::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPeggyWithdrawalTxsRequest::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.sender)
}
inline std::string* GetPeggyWithdrawalTxsRequest::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.sender)
  return _s;
}
inline const std::string& GetPeggyWithdrawalTxsRequest::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void GetPeggyWithdrawalTxsRequest::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPeggyWithdrawalTxsRequest::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* GetPeggyWithdrawalTxsRequest::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.sender)
  return _impl_.sender_.Release();
}
inline void GetPeggyWithdrawalTxsRequest::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void GetPeggyWithdrawalTxsRequest::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& GetPeggyWithdrawalTxsRequest::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPeggyWithdrawalTxsRequest::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.receiver)
}
inline std::string* GetPeggyWithdrawalTxsRequest::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.receiver)
  return _s;
}
inline const std::string& GetPeggyWithdrawalTxsRequest::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void GetPeggyWithdrawalTxsRequest::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPeggyWithdrawalTxsRequest::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* GetPeggyWithdrawalTxsRequest::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.receiver)
  return _impl_.receiver_.Release();
}
inline void GetPeggyWithdrawalTxsRequest::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.receiver)
}

// sint32 limit = 3 [json_name = "limit"];
inline void GetPeggyWithdrawalTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetPeggyWithdrawalTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.limit)
  return _internal_limit();
}
inline void GetPeggyWithdrawalTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.limit)
}
inline ::int32_t GetPeggyWithdrawalTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetPeggyWithdrawalTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 4 [json_name = "skip"];
inline void GetPeggyWithdrawalTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetPeggyWithdrawalTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.skip)
  return _internal_skip();
}
inline void GetPeggyWithdrawalTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetPeggyWithdrawalTxsRequest.skip)
}
inline ::uint64_t GetPeggyWithdrawalTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetPeggyWithdrawalTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// -------------------------------------------------------------------

// GetPeggyWithdrawalTxsResponse

// repeated .injective_explorer_rpc.PeggyWithdrawalTx field = 1 [json_name = "field"];
inline int GetPeggyWithdrawalTxsResponse::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int GetPeggyWithdrawalTxsResponse::field_size() const {
  return _internal_field_size();
}
inline void GetPeggyWithdrawalTxsResponse::clear_field() {
  _internal_mutable_field()->Clear();
}
inline ::injective_explorer_rpc::PeggyWithdrawalTx* GetPeggyWithdrawalTxsResponse::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse.field)
  return _internal_mutable_field()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyWithdrawalTx >*
GetPeggyWithdrawalTxsResponse::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse.field)
  return _internal_mutable_field();
}
inline const ::injective_explorer_rpc::PeggyWithdrawalTx& GetPeggyWithdrawalTxsResponse::_internal_field(int index) const {
  return _internal_field().Get(index);
}
inline const ::injective_explorer_rpc::PeggyWithdrawalTx& GetPeggyWithdrawalTxsResponse::field(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse.field)
  return _internal_field(index);
}
inline ::injective_explorer_rpc::PeggyWithdrawalTx* GetPeggyWithdrawalTxsResponse::_internal_add_field() {
  return _internal_mutable_field()->Add();
}
inline ::injective_explorer_rpc::PeggyWithdrawalTx* GetPeggyWithdrawalTxsResponse::add_field() {
  ::injective_explorer_rpc::PeggyWithdrawalTx* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::PeggyWithdrawalTx >&
GetPeggyWithdrawalTxsResponse::field() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetPeggyWithdrawalTxsResponse.field)
  return _internal_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyWithdrawalTx>&
GetPeggyWithdrawalTxsResponse::_internal_field() const {
  return _impl_.field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::PeggyWithdrawalTx>*
GetPeggyWithdrawalTxsResponse::_internal_mutable_field() {
  return &_impl_.field_;
}

// -------------------------------------------------------------------

// PeggyWithdrawalTx

// string sender = 1 [json_name = "sender"];
inline void PeggyWithdrawalTx::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.sender)
}
inline std::string* PeggyWithdrawalTx::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.sender)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.sender)
  return _impl_.sender_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void PeggyWithdrawalTx::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.receiver)
}
inline std::string* PeggyWithdrawalTx::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.receiver)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.receiver)
  return _impl_.receiver_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.receiver)
}

// string amount = 3 [json_name = "amount"];
inline void PeggyWithdrawalTx::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::amount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.amount)
}
inline std::string* PeggyWithdrawalTx::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.amount)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_amount() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.amount)
  return _impl_.amount_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.amount)
}

// string denom = 4 [json_name = "denom"];
inline void PeggyWithdrawalTx::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::denom() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.denom)
}
inline std::string* PeggyWithdrawalTx::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.denom)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_denom() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.denom)
  return _impl_.denom_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.denom)
}

// string bridge_fee = 5 [json_name = "bridgeFee"];
inline void PeggyWithdrawalTx::clear_bridge_fee() {
  _impl_.bridge_fee_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::bridge_fee() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.bridge_fee)
  return _internal_bridge_fee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_bridge_fee(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.bridge_fee_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.bridge_fee)
}
inline std::string* PeggyWithdrawalTx::mutable_bridge_fee() {
  std::string* _s = _internal_mutable_bridge_fee();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.bridge_fee)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_bridge_fee() const {
  return _impl_.bridge_fee_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_bridge_fee(const std::string& value) {
  ;


  _impl_.bridge_fee_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_bridge_fee() {
  ;
  return _impl_.bridge_fee_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_bridge_fee() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.bridge_fee)
  return _impl_.bridge_fee_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_bridge_fee(std::string* value) {
  _impl_.bridge_fee_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bridge_fee_.IsDefault()) {
          _impl_.bridge_fee_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.bridge_fee)
}

// uint64 outgoing_tx_id = 6 [json_name = "outgoingTxId"];
inline void PeggyWithdrawalTx::clear_outgoing_tx_id() {
  _impl_.outgoing_tx_id_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyWithdrawalTx::outgoing_tx_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.outgoing_tx_id)
  return _internal_outgoing_tx_id();
}
inline void PeggyWithdrawalTx::set_outgoing_tx_id(::uint64_t value) {
  _internal_set_outgoing_tx_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.outgoing_tx_id)
}
inline ::uint64_t PeggyWithdrawalTx::_internal_outgoing_tx_id() const {
  return _impl_.outgoing_tx_id_;
}
inline void PeggyWithdrawalTx::_internal_set_outgoing_tx_id(::uint64_t value) {
  ;
  _impl_.outgoing_tx_id_ = value;
}

// uint64 batch_timeout = 7 [json_name = "batchTimeout"];
inline void PeggyWithdrawalTx::clear_batch_timeout() {
  _impl_.batch_timeout_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyWithdrawalTx::batch_timeout() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.batch_timeout)
  return _internal_batch_timeout();
}
inline void PeggyWithdrawalTx::set_batch_timeout(::uint64_t value) {
  _internal_set_batch_timeout(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.batch_timeout)
}
inline ::uint64_t PeggyWithdrawalTx::_internal_batch_timeout() const {
  return _impl_.batch_timeout_;
}
inline void PeggyWithdrawalTx::_internal_set_batch_timeout(::uint64_t value) {
  ;
  _impl_.batch_timeout_ = value;
}

// uint64 batch_nonce = 8 [json_name = "batchNonce"];
inline void PeggyWithdrawalTx::clear_batch_nonce() {
  _impl_.batch_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyWithdrawalTx::batch_nonce() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.batch_nonce)
  return _internal_batch_nonce();
}
inline void PeggyWithdrawalTx::set_batch_nonce(::uint64_t value) {
  _internal_set_batch_nonce(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.batch_nonce)
}
inline ::uint64_t PeggyWithdrawalTx::_internal_batch_nonce() const {
  return _impl_.batch_nonce_;
}
inline void PeggyWithdrawalTx::_internal_set_batch_nonce(::uint64_t value) {
  ;
  _impl_.batch_nonce_ = value;
}

// string orchestrator_address = 9 [json_name = "orchestratorAddress"];
inline void PeggyWithdrawalTx::clear_orchestrator_address() {
  _impl_.orchestrator_address_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::orchestrator_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.orchestrator_address)
  return _internal_orchestrator_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_orchestrator_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.orchestrator_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.orchestrator_address)
}
inline std::string* PeggyWithdrawalTx::mutable_orchestrator_address() {
  std::string* _s = _internal_mutable_orchestrator_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.orchestrator_address)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_orchestrator_address() const {
  return _impl_.orchestrator_address_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_orchestrator_address(const std::string& value) {
  ;


  _impl_.orchestrator_address_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_orchestrator_address() {
  ;
  return _impl_.orchestrator_address_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_orchestrator_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.orchestrator_address)
  return _impl_.orchestrator_address_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_orchestrator_address(std::string* value) {
  _impl_.orchestrator_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orchestrator_address_.IsDefault()) {
          _impl_.orchestrator_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.orchestrator_address)
}

// uint64 event_nonce = 10 [json_name = "eventNonce"];
inline void PeggyWithdrawalTx::clear_event_nonce() {
  _impl_.event_nonce_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyWithdrawalTx::event_nonce() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.event_nonce)
  return _internal_event_nonce();
}
inline void PeggyWithdrawalTx::set_event_nonce(::uint64_t value) {
  _internal_set_event_nonce(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.event_nonce)
}
inline ::uint64_t PeggyWithdrawalTx::_internal_event_nonce() const {
  return _impl_.event_nonce_;
}
inline void PeggyWithdrawalTx::_internal_set_event_nonce(::uint64_t value) {
  ;
  _impl_.event_nonce_ = value;
}

// uint64 event_height = 11 [json_name = "eventHeight"];
inline void PeggyWithdrawalTx::clear_event_height() {
  _impl_.event_height_ = ::uint64_t{0u};
}
inline ::uint64_t PeggyWithdrawalTx::event_height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.event_height)
  return _internal_event_height();
}
inline void PeggyWithdrawalTx::set_event_height(::uint64_t value) {
  _internal_set_event_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.event_height)
}
inline ::uint64_t PeggyWithdrawalTx::_internal_event_height() const {
  return _impl_.event_height_;
}
inline void PeggyWithdrawalTx::_internal_set_event_height(::uint64_t value) {
  ;
  _impl_.event_height_ = value;
}

// string state = 12 [json_name = "state"];
inline void PeggyWithdrawalTx::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::state() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.state)
}
inline std::string* PeggyWithdrawalTx::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.state)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_state() const {
  return _impl_.state_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_state() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.state)
  return _impl_.state_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.state)
}

// sint32 claim_type = 13 [json_name = "claimType"];
inline void PeggyWithdrawalTx::clear_claim_type() {
  _impl_.claim_type_ = 0;
}
inline ::int32_t PeggyWithdrawalTx::claim_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.claim_type)
  return _internal_claim_type();
}
inline void PeggyWithdrawalTx::set_claim_type(::int32_t value) {
  _internal_set_claim_type(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.claim_type)
}
inline ::int32_t PeggyWithdrawalTx::_internal_claim_type() const {
  return _impl_.claim_type_;
}
inline void PeggyWithdrawalTx::_internal_set_claim_type(::int32_t value) {
  ;
  _impl_.claim_type_ = value;
}

// repeated string tx_hashes = 14 [json_name = "txHashes"];
inline int PeggyWithdrawalTx::_internal_tx_hashes_size() const {
  return _impl_.tx_hashes_.size();
}
inline int PeggyWithdrawalTx::tx_hashes_size() const {
  return _internal_tx_hashes_size();
}
inline void PeggyWithdrawalTx::clear_tx_hashes() {
  _internal_mutable_tx_hashes()->Clear();
}
inline std::string* PeggyWithdrawalTx::add_tx_hashes() {
  std::string* _s = _internal_add_tx_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::tx_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
  return _internal_tx_hashes(index);
}
inline std::string* PeggyWithdrawalTx::mutable_tx_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
  return _internal_mutable_tx_hashes()->Mutable(index);
}
inline void PeggyWithdrawalTx::set_tx_hashes(int index, const std::string& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::set_tx_hashes(int index, std::string&& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::set_tx_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::set_tx_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::set_tx_hashes(int index, absl::string_view value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::add_tx_hashes(const std::string& value) {
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::add_tx_hashes(std::string&& value) {
  _internal_mutable_tx_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::add_tx_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::add_tx_hashes(const char* value, std::size_t size) {
  _internal_mutable_tx_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline void PeggyWithdrawalTx::add_tx_hashes(absl::string_view value) {
  _internal_mutable_tx_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeggyWithdrawalTx::tx_hashes() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
  return _internal_tx_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* PeggyWithdrawalTx::mutable_tx_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.PeggyWithdrawalTx.tx_hashes)
  return _internal_mutable_tx_hashes();
}
inline const std::string& PeggyWithdrawalTx::_internal_tx_hashes(int index) const {
  return _internal_tx_hashes().Get(index);
}
inline std::string* PeggyWithdrawalTx::_internal_add_tx_hashes() {
  return _internal_mutable_tx_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeggyWithdrawalTx::_internal_tx_hashes() const {
  return _impl_.tx_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeggyWithdrawalTx::_internal_mutable_tx_hashes() {
  return &_impl_.tx_hashes_;
}

// string created_at = 15 [json_name = "createdAt"];
inline void PeggyWithdrawalTx::clear_created_at() {
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::created_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.created_at)
}
inline std::string* PeggyWithdrawalTx::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.created_at)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_created_at() const {
  return _impl_.created_at_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_created_at(const std::string& value) {
  ;


  _impl_.created_at_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_created_at() {
  ;
  return _impl_.created_at_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_created_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.created_at)
  return _impl_.created_at_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_created_at(std::string* value) {
  _impl_.created_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.created_at_.IsDefault()) {
          _impl_.created_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.created_at)
}

// string updated_at = 16 [json_name = "updatedAt"];
inline void PeggyWithdrawalTx::clear_updated_at() {
  _impl_.updated_at_.ClearToEmpty();
}
inline const std::string& PeggyWithdrawalTx::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.PeggyWithdrawalTx.updated_at)
  return _internal_updated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PeggyWithdrawalTx::set_updated_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.updated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.PeggyWithdrawalTx.updated_at)
}
inline std::string* PeggyWithdrawalTx::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.PeggyWithdrawalTx.updated_at)
  return _s;
}
inline const std::string& PeggyWithdrawalTx::_internal_updated_at() const {
  return _impl_.updated_at_.Get();
}
inline void PeggyWithdrawalTx::_internal_set_updated_at(const std::string& value) {
  ;


  _impl_.updated_at_.Set(value, GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::_internal_mutable_updated_at() {
  ;
  return _impl_.updated_at_.Mutable( GetArenaForAllocation());
}
inline std::string* PeggyWithdrawalTx::release_updated_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.PeggyWithdrawalTx.updated_at)
  return _impl_.updated_at_.Release();
}
inline void PeggyWithdrawalTx::set_allocated_updated_at(std::string* value) {
  _impl_.updated_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.updated_at_.IsDefault()) {
          _impl_.updated_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.PeggyWithdrawalTx.updated_at)
}

// -------------------------------------------------------------------

// GetIBCTransferTxsRequest

// string sender = 1 [json_name = "sender"];
inline void GetIBCTransferTxsRequest::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.sender)
}
inline std::string* GetIBCTransferTxsRequest::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.sender)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.sender)
  return _impl_.sender_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void GetIBCTransferTxsRequest::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.receiver)
}
inline std::string* GetIBCTransferTxsRequest::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.receiver)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.receiver)
  return _impl_.receiver_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.receiver)
}

// string src_channel = 3 [json_name = "srcChannel"];
inline void GetIBCTransferTxsRequest::clear_src_channel() {
  _impl_.src_channel_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::src_channel() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.src_channel)
  return _internal_src_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_src_channel(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_channel_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.src_channel)
}
inline std::string* GetIBCTransferTxsRequest::mutable_src_channel() {
  std::string* _s = _internal_mutable_src_channel();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.src_channel)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_src_channel() const {
  return _impl_.src_channel_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_src_channel(const std::string& value) {
  ;


  _impl_.src_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_src_channel() {
  ;
  return _impl_.src_channel_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_src_channel() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.src_channel)
  return _impl_.src_channel_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_src_channel(std::string* value) {
  _impl_.src_channel_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_channel_.IsDefault()) {
          _impl_.src_channel_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.src_channel)
}

// string src_port = 4 [json_name = "srcPort"];
inline void GetIBCTransferTxsRequest::clear_src_port() {
  _impl_.src_port_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::src_port() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.src_port)
  return _internal_src_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_src_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.src_port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.src_port)
}
inline std::string* GetIBCTransferTxsRequest::mutable_src_port() {
  std::string* _s = _internal_mutable_src_port();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.src_port)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_src_port() const {
  return _impl_.src_port_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_src_port(const std::string& value) {
  ;


  _impl_.src_port_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_src_port() {
  ;
  return _impl_.src_port_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_src_port() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.src_port)
  return _impl_.src_port_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_src_port(std::string* value) {
  _impl_.src_port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.src_port_.IsDefault()) {
          _impl_.src_port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.src_port)
}

// string dest_channel = 5 [json_name = "destChannel"];
inline void GetIBCTransferTxsRequest::clear_dest_channel() {
  _impl_.dest_channel_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::dest_channel() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_channel)
  return _internal_dest_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_dest_channel(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dest_channel_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_channel)
}
inline std::string* GetIBCTransferTxsRequest::mutable_dest_channel() {
  std::string* _s = _internal_mutable_dest_channel();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_channel)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_dest_channel() const {
  return _impl_.dest_channel_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_dest_channel(const std::string& value) {
  ;


  _impl_.dest_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_dest_channel() {
  ;
  return _impl_.dest_channel_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_dest_channel() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_channel)
  return _impl_.dest_channel_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_dest_channel(std::string* value) {
  _impl_.dest_channel_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dest_channel_.IsDefault()) {
          _impl_.dest_channel_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_channel)
}

// string dest_port = 6 [json_name = "destPort"];
inline void GetIBCTransferTxsRequest::clear_dest_port() {
  _impl_.dest_port_.ClearToEmpty();
}
inline const std::string& GetIBCTransferTxsRequest::dest_port() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_port)
  return _internal_dest_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIBCTransferTxsRequest::set_dest_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dest_port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_port)
}
inline std::string* GetIBCTransferTxsRequest::mutable_dest_port() {
  std::string* _s = _internal_mutable_dest_port();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_port)
  return _s;
}
inline const std::string& GetIBCTransferTxsRequest::_internal_dest_port() const {
  return _impl_.dest_port_.Get();
}
inline void GetIBCTransferTxsRequest::_internal_set_dest_port(const std::string& value) {
  ;


  _impl_.dest_port_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::_internal_mutable_dest_port() {
  ;
  return _impl_.dest_port_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIBCTransferTxsRequest::release_dest_port() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_port)
  return _impl_.dest_port_.Release();
}
inline void GetIBCTransferTxsRequest::set_allocated_dest_port(std::string* value) {
  _impl_.dest_port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dest_port_.IsDefault()) {
          _impl_.dest_port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetIBCTransferTxsRequest.dest_port)
}

// sint32 limit = 7 [json_name = "limit"];
inline void GetIBCTransferTxsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetIBCTransferTxsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.limit)
  return _internal_limit();
}
inline void GetIBCTransferTxsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.limit)
}
inline ::int32_t GetIBCTransferTxsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetIBCTransferTxsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// uint64 skip = 8 [json_name = "skip"];
inline void GetIBCTransferTxsRequest::clear_skip() {
  _impl_.skip_ = ::uint64_t{0u};
}
inline ::uint64_t GetIBCTransferTxsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsRequest.skip)
  return _internal_skip();
}
inline void GetIBCTransferTxsRequest::set_skip(::uint64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetIBCTransferTxsRequest.skip)
}
inline ::uint64_t GetIBCTransferTxsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetIBCTransferTxsRequest::_internal_set_skip(::uint64_t value) {
  ;
  _impl_.skip_ = value;
}

// -------------------------------------------------------------------

// GetIBCTransferTxsResponse

// repeated .injective_explorer_rpc.IBCTransferTx field = 1 [json_name = "field"];
inline int GetIBCTransferTxsResponse::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int GetIBCTransferTxsResponse::field_size() const {
  return _internal_field_size();
}
inline void GetIBCTransferTxsResponse::clear_field() {
  _internal_mutable_field()->Clear();
}
inline ::injective_explorer_rpc::IBCTransferTx* GetIBCTransferTxsResponse::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetIBCTransferTxsResponse.field)
  return _internal_mutable_field()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::IBCTransferTx >*
GetIBCTransferTxsResponse::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetIBCTransferTxsResponse.field)
  return _internal_mutable_field();
}
inline const ::injective_explorer_rpc::IBCTransferTx& GetIBCTransferTxsResponse::_internal_field(int index) const {
  return _internal_field().Get(index);
}
inline const ::injective_explorer_rpc::IBCTransferTx& GetIBCTransferTxsResponse::field(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetIBCTransferTxsResponse.field)
  return _internal_field(index);
}
inline ::injective_explorer_rpc::IBCTransferTx* GetIBCTransferTxsResponse::_internal_add_field() {
  return _internal_mutable_field()->Add();
}
inline ::injective_explorer_rpc::IBCTransferTx* GetIBCTransferTxsResponse::add_field() {
  ::injective_explorer_rpc::IBCTransferTx* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetIBCTransferTxsResponse.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::IBCTransferTx >&
GetIBCTransferTxsResponse::field() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetIBCTransferTxsResponse.field)
  return _internal_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::IBCTransferTx>&
GetIBCTransferTxsResponse::_internal_field() const {
  return _impl_.field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::IBCTransferTx>*
GetIBCTransferTxsResponse::_internal_mutable_field() {
  return &_impl_.field_;
}

// -------------------------------------------------------------------

// IBCTransferTx

// string sender = 1 [json_name = "sender"];
inline void IBCTransferTx::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::sender() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_sender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.sender)
}
inline std::string* IBCTransferTx::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.sender)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void IBCTransferTx::_internal_set_sender(const std::string& value) {
  ;


  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_sender() {
  ;
  return _impl_.sender_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_sender() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.sender)
  return _impl_.sender_.Release();
}
inline void IBCTransferTx::set_allocated_sender(std::string* value) {
  _impl_.sender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.sender)
}

// string receiver = 2 [json_name = "receiver"];
inline void IBCTransferTx::clear_receiver() {
  _impl_.receiver_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::receiver() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.receiver)
  return _internal_receiver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_receiver(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.receiver_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.receiver)
}
inline std::string* IBCTransferTx::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.receiver)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_receiver() const {
  return _impl_.receiver_.Get();
}
inline void IBCTransferTx::_internal_set_receiver(const std::string& value) {
  ;


  _impl_.receiver_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_receiver() {
  ;
  return _impl_.receiver_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_receiver() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.receiver)
  return _impl_.receiver_.Release();
}
inline void IBCTransferTx::set_allocated_receiver(std::string* value) {
  _impl_.receiver_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receiver_.IsDefault()) {
          _impl_.receiver_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.receiver)
}

// string source_port = 3 [json_name = "sourcePort"];
inline void IBCTransferTx::clear_source_port() {
  _impl_.source_port_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::source_port() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.source_port)
  return _internal_source_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_source_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.source_port)
}
inline std::string* IBCTransferTx::mutable_source_port() {
  std::string* _s = _internal_mutable_source_port();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.source_port)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_source_port() const {
  return _impl_.source_port_.Get();
}
inline void IBCTransferTx::_internal_set_source_port(const std::string& value) {
  ;


  _impl_.source_port_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_source_port() {
  ;
  return _impl_.source_port_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_source_port() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.source_port)
  return _impl_.source_port_.Release();
}
inline void IBCTransferTx::set_allocated_source_port(std::string* value) {
  _impl_.source_port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_port_.IsDefault()) {
          _impl_.source_port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.source_port)
}

// string source_channel = 4 [json_name = "sourceChannel"];
inline void IBCTransferTx::clear_source_channel() {
  _impl_.source_channel_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::source_channel() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.source_channel)
  return _internal_source_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_source_channel(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.source_channel_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.source_channel)
}
inline std::string* IBCTransferTx::mutable_source_channel() {
  std::string* _s = _internal_mutable_source_channel();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.source_channel)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_source_channel() const {
  return _impl_.source_channel_.Get();
}
inline void IBCTransferTx::_internal_set_source_channel(const std::string& value) {
  ;


  _impl_.source_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_source_channel() {
  ;
  return _impl_.source_channel_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_source_channel() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.source_channel)
  return _impl_.source_channel_.Release();
}
inline void IBCTransferTx::set_allocated_source_channel(std::string* value) {
  _impl_.source_channel_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_channel_.IsDefault()) {
          _impl_.source_channel_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.source_channel)
}

// string destination_port = 5 [json_name = "destinationPort"];
inline void IBCTransferTx::clear_destination_port() {
  _impl_.destination_port_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::destination_port() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.destination_port)
  return _internal_destination_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_destination_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.destination_port)
}
inline std::string* IBCTransferTx::mutable_destination_port() {
  std::string* _s = _internal_mutable_destination_port();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.destination_port)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_destination_port() const {
  return _impl_.destination_port_.Get();
}
inline void IBCTransferTx::_internal_set_destination_port(const std::string& value) {
  ;


  _impl_.destination_port_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_destination_port() {
  ;
  return _impl_.destination_port_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_destination_port() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.destination_port)
  return _impl_.destination_port_.Release();
}
inline void IBCTransferTx::set_allocated_destination_port(std::string* value) {
  _impl_.destination_port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_port_.IsDefault()) {
          _impl_.destination_port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.destination_port)
}

// string destination_channel = 6 [json_name = "destinationChannel"];
inline void IBCTransferTx::clear_destination_channel() {
  _impl_.destination_channel_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::destination_channel() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.destination_channel)
  return _internal_destination_channel();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_destination_channel(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.destination_channel_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.destination_channel)
}
inline std::string* IBCTransferTx::mutable_destination_channel() {
  std::string* _s = _internal_mutable_destination_channel();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.destination_channel)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_destination_channel() const {
  return _impl_.destination_channel_.Get();
}
inline void IBCTransferTx::_internal_set_destination_channel(const std::string& value) {
  ;


  _impl_.destination_channel_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_destination_channel() {
  ;
  return _impl_.destination_channel_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_destination_channel() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.destination_channel)
  return _impl_.destination_channel_.Release();
}
inline void IBCTransferTx::set_allocated_destination_channel(std::string* value) {
  _impl_.destination_channel_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.destination_channel_.IsDefault()) {
          _impl_.destination_channel_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.destination_channel)
}

// string amount = 7 [json_name = "amount"];
inline void IBCTransferTx::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::amount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.amount)
}
inline std::string* IBCTransferTx::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.amount)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void IBCTransferTx::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_amount() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.amount)
  return _impl_.amount_.Release();
}
inline void IBCTransferTx::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.amount)
}

// string denom = 8 [json_name = "denom"];
inline void IBCTransferTx::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::denom() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.denom)
}
inline std::string* IBCTransferTx::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.denom)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void IBCTransferTx::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_denom() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.denom)
  return _impl_.denom_.Release();
}
inline void IBCTransferTx::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.denom)
}

// string timeout_height = 9 [json_name = "timeoutHeight"];
inline void IBCTransferTx::clear_timeout_height() {
  _impl_.timeout_height_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::timeout_height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.timeout_height)
  return _internal_timeout_height();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_timeout_height(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timeout_height_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.timeout_height)
}
inline std::string* IBCTransferTx::mutable_timeout_height() {
  std::string* _s = _internal_mutable_timeout_height();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.timeout_height)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_timeout_height() const {
  return _impl_.timeout_height_.Get();
}
inline void IBCTransferTx::_internal_set_timeout_height(const std::string& value) {
  ;


  _impl_.timeout_height_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_timeout_height() {
  ;
  return _impl_.timeout_height_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_timeout_height() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.timeout_height)
  return _impl_.timeout_height_.Release();
}
inline void IBCTransferTx::set_allocated_timeout_height(std::string* value) {
  _impl_.timeout_height_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timeout_height_.IsDefault()) {
          _impl_.timeout_height_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.timeout_height)
}

// uint64 timeout_timestamp = 10 [json_name = "timeoutTimestamp"];
inline void IBCTransferTx::clear_timeout_timestamp() {
  _impl_.timeout_timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t IBCTransferTx::timeout_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.timeout_timestamp)
  return _internal_timeout_timestamp();
}
inline void IBCTransferTx::set_timeout_timestamp(::uint64_t value) {
  _internal_set_timeout_timestamp(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.timeout_timestamp)
}
inline ::uint64_t IBCTransferTx::_internal_timeout_timestamp() const {
  return _impl_.timeout_timestamp_;
}
inline void IBCTransferTx::_internal_set_timeout_timestamp(::uint64_t value) {
  ;
  _impl_.timeout_timestamp_ = value;
}

// uint64 packet_sequence = 11 [json_name = "packetSequence"];
inline void IBCTransferTx::clear_packet_sequence() {
  _impl_.packet_sequence_ = ::uint64_t{0u};
}
inline ::uint64_t IBCTransferTx::packet_sequence() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.packet_sequence)
  return _internal_packet_sequence();
}
inline void IBCTransferTx::set_packet_sequence(::uint64_t value) {
  _internal_set_packet_sequence(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.packet_sequence)
}
inline ::uint64_t IBCTransferTx::_internal_packet_sequence() const {
  return _impl_.packet_sequence_;
}
inline void IBCTransferTx::_internal_set_packet_sequence(::uint64_t value) {
  ;
  _impl_.packet_sequence_ = value;
}

// bytes data_hex = 12 [json_name = "dataHex"];
inline void IBCTransferTx::clear_data_hex() {
  _impl_.data_hex_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::data_hex() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.data_hex)
  return _internal_data_hex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_data_hex(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_hex_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.data_hex)
}
inline std::string* IBCTransferTx::mutable_data_hex() {
  std::string* _s = _internal_mutable_data_hex();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.data_hex)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_data_hex() const {
  return _impl_.data_hex_.Get();
}
inline void IBCTransferTx::_internal_set_data_hex(const std::string& value) {
  ;


  _impl_.data_hex_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_data_hex() {
  ;
  return _impl_.data_hex_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_data_hex() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.data_hex)
  return _impl_.data_hex_.Release();
}
inline void IBCTransferTx::set_allocated_data_hex(std::string* value) {
  _impl_.data_hex_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_hex_.IsDefault()) {
          _impl_.data_hex_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.data_hex)
}

// string state = 13 [json_name = "state"];
inline void IBCTransferTx::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::state() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_state(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.state)
}
inline std::string* IBCTransferTx::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.state)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_state() const {
  return _impl_.state_.Get();
}
inline void IBCTransferTx::_internal_set_state(const std::string& value) {
  ;


  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_state() {
  ;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_state() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.state)
  return _impl_.state_.Release();
}
inline void IBCTransferTx::set_allocated_state(std::string* value) {
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.state)
}

// repeated string tx_hashes = 14 [json_name = "txHashes"];
inline int IBCTransferTx::_internal_tx_hashes_size() const {
  return _impl_.tx_hashes_.size();
}
inline int IBCTransferTx::tx_hashes_size() const {
  return _internal_tx_hashes_size();
}
inline void IBCTransferTx::clear_tx_hashes() {
  _internal_mutable_tx_hashes()->Clear();
}
inline std::string* IBCTransferTx::add_tx_hashes() {
  std::string* _s = _internal_add_tx_hashes();
  // @@protoc_insertion_point(field_add_mutable:injective_explorer_rpc.IBCTransferTx.tx_hashes)
  return _s;
}
inline const std::string& IBCTransferTx::tx_hashes(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.tx_hashes)
  return _internal_tx_hashes(index);
}
inline std::string* IBCTransferTx::mutable_tx_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.tx_hashes)
  return _internal_mutable_tx_hashes()->Mutable(index);
}
inline void IBCTransferTx::set_tx_hashes(int index, const std::string& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::set_tx_hashes(int index, std::string&& value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::set_tx_hashes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::set_tx_hashes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::set_tx_hashes(int index, absl::string_view value) {
  _internal_mutable_tx_hashes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::add_tx_hashes(const std::string& value) {
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::add_tx_hashes(std::string&& value) {
  _internal_mutable_tx_hashes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::add_tx_hashes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_tx_hashes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::add_tx_hashes(const char* value, std::size_t size) {
  _internal_mutable_tx_hashes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline void IBCTransferTx::add_tx_hashes(absl::string_view value) {
  _internal_mutable_tx_hashes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_explorer_rpc.IBCTransferTx.tx_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IBCTransferTx::tx_hashes() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.IBCTransferTx.tx_hashes)
  return _internal_tx_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* IBCTransferTx::mutable_tx_hashes() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.IBCTransferTx.tx_hashes)
  return _internal_mutable_tx_hashes();
}
inline const std::string& IBCTransferTx::_internal_tx_hashes(int index) const {
  return _internal_tx_hashes().Get(index);
}
inline std::string* IBCTransferTx::_internal_add_tx_hashes() {
  return _internal_mutable_tx_hashes()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IBCTransferTx::_internal_tx_hashes() const {
  return _impl_.tx_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IBCTransferTx::_internal_mutable_tx_hashes() {
  return &_impl_.tx_hashes_;
}

// string created_at = 15 [json_name = "createdAt"];
inline void IBCTransferTx::clear_created_at() {
  _impl_.created_at_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::created_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.created_at)
  return _internal_created_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_created_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.created_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.created_at)
}
inline std::string* IBCTransferTx::mutable_created_at() {
  std::string* _s = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.created_at)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_created_at() const {
  return _impl_.created_at_.Get();
}
inline void IBCTransferTx::_internal_set_created_at(const std::string& value) {
  ;


  _impl_.created_at_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_created_at() {
  ;
  return _impl_.created_at_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_created_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.created_at)
  return _impl_.created_at_.Release();
}
inline void IBCTransferTx::set_allocated_created_at(std::string* value) {
  _impl_.created_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.created_at_.IsDefault()) {
          _impl_.created_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.created_at)
}

// string updated_at = 16 [json_name = "updatedAt"];
inline void IBCTransferTx::clear_updated_at() {
  _impl_.updated_at_.ClearToEmpty();
}
inline const std::string& IBCTransferTx::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.IBCTransferTx.updated_at)
  return _internal_updated_at();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IBCTransferTx::set_updated_at(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.updated_at_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.IBCTransferTx.updated_at)
}
inline std::string* IBCTransferTx::mutable_updated_at() {
  std::string* _s = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.IBCTransferTx.updated_at)
  return _s;
}
inline const std::string& IBCTransferTx::_internal_updated_at() const {
  return _impl_.updated_at_.Get();
}
inline void IBCTransferTx::_internal_set_updated_at(const std::string& value) {
  ;


  _impl_.updated_at_.Set(value, GetArenaForAllocation());
}
inline std::string* IBCTransferTx::_internal_mutable_updated_at() {
  ;
  return _impl_.updated_at_.Mutable( GetArenaForAllocation());
}
inline std::string* IBCTransferTx::release_updated_at() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.IBCTransferTx.updated_at)
  return _impl_.updated_at_.Release();
}
inline void IBCTransferTx::set_allocated_updated_at(std::string* value) {
  _impl_.updated_at_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.updated_at_.IsDefault()) {
          _impl_.updated_at_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.IBCTransferTx.updated_at)
}

// -------------------------------------------------------------------

// GetWasmCodesRequest

// sint32 limit = 1 [json_name = "limit"];
inline void GetWasmCodesRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetWasmCodesRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodesRequest.limit)
  return _internal_limit();
}
inline void GetWasmCodesRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodesRequest.limit)
}
inline ::int32_t GetWasmCodesRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetWasmCodesRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 from_number = 2 [json_name = "fromNumber"];
inline void GetWasmCodesRequest::clear_from_number() {
  _impl_.from_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmCodesRequest::from_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodesRequest.from_number)
  return _internal_from_number();
}
inline void GetWasmCodesRequest::set_from_number(::int64_t value) {
  _internal_set_from_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodesRequest.from_number)
}
inline ::int64_t GetWasmCodesRequest::_internal_from_number() const {
  return _impl_.from_number_;
}
inline void GetWasmCodesRequest::_internal_set_from_number(::int64_t value) {
  ;
  _impl_.from_number_ = value;
}

// sint64 to_number = 3 [json_name = "toNumber"];
inline void GetWasmCodesRequest::clear_to_number() {
  _impl_.to_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmCodesRequest::to_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodesRequest.to_number)
  return _internal_to_number();
}
inline void GetWasmCodesRequest::set_to_number(::int64_t value) {
  _internal_set_to_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodesRequest.to_number)
}
inline ::int64_t GetWasmCodesRequest::_internal_to_number() const {
  return _impl_.to_number_;
}
inline void GetWasmCodesRequest::_internal_set_to_number(::int64_t value) {
  ;
  _impl_.to_number_ = value;
}

// -------------------------------------------------------------------

// GetWasmCodesResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetWasmCodesResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetWasmCodesResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetWasmCodesResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetWasmCodesResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodesResponse.paging)
  return _internal_paging();
}
inline void GetWasmCodesResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetWasmCodesResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetWasmCodesResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetWasmCodesResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodesResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetWasmCodesResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetWasmCodesResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodesResponse.paging)
  return _msg;
}
inline void GetWasmCodesResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodesResponse.paging)
}

// repeated .injective_explorer_rpc.WasmCode data = 2 [json_name = "data"];
inline int GetWasmCodesResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetWasmCodesResponse::data_size() const {
  return _internal_data_size();
}
inline void GetWasmCodesResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::WasmCode* GetWasmCodesResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodesResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCode >*
GetWasmCodesResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetWasmCodesResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::WasmCode& GetWasmCodesResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::WasmCode& GetWasmCodesResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodesResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::WasmCode* GetWasmCodesResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::WasmCode* GetWasmCodesResponse::add_data() {
  ::injective_explorer_rpc::WasmCode* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetWasmCodesResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCode >&
GetWasmCodesResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetWasmCodesResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCode>&
GetWasmCodesResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCode>*
GetWasmCodesResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// WasmCode

// uint64 code_id = 1 [json_name = "codeId"];
inline void WasmCode::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t WasmCode::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.code_id)
  return _internal_code_id();
}
inline void WasmCode::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.code_id)
}
inline ::uint64_t WasmCode::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void WasmCode::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string tx_hash = 2 [json_name = "txHash"];
inline void WasmCode::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& WasmCode::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.tx_hash)
}
inline std::string* WasmCode::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.tx_hash)
  return _s;
}
inline const std::string& WasmCode::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void WasmCode::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void WasmCode::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.tx_hash)
}

// .injective_explorer_rpc.Checksum checksum = 3 [json_name = "checksum"];
inline bool WasmCode::has_checksum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.checksum_ != nullptr);
  return value;
}
inline void WasmCode::clear_checksum() {
  if (_impl_.checksum_ != nullptr) _impl_.checksum_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Checksum& WasmCode::_internal_checksum() const {
  const ::injective_explorer_rpc::Checksum* p = _impl_.checksum_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Checksum&>(
      ::injective_explorer_rpc::_Checksum_default_instance_);
}
inline const ::injective_explorer_rpc::Checksum& WasmCode::checksum() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.checksum)
  return _internal_checksum();
}
inline void WasmCode::unsafe_arena_set_allocated_checksum(
    ::injective_explorer_rpc::Checksum* checksum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checksum_);
  }
  _impl_.checksum_ = checksum;
  if (checksum) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.WasmCode.checksum)
}
inline ::injective_explorer_rpc::Checksum* WasmCode::release_checksum() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Checksum* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Checksum* WasmCode::unsafe_arena_release_checksum() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.checksum)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Checksum* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Checksum* WasmCode::_internal_mutable_checksum() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Checksum>(GetArenaForAllocation());
    _impl_.checksum_ = p;
  }
  return _impl_.checksum_;
}
inline ::injective_explorer_rpc::Checksum* WasmCode::mutable_checksum() {
  ::injective_explorer_rpc::Checksum* _msg = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.checksum)
  return _msg;
}
inline void WasmCode::set_allocated_checksum(::injective_explorer_rpc::Checksum* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(checksum);
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.checksum)
}

// uint64 created_at = 4 [json_name = "createdAt"];
inline void WasmCode::clear_created_at() {
  _impl_.created_at_ = ::uint64_t{0u};
}
inline ::uint64_t WasmCode::created_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.created_at)
  return _internal_created_at();
}
inline void WasmCode::set_created_at(::uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.created_at)
}
inline ::uint64_t WasmCode::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void WasmCode::_internal_set_created_at(::uint64_t value) {
  ;
  _impl_.created_at_ = value;
}

// string contract_type = 5 [json_name = "contractType"];
inline void WasmCode::clear_contract_type() {
  _impl_.contract_type_.ClearToEmpty();
}
inline const std::string& WasmCode::contract_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.contract_type)
  return _internal_contract_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_contract_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.contract_type)
}
inline std::string* WasmCode::mutable_contract_type() {
  std::string* _s = _internal_mutable_contract_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.contract_type)
  return _s;
}
inline const std::string& WasmCode::_internal_contract_type() const {
  return _impl_.contract_type_.Get();
}
inline void WasmCode::_internal_set_contract_type(const std::string& value) {
  ;


  _impl_.contract_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_contract_type() {
  ;
  return _impl_.contract_type_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_contract_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.contract_type)
  return _impl_.contract_type_.Release();
}
inline void WasmCode::set_allocated_contract_type(std::string* value) {
  _impl_.contract_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_type_.IsDefault()) {
          _impl_.contract_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.contract_type)
}

// string version = 6 [json_name = "version"];
inline void WasmCode::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& WasmCode::version() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.version)
}
inline std::string* WasmCode::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.version)
  return _s;
}
inline const std::string& WasmCode::_internal_version() const {
  return _impl_.version_.Get();
}
inline void WasmCode::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_version() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.version)
  return _impl_.version_.Release();
}
inline void WasmCode::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.version)
}

// .injective_explorer_rpc.ContractPermission permission = 7 [json_name = "permission"];
inline bool WasmCode::has_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.permission_ != nullptr);
  return value;
}
inline void WasmCode::clear_permission() {
  if (_impl_.permission_ != nullptr) _impl_.permission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective_explorer_rpc::ContractPermission& WasmCode::_internal_permission() const {
  const ::injective_explorer_rpc::ContractPermission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::ContractPermission&>(
      ::injective_explorer_rpc::_ContractPermission_default_instance_);
}
inline const ::injective_explorer_rpc::ContractPermission& WasmCode::permission() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.permission)
  return _internal_permission();
}
inline void WasmCode::unsafe_arena_set_allocated_permission(
    ::injective_explorer_rpc::ContractPermission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.WasmCode.permission)
}
inline ::injective_explorer_rpc::ContractPermission* WasmCode::release_permission() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::ContractPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::ContractPermission* WasmCode::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.permission)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::ContractPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::ContractPermission* WasmCode::_internal_mutable_permission() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::ContractPermission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::injective_explorer_rpc::ContractPermission* WasmCode::mutable_permission() {
  ::injective_explorer_rpc::ContractPermission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.permission)
  return _msg;
}
inline void WasmCode::set_allocated_permission(::injective_explorer_rpc::ContractPermission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.permission)
}

// string code_schema = 8 [json_name = "codeSchema"];
inline void WasmCode::clear_code_schema() {
  _impl_.code_schema_.ClearToEmpty();
}
inline const std::string& WasmCode::code_schema() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.code_schema)
  return _internal_code_schema();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_code_schema(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.code_schema)
}
inline std::string* WasmCode::mutable_code_schema() {
  std::string* _s = _internal_mutable_code_schema();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.code_schema)
  return _s;
}
inline const std::string& WasmCode::_internal_code_schema() const {
  return _impl_.code_schema_.Get();
}
inline void WasmCode::_internal_set_code_schema(const std::string& value) {
  ;


  _impl_.code_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_code_schema() {
  ;
  return _impl_.code_schema_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_code_schema() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.code_schema)
  return _impl_.code_schema_.Release();
}
inline void WasmCode::set_allocated_code_schema(std::string* value) {
  _impl_.code_schema_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_schema_.IsDefault()) {
          _impl_.code_schema_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.code_schema)
}

// string code_view = 9 [json_name = "codeView"];
inline void WasmCode::clear_code_view() {
  _impl_.code_view_.ClearToEmpty();
}
inline const std::string& WasmCode::code_view() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.code_view)
  return _internal_code_view();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_code_view(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_view_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.code_view)
}
inline std::string* WasmCode::mutable_code_view() {
  std::string* _s = _internal_mutable_code_view();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.code_view)
  return _s;
}
inline const std::string& WasmCode::_internal_code_view() const {
  return _impl_.code_view_.Get();
}
inline void WasmCode::_internal_set_code_view(const std::string& value) {
  ;


  _impl_.code_view_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_code_view() {
  ;
  return _impl_.code_view_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_code_view() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.code_view)
  return _impl_.code_view_.Release();
}
inline void WasmCode::set_allocated_code_view(std::string* value) {
  _impl_.code_view_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_view_.IsDefault()) {
          _impl_.code_view_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.code_view)
}

// uint64 instantiates = 10 [json_name = "instantiates"];
inline void WasmCode::clear_instantiates() {
  _impl_.instantiates_ = ::uint64_t{0u};
}
inline ::uint64_t WasmCode::instantiates() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.instantiates)
  return _internal_instantiates();
}
inline void WasmCode::set_instantiates(::uint64_t value) {
  _internal_set_instantiates(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.instantiates)
}
inline ::uint64_t WasmCode::_internal_instantiates() const {
  return _impl_.instantiates_;
}
inline void WasmCode::_internal_set_instantiates(::uint64_t value) {
  ;
  _impl_.instantiates_ = value;
}

// string creator = 11 [json_name = "creator"];
inline void WasmCode::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& WasmCode::creator() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCode::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.creator)
}
inline std::string* WasmCode::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCode.creator)
  return _s;
}
inline const std::string& WasmCode::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void WasmCode::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCode::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCode::release_creator() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCode.creator)
  return _impl_.creator_.Release();
}
inline void WasmCode::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCode.creator)
}

// sint64 code_number = 12 [json_name = "codeNumber"];
inline void WasmCode::clear_code_number() {
  _impl_.code_number_ = ::int64_t{0};
}
inline ::int64_t WasmCode::code_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.code_number)
  return _internal_code_number();
}
inline void WasmCode::set_code_number(::int64_t value) {
  _internal_set_code_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.code_number)
}
inline ::int64_t WasmCode::_internal_code_number() const {
  return _impl_.code_number_;
}
inline void WasmCode::_internal_set_code_number(::int64_t value) {
  ;
  _impl_.code_number_ = value;
}

// sint64 proposal_id = 13 [json_name = "proposalId"];
inline void WasmCode::clear_proposal_id() {
  _impl_.proposal_id_ = ::int64_t{0};
}
inline ::int64_t WasmCode::proposal_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCode.proposal_id)
  return _internal_proposal_id();
}
inline void WasmCode::set_proposal_id(::int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCode.proposal_id)
}
inline ::int64_t WasmCode::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline void WasmCode::_internal_set_proposal_id(::int64_t value) {
  ;
  _impl_.proposal_id_ = value;
}

// -------------------------------------------------------------------

// Checksum

// string algorithm = 1 [json_name = "algorithm"];
inline void Checksum::clear_algorithm() {
  _impl_.algorithm_.ClearToEmpty();
}
inline const std::string& Checksum::algorithm() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Checksum.algorithm)
  return _internal_algorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Checksum::set_algorithm(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.algorithm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Checksum.algorithm)
}
inline std::string* Checksum::mutable_algorithm() {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Checksum.algorithm)
  return _s;
}
inline const std::string& Checksum::_internal_algorithm() const {
  return _impl_.algorithm_.Get();
}
inline void Checksum::_internal_set_algorithm(const std::string& value) {
  ;


  _impl_.algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* Checksum::_internal_mutable_algorithm() {
  ;
  return _impl_.algorithm_.Mutable( GetArenaForAllocation());
}
inline std::string* Checksum::release_algorithm() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Checksum.algorithm)
  return _impl_.algorithm_.Release();
}
inline void Checksum::set_allocated_algorithm(std::string* value) {
  _impl_.algorithm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.algorithm_.IsDefault()) {
          _impl_.algorithm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Checksum.algorithm)
}

// string hash = 2 [json_name = "hash"];
inline void Checksum::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Checksum::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Checksum.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Checksum::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Checksum.hash)
}
inline std::string* Checksum::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Checksum.hash)
  return _s;
}
inline const std::string& Checksum::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Checksum::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Checksum::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* Checksum::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Checksum.hash)
  return _impl_.hash_.Release();
}
inline void Checksum::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Checksum.hash)
}

// -------------------------------------------------------------------

// ContractPermission

// sint32 access_type = 1 [json_name = "accessType"];
inline void ContractPermission::clear_access_type() {
  _impl_.access_type_ = 0;
}
inline ::int32_t ContractPermission::access_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ContractPermission.access_type)
  return _internal_access_type();
}
inline void ContractPermission::set_access_type(::int32_t value) {
  _internal_set_access_type(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ContractPermission.access_type)
}
inline ::int32_t ContractPermission::_internal_access_type() const {
  return _impl_.access_type_;
}
inline void ContractPermission::_internal_set_access_type(::int32_t value) {
  ;
  _impl_.access_type_ = value;
}

// string address = 2 [json_name = "address"];
inline void ContractPermission::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ContractPermission::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ContractPermission.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractPermission::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ContractPermission.address)
}
inline std::string* ContractPermission::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ContractPermission.address)
  return _s;
}
inline const std::string& ContractPermission::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ContractPermission::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractPermission::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractPermission::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ContractPermission.address)
  return _impl_.address_.Release();
}
inline void ContractPermission::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ContractPermission.address)
}

// -------------------------------------------------------------------

// GetWasmCodeByIDRequest

// sint64 code_id = 1 [json_name = "codeId"];
inline void GetWasmCodeByIDRequest::clear_code_id() {
  _impl_.code_id_ = ::int64_t{0};
}
inline ::int64_t GetWasmCodeByIDRequest::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDRequest.code_id)
  return _internal_code_id();
}
inline void GetWasmCodeByIDRequest::set_code_id(::int64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDRequest.code_id)
}
inline ::int64_t GetWasmCodeByIDRequest::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void GetWasmCodeByIDRequest::_internal_set_code_id(::int64_t value) {
  ;
  _impl_.code_id_ = value;
}

// -------------------------------------------------------------------

// GetWasmCodeByIDResponse

// uint64 code_id = 1 [json_name = "codeId"];
inline void GetWasmCodeByIDResponse::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmCodeByIDResponse::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.code_id)
  return _internal_code_id();
}
inline void GetWasmCodeByIDResponse::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.code_id)
}
inline ::uint64_t GetWasmCodeByIDResponse::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void GetWasmCodeByIDResponse::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string tx_hash = 2 [json_name = "txHash"];
inline void GetWasmCodeByIDResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.tx_hash)
}
inline std::string* GetWasmCodeByIDResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.tx_hash)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.tx_hash)
}

// .injective_explorer_rpc.Checksum checksum = 3 [json_name = "checksum"];
inline bool GetWasmCodeByIDResponse::has_checksum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.checksum_ != nullptr);
  return value;
}
inline void GetWasmCodeByIDResponse::clear_checksum() {
  if (_impl_.checksum_ != nullptr) _impl_.checksum_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Checksum& GetWasmCodeByIDResponse::_internal_checksum() const {
  const ::injective_explorer_rpc::Checksum* p = _impl_.checksum_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Checksum&>(
      ::injective_explorer_rpc::_Checksum_default_instance_);
}
inline const ::injective_explorer_rpc::Checksum& GetWasmCodeByIDResponse::checksum() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.checksum)
  return _internal_checksum();
}
inline void GetWasmCodeByIDResponse::unsafe_arena_set_allocated_checksum(
    ::injective_explorer_rpc::Checksum* checksum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checksum_);
  }
  _impl_.checksum_ = checksum;
  if (checksum) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.checksum)
}
inline ::injective_explorer_rpc::Checksum* GetWasmCodeByIDResponse::release_checksum() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Checksum* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Checksum* GetWasmCodeByIDResponse::unsafe_arena_release_checksum() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.checksum)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Checksum* temp = _impl_.checksum_;
  _impl_.checksum_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Checksum* GetWasmCodeByIDResponse::_internal_mutable_checksum() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Checksum>(GetArenaForAllocation());
    _impl_.checksum_ = p;
  }
  return _impl_.checksum_;
}
inline ::injective_explorer_rpc::Checksum* GetWasmCodeByIDResponse::mutable_checksum() {
  ::injective_explorer_rpc::Checksum* _msg = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.checksum)
  return _msg;
}
inline void GetWasmCodeByIDResponse::set_allocated_checksum(::injective_explorer_rpc::Checksum* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(checksum);
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.checksum)
}

// uint64 created_at = 4 [json_name = "createdAt"];
inline void GetWasmCodeByIDResponse::clear_created_at() {
  _impl_.created_at_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmCodeByIDResponse::created_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.created_at)
  return _internal_created_at();
}
inline void GetWasmCodeByIDResponse::set_created_at(::uint64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.created_at)
}
inline ::uint64_t GetWasmCodeByIDResponse::_internal_created_at() const {
  return _impl_.created_at_;
}
inline void GetWasmCodeByIDResponse::_internal_set_created_at(::uint64_t value) {
  ;
  _impl_.created_at_ = value;
}

// string contract_type = 5 [json_name = "contractType"];
inline void GetWasmCodeByIDResponse::clear_contract_type() {
  _impl_.contract_type_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::contract_type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.contract_type)
  return _internal_contract_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_contract_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.contract_type)
}
inline std::string* GetWasmCodeByIDResponse::mutable_contract_type() {
  std::string* _s = _internal_mutable_contract_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.contract_type)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_contract_type() const {
  return _impl_.contract_type_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_contract_type(const std::string& value) {
  ;


  _impl_.contract_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_contract_type() {
  ;
  return _impl_.contract_type_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_contract_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.contract_type)
  return _impl_.contract_type_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_contract_type(std::string* value) {
  _impl_.contract_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_type_.IsDefault()) {
          _impl_.contract_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.contract_type)
}

// string version = 6 [json_name = "version"];
inline void GetWasmCodeByIDResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::version() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.version)
}
inline std::string* GetWasmCodeByIDResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.version)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_version() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.version)
  return _impl_.version_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.version)
}

// .injective_explorer_rpc.ContractPermission permission = 7 [json_name = "permission"];
inline bool GetWasmCodeByIDResponse::has_permission() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.permission_ != nullptr);
  return value;
}
inline void GetWasmCodeByIDResponse::clear_permission() {
  if (_impl_.permission_ != nullptr) _impl_.permission_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective_explorer_rpc::ContractPermission& GetWasmCodeByIDResponse::_internal_permission() const {
  const ::injective_explorer_rpc::ContractPermission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::ContractPermission&>(
      ::injective_explorer_rpc::_ContractPermission_default_instance_);
}
inline const ::injective_explorer_rpc::ContractPermission& GetWasmCodeByIDResponse::permission() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.permission)
  return _internal_permission();
}
inline void GetWasmCodeByIDResponse::unsafe_arena_set_allocated_permission(
    ::injective_explorer_rpc::ContractPermission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.permission)
}
inline ::injective_explorer_rpc::ContractPermission* GetWasmCodeByIDResponse::release_permission() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::ContractPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::ContractPermission* GetWasmCodeByIDResponse::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.permission)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::ContractPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::ContractPermission* GetWasmCodeByIDResponse::_internal_mutable_permission() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::ContractPermission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::injective_explorer_rpc::ContractPermission* GetWasmCodeByIDResponse::mutable_permission() {
  ::injective_explorer_rpc::ContractPermission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.permission)
  return _msg;
}
inline void GetWasmCodeByIDResponse::set_allocated_permission(::injective_explorer_rpc::ContractPermission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.permission)
}

// string code_schema = 8 [json_name = "codeSchema"];
inline void GetWasmCodeByIDResponse::clear_code_schema() {
  _impl_.code_schema_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::code_schema() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.code_schema)
  return _internal_code_schema();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_code_schema(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.code_schema)
}
inline std::string* GetWasmCodeByIDResponse::mutable_code_schema() {
  std::string* _s = _internal_mutable_code_schema();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.code_schema)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_code_schema() const {
  return _impl_.code_schema_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_code_schema(const std::string& value) {
  ;


  _impl_.code_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_code_schema() {
  ;
  return _impl_.code_schema_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_code_schema() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.code_schema)
  return _impl_.code_schema_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_code_schema(std::string* value) {
  _impl_.code_schema_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_schema_.IsDefault()) {
          _impl_.code_schema_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.code_schema)
}

// string code_view = 9 [json_name = "codeView"];
inline void GetWasmCodeByIDResponse::clear_code_view() {
  _impl_.code_view_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::code_view() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.code_view)
  return _internal_code_view();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_code_view(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.code_view_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.code_view)
}
inline std::string* GetWasmCodeByIDResponse::mutable_code_view() {
  std::string* _s = _internal_mutable_code_view();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.code_view)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_code_view() const {
  return _impl_.code_view_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_code_view(const std::string& value) {
  ;


  _impl_.code_view_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_code_view() {
  ;
  return _impl_.code_view_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_code_view() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.code_view)
  return _impl_.code_view_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_code_view(std::string* value) {
  _impl_.code_view_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_view_.IsDefault()) {
          _impl_.code_view_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.code_view)
}

// uint64 instantiates = 10 [json_name = "instantiates"];
inline void GetWasmCodeByIDResponse::clear_instantiates() {
  _impl_.instantiates_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmCodeByIDResponse::instantiates() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.instantiates)
  return _internal_instantiates();
}
inline void GetWasmCodeByIDResponse::set_instantiates(::uint64_t value) {
  _internal_set_instantiates(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.instantiates)
}
inline ::uint64_t GetWasmCodeByIDResponse::_internal_instantiates() const {
  return _impl_.instantiates_;
}
inline void GetWasmCodeByIDResponse::_internal_set_instantiates(::uint64_t value) {
  ;
  _impl_.instantiates_ = value;
}

// string creator = 11 [json_name = "creator"];
inline void GetWasmCodeByIDResponse::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& GetWasmCodeByIDResponse::creator() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmCodeByIDResponse::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.creator)
}
inline std::string* GetWasmCodeByIDResponse::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmCodeByIDResponse.creator)
  return _s;
}
inline const std::string& GetWasmCodeByIDResponse::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void GetWasmCodeByIDResponse::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmCodeByIDResponse::release_creator() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmCodeByIDResponse.creator)
  return _impl_.creator_.Release();
}
inline void GetWasmCodeByIDResponse::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmCodeByIDResponse.creator)
}

// sint64 code_number = 12 [json_name = "codeNumber"];
inline void GetWasmCodeByIDResponse::clear_code_number() {
  _impl_.code_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmCodeByIDResponse::code_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.code_number)
  return _internal_code_number();
}
inline void GetWasmCodeByIDResponse::set_code_number(::int64_t value) {
  _internal_set_code_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.code_number)
}
inline ::int64_t GetWasmCodeByIDResponse::_internal_code_number() const {
  return _impl_.code_number_;
}
inline void GetWasmCodeByIDResponse::_internal_set_code_number(::int64_t value) {
  ;
  _impl_.code_number_ = value;
}

// sint64 proposal_id = 13 [json_name = "proposalId"];
inline void GetWasmCodeByIDResponse::clear_proposal_id() {
  _impl_.proposal_id_ = ::int64_t{0};
}
inline ::int64_t GetWasmCodeByIDResponse::proposal_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmCodeByIDResponse.proposal_id)
  return _internal_proposal_id();
}
inline void GetWasmCodeByIDResponse::set_proposal_id(::int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmCodeByIDResponse.proposal_id)
}
inline ::int64_t GetWasmCodeByIDResponse::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline void GetWasmCodeByIDResponse::_internal_set_proposal_id(::int64_t value) {
  ;
  _impl_.proposal_id_ = value;
}

// -------------------------------------------------------------------

// GetWasmContractsRequest

// sint32 limit = 1 [json_name = "limit"];
inline void GetWasmContractsRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetWasmContractsRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.limit)
  return _internal_limit();
}
inline void GetWasmContractsRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.limit)
}
inline ::int32_t GetWasmContractsRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetWasmContractsRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// sint64 code_id = 2 [json_name = "codeId"];
inline void GetWasmContractsRequest::clear_code_id() {
  _impl_.code_id_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractsRequest::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.code_id)
  return _internal_code_id();
}
inline void GetWasmContractsRequest::set_code_id(::int64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.code_id)
}
inline ::int64_t GetWasmContractsRequest::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void GetWasmContractsRequest::_internal_set_code_id(::int64_t value) {
  ;
  _impl_.code_id_ = value;
}

// sint64 from_number = 3 [json_name = "fromNumber"];
inline void GetWasmContractsRequest::clear_from_number() {
  _impl_.from_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractsRequest::from_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.from_number)
  return _internal_from_number();
}
inline void GetWasmContractsRequest::set_from_number(::int64_t value) {
  _internal_set_from_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.from_number)
}
inline ::int64_t GetWasmContractsRequest::_internal_from_number() const {
  return _impl_.from_number_;
}
inline void GetWasmContractsRequest::_internal_set_from_number(::int64_t value) {
  ;
  _impl_.from_number_ = value;
}

// sint64 to_number = 4 [json_name = "toNumber"];
inline void GetWasmContractsRequest::clear_to_number() {
  _impl_.to_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractsRequest::to_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.to_number)
  return _internal_to_number();
}
inline void GetWasmContractsRequest::set_to_number(::int64_t value) {
  _internal_set_to_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.to_number)
}
inline ::int64_t GetWasmContractsRequest::_internal_to_number() const {
  return _impl_.to_number_;
}
inline void GetWasmContractsRequest::_internal_set_to_number(::int64_t value) {
  ;
  _impl_.to_number_ = value;
}

// bool assets_only = 5 [json_name = "assetsOnly"];
inline void GetWasmContractsRequest::clear_assets_only() {
  _impl_.assets_only_ = false;
}
inline bool GetWasmContractsRequest::assets_only() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.assets_only)
  return _internal_assets_only();
}
inline void GetWasmContractsRequest::set_assets_only(bool value) {
  _internal_set_assets_only(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.assets_only)
}
inline bool GetWasmContractsRequest::_internal_assets_only() const {
  return _impl_.assets_only_;
}
inline void GetWasmContractsRequest::_internal_set_assets_only(bool value) {
  ;
  _impl_.assets_only_ = value;
}

// sint64 skip = 6 [json_name = "skip"];
inline void GetWasmContractsRequest::clear_skip() {
  _impl_.skip_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractsRequest::skip() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsRequest.skip)
  return _internal_skip();
}
inline void GetWasmContractsRequest::set_skip(::int64_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractsRequest.skip)
}
inline ::int64_t GetWasmContractsRequest::_internal_skip() const {
  return _impl_.skip_;
}
inline void GetWasmContractsRequest::_internal_set_skip(::int64_t value) {
  ;
  _impl_.skip_ = value;
}

// -------------------------------------------------------------------

// GetWasmContractsResponse

// .injective_explorer_rpc.Paging paging = 1 [json_name = "paging"];
inline bool GetWasmContractsResponse::has_paging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paging_ != nullptr);
  return value;
}
inline void GetWasmContractsResponse::clear_paging() {
  if (_impl_.paging_ != nullptr) _impl_.paging_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Paging& GetWasmContractsResponse::_internal_paging() const {
  const ::injective_explorer_rpc::Paging* p = _impl_.paging_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Paging&>(
      ::injective_explorer_rpc::_Paging_default_instance_);
}
inline const ::injective_explorer_rpc::Paging& GetWasmContractsResponse::paging() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsResponse.paging)
  return _internal_paging();
}
inline void GetWasmContractsResponse::unsafe_arena_set_allocated_paging(
    ::injective_explorer_rpc::Paging* paging) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paging_);
  }
  _impl_.paging_ = paging;
  if (paging) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetWasmContractsResponse.paging)
}
inline ::injective_explorer_rpc::Paging* GetWasmContractsResponse::release_paging() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetWasmContractsResponse::unsafe_arena_release_paging() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractsResponse.paging)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Paging* temp = _impl_.paging_;
  _impl_.paging_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Paging* GetWasmContractsResponse::_internal_mutable_paging() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.paging_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Paging>(GetArenaForAllocation());
    _impl_.paging_ = p;
  }
  return _impl_.paging_;
}
inline ::injective_explorer_rpc::Paging* GetWasmContractsResponse::mutable_paging() {
  ::injective_explorer_rpc::Paging* _msg = _internal_mutable_paging();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractsResponse.paging)
  return _msg;
}
inline void GetWasmContractsResponse::set_allocated_paging(::injective_explorer_rpc::Paging* paging) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paging_;
  }
  if (paging) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paging);
    if (message_arena != submessage_arena) {
      paging = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paging, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.paging_ = paging;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractsResponse.paging)
}

// repeated .injective_explorer_rpc.WasmContract data = 2 [json_name = "data"];
inline int GetWasmContractsResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int GetWasmContractsResponse::data_size() const {
  return _internal_data_size();
}
inline void GetWasmContractsResponse::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::injective_explorer_rpc::WasmContract* GetWasmContractsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractsResponse.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmContract >*
GetWasmContractsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetWasmContractsResponse.data)
  return _internal_mutable_data();
}
inline const ::injective_explorer_rpc::WasmContract& GetWasmContractsResponse::_internal_data(int index) const {
  return _internal_data().Get(index);
}
inline const ::injective_explorer_rpc::WasmContract& GetWasmContractsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractsResponse.data)
  return _internal_data(index);
}
inline ::injective_explorer_rpc::WasmContract* GetWasmContractsResponse::_internal_add_data() {
  return _internal_mutable_data()->Add();
}
inline ::injective_explorer_rpc::WasmContract* GetWasmContractsResponse::add_data() {
  ::injective_explorer_rpc::WasmContract* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetWasmContractsResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmContract >&
GetWasmContractsResponse::data() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetWasmContractsResponse.data)
  return _internal_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmContract>&
GetWasmContractsResponse::_internal_data() const {
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmContract>*
GetWasmContractsResponse::_internal_mutable_data() {
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// WasmContract

// string label = 1 [json_name = "label"];
inline void WasmContract::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& WasmContract::label() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.label)
}
inline std::string* WasmContract::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.label)
  return _s;
}
inline const std::string& WasmContract::_internal_label() const {
  return _impl_.label_.Get();
}
inline void WasmContract::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_label() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.label)
  return _impl_.label_.Release();
}
inline void WasmContract::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.label)
}

// string address = 2 [json_name = "address"];
inline void WasmContract::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& WasmContract::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.address)
}
inline std::string* WasmContract::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.address)
  return _s;
}
inline const std::string& WasmContract::_internal_address() const {
  return _impl_.address_.Get();
}
inline void WasmContract::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.address)
  return _impl_.address_.Release();
}
inline void WasmContract::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.address)
}

// string tx_hash = 3 [json_name = "txHash"];
inline void WasmContract::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& WasmContract::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.tx_hash)
}
inline std::string* WasmContract::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.tx_hash)
  return _s;
}
inline const std::string& WasmContract::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void WasmContract::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void WasmContract::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.tx_hash)
}

// string creator = 4 [json_name = "creator"];
inline void WasmContract::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& WasmContract::creator() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.creator)
}
inline std::string* WasmContract::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.creator)
  return _s;
}
inline const std::string& WasmContract::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void WasmContract::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_creator() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.creator)
  return _impl_.creator_.Release();
}
inline void WasmContract::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.creator)
}

// uint64 executes = 5 [json_name = "executes"];
inline void WasmContract::clear_executes() {
  _impl_.executes_ = ::uint64_t{0u};
}
inline ::uint64_t WasmContract::executes() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.executes)
  return _internal_executes();
}
inline void WasmContract::set_executes(::uint64_t value) {
  _internal_set_executes(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.executes)
}
inline ::uint64_t WasmContract::_internal_executes() const {
  return _impl_.executes_;
}
inline void WasmContract::_internal_set_executes(::uint64_t value) {
  ;
  _impl_.executes_ = value;
}

// uint64 instantiated_at = 6 [json_name = "instantiatedAt"];
inline void WasmContract::clear_instantiated_at() {
  _impl_.instantiated_at_ = ::uint64_t{0u};
}
inline ::uint64_t WasmContract::instantiated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.instantiated_at)
  return _internal_instantiated_at();
}
inline void WasmContract::set_instantiated_at(::uint64_t value) {
  _internal_set_instantiated_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.instantiated_at)
}
inline ::uint64_t WasmContract::_internal_instantiated_at() const {
  return _impl_.instantiated_at_;
}
inline void WasmContract::_internal_set_instantiated_at(::uint64_t value) {
  ;
  _impl_.instantiated_at_ = value;
}

// string init_message = 7 [json_name = "initMessage"];
inline void WasmContract::clear_init_message() {
  _impl_.init_message_.ClearToEmpty();
}
inline const std::string& WasmContract::init_message() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.init_message)
  return _internal_init_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_init_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.init_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.init_message)
}
inline std::string* WasmContract::mutable_init_message() {
  std::string* _s = _internal_mutable_init_message();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.init_message)
  return _s;
}
inline const std::string& WasmContract::_internal_init_message() const {
  return _impl_.init_message_.Get();
}
inline void WasmContract::_internal_set_init_message(const std::string& value) {
  ;


  _impl_.init_message_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_init_message() {
  ;
  return _impl_.init_message_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_init_message() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.init_message)
  return _impl_.init_message_.Release();
}
inline void WasmContract::set_allocated_init_message(std::string* value) {
  _impl_.init_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.init_message_.IsDefault()) {
          _impl_.init_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.init_message)
}

// uint64 last_executed_at = 8 [json_name = "lastExecutedAt"];
inline void WasmContract::clear_last_executed_at() {
  _impl_.last_executed_at_ = ::uint64_t{0u};
}
inline ::uint64_t WasmContract::last_executed_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.last_executed_at)
  return _internal_last_executed_at();
}
inline void WasmContract::set_last_executed_at(::uint64_t value) {
  _internal_set_last_executed_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.last_executed_at)
}
inline ::uint64_t WasmContract::_internal_last_executed_at() const {
  return _impl_.last_executed_at_;
}
inline void WasmContract::_internal_set_last_executed_at(::uint64_t value) {
  ;
  _impl_.last_executed_at_ = value;
}

// repeated .injective_explorer_rpc.ContractFund funds = 9 [json_name = "funds"];
inline int WasmContract::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int WasmContract::funds_size() const {
  return _internal_funds_size();
}
inline void WasmContract::clear_funds() {
  _internal_mutable_funds()->Clear();
}
inline ::injective_explorer_rpc::ContractFund* WasmContract::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >*
WasmContract::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.WasmContract.funds)
  return _internal_mutable_funds();
}
inline const ::injective_explorer_rpc::ContractFund& WasmContract::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::injective_explorer_rpc::ContractFund& WasmContract::funds(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.funds)
  return _internal_funds(index);
}
inline ::injective_explorer_rpc::ContractFund* WasmContract::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::injective_explorer_rpc::ContractFund* WasmContract::add_funds() {
  ::injective_explorer_rpc::ContractFund* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.WasmContract.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >&
WasmContract::funds() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.WasmContract.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>&
WasmContract::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>*
WasmContract::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// uint64 code_id = 10 [json_name = "codeId"];
inline void WasmContract::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t WasmContract::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.code_id)
  return _internal_code_id();
}
inline void WasmContract::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.code_id)
}
inline ::uint64_t WasmContract::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void WasmContract::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string admin = 11 [json_name = "admin"];
inline void WasmContract::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& WasmContract::admin() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.admin)
}
inline std::string* WasmContract::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.admin)
  return _s;
}
inline const std::string& WasmContract::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void WasmContract::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_admin() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.admin)
  return _impl_.admin_.Release();
}
inline void WasmContract::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.admin)
}

// string current_migrate_message = 12 [json_name = "currentMigrateMessage"];
inline void WasmContract::clear_current_migrate_message() {
  _impl_.current_migrate_message_.ClearToEmpty();
}
inline const std::string& WasmContract::current_migrate_message() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.current_migrate_message)
  return _internal_current_migrate_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_current_migrate_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.current_migrate_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.current_migrate_message)
}
inline std::string* WasmContract::mutable_current_migrate_message() {
  std::string* _s = _internal_mutable_current_migrate_message();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.current_migrate_message)
  return _s;
}
inline const std::string& WasmContract::_internal_current_migrate_message() const {
  return _impl_.current_migrate_message_.Get();
}
inline void WasmContract::_internal_set_current_migrate_message(const std::string& value) {
  ;


  _impl_.current_migrate_message_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_current_migrate_message() {
  ;
  return _impl_.current_migrate_message_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_current_migrate_message() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.current_migrate_message)
  return _impl_.current_migrate_message_.Release();
}
inline void WasmContract::set_allocated_current_migrate_message(std::string* value) {
  _impl_.current_migrate_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_migrate_message_.IsDefault()) {
          _impl_.current_migrate_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.current_migrate_message)
}

// sint64 contract_number = 13 [json_name = "contractNumber"];
inline void WasmContract::clear_contract_number() {
  _impl_.contract_number_ = ::int64_t{0};
}
inline ::int64_t WasmContract::contract_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.contract_number)
  return _internal_contract_number();
}
inline void WasmContract::set_contract_number(::int64_t value) {
  _internal_set_contract_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.contract_number)
}
inline ::int64_t WasmContract::_internal_contract_number() const {
  return _impl_.contract_number_;
}
inline void WasmContract::_internal_set_contract_number(::int64_t value) {
  ;
  _impl_.contract_number_ = value;
}

// string version = 14 [json_name = "version"];
inline void WasmContract::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& WasmContract::version() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.version)
}
inline std::string* WasmContract::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.version)
  return _s;
}
inline const std::string& WasmContract::_internal_version() const {
  return _impl_.version_.Get();
}
inline void WasmContract::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_version() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.version)
  return _impl_.version_.Release();
}
inline void WasmContract::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.version)
}

// string type = 15 [json_name = "type"];
inline void WasmContract::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& WasmContract::type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmContract::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.type)
}
inline std::string* WasmContract::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.type)
  return _s;
}
inline const std::string& WasmContract::_internal_type() const {
  return _impl_.type_.Get();
}
inline void WasmContract::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmContract::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmContract::release_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.type)
  return _impl_.type_.Release();
}
inline void WasmContract::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.type)
}

// .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16 [json_name = "cw20Metadata"];
inline bool WasmContract::has_cw20_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cw20_metadata_ != nullptr);
  return value;
}
inline void WasmContract::clear_cw20_metadata() {
  if (_impl_.cw20_metadata_ != nullptr) _impl_.cw20_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Cw20Metadata& WasmContract::_internal_cw20_metadata() const {
  const ::injective_explorer_rpc::Cw20Metadata* p = _impl_.cw20_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Cw20Metadata&>(
      ::injective_explorer_rpc::_Cw20Metadata_default_instance_);
}
inline const ::injective_explorer_rpc::Cw20Metadata& WasmContract::cw20_metadata() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.cw20_metadata)
  return _internal_cw20_metadata();
}
inline void WasmContract::unsafe_arena_set_allocated_cw20_metadata(
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cw20_metadata_);
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  if (cw20_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.WasmContract.cw20_metadata)
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmContract::release_cw20_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmContract::unsafe_arena_release_cw20_metadata() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmContract.cw20_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmContract::_internal_mutable_cw20_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cw20_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Cw20Metadata>(GetArenaForAllocation());
    _impl_.cw20_metadata_ = p;
  }
  return _impl_.cw20_metadata_;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmContract::mutable_cw20_metadata() {
  ::injective_explorer_rpc::Cw20Metadata* _msg = _internal_mutable_cw20_metadata();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmContract.cw20_metadata)
  return _msg;
}
inline void WasmContract::set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cw20_metadata_;
  }
  if (cw20_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cw20_metadata);
    if (message_arena != submessage_arena) {
      cw20_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cw20_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmContract.cw20_metadata)
}

// sint64 proposal_id = 17 [json_name = "proposalId"];
inline void WasmContract::clear_proposal_id() {
  _impl_.proposal_id_ = ::int64_t{0};
}
inline ::int64_t WasmContract::proposal_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmContract.proposal_id)
  return _internal_proposal_id();
}
inline void WasmContract::set_proposal_id(::int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmContract.proposal_id)
}
inline ::int64_t WasmContract::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline void WasmContract::_internal_set_proposal_id(::int64_t value) {
  ;
  _impl_.proposal_id_ = value;
}

// -------------------------------------------------------------------

// ContractFund

// string denom = 1 [json_name = "denom"];
inline void ContractFund::clear_denom() {
  _impl_.denom_.ClearToEmpty();
}
inline const std::string& ContractFund::denom() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ContractFund.denom)
  return _internal_denom();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractFund::set_denom(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.denom_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ContractFund.denom)
}
inline std::string* ContractFund::mutable_denom() {
  std::string* _s = _internal_mutable_denom();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ContractFund.denom)
  return _s;
}
inline const std::string& ContractFund::_internal_denom() const {
  return _impl_.denom_.Get();
}
inline void ContractFund::_internal_set_denom(const std::string& value) {
  ;


  _impl_.denom_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFund::_internal_mutable_denom() {
  ;
  return _impl_.denom_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractFund::release_denom() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ContractFund.denom)
  return _impl_.denom_.Release();
}
inline void ContractFund::set_allocated_denom(std::string* value) {
  _impl_.denom_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denom_.IsDefault()) {
          _impl_.denom_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ContractFund.denom)
}

// string amount = 2 [json_name = "amount"];
inline void ContractFund::clear_amount() {
  _impl_.amount_.ClearToEmpty();
}
inline const std::string& ContractFund::amount() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.ContractFund.amount)
  return _internal_amount();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContractFund::set_amount(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.amount_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.ContractFund.amount)
}
inline std::string* ContractFund::mutable_amount() {
  std::string* _s = _internal_mutable_amount();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.ContractFund.amount)
  return _s;
}
inline const std::string& ContractFund::_internal_amount() const {
  return _impl_.amount_.Get();
}
inline void ContractFund::_internal_set_amount(const std::string& value) {
  ;


  _impl_.amount_.Set(value, GetArenaForAllocation());
}
inline std::string* ContractFund::_internal_mutable_amount() {
  ;
  return _impl_.amount_.Mutable( GetArenaForAllocation());
}
inline std::string* ContractFund::release_amount() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.ContractFund.amount)
  return _impl_.amount_.Release();
}
inline void ContractFund::set_allocated_amount(std::string* value) {
  _impl_.amount_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.amount_.IsDefault()) {
          _impl_.amount_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.ContractFund.amount)
}

// -------------------------------------------------------------------

// Cw20Metadata

// .injective_explorer_rpc.Cw20TokenInfo token_info = 1 [json_name = "tokenInfo"];
inline bool Cw20Metadata::has_token_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_info_ != nullptr);
  return value;
}
inline void Cw20Metadata::clear_token_info() {
  if (_impl_.token_info_ != nullptr) _impl_.token_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Cw20TokenInfo& Cw20Metadata::_internal_token_info() const {
  const ::injective_explorer_rpc::Cw20TokenInfo* p = _impl_.token_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Cw20TokenInfo&>(
      ::injective_explorer_rpc::_Cw20TokenInfo_default_instance_);
}
inline const ::injective_explorer_rpc::Cw20TokenInfo& Cw20Metadata::token_info() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20Metadata.token_info)
  return _internal_token_info();
}
inline void Cw20Metadata::unsafe_arena_set_allocated_token_info(
    ::injective_explorer_rpc::Cw20TokenInfo* token_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_info_);
  }
  _impl_.token_info_ = token_info;
  if (token_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.Cw20Metadata.token_info)
}
inline ::injective_explorer_rpc::Cw20TokenInfo* Cw20Metadata::release_token_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20TokenInfo* temp = _impl_.token_info_;
  _impl_.token_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Cw20TokenInfo* Cw20Metadata::unsafe_arena_release_token_info() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20Metadata.token_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20TokenInfo* temp = _impl_.token_info_;
  _impl_.token_info_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Cw20TokenInfo* Cw20Metadata::_internal_mutable_token_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Cw20TokenInfo>(GetArenaForAllocation());
    _impl_.token_info_ = p;
  }
  return _impl_.token_info_;
}
inline ::injective_explorer_rpc::Cw20TokenInfo* Cw20Metadata::mutable_token_info() {
  ::injective_explorer_rpc::Cw20TokenInfo* _msg = _internal_mutable_token_info();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20Metadata.token_info)
  return _msg;
}
inline void Cw20Metadata::set_allocated_token_info(::injective_explorer_rpc::Cw20TokenInfo* token_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_info_;
  }
  if (token_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_info);
    if (message_arena != submessage_arena) {
      token_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_info_ = token_info;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20Metadata.token_info)
}

// .injective_explorer_rpc.Cw20MarketingInfo marketing_info = 2 [json_name = "marketingInfo"];
inline bool Cw20Metadata::has_marketing_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.marketing_info_ != nullptr);
  return value;
}
inline void Cw20Metadata::clear_marketing_info() {
  if (_impl_.marketing_info_ != nullptr) _impl_.marketing_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::injective_explorer_rpc::Cw20MarketingInfo& Cw20Metadata::_internal_marketing_info() const {
  const ::injective_explorer_rpc::Cw20MarketingInfo* p = _impl_.marketing_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Cw20MarketingInfo&>(
      ::injective_explorer_rpc::_Cw20MarketingInfo_default_instance_);
}
inline const ::injective_explorer_rpc::Cw20MarketingInfo& Cw20Metadata::marketing_info() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20Metadata.marketing_info)
  return _internal_marketing_info();
}
inline void Cw20Metadata::unsafe_arena_set_allocated_marketing_info(
    ::injective_explorer_rpc::Cw20MarketingInfo* marketing_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.marketing_info_);
  }
  _impl_.marketing_info_ = marketing_info;
  if (marketing_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.Cw20Metadata.marketing_info)
}
inline ::injective_explorer_rpc::Cw20MarketingInfo* Cw20Metadata::release_marketing_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::Cw20MarketingInfo* temp = _impl_.marketing_info_;
  _impl_.marketing_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Cw20MarketingInfo* Cw20Metadata::unsafe_arena_release_marketing_info() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20Metadata.marketing_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::injective_explorer_rpc::Cw20MarketingInfo* temp = _impl_.marketing_info_;
  _impl_.marketing_info_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Cw20MarketingInfo* Cw20Metadata::_internal_mutable_marketing_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.marketing_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Cw20MarketingInfo>(GetArenaForAllocation());
    _impl_.marketing_info_ = p;
  }
  return _impl_.marketing_info_;
}
inline ::injective_explorer_rpc::Cw20MarketingInfo* Cw20Metadata::mutable_marketing_info() {
  ::injective_explorer_rpc::Cw20MarketingInfo* _msg = _internal_mutable_marketing_info();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20Metadata.marketing_info)
  return _msg;
}
inline void Cw20Metadata::set_allocated_marketing_info(::injective_explorer_rpc::Cw20MarketingInfo* marketing_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.marketing_info_;
  }
  if (marketing_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(marketing_info);
    if (message_arena != submessage_arena) {
      marketing_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketing_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.marketing_info_ = marketing_info;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20Metadata.marketing_info)
}

// -------------------------------------------------------------------

// Cw20TokenInfo

// string name = 1 [json_name = "name"];
inline void Cw20TokenInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Cw20TokenInfo::name() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20TokenInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20TokenInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20TokenInfo.name)
}
inline std::string* Cw20TokenInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20TokenInfo.name)
  return _s;
}
inline const std::string& Cw20TokenInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Cw20TokenInfo::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::release_name() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20TokenInfo.name)
  return _impl_.name_.Release();
}
inline void Cw20TokenInfo::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20TokenInfo.name)
}

// string symbol = 2 [json_name = "symbol"];
inline void Cw20TokenInfo::clear_symbol() {
  _impl_.symbol_.ClearToEmpty();
}
inline const std::string& Cw20TokenInfo::symbol() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20TokenInfo.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20TokenInfo::set_symbol(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20TokenInfo.symbol)
}
inline std::string* Cw20TokenInfo::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20TokenInfo.symbol)
  return _s;
}
inline const std::string& Cw20TokenInfo::_internal_symbol() const {
  return _impl_.symbol_.Get();
}
inline void Cw20TokenInfo::_internal_set_symbol(const std::string& value) {
  ;


  _impl_.symbol_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::_internal_mutable_symbol() {
  ;
  return _impl_.symbol_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::release_symbol() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20TokenInfo.symbol)
  return _impl_.symbol_.Release();
}
inline void Cw20TokenInfo::set_allocated_symbol(std::string* value) {
  _impl_.symbol_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.symbol_.IsDefault()) {
          _impl_.symbol_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20TokenInfo.symbol)
}

// sint64 decimals = 3 [json_name = "decimals"];
inline void Cw20TokenInfo::clear_decimals() {
  _impl_.decimals_ = ::int64_t{0};
}
inline ::int64_t Cw20TokenInfo::decimals() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20TokenInfo.decimals)
  return _internal_decimals();
}
inline void Cw20TokenInfo::set_decimals(::int64_t value) {
  _internal_set_decimals(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20TokenInfo.decimals)
}
inline ::int64_t Cw20TokenInfo::_internal_decimals() const {
  return _impl_.decimals_;
}
inline void Cw20TokenInfo::_internal_set_decimals(::int64_t value) {
  ;
  _impl_.decimals_ = value;
}

// string total_supply = 4 [json_name = "totalSupply"];
inline void Cw20TokenInfo::clear_total_supply() {
  _impl_.total_supply_.ClearToEmpty();
}
inline const std::string& Cw20TokenInfo::total_supply() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20TokenInfo.total_supply)
  return _internal_total_supply();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20TokenInfo::set_total_supply(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.total_supply_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20TokenInfo.total_supply)
}
inline std::string* Cw20TokenInfo::mutable_total_supply() {
  std::string* _s = _internal_mutable_total_supply();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20TokenInfo.total_supply)
  return _s;
}
inline const std::string& Cw20TokenInfo::_internal_total_supply() const {
  return _impl_.total_supply_.Get();
}
inline void Cw20TokenInfo::_internal_set_total_supply(const std::string& value) {
  ;


  _impl_.total_supply_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::_internal_mutable_total_supply() {
  ;
  return _impl_.total_supply_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20TokenInfo::release_total_supply() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20TokenInfo.total_supply)
  return _impl_.total_supply_.Release();
}
inline void Cw20TokenInfo::set_allocated_total_supply(std::string* value) {
  _impl_.total_supply_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_supply_.IsDefault()) {
          _impl_.total_supply_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20TokenInfo.total_supply)
}

// -------------------------------------------------------------------

// Cw20MarketingInfo

// string project = 1 [json_name = "project"];
inline void Cw20MarketingInfo::clear_project() {
  _impl_.project_.ClearToEmpty();
}
inline const std::string& Cw20MarketingInfo::project() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20MarketingInfo.project)
  return _internal_project();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20MarketingInfo::set_project(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.project_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20MarketingInfo.project)
}
inline std::string* Cw20MarketingInfo::mutable_project() {
  std::string* _s = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20MarketingInfo.project)
  return _s;
}
inline const std::string& Cw20MarketingInfo::_internal_project() const {
  return _impl_.project_.Get();
}
inline void Cw20MarketingInfo::_internal_set_project(const std::string& value) {
  ;


  _impl_.project_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::_internal_mutable_project() {
  ;
  return _impl_.project_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::release_project() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20MarketingInfo.project)
  return _impl_.project_.Release();
}
inline void Cw20MarketingInfo::set_allocated_project(std::string* value) {
  _impl_.project_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.project_.IsDefault()) {
          _impl_.project_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20MarketingInfo.project)
}

// string description = 2 [json_name = "description"];
inline void Cw20MarketingInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Cw20MarketingInfo::description() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20MarketingInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20MarketingInfo::set_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20MarketingInfo.description)
}
inline std::string* Cw20MarketingInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20MarketingInfo.description)
  return _s;
}
inline const std::string& Cw20MarketingInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Cw20MarketingInfo::_internal_set_description(const std::string& value) {
  ;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::_internal_mutable_description() {
  ;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::release_description() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20MarketingInfo.description)
  return _impl_.description_.Release();
}
inline void Cw20MarketingInfo::set_allocated_description(std::string* value) {
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20MarketingInfo.description)
}

// string logo = 3 [json_name = "logo"];
inline void Cw20MarketingInfo::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& Cw20MarketingInfo::logo() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20MarketingInfo.logo)
  return _internal_logo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20MarketingInfo::set_logo(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.logo_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20MarketingInfo.logo)
}
inline std::string* Cw20MarketingInfo::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20MarketingInfo.logo)
  return _s;
}
inline const std::string& Cw20MarketingInfo::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void Cw20MarketingInfo::_internal_set_logo(const std::string& value) {
  ;


  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::_internal_mutable_logo() {
  ;
  return _impl_.logo_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::release_logo() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20MarketingInfo.logo)
  return _impl_.logo_.Release();
}
inline void Cw20MarketingInfo::set_allocated_logo(std::string* value) {
  _impl_.logo_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logo_.IsDefault()) {
          _impl_.logo_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20MarketingInfo.logo)
}

// bytes marketing = 4 [json_name = "marketing"];
inline void Cw20MarketingInfo::clear_marketing() {
  _impl_.marketing_.ClearToEmpty();
}
inline const std::string& Cw20MarketingInfo::marketing() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Cw20MarketingInfo.marketing)
  return _internal_marketing();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Cw20MarketingInfo::set_marketing(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.marketing_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Cw20MarketingInfo.marketing)
}
inline std::string* Cw20MarketingInfo::mutable_marketing() {
  std::string* _s = _internal_mutable_marketing();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Cw20MarketingInfo.marketing)
  return _s;
}
inline const std::string& Cw20MarketingInfo::_internal_marketing() const {
  return _impl_.marketing_.Get();
}
inline void Cw20MarketingInfo::_internal_set_marketing(const std::string& value) {
  ;


  _impl_.marketing_.Set(value, GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::_internal_mutable_marketing() {
  ;
  return _impl_.marketing_.Mutable( GetArenaForAllocation());
}
inline std::string* Cw20MarketingInfo::release_marketing() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Cw20MarketingInfo.marketing)
  return _impl_.marketing_.Release();
}
inline void Cw20MarketingInfo::set_allocated_marketing(std::string* value) {
  _impl_.marketing_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.marketing_.IsDefault()) {
          _impl_.marketing_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Cw20MarketingInfo.marketing)
}

// -------------------------------------------------------------------

// GetWasmContractByAddressRequest

// string contract_address = 1 [json_name = "contractAddress"];
inline void GetWasmContractByAddressRequest::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressRequest::contract_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressRequest.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressRequest::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressRequest.contract_address)
}
inline std::string* GetWasmContractByAddressRequest::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressRequest.contract_address)
  return _s;
}
inline const std::string& GetWasmContractByAddressRequest::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void GetWasmContractByAddressRequest::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressRequest::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressRequest::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressRequest.contract_address)
  return _impl_.contract_address_.Release();
}
inline void GetWasmContractByAddressRequest::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressRequest.contract_address)
}

// -------------------------------------------------------------------

// GetWasmContractByAddressResponse

// string label = 1 [json_name = "label"];
inline void GetWasmContractByAddressResponse::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::label() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_label(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.label)
}
inline std::string* GetWasmContractByAddressResponse::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.label)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_label() const {
  return _impl_.label_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_label(const std::string& value) {
  ;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_label() {
  ;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_label() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.label)
  return _impl_.label_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_label(std::string* value) {
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.label)
}

// string address = 2 [json_name = "address"];
inline void GetWasmContractByAddressResponse::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.address)
}
inline std::string* GetWasmContractByAddressResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.address)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.address)
  return _impl_.address_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.address)
}

// string tx_hash = 3 [json_name = "txHash"];
inline void GetWasmContractByAddressResponse::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::tx_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.tx_hash)
  return _internal_tx_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_tx_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.tx_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.tx_hash)
}
inline std::string* GetWasmContractByAddressResponse::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.tx_hash)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_tx_hash(const std::string& value) {
  ;


  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_tx_hash() {
  ;
  return _impl_.tx_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_tx_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_tx_hash(std::string* value) {
  _impl_.tx_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tx_hash_.IsDefault()) {
          _impl_.tx_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.tx_hash)
}

// string creator = 4 [json_name = "creator"];
inline void GetWasmContractByAddressResponse::clear_creator() {
  _impl_.creator_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::creator() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.creator)
  return _internal_creator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_creator(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.creator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.creator)
}
inline std::string* GetWasmContractByAddressResponse::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.creator)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_creator(const std::string& value) {
  ;


  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_creator() {
  ;
  return _impl_.creator_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_creator() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.creator)
  return _impl_.creator_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_creator(std::string* value) {
  _impl_.creator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.creator_.IsDefault()) {
          _impl_.creator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.creator)
}

// uint64 executes = 5 [json_name = "executes"];
inline void GetWasmContractByAddressResponse::clear_executes() {
  _impl_.executes_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmContractByAddressResponse::executes() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.executes)
  return _internal_executes();
}
inline void GetWasmContractByAddressResponse::set_executes(::uint64_t value) {
  _internal_set_executes(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.executes)
}
inline ::uint64_t GetWasmContractByAddressResponse::_internal_executes() const {
  return _impl_.executes_;
}
inline void GetWasmContractByAddressResponse::_internal_set_executes(::uint64_t value) {
  ;
  _impl_.executes_ = value;
}

// uint64 instantiated_at = 6 [json_name = "instantiatedAt"];
inline void GetWasmContractByAddressResponse::clear_instantiated_at() {
  _impl_.instantiated_at_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmContractByAddressResponse::instantiated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.instantiated_at)
  return _internal_instantiated_at();
}
inline void GetWasmContractByAddressResponse::set_instantiated_at(::uint64_t value) {
  _internal_set_instantiated_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.instantiated_at)
}
inline ::uint64_t GetWasmContractByAddressResponse::_internal_instantiated_at() const {
  return _impl_.instantiated_at_;
}
inline void GetWasmContractByAddressResponse::_internal_set_instantiated_at(::uint64_t value) {
  ;
  _impl_.instantiated_at_ = value;
}

// string init_message = 7 [json_name = "initMessage"];
inline void GetWasmContractByAddressResponse::clear_init_message() {
  _impl_.init_message_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::init_message() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.init_message)
  return _internal_init_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_init_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.init_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.init_message)
}
inline std::string* GetWasmContractByAddressResponse::mutable_init_message() {
  std::string* _s = _internal_mutable_init_message();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.init_message)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_init_message() const {
  return _impl_.init_message_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_init_message(const std::string& value) {
  ;


  _impl_.init_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_init_message() {
  ;
  return _impl_.init_message_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_init_message() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.init_message)
  return _impl_.init_message_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_init_message(std::string* value) {
  _impl_.init_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.init_message_.IsDefault()) {
          _impl_.init_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.init_message)
}

// uint64 last_executed_at = 8 [json_name = "lastExecutedAt"];
inline void GetWasmContractByAddressResponse::clear_last_executed_at() {
  _impl_.last_executed_at_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmContractByAddressResponse::last_executed_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.last_executed_at)
  return _internal_last_executed_at();
}
inline void GetWasmContractByAddressResponse::set_last_executed_at(::uint64_t value) {
  _internal_set_last_executed_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.last_executed_at)
}
inline ::uint64_t GetWasmContractByAddressResponse::_internal_last_executed_at() const {
  return _impl_.last_executed_at_;
}
inline void GetWasmContractByAddressResponse::_internal_set_last_executed_at(::uint64_t value) {
  ;
  _impl_.last_executed_at_ = value;
}

// repeated .injective_explorer_rpc.ContractFund funds = 9 [json_name = "funds"];
inline int GetWasmContractByAddressResponse::_internal_funds_size() const {
  return _impl_.funds_.size();
}
inline int GetWasmContractByAddressResponse::funds_size() const {
  return _internal_funds_size();
}
inline void GetWasmContractByAddressResponse::clear_funds() {
  _internal_mutable_funds()->Clear();
}
inline ::injective_explorer_rpc::ContractFund* GetWasmContractByAddressResponse::mutable_funds(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.funds)
  return _internal_mutable_funds()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >*
GetWasmContractByAddressResponse::mutable_funds() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetWasmContractByAddressResponse.funds)
  return _internal_mutable_funds();
}
inline const ::injective_explorer_rpc::ContractFund& GetWasmContractByAddressResponse::_internal_funds(int index) const {
  return _internal_funds().Get(index);
}
inline const ::injective_explorer_rpc::ContractFund& GetWasmContractByAddressResponse::funds(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.funds)
  return _internal_funds(index);
}
inline ::injective_explorer_rpc::ContractFund* GetWasmContractByAddressResponse::_internal_add_funds() {
  return _internal_mutable_funds()->Add();
}
inline ::injective_explorer_rpc::ContractFund* GetWasmContractByAddressResponse::add_funds() {
  ::injective_explorer_rpc::ContractFund* _add = _internal_add_funds();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetWasmContractByAddressResponse.funds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::ContractFund >&
GetWasmContractByAddressResponse::funds() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetWasmContractByAddressResponse.funds)
  return _internal_funds();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>&
GetWasmContractByAddressResponse::_internal_funds() const {
  return _impl_.funds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::ContractFund>*
GetWasmContractByAddressResponse::_internal_mutable_funds() {
  return &_impl_.funds_;
}

// uint64 code_id = 10 [json_name = "codeId"];
inline void GetWasmContractByAddressResponse::clear_code_id() {
  _impl_.code_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetWasmContractByAddressResponse::code_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.code_id)
  return _internal_code_id();
}
inline void GetWasmContractByAddressResponse::set_code_id(::uint64_t value) {
  _internal_set_code_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.code_id)
}
inline ::uint64_t GetWasmContractByAddressResponse::_internal_code_id() const {
  return _impl_.code_id_;
}
inline void GetWasmContractByAddressResponse::_internal_set_code_id(::uint64_t value) {
  ;
  _impl_.code_id_ = value;
}

// string admin = 11 [json_name = "admin"];
inline void GetWasmContractByAddressResponse::clear_admin() {
  _impl_.admin_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::admin() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.admin)
  return _internal_admin();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_admin(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.admin_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.admin)
}
inline std::string* GetWasmContractByAddressResponse::mutable_admin() {
  std::string* _s = _internal_mutable_admin();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.admin)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_admin() const {
  return _impl_.admin_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_admin(const std::string& value) {
  ;


  _impl_.admin_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_admin() {
  ;
  return _impl_.admin_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_admin() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.admin)
  return _impl_.admin_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_admin(std::string* value) {
  _impl_.admin_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_.IsDefault()) {
          _impl_.admin_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.admin)
}

// string current_migrate_message = 12 [json_name = "currentMigrateMessage"];
inline void GetWasmContractByAddressResponse::clear_current_migrate_message() {
  _impl_.current_migrate_message_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::current_migrate_message() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.current_migrate_message)
  return _internal_current_migrate_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_current_migrate_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.current_migrate_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.current_migrate_message)
}
inline std::string* GetWasmContractByAddressResponse::mutable_current_migrate_message() {
  std::string* _s = _internal_mutable_current_migrate_message();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.current_migrate_message)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_current_migrate_message() const {
  return _impl_.current_migrate_message_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_current_migrate_message(const std::string& value) {
  ;


  _impl_.current_migrate_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_current_migrate_message() {
  ;
  return _impl_.current_migrate_message_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_current_migrate_message() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.current_migrate_message)
  return _impl_.current_migrate_message_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_current_migrate_message(std::string* value) {
  _impl_.current_migrate_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_migrate_message_.IsDefault()) {
          _impl_.current_migrate_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.current_migrate_message)
}

// sint64 contract_number = 13 [json_name = "contractNumber"];
inline void GetWasmContractByAddressResponse::clear_contract_number() {
  _impl_.contract_number_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractByAddressResponse::contract_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.contract_number)
  return _internal_contract_number();
}
inline void GetWasmContractByAddressResponse::set_contract_number(::int64_t value) {
  _internal_set_contract_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.contract_number)
}
inline ::int64_t GetWasmContractByAddressResponse::_internal_contract_number() const {
  return _impl_.contract_number_;
}
inline void GetWasmContractByAddressResponse::_internal_set_contract_number(::int64_t value) {
  ;
  _impl_.contract_number_ = value;
}

// string version = 14 [json_name = "version"];
inline void GetWasmContractByAddressResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::version() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_version(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.version)
}
inline std::string* GetWasmContractByAddressResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.version)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_version(const std::string& value) {
  ;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_version() {
  ;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_version() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.version)
  return _impl_.version_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_version(std::string* value) {
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.version)
}

// string type = 15 [json_name = "type"];
inline void GetWasmContractByAddressResponse::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GetWasmContractByAddressResponse::type() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetWasmContractByAddressResponse::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.type)
}
inline std::string* GetWasmContractByAddressResponse::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.type)
  return _s;
}
inline const std::string& GetWasmContractByAddressResponse::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GetWasmContractByAddressResponse::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* GetWasmContractByAddressResponse::release_type() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.type)
  return _impl_.type_.Release();
}
inline void GetWasmContractByAddressResponse::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.type)
}

// .injective_explorer_rpc.Cw20Metadata cw20_metadata = 16 [json_name = "cw20Metadata"];
inline bool GetWasmContractByAddressResponse::has_cw20_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cw20_metadata_ != nullptr);
  return value;
}
inline void GetWasmContractByAddressResponse::clear_cw20_metadata() {
  if (_impl_.cw20_metadata_ != nullptr) _impl_.cw20_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Cw20Metadata& GetWasmContractByAddressResponse::_internal_cw20_metadata() const {
  const ::injective_explorer_rpc::Cw20Metadata* p = _impl_.cw20_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Cw20Metadata&>(
      ::injective_explorer_rpc::_Cw20Metadata_default_instance_);
}
inline const ::injective_explorer_rpc::Cw20Metadata& GetWasmContractByAddressResponse::cw20_metadata() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.cw20_metadata)
  return _internal_cw20_metadata();
}
inline void GetWasmContractByAddressResponse::unsafe_arena_set_allocated_cw20_metadata(
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cw20_metadata_);
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  if (cw20_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.cw20_metadata)
}
inline ::injective_explorer_rpc::Cw20Metadata* GetWasmContractByAddressResponse::release_cw20_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* GetWasmContractByAddressResponse::unsafe_arena_release_cw20_metadata() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetWasmContractByAddressResponse.cw20_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* GetWasmContractByAddressResponse::_internal_mutable_cw20_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cw20_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Cw20Metadata>(GetArenaForAllocation());
    _impl_.cw20_metadata_ = p;
  }
  return _impl_.cw20_metadata_;
}
inline ::injective_explorer_rpc::Cw20Metadata* GetWasmContractByAddressResponse::mutable_cw20_metadata() {
  ::injective_explorer_rpc::Cw20Metadata* _msg = _internal_mutable_cw20_metadata();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetWasmContractByAddressResponse.cw20_metadata)
  return _msg;
}
inline void GetWasmContractByAddressResponse::set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cw20_metadata_;
  }
  if (cw20_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cw20_metadata);
    if (message_arena != submessage_arena) {
      cw20_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cw20_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetWasmContractByAddressResponse.cw20_metadata)
}

// sint64 proposal_id = 17 [json_name = "proposalId"];
inline void GetWasmContractByAddressResponse::clear_proposal_id() {
  _impl_.proposal_id_ = ::int64_t{0};
}
inline ::int64_t GetWasmContractByAddressResponse::proposal_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetWasmContractByAddressResponse.proposal_id)
  return _internal_proposal_id();
}
inline void GetWasmContractByAddressResponse::set_proposal_id(::int64_t value) {
  _internal_set_proposal_id(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetWasmContractByAddressResponse.proposal_id)
}
inline ::int64_t GetWasmContractByAddressResponse::_internal_proposal_id() const {
  return _impl_.proposal_id_;
}
inline void GetWasmContractByAddressResponse::_internal_set_proposal_id(::int64_t value) {
  ;
  _impl_.proposal_id_ = value;
}

// -------------------------------------------------------------------

// GetCw20BalanceRequest

// string address = 1 [json_name = "address"];
inline void GetCw20BalanceRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetCw20BalanceRequest::address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetCw20BalanceRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetCw20BalanceRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetCw20BalanceRequest.address)
}
inline std::string* GetCw20BalanceRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetCw20BalanceRequest.address)
  return _s;
}
inline const std::string& GetCw20BalanceRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetCw20BalanceRequest::_internal_set_address(const std::string& value) {
  ;


  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCw20BalanceRequest::_internal_mutable_address() {
  ;
  return _impl_.address_.Mutable( GetArenaForAllocation());
}
inline std::string* GetCw20BalanceRequest::release_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.GetCw20BalanceRequest.address)
  return _impl_.address_.Release();
}
inline void GetCw20BalanceRequest::set_allocated_address(std::string* value) {
  _impl_.address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.GetCw20BalanceRequest.address)
}

// sint32 limit = 2 [json_name = "limit"];
inline void GetCw20BalanceRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline ::int32_t GetCw20BalanceRequest::limit() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetCw20BalanceRequest.limit)
  return _internal_limit();
}
inline void GetCw20BalanceRequest::set_limit(::int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.GetCw20BalanceRequest.limit)
}
inline ::int32_t GetCw20BalanceRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline void GetCw20BalanceRequest::_internal_set_limit(::int32_t value) {
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// GetCw20BalanceResponse

// repeated .injective_explorer_rpc.WasmCw20Balance field = 1 [json_name = "field"];
inline int GetCw20BalanceResponse::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int GetCw20BalanceResponse::field_size() const {
  return _internal_field_size();
}
inline void GetCw20BalanceResponse::clear_field() {
  _internal_mutable_field()->Clear();
}
inline ::injective_explorer_rpc::WasmCw20Balance* GetCw20BalanceResponse::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.GetCw20BalanceResponse.field)
  return _internal_mutable_field()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCw20Balance >*
GetCw20BalanceResponse::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.GetCw20BalanceResponse.field)
  return _internal_mutable_field();
}
inline const ::injective_explorer_rpc::WasmCw20Balance& GetCw20BalanceResponse::_internal_field(int index) const {
  return _internal_field().Get(index);
}
inline const ::injective_explorer_rpc::WasmCw20Balance& GetCw20BalanceResponse::field(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.GetCw20BalanceResponse.field)
  return _internal_field(index);
}
inline ::injective_explorer_rpc::WasmCw20Balance* GetCw20BalanceResponse::_internal_add_field() {
  return _internal_mutable_field()->Add();
}
inline ::injective_explorer_rpc::WasmCw20Balance* GetCw20BalanceResponse::add_field() {
  ::injective_explorer_rpc::WasmCw20Balance* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.GetCw20BalanceResponse.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::WasmCw20Balance >&
GetCw20BalanceResponse::field() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.GetCw20BalanceResponse.field)
  return _internal_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCw20Balance>&
GetCw20BalanceResponse::_internal_field() const {
  return _impl_.field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::WasmCw20Balance>*
GetCw20BalanceResponse::_internal_mutable_field() {
  return &_impl_.field_;
}

// -------------------------------------------------------------------

// WasmCw20Balance

// string contract_address = 1 [json_name = "contractAddress"];
inline void WasmCw20Balance::clear_contract_address() {
  _impl_.contract_address_.ClearToEmpty();
}
inline const std::string& WasmCw20Balance::contract_address() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCw20Balance.contract_address)
  return _internal_contract_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCw20Balance::set_contract_address(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.contract_address_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCw20Balance.contract_address)
}
inline std::string* WasmCw20Balance::mutable_contract_address() {
  std::string* _s = _internal_mutable_contract_address();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCw20Balance.contract_address)
  return _s;
}
inline const std::string& WasmCw20Balance::_internal_contract_address() const {
  return _impl_.contract_address_.Get();
}
inline void WasmCw20Balance::_internal_set_contract_address(const std::string& value) {
  ;


  _impl_.contract_address_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::_internal_mutable_contract_address() {
  ;
  return _impl_.contract_address_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::release_contract_address() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCw20Balance.contract_address)
  return _impl_.contract_address_.Release();
}
inline void WasmCw20Balance::set_allocated_contract_address(std::string* value) {
  _impl_.contract_address_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contract_address_.IsDefault()) {
          _impl_.contract_address_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCw20Balance.contract_address)
}

// string account = 2 [json_name = "account"];
inline void WasmCw20Balance::clear_account() {
  _impl_.account_.ClearToEmpty();
}
inline const std::string& WasmCw20Balance::account() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCw20Balance.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCw20Balance::set_account(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCw20Balance.account)
}
inline std::string* WasmCw20Balance::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCw20Balance.account)
  return _s;
}
inline const std::string& WasmCw20Balance::_internal_account() const {
  return _impl_.account_.Get();
}
inline void WasmCw20Balance::_internal_set_account(const std::string& value) {
  ;


  _impl_.account_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::_internal_mutable_account() {
  ;
  return _impl_.account_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::release_account() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCw20Balance.account)
  return _impl_.account_.Release();
}
inline void WasmCw20Balance::set_allocated_account(std::string* value) {
  _impl_.account_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_.IsDefault()) {
          _impl_.account_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCw20Balance.account)
}

// string balance = 3 [json_name = "balance"];
inline void WasmCw20Balance::clear_balance() {
  _impl_.balance_.ClearToEmpty();
}
inline const std::string& WasmCw20Balance::balance() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCw20Balance.balance)
  return _internal_balance();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WasmCw20Balance::set_balance(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.balance_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCw20Balance.balance)
}
inline std::string* WasmCw20Balance::mutable_balance() {
  std::string* _s = _internal_mutable_balance();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCw20Balance.balance)
  return _s;
}
inline const std::string& WasmCw20Balance::_internal_balance() const {
  return _impl_.balance_.Get();
}
inline void WasmCw20Balance::_internal_set_balance(const std::string& value) {
  ;


  _impl_.balance_.Set(value, GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::_internal_mutable_balance() {
  ;
  return _impl_.balance_.Mutable( GetArenaForAllocation());
}
inline std::string* WasmCw20Balance::release_balance() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCw20Balance.balance)
  return _impl_.balance_.Release();
}
inline void WasmCw20Balance::set_allocated_balance(std::string* value) {
  _impl_.balance_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.balance_.IsDefault()) {
          _impl_.balance_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCw20Balance.balance)
}

// sint64 updated_at = 4 [json_name = "updatedAt"];
inline void WasmCw20Balance::clear_updated_at() {
  _impl_.updated_at_ = ::int64_t{0};
}
inline ::int64_t WasmCw20Balance::updated_at() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCw20Balance.updated_at)
  return _internal_updated_at();
}
inline void WasmCw20Balance::set_updated_at(::int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.WasmCw20Balance.updated_at)
}
inline ::int64_t WasmCw20Balance::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline void WasmCw20Balance::_internal_set_updated_at(::int64_t value) {
  ;
  _impl_.updated_at_ = value;
}

// .injective_explorer_rpc.Cw20Metadata cw20_metadata = 5 [json_name = "cw20Metadata"];
inline bool WasmCw20Balance::has_cw20_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cw20_metadata_ != nullptr);
  return value;
}
inline void WasmCw20Balance::clear_cw20_metadata() {
  if (_impl_.cw20_metadata_ != nullptr) _impl_.cw20_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::injective_explorer_rpc::Cw20Metadata& WasmCw20Balance::_internal_cw20_metadata() const {
  const ::injective_explorer_rpc::Cw20Metadata* p = _impl_.cw20_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::injective_explorer_rpc::Cw20Metadata&>(
      ::injective_explorer_rpc::_Cw20Metadata_default_instance_);
}
inline const ::injective_explorer_rpc::Cw20Metadata& WasmCw20Balance::cw20_metadata() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.WasmCw20Balance.cw20_metadata)
  return _internal_cw20_metadata();
}
inline void WasmCw20Balance::unsafe_arena_set_allocated_cw20_metadata(
    ::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cw20_metadata_);
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  if (cw20_metadata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:injective_explorer_rpc.WasmCw20Balance.cw20_metadata)
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmCw20Balance::release_cw20_metadata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmCw20Balance::unsafe_arena_release_cw20_metadata() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.WasmCw20Balance.cw20_metadata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::injective_explorer_rpc::Cw20Metadata* temp = _impl_.cw20_metadata_;
  _impl_.cw20_metadata_ = nullptr;
  return temp;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmCw20Balance::_internal_mutable_cw20_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cw20_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::injective_explorer_rpc::Cw20Metadata>(GetArenaForAllocation());
    _impl_.cw20_metadata_ = p;
  }
  return _impl_.cw20_metadata_;
}
inline ::injective_explorer_rpc::Cw20Metadata* WasmCw20Balance::mutable_cw20_metadata() {
  ::injective_explorer_rpc::Cw20Metadata* _msg = _internal_mutable_cw20_metadata();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.WasmCw20Balance.cw20_metadata)
  return _msg;
}
inline void WasmCw20Balance::set_allocated_cw20_metadata(::injective_explorer_rpc::Cw20Metadata* cw20_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cw20_metadata_;
  }
  if (cw20_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cw20_metadata);
    if (message_arena != submessage_arena) {
      cw20_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cw20_metadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cw20_metadata_ = cw20_metadata;
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.WasmCw20Balance.cw20_metadata)
}

// -------------------------------------------------------------------

// RelayersRequest

// repeated string market_i_ds = 1 [json_name = "marketIDs"];
inline int RelayersRequest::_internal_market_i_ds_size() const {
  return _impl_.market_i_ds_.size();
}
inline int RelayersRequest::market_i_ds_size() const {
  return _internal_market_i_ds_size();
}
inline void RelayersRequest::clear_market_i_ds() {
  _internal_mutable_market_i_ds()->Clear();
}
inline std::string* RelayersRequest::add_market_i_ds() {
  std::string* _s = _internal_add_market_i_ds();
  // @@protoc_insertion_point(field_add_mutable:injective_explorer_rpc.RelayersRequest.market_i_ds)
  return _s;
}
inline const std::string& RelayersRequest::market_i_ds(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.RelayersRequest.market_i_ds)
  return _internal_market_i_ds(index);
}
inline std::string* RelayersRequest::mutable_market_i_ds(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.RelayersRequest.market_i_ds)
  return _internal_mutable_market_i_ds()->Mutable(index);
}
inline void RelayersRequest::set_market_i_ds(int index, const std::string& value) {
  _internal_mutable_market_i_ds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::set_market_i_ds(int index, std::string&& value) {
  _internal_mutable_market_i_ds()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::set_market_i_ds(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_i_ds()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::set_market_i_ds(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_market_i_ds()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::set_market_i_ds(int index, absl::string_view value) {
  _internal_mutable_market_i_ds()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::add_market_i_ds(const std::string& value) {
  _internal_mutable_market_i_ds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::add_market_i_ds(std::string&& value) {
  _internal_mutable_market_i_ds()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::add_market_i_ds(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_market_i_ds()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::add_market_i_ds(const char* value, std::size_t size) {
  _internal_mutable_market_i_ds()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline void RelayersRequest::add_market_i_ds(absl::string_view value) {
  _internal_mutable_market_i_ds()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:injective_explorer_rpc.RelayersRequest.market_i_ds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RelayersRequest::market_i_ds() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.RelayersRequest.market_i_ds)
  return _internal_market_i_ds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RelayersRequest::mutable_market_i_ds() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.RelayersRequest.market_i_ds)
  return _internal_mutable_market_i_ds();
}
inline const std::string& RelayersRequest::_internal_market_i_ds(int index) const {
  return _internal_market_i_ds().Get(index);
}
inline std::string* RelayersRequest::_internal_add_market_i_ds() {
  return _internal_mutable_market_i_ds()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RelayersRequest::_internal_market_i_ds() const {
  return _impl_.market_i_ds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RelayersRequest::_internal_mutable_market_i_ds() {
  return &_impl_.market_i_ds_;
}

// -------------------------------------------------------------------

// RelayersResponse

// repeated .injective_explorer_rpc.RelayerMarkets field = 1 [json_name = "field"];
inline int RelayersResponse::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int RelayersResponse::field_size() const {
  return _internal_field_size();
}
inline void RelayersResponse::clear_field() {
  _internal_mutable_field()->Clear();
}
inline ::injective_explorer_rpc::RelayerMarkets* RelayersResponse::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.RelayersResponse.field)
  return _internal_mutable_field()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::RelayerMarkets >*
RelayersResponse::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.RelayersResponse.field)
  return _internal_mutable_field();
}
inline const ::injective_explorer_rpc::RelayerMarkets& RelayersResponse::_internal_field(int index) const {
  return _internal_field().Get(index);
}
inline const ::injective_explorer_rpc::RelayerMarkets& RelayersResponse::field(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.RelayersResponse.field)
  return _internal_field(index);
}
inline ::injective_explorer_rpc::RelayerMarkets* RelayersResponse::_internal_add_field() {
  return _internal_mutable_field()->Add();
}
inline ::injective_explorer_rpc::RelayerMarkets* RelayersResponse::add_field() {
  ::injective_explorer_rpc::RelayerMarkets* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.RelayersResponse.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::RelayerMarkets >&
RelayersResponse::field() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.RelayersResponse.field)
  return _internal_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::RelayerMarkets>&
RelayersResponse::_internal_field() const {
  return _impl_.field_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::RelayerMarkets>*
RelayersResponse::_internal_mutable_field() {
  return &_impl_.field_;
}

// -------------------------------------------------------------------

// RelayerMarkets

// string market_id = 1 [json_name = "marketId"];
inline void RelayerMarkets::clear_market_id() {
  _impl_.market_id_.ClearToEmpty();
}
inline const std::string& RelayerMarkets::market_id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.RelayerMarkets.market_id)
  return _internal_market_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RelayerMarkets::set_market_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.market_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.RelayerMarkets.market_id)
}
inline std::string* RelayerMarkets::mutable_market_id() {
  std::string* _s = _internal_mutable_market_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.RelayerMarkets.market_id)
  return _s;
}
inline const std::string& RelayerMarkets::_internal_market_id() const {
  return _impl_.market_id_.Get();
}
inline void RelayerMarkets::_internal_set_market_id(const std::string& value) {
  ;


  _impl_.market_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RelayerMarkets::_internal_mutable_market_id() {
  ;
  return _impl_.market_id_.Mutable( GetArenaForAllocation());
}
inline std::string* RelayerMarkets::release_market_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.RelayerMarkets.market_id)
  return _impl_.market_id_.Release();
}
inline void RelayerMarkets::set_allocated_market_id(std::string* value) {
  _impl_.market_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.market_id_.IsDefault()) {
          _impl_.market_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.RelayerMarkets.market_id)
}

// repeated .injective_explorer_rpc.Relayer relayers = 2 [json_name = "relayers"];
inline int RelayerMarkets::_internal_relayers_size() const {
  return _impl_.relayers_.size();
}
inline int RelayerMarkets::relayers_size() const {
  return _internal_relayers_size();
}
inline void RelayerMarkets::clear_relayers() {
  _internal_mutable_relayers()->Clear();
}
inline ::injective_explorer_rpc::Relayer* RelayerMarkets::mutable_relayers(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.RelayerMarkets.relayers)
  return _internal_mutable_relayers()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Relayer >*
RelayerMarkets::mutable_relayers() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.RelayerMarkets.relayers)
  return _internal_mutable_relayers();
}
inline const ::injective_explorer_rpc::Relayer& RelayerMarkets::_internal_relayers(int index) const {
  return _internal_relayers().Get(index);
}
inline const ::injective_explorer_rpc::Relayer& RelayerMarkets::relayers(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.RelayerMarkets.relayers)
  return _internal_relayers(index);
}
inline ::injective_explorer_rpc::Relayer* RelayerMarkets::_internal_add_relayers() {
  return _internal_mutable_relayers()->Add();
}
inline ::injective_explorer_rpc::Relayer* RelayerMarkets::add_relayers() {
  ::injective_explorer_rpc::Relayer* _add = _internal_add_relayers();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.RelayerMarkets.relayers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::Relayer >&
RelayerMarkets::relayers() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.RelayerMarkets.relayers)
  return _internal_relayers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Relayer>&
RelayerMarkets::_internal_relayers() const {
  return _impl_.relayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::Relayer>*
RelayerMarkets::_internal_mutable_relayers() {
  return &_impl_.relayers_;
}

// -------------------------------------------------------------------

// Relayer

// string name = 1 [json_name = "name"];
inline void Relayer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Relayer::name() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Relayer.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relayer::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Relayer.name)
}
inline std::string* Relayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Relayer.name)
  return _s;
}
inline const std::string& Relayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Relayer::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Relayer::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Relayer::release_name() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Relayer.name)
  return _impl_.name_.Release();
}
inline void Relayer::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Relayer.name)
}

// string cta = 2 [json_name = "cta"];
inline void Relayer::clear_cta() {
  _impl_.cta_.ClearToEmpty();
}
inline const std::string& Relayer::cta() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.Relayer.cta)
  return _internal_cta();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Relayer::set_cta(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.cta_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.Relayer.cta)
}
inline std::string* Relayer::mutable_cta() {
  std::string* _s = _internal_mutable_cta();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.Relayer.cta)
  return _s;
}
inline const std::string& Relayer::_internal_cta() const {
  return _impl_.cta_.Get();
}
inline void Relayer::_internal_set_cta(const std::string& value) {
  ;


  _impl_.cta_.Set(value, GetArenaForAllocation());
}
inline std::string* Relayer::_internal_mutable_cta() {
  ;
  return _impl_.cta_.Mutable( GetArenaForAllocation());
}
inline std::string* Relayer::release_cta() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.Relayer.cta)
  return _impl_.cta_.Release();
}
inline void Relayer::set_allocated_cta(std::string* value) {
  _impl_.cta_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cta_.IsDefault()) {
          _impl_.cta_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.Relayer.cta)
}

// -------------------------------------------------------------------

// StreamTxsRequest

// -------------------------------------------------------------------

// StreamTxsResponse

// string id = 1 [json_name = "id"];
inline void StreamTxsResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::id() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.id)
}
inline std::string* StreamTxsResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.id)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void StreamTxsResponse::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_id() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.id)
  return _impl_.id_.Release();
}
inline void StreamTxsResponse::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.id)
}

// uint64 block_number = 2 [json_name = "blockNumber"];
inline void StreamTxsResponse::clear_block_number() {
  _impl_.block_number_ = ::uint64_t{0u};
}
inline ::uint64_t StreamTxsResponse::block_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.block_number)
  return _internal_block_number();
}
inline void StreamTxsResponse::set_block_number(::uint64_t value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.block_number)
}
inline ::uint64_t StreamTxsResponse::_internal_block_number() const {
  return _impl_.block_number_;
}
inline void StreamTxsResponse::_internal_set_block_number(::uint64_t value) {
  ;
  _impl_.block_number_ = value;
}

// string block_timestamp = 3 [json_name = "blockTimestamp"];
inline void StreamTxsResponse::clear_block_timestamp() {
  _impl_.block_timestamp_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::block_timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.block_timestamp)
  return _internal_block_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_block_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.block_timestamp)
}
inline std::string* StreamTxsResponse::mutable_block_timestamp() {
  std::string* _s = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.block_timestamp)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_block_timestamp() const {
  return _impl_.block_timestamp_.Get();
}
inline void StreamTxsResponse::_internal_set_block_timestamp(const std::string& value) {
  ;


  _impl_.block_timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_block_timestamp() {
  ;
  return _impl_.block_timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_block_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.block_timestamp)
  return _impl_.block_timestamp_.Release();
}
inline void StreamTxsResponse::set_allocated_block_timestamp(std::string* value) {
  _impl_.block_timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_timestamp_.IsDefault()) {
          _impl_.block_timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.block_timestamp)
}

// string hash = 4 [json_name = "hash"];
inline void StreamTxsResponse::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.hash)
}
inline std::string* StreamTxsResponse::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.hash)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void StreamTxsResponse::_internal_set_hash(const std::string& value) {
  ;


  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_hash() {
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.hash)
  return _impl_.hash_.Release();
}
inline void StreamTxsResponse::set_allocated_hash(std::string* value) {
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.hash)
}

// string codespace = 5 [json_name = "codespace"];
inline void StreamTxsResponse::clear_codespace() {
  _impl_.codespace_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::codespace() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.codespace)
  return _internal_codespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_codespace(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.codespace_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.codespace)
}
inline std::string* StreamTxsResponse::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.codespace)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_codespace() const {
  return _impl_.codespace_.Get();
}
inline void StreamTxsResponse::_internal_set_codespace(const std::string& value) {
  ;


  _impl_.codespace_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_codespace() {
  ;
  return _impl_.codespace_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_codespace() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.codespace)
  return _impl_.codespace_.Release();
}
inline void StreamTxsResponse::set_allocated_codespace(std::string* value) {
  _impl_.codespace_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codespace_.IsDefault()) {
          _impl_.codespace_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.codespace)
}

// string messages = 6 [json_name = "messages"];
inline void StreamTxsResponse::clear_messages() {
  _impl_.messages_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::messages() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.messages)
  return _internal_messages();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_messages(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.messages_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.messages)
}
inline std::string* StreamTxsResponse::mutable_messages() {
  std::string* _s = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.messages)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_messages() const {
  return _impl_.messages_.Get();
}
inline void StreamTxsResponse::_internal_set_messages(const std::string& value) {
  ;


  _impl_.messages_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_messages() {
  ;
  return _impl_.messages_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_messages() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.messages)
  return _impl_.messages_.Release();
}
inline void StreamTxsResponse::set_allocated_messages(std::string* value) {
  _impl_.messages_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.messages_.IsDefault()) {
          _impl_.messages_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.messages)
}

// uint64 tx_number = 7 [json_name = "txNumber"];
inline void StreamTxsResponse::clear_tx_number() {
  _impl_.tx_number_ = ::uint64_t{0u};
}
inline ::uint64_t StreamTxsResponse::tx_number() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.tx_number)
  return _internal_tx_number();
}
inline void StreamTxsResponse::set_tx_number(::uint64_t value) {
  _internal_set_tx_number(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.tx_number)
}
inline ::uint64_t StreamTxsResponse::_internal_tx_number() const {
  return _impl_.tx_number_;
}
inline void StreamTxsResponse::_internal_set_tx_number(::uint64_t value) {
  ;
  _impl_.tx_number_ = value;
}

// string error_log = 8 [json_name = "errorLog"];
inline void StreamTxsResponse::clear_error_log() {
  _impl_.error_log_.ClearToEmpty();
}
inline const std::string& StreamTxsResponse::error_log() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.error_log)
  return _internal_error_log();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamTxsResponse::set_error_log(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.error_log_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.error_log)
}
inline std::string* StreamTxsResponse::mutable_error_log() {
  std::string* _s = _internal_mutable_error_log();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamTxsResponse.error_log)
  return _s;
}
inline const std::string& StreamTxsResponse::_internal_error_log() const {
  return _impl_.error_log_.Get();
}
inline void StreamTxsResponse::_internal_set_error_log(const std::string& value) {
  ;


  _impl_.error_log_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::_internal_mutable_error_log() {
  ;
  return _impl_.error_log_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamTxsResponse::release_error_log() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamTxsResponse.error_log)
  return _impl_.error_log_.Release();
}
inline void StreamTxsResponse::set_allocated_error_log(std::string* value) {
  _impl_.error_log_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_log_.IsDefault()) {
          _impl_.error_log_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamTxsResponse.error_log)
}

// uint32 code = 9 [json_name = "code"];
inline void StreamTxsResponse::clear_code() {
  _impl_.code_ = 0u;
}
inline ::uint32_t StreamTxsResponse::code() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamTxsResponse.code)
  return _internal_code();
}
inline void StreamTxsResponse::set_code(::uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamTxsResponse.code)
}
inline ::uint32_t StreamTxsResponse::_internal_code() const {
  return _impl_.code_;
}
inline void StreamTxsResponse::_internal_set_code(::uint32_t value) {
  ;
  _impl_.code_ = value;
}

// -------------------------------------------------------------------

// StreamBlocksRequest

// -------------------------------------------------------------------

// StreamBlocksResponse

// uint64 height = 1 [json_name = "height"];
inline void StreamBlocksResponse::clear_height() {
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t StreamBlocksResponse::height() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.height)
  return _internal_height();
}
inline void StreamBlocksResponse::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.height)
}
inline ::uint64_t StreamBlocksResponse::_internal_height() const {
  return _impl_.height_;
}
inline void StreamBlocksResponse::_internal_set_height(::uint64_t value) {
  ;
  _impl_.height_ = value;
}

// string proposer = 2 [json_name = "proposer"];
inline void StreamBlocksResponse::clear_proposer() {
  _impl_.proposer_.ClearToEmpty();
}
inline const std::string& StreamBlocksResponse::proposer() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.proposer)
  return _internal_proposer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlocksResponse::set_proposer(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.proposer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.proposer)
}
inline std::string* StreamBlocksResponse::mutable_proposer() {
  std::string* _s = _internal_mutable_proposer();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.proposer)
  return _s;
}
inline const std::string& StreamBlocksResponse::_internal_proposer() const {
  return _impl_.proposer_.Get();
}
inline void StreamBlocksResponse::_internal_set_proposer(const std::string& value) {
  ;


  _impl_.proposer_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::_internal_mutable_proposer() {
  ;
  return _impl_.proposer_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::release_proposer() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamBlocksResponse.proposer)
  return _impl_.proposer_.Release();
}
inline void StreamBlocksResponse::set_allocated_proposer(std::string* value) {
  _impl_.proposer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proposer_.IsDefault()) {
          _impl_.proposer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamBlocksResponse.proposer)
}

// string moniker = 3 [json_name = "moniker"];
inline void StreamBlocksResponse::clear_moniker() {
  _impl_.moniker_.ClearToEmpty();
}
inline const std::string& StreamBlocksResponse::moniker() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.moniker)
  return _internal_moniker();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlocksResponse::set_moniker(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.moniker_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.moniker)
}
inline std::string* StreamBlocksResponse::mutable_moniker() {
  std::string* _s = _internal_mutable_moniker();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.moniker)
  return _s;
}
inline const std::string& StreamBlocksResponse::_internal_moniker() const {
  return _impl_.moniker_.Get();
}
inline void StreamBlocksResponse::_internal_set_moniker(const std::string& value) {
  ;


  _impl_.moniker_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::_internal_mutable_moniker() {
  ;
  return _impl_.moniker_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::release_moniker() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamBlocksResponse.moniker)
  return _impl_.moniker_.Release();
}
inline void StreamBlocksResponse::set_allocated_moniker(std::string* value) {
  _impl_.moniker_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.moniker_.IsDefault()) {
          _impl_.moniker_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamBlocksResponse.moniker)
}

// string block_hash = 4 [json_name = "blockHash"];
inline void StreamBlocksResponse::clear_block_hash() {
  _impl_.block_hash_.ClearToEmpty();
}
inline const std::string& StreamBlocksResponse::block_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.block_hash)
  return _internal_block_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlocksResponse::set_block_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.block_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.block_hash)
}
inline std::string* StreamBlocksResponse::mutable_block_hash() {
  std::string* _s = _internal_mutable_block_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.block_hash)
  return _s;
}
inline const std::string& StreamBlocksResponse::_internal_block_hash() const {
  return _impl_.block_hash_.Get();
}
inline void StreamBlocksResponse::_internal_set_block_hash(const std::string& value) {
  ;


  _impl_.block_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::_internal_mutable_block_hash() {
  ;
  return _impl_.block_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::release_block_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamBlocksResponse.block_hash)
  return _impl_.block_hash_.Release();
}
inline void StreamBlocksResponse::set_allocated_block_hash(std::string* value) {
  _impl_.block_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.block_hash_.IsDefault()) {
          _impl_.block_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamBlocksResponse.block_hash)
}

// string parent_hash = 5 [json_name = "parentHash"];
inline void StreamBlocksResponse::clear_parent_hash() {
  _impl_.parent_hash_.ClearToEmpty();
}
inline const std::string& StreamBlocksResponse::parent_hash() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.parent_hash)
  return _internal_parent_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlocksResponse::set_parent_hash(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.parent_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.parent_hash)
}
inline std::string* StreamBlocksResponse::mutable_parent_hash() {
  std::string* _s = _internal_mutable_parent_hash();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.parent_hash)
  return _s;
}
inline const std::string& StreamBlocksResponse::_internal_parent_hash() const {
  return _impl_.parent_hash_.Get();
}
inline void StreamBlocksResponse::_internal_set_parent_hash(const std::string& value) {
  ;


  _impl_.parent_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::_internal_mutable_parent_hash() {
  ;
  return _impl_.parent_hash_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::release_parent_hash() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamBlocksResponse.parent_hash)
  return _impl_.parent_hash_.Release();
}
inline void StreamBlocksResponse::set_allocated_parent_hash(std::string* value) {
  _impl_.parent_hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_hash_.IsDefault()) {
          _impl_.parent_hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamBlocksResponse.parent_hash)
}

// sint64 num_pre_commits = 6 [json_name = "numPreCommits"];
inline void StreamBlocksResponse::clear_num_pre_commits() {
  _impl_.num_pre_commits_ = ::int64_t{0};
}
inline ::int64_t StreamBlocksResponse::num_pre_commits() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.num_pre_commits)
  return _internal_num_pre_commits();
}
inline void StreamBlocksResponse::set_num_pre_commits(::int64_t value) {
  _internal_set_num_pre_commits(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.num_pre_commits)
}
inline ::int64_t StreamBlocksResponse::_internal_num_pre_commits() const {
  return _impl_.num_pre_commits_;
}
inline void StreamBlocksResponse::_internal_set_num_pre_commits(::int64_t value) {
  ;
  _impl_.num_pre_commits_ = value;
}

// sint64 num_txs = 7 [json_name = "numTxs"];
inline void StreamBlocksResponse::clear_num_txs() {
  _impl_.num_txs_ = ::int64_t{0};
}
inline ::int64_t StreamBlocksResponse::num_txs() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.num_txs)
  return _internal_num_txs();
}
inline void StreamBlocksResponse::set_num_txs(::int64_t value) {
  _internal_set_num_txs(value);
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.num_txs)
}
inline ::int64_t StreamBlocksResponse::_internal_num_txs() const {
  return _impl_.num_txs_;
}
inline void StreamBlocksResponse::_internal_set_num_txs(::int64_t value) {
  ;
  _impl_.num_txs_ = value;
}

// repeated .injective_explorer_rpc.TxDataRPC txs = 8 [json_name = "txs"];
inline int StreamBlocksResponse::_internal_txs_size() const {
  return _impl_.txs_.size();
}
inline int StreamBlocksResponse::txs_size() const {
  return _internal_txs_size();
}
inline void StreamBlocksResponse::clear_txs() {
  _internal_mutable_txs()->Clear();
}
inline ::injective_explorer_rpc::TxDataRPC* StreamBlocksResponse::mutable_txs(int index) {
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.txs)
  return _internal_mutable_txs()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >*
StreamBlocksResponse::mutable_txs() {
  // @@protoc_insertion_point(field_mutable_list:injective_explorer_rpc.StreamBlocksResponse.txs)
  return _internal_mutable_txs();
}
inline const ::injective_explorer_rpc::TxDataRPC& StreamBlocksResponse::_internal_txs(int index) const {
  return _internal_txs().Get(index);
}
inline const ::injective_explorer_rpc::TxDataRPC& StreamBlocksResponse::txs(int index) const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.txs)
  return _internal_txs(index);
}
inline ::injective_explorer_rpc::TxDataRPC* StreamBlocksResponse::_internal_add_txs() {
  return _internal_mutable_txs()->Add();
}
inline ::injective_explorer_rpc::TxDataRPC* StreamBlocksResponse::add_txs() {
  ::injective_explorer_rpc::TxDataRPC* _add = _internal_add_txs();
  // @@protoc_insertion_point(field_add:injective_explorer_rpc.StreamBlocksResponse.txs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::injective_explorer_rpc::TxDataRPC >&
StreamBlocksResponse::txs() const {
  // @@protoc_insertion_point(field_list:injective_explorer_rpc.StreamBlocksResponse.txs)
  return _internal_txs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>&
StreamBlocksResponse::_internal_txs() const {
  return _impl_.txs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::injective_explorer_rpc::TxDataRPC>*
StreamBlocksResponse::_internal_mutable_txs() {
  return &_impl_.txs_;
}

// string timestamp = 9 [json_name = "timestamp"];
inline void StreamBlocksResponse::clear_timestamp() {
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& StreamBlocksResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:injective_explorer_rpc.StreamBlocksResponse.timestamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreamBlocksResponse::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.timestamp_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:injective_explorer_rpc.StreamBlocksResponse.timestamp)
}
inline std::string* StreamBlocksResponse::mutable_timestamp() {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:injective_explorer_rpc.StreamBlocksResponse.timestamp)
  return _s;
}
inline const std::string& StreamBlocksResponse::_internal_timestamp() const {
  return _impl_.timestamp_.Get();
}
inline void StreamBlocksResponse::_internal_set_timestamp(const std::string& value) {
  ;


  _impl_.timestamp_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::_internal_mutable_timestamp() {
  ;
  return _impl_.timestamp_.Mutable( GetArenaForAllocation());
}
inline std::string* StreamBlocksResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:injective_explorer_rpc.StreamBlocksResponse.timestamp)
  return _impl_.timestamp_.Release();
}
inline void StreamBlocksResponse::set_allocated_timestamp(std::string* value) {
  _impl_.timestamp_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:injective_explorer_rpc.StreamBlocksResponse.timestamp)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace injective_explorer_rpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_exchange_2finjective_5fexplorer_5frpc_2eproto_2epb_2eh
