// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: exchange/injective_derivative_exchange_rpc.proto
// Original file comments:
// Code generated with goa v3.5.2, DO NOT EDIT.
//
// InjectiveDerivativeExchangeRPC protocol buffer definition
//
// Command:
// $$ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
#ifndef GRPC_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto__INCLUDED
#define GRPC_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto__INCLUDED

#include "exchange/injective_derivative_exchange_rpc.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace injective_derivative_exchange_rpc {

// InjectiveDerivativeExchangeRPC defines gRPC API of Derivative Markets
// provider.
class InjectiveDerivativeExchangeRPC final {
 public:
  static constexpr char const* service_full_name() {
    return "injective_derivative_exchange_rpc.InjectiveDerivativeExchangeRPC";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Markets gets a list of Derivative Markets
    virtual ::grpc::Status Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::injective_derivative_exchange_rpc::MarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>> AsyncMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>>(AsyncMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>> PrepareAsyncMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>>(PrepareAsyncMarketsRaw(context, request, cq));
    }
    // Market gets details of a single derivative market
    virtual ::grpc::Status Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::injective_derivative_exchange_rpc::MarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>> AsyncMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>>(AsyncMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>> PrepareAsyncMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>>(PrepareAsyncMarketRaw(context, request, cq));
    }
    // StreamMarket streams live updates of selected derivative markets
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>> StreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(StreamMarketRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>> AsyncStreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(AsyncStreamMarketRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>> PrepareAsyncStreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(PrepareAsyncStreamMarketRaw(context, request, cq));
    }
    // BinaryOptionsMarkets gets a list of Binary Options Markets
    virtual ::grpc::Status BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>> AsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>>(AsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>> PrepareAsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>>(PrepareAsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    // BinaryOptionMarket gets details of a single binary options market
    virtual ::grpc::Status BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>> AsyncBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>>(AsyncBinaryOptionsMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>> PrepareAsyncBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>>(PrepareAsyncBinaryOptionsMarketRaw(context, request, cq));
    }
    // Orderbook gets the Orderbook of a Derivative Market
    virtual ::grpc::Status Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::injective_derivative_exchange_rpc::OrderbookResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>> AsyncOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>>(AsyncOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>> PrepareAsyncOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>>(PrepareAsyncOrderbookRaw(context, request, cq));
    }
    // Orderbook gets the Orderbook of a Derivative Market
    virtual ::grpc::Status OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>> AsyncOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>>(AsyncOrderbookV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>> PrepareAsyncOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>>(PrepareAsyncOrderbookV2Raw(context, request, cq));
    }
    // Orderbooks gets the Orderbooks of requested derivative markets
    virtual ::grpc::Status Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>> AsyncOrderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>>(AsyncOrderbooksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>> PrepareAsyncOrderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>>(PrepareAsyncOrderbooksRaw(context, request, cq));
    }
    // Orderbooks gets the Orderbooks of requested derivative markets
    virtual ::grpc::Status OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>> AsyncOrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>>(AsyncOrderbooksV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>> PrepareAsyncOrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>>(PrepareAsyncOrderbooksV2Raw(context, request, cq));
    }
    // Stream live snapshot updates of selected derivative market orderbook
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> StreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(StreamOrderbookRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> AsyncStreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(AsyncStreamOrderbookRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> PrepareAsyncStreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(PrepareAsyncStreamOrderbookRaw(context, request, cq));
    }
    // Stream live snapshot updates of selected derivative market orderbook
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> StreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(StreamOrderbookV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> AsyncStreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(AsyncStreamOrderbookV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> PrepareAsyncStreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(PrepareAsyncStreamOrderbookV2Raw(context, request, cq));
    }
    // Stream live level updates of selected derivative market orderbook
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> StreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(StreamOrderbookUpdateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> AsyncStreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(AsyncStreamOrderbookUpdateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> PrepareAsyncStreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(PrepareAsyncStreamOrderbookUpdateRaw(context, request, cq));
    }
    // DerivativeLimitOrders gets the limit orders of a Derivative Market.
    virtual ::grpc::Status Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::injective_derivative_exchange_rpc::OrdersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>> AsyncOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>>(AsyncOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>> PrepareAsyncOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>>(PrepareAsyncOrdersRaw(context, request, cq));
    }
    // Positions gets the positions for a trader.
    virtual ::grpc::Status Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::injective_derivative_exchange_rpc::PositionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>> AsyncPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>>(AsyncPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>> PrepareAsyncPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>>(PrepareAsyncPositionsRaw(context, request, cq));
    }
    // LiquidablePositions gets all the liquidable positions.
    virtual ::grpc::Status LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>> AsyncLiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>>(AsyncLiquidablePositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>> PrepareAsyncLiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>>(PrepareAsyncLiquidablePositionsRaw(context, request, cq));
    }
    // FundingPayments gets the funding payments for a trader.
    virtual ::grpc::Status FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>> AsyncFundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>>(AsyncFundingPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>> PrepareAsyncFundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>>(PrepareAsyncFundingPaymentsRaw(context, request, cq));
    }
    // FundingRates gets the historical funding rates for a market.
    virtual ::grpc::Status FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>> AsyncFundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>>(AsyncFundingRatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>> PrepareAsyncFundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>>(PrepareAsyncFundingRatesRaw(context, request, cq));
    }
    // StreamPositions streams derivatives position updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> StreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(StreamPositionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> AsyncStreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(AsyncStreamPositionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> PrepareAsyncStreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(PrepareAsyncStreamPositionsRaw(context, request, cq));
    }
    // StreamOrders streams updates to individual orders of a Derivative Market.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> StreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(StreamOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> AsyncStreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(AsyncStreamOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> PrepareAsyncStreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(PrepareAsyncStreamOrdersRaw(context, request, cq));
    }
    // Trades gets the trades of a Derivative Market.
    virtual ::grpc::Status Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::injective_derivative_exchange_rpc::TradesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>> AsyncTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>>(AsyncTradesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>> PrepareAsyncTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>>(PrepareAsyncTradesRaw(context, request, cq));
    }
    // StreamTrades streams newly executed trades from Derivative Market.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>> StreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(StreamTradesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>> AsyncStreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(AsyncStreamTradesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>> PrepareAsyncStreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(PrepareAsyncStreamTradesRaw(context, request, cq));
    }
    // SubaccountOrdersList lists orders posted from this subaccount.
    virtual ::grpc::Status SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>> AsyncSubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>>(AsyncSubaccountOrdersListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>> PrepareAsyncSubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>>(PrepareAsyncSubaccountOrdersListRaw(context, request, cq));
    }
    // SubaccountTradesList gets a list of derivatives trades executed by this
    // subaccount.
    virtual ::grpc::Status SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>> AsyncSubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>>(AsyncSubaccountTradesListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>> PrepareAsyncSubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>>(PrepareAsyncSubaccountTradesListRaw(context, request, cq));
    }
    // Lists history orders posted from a subaccount
    virtual ::grpc::Status OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>> AsyncOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>>(AsyncOrdersHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>> PrepareAsyncOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>>(PrepareAsyncOrdersHistoryRaw(context, request, cq));
    }
    // Stream updates to historical orders of a derivative Market
    std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> StreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(StreamOrdersHistoryRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> AsyncStreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(AsyncStreamOrdersHistoryRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> PrepareAsyncStreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(PrepareAsyncStreamOrdersHistoryRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Markets gets a list of Derivative Markets
      virtual void Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Market gets details of a single derivative market
      virtual void Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StreamMarket streams live updates of selected derivative markets
      virtual void StreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamMarketResponse>* reactor) = 0;
      // BinaryOptionsMarkets gets a list of Binary Options Markets
      virtual void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // BinaryOptionMarket gets details of a single binary options market
      virtual void BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Orderbook gets the Orderbook of a Derivative Market
      virtual void Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Orderbook gets the Orderbook of a Derivative Market
      virtual void OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Orderbooks gets the Orderbooks of requested derivative markets
      virtual void Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Orderbooks gets the Orderbooks of requested derivative markets
      virtual void OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stream live snapshot updates of selected derivative market orderbook
      virtual void StreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* reactor) = 0;
      // Stream live snapshot updates of selected derivative market orderbook
      virtual void StreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* reactor) = 0;
      // Stream live level updates of selected derivative market orderbook
      virtual void StreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* reactor) = 0;
      // DerivativeLimitOrders gets the limit orders of a Derivative Market.
      virtual void Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Positions gets the positions for a trader.
      virtual void Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // LiquidablePositions gets all the liquidable positions.
      virtual void LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // FundingPayments gets the funding payments for a trader.
      virtual void FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // FundingRates gets the historical funding rates for a market.
      virtual void FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StreamPositions streams derivatives position updates.
      virtual void StreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* reactor) = 0;
      // StreamOrders streams updates to individual orders of a Derivative Market.
      virtual void StreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* reactor) = 0;
      // Trades gets the trades of a Derivative Market.
      virtual void Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // StreamTrades streams newly executed trades from Derivative Market.
      virtual void StreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamTradesResponse>* reactor) = 0;
      // SubaccountOrdersList lists orders posted from this subaccount.
      virtual void SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // SubaccountTradesList gets a list of derivatives trades executed by this
      // subaccount.
      virtual void SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Lists history orders posted from a subaccount
      virtual void OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Stream updates to historical orders of a derivative Market
      virtual void StreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>* AsyncMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketsResponse>* PrepareAsyncMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>* AsyncMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::MarketResponse>* PrepareAsyncMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>* StreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>* AsyncStreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamMarketResponse>* PrepareAsyncStreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* AsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* PrepareAsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* AsyncBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* PrepareAsyncBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>* AsyncOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookResponse>* PrepareAsyncOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>* AsyncOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbookV2Response>* PrepareAsyncOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>* AsyncOrderbooksRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksResponse>* PrepareAsyncOrderbooksRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>* AsyncOrderbooksV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrderbooksV2Response>* PrepareAsyncOrderbooksV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* StreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* AsyncStreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* PrepareAsyncStreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* StreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* AsyncStreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* PrepareAsyncStreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* StreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* AsyncStreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* PrepareAsyncStreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>* AsyncOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersResponse>* PrepareAsyncOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>* AsyncPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::PositionsResponse>* PrepareAsyncPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* AsyncLiquidablePositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* PrepareAsyncLiquidablePositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* AsyncFundingPaymentsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* PrepareAsyncFundingPaymentsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>* AsyncFundingRatesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::FundingRatesResponse>* PrepareAsyncFundingRatesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* StreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* AsyncStreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* PrepareAsyncStreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* StreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* AsyncStreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* PrepareAsyncStreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>* AsyncTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::TradesResponse>* PrepareAsyncTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>* StreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>* AsyncStreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamTradesResponse>* PrepareAsyncStreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* AsyncSubaccountOrdersListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* PrepareAsyncSubaccountOrdersListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* AsyncSubaccountTradesListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* PrepareAsyncSubaccountTradesListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* AsyncOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* PrepareAsyncOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* StreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* AsyncStreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* PrepareAsyncStreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::injective_derivative_exchange_rpc::MarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>> AsyncMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>>(AsyncMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>> PrepareAsyncMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>>(PrepareAsyncMarketsRaw(context, request, cq));
    }
    ::grpc::Status Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::injective_derivative_exchange_rpc::MarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>> AsyncMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>>(AsyncMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>> PrepareAsyncMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>>(PrepareAsyncMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>> StreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(StreamMarketRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>> AsyncStreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(AsyncStreamMarketRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>> PrepareAsyncStreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>>(PrepareAsyncStreamMarketRaw(context, request, cq));
    }
    ::grpc::Status BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>> AsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>>(AsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>> PrepareAsyncBinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>>(PrepareAsyncBinaryOptionsMarketsRaw(context, request, cq));
    }
    ::grpc::Status BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>> AsyncBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>>(AsyncBinaryOptionsMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>> PrepareAsyncBinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>>(PrepareAsyncBinaryOptionsMarketRaw(context, request, cq));
    }
    ::grpc::Status Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::injective_derivative_exchange_rpc::OrderbookResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>> AsyncOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>>(AsyncOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>> PrepareAsyncOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>>(PrepareAsyncOrderbookRaw(context, request, cq));
    }
    ::grpc::Status OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>> AsyncOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>>(AsyncOrderbookV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>> PrepareAsyncOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>>(PrepareAsyncOrderbookV2Raw(context, request, cq));
    }
    ::grpc::Status Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>> AsyncOrderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>>(AsyncOrderbooksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>> PrepareAsyncOrderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>>(PrepareAsyncOrderbooksRaw(context, request, cq));
    }
    ::grpc::Status OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>> AsyncOrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>>(AsyncOrderbooksV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>> PrepareAsyncOrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>>(PrepareAsyncOrderbooksV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> StreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(StreamOrderbookRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> AsyncStreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(AsyncStreamOrderbookRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>> PrepareAsyncStreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>>(PrepareAsyncStreamOrderbookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> StreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(StreamOrderbookV2Raw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> AsyncStreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(AsyncStreamOrderbookV2Raw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>> PrepareAsyncStreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>>(PrepareAsyncStreamOrderbookV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> StreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(StreamOrderbookUpdateRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> AsyncStreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(AsyncStreamOrderbookUpdateRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>> PrepareAsyncStreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>>(PrepareAsyncStreamOrderbookUpdateRaw(context, request, cq));
    }
    ::grpc::Status Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::injective_derivative_exchange_rpc::OrdersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>> AsyncOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>>(AsyncOrdersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>> PrepareAsyncOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>>(PrepareAsyncOrdersRaw(context, request, cq));
    }
    ::grpc::Status Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::injective_derivative_exchange_rpc::PositionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>> AsyncPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>>(AsyncPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>> PrepareAsyncPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>>(PrepareAsyncPositionsRaw(context, request, cq));
    }
    ::grpc::Status LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>> AsyncLiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>>(AsyncLiquidablePositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>> PrepareAsyncLiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>>(PrepareAsyncLiquidablePositionsRaw(context, request, cq));
    }
    ::grpc::Status FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>> AsyncFundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>>(AsyncFundingPaymentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>> PrepareAsyncFundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>>(PrepareAsyncFundingPaymentsRaw(context, request, cq));
    }
    ::grpc::Status FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>> AsyncFundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>>(AsyncFundingRatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>> PrepareAsyncFundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>>(PrepareAsyncFundingRatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> StreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(StreamPositionsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> AsyncStreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(AsyncStreamPositionsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>> PrepareAsyncStreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>>(PrepareAsyncStreamPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> StreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(StreamOrdersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> AsyncStreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(AsyncStreamOrdersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>> PrepareAsyncStreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>>(PrepareAsyncStreamOrdersRaw(context, request, cq));
    }
    ::grpc::Status Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::injective_derivative_exchange_rpc::TradesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>> AsyncTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>>(AsyncTradesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>> PrepareAsyncTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>>(PrepareAsyncTradesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>> StreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(StreamTradesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>> AsyncStreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(AsyncStreamTradesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>> PrepareAsyncStreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>>(PrepareAsyncStreamTradesRaw(context, request, cq));
    }
    ::grpc::Status SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>> AsyncSubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>>(AsyncSubaccountOrdersListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>> PrepareAsyncSubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>>(PrepareAsyncSubaccountOrdersListRaw(context, request, cq));
    }
    ::grpc::Status SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>> AsyncSubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>>(AsyncSubaccountTradesListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>> PrepareAsyncSubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>>(PrepareAsyncSubaccountTradesListRaw(context, request, cq));
    }
    ::grpc::Status OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>> AsyncOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>>(AsyncOrdersHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>> PrepareAsyncOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>>(PrepareAsyncOrdersHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> StreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(StreamOrdersHistoryRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> AsyncStreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(AsyncStreamOrdersHistoryRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>> PrepareAsyncStreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>>(PrepareAsyncStreamOrdersHistoryRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void Markets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response, std::function<void(::grpc::Status)>) override;
      void Market(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamMarketResponse>* reactor) override;
      void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response, std::function<void(::grpc::Status)>) override;
      void BinaryOptionsMarkets(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response, std::function<void(::grpc::Status)>) override;
      void BinaryOptionsMarket(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response, std::function<void(::grpc::Status)>) override;
      void Orderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response, std::function<void(::grpc::Status)>) override;
      void OrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response, std::function<void(::grpc::Status)>) override;
      void Orderbooks(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response, std::function<void(::grpc::Status)>) override;
      void OrderbooksV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamOrderbook(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* reactor) override;
      void StreamOrderbookV2(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* reactor) override;
      void StreamOrderbookUpdate(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* reactor) override;
      void Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response, std::function<void(::grpc::Status)>) override;
      void Orders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response, std::function<void(::grpc::Status)>) override;
      void Positions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response, std::function<void(::grpc::Status)>) override;
      void LiquidablePositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response, std::function<void(::grpc::Status)>) override;
      void FundingPayments(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response, std::function<void(::grpc::Status)>) override;
      void FundingRates(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamPositions(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* reactor) override;
      void StreamOrders(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* reactor) override;
      void Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response, std::function<void(::grpc::Status)>) override;
      void Trades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamTrades(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamTradesResponse>* reactor) override;
      void SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountOrdersList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response, std::function<void(::grpc::Status)>) override;
      void SubaccountTradesList(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void OrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StreamOrdersHistory(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* request, ::grpc::ClientReadReactor< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>* AsyncMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketsResponse>* PrepareAsyncMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>* AsyncMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::MarketResponse>* PrepareAsyncMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::MarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>* StreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>* AsyncStreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamMarketResponse>* PrepareAsyncStreamMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* AsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* PrepareAsyncBinaryOptionsMarketsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* AsyncBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* PrepareAsyncBinaryOptionsMarketRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>* AsyncOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookResponse>* PrepareAsyncOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>* AsyncOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbookV2Response>* PrepareAsyncOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>* AsyncOrderbooksRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksResponse>* PrepareAsyncOrderbooksRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>* AsyncOrderbooksV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrderbooksV2Response>* PrepareAsyncOrderbooksV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* StreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* AsyncStreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* PrepareAsyncStreamOrderbookRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* StreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* AsyncStreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* PrepareAsyncStreamOrderbookV2Raw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* StreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* AsyncStreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* PrepareAsyncStreamOrderbookUpdateRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>* AsyncOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersResponse>* PrepareAsyncOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>* AsyncPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::PositionsResponse>* PrepareAsyncPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* AsyncLiquidablePositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* PrepareAsyncLiquidablePositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* AsyncFundingPaymentsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* PrepareAsyncFundingPaymentsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>* AsyncFundingRatesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::FundingRatesResponse>* PrepareAsyncFundingRatesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* StreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* AsyncStreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* PrepareAsyncStreamPositionsRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* StreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* AsyncStreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* PrepareAsyncStreamOrdersRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>* AsyncTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::TradesResponse>* PrepareAsyncTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::TradesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>* StreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>* AsyncStreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamTradesResponse>* PrepareAsyncStreamTradesRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* AsyncSubaccountOrdersListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* PrepareAsyncSubaccountOrdersListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* AsyncSubaccountTradesListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* PrepareAsyncSubaccountTradesListRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* AsyncOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* PrepareAsyncOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* StreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* AsyncStreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* PrepareAsyncStreamOrdersHistoryRaw(::grpc::ClientContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Markets_;
    const ::grpc::internal::RpcMethod rpcmethod_Market_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_BinaryOptionsMarkets_;
    const ::grpc::internal::RpcMethod rpcmethod_BinaryOptionsMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_Orderbook_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderbookV2_;
    const ::grpc::internal::RpcMethod rpcmethod_Orderbooks_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderbooksV2_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamOrderbook_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamOrderbookV2_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamOrderbookUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_Orders_;
    const ::grpc::internal::RpcMethod rpcmethod_Positions_;
    const ::grpc::internal::RpcMethod rpcmethod_LiquidablePositions_;
    const ::grpc::internal::RpcMethod rpcmethod_FundingPayments_;
    const ::grpc::internal::RpcMethod rpcmethod_FundingRates_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamPositions_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamOrders_;
    const ::grpc::internal::RpcMethod rpcmethod_Trades_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamTrades_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountOrdersList_;
    const ::grpc::internal::RpcMethod rpcmethod_SubaccountTradesList_;
    const ::grpc::internal::RpcMethod rpcmethod_OrdersHistory_;
    const ::grpc::internal::RpcMethod rpcmethod_StreamOrdersHistory_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Markets gets a list of Derivative Markets
    virtual ::grpc::Status Markets(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response);
    // Market gets details of a single derivative market
    virtual ::grpc::Status Market(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response);
    // StreamMarket streams live updates of selected derivative markets
    virtual ::grpc::Status StreamMarket(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* writer);
    // BinaryOptionsMarkets gets a list of Binary Options Markets
    virtual ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response);
    // BinaryOptionMarket gets details of a single binary options market
    virtual ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response);
    // Orderbook gets the Orderbook of a Derivative Market
    virtual ::grpc::Status Orderbook(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response);
    // Orderbook gets the Orderbook of a Derivative Market
    virtual ::grpc::Status OrderbookV2(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response);
    // Orderbooks gets the Orderbooks of requested derivative markets
    virtual ::grpc::Status Orderbooks(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response);
    // Orderbooks gets the Orderbooks of requested derivative markets
    virtual ::grpc::Status OrderbooksV2(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response);
    // Stream live snapshot updates of selected derivative market orderbook
    virtual ::grpc::Status StreamOrderbook(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* writer);
    // Stream live snapshot updates of selected derivative market orderbook
    virtual ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* writer);
    // Stream live level updates of selected derivative market orderbook
    virtual ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* writer);
    // DerivativeLimitOrders gets the limit orders of a Derivative Market.
    virtual ::grpc::Status Orders(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response);
    // Positions gets the positions for a trader.
    virtual ::grpc::Status Positions(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response);
    // LiquidablePositions gets all the liquidable positions.
    virtual ::grpc::Status LiquidablePositions(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response);
    // FundingPayments gets the funding payments for a trader.
    virtual ::grpc::Status FundingPayments(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response);
    // FundingRates gets the historical funding rates for a market.
    virtual ::grpc::Status FundingRates(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response);
    // StreamPositions streams derivatives position updates.
    virtual ::grpc::Status StreamPositions(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* writer);
    // StreamOrders streams updates to individual orders of a Derivative Market.
    virtual ::grpc::Status StreamOrders(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* writer);
    // Trades gets the trades of a Derivative Market.
    virtual ::grpc::Status Trades(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response);
    // StreamTrades streams newly executed trades from Derivative Market.
    virtual ::grpc::Status StreamTrades(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* writer);
    // SubaccountOrdersList lists orders posted from this subaccount.
    virtual ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response);
    // SubaccountTradesList gets a list of derivatives trades executed by this
    // subaccount.
    virtual ::grpc::Status SubaccountTradesList(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response);
    // Lists history orders posted from a subaccount
    virtual ::grpc::Status OrdersHistory(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response);
    // Stream updates to historical orders of a derivative Market
    virtual ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* request, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Markets() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarkets(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::MarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::MarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Market() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarket(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::MarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::MarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamMarket() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamMarket(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamMarketRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarkets(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarket(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Orderbook() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbook(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrderbookResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbookV2(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrderbookV2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Orderbooks() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbooks(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrderbooksResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbooksV2(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrderbooksV2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbook(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamOrderbookRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbookV2(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbookUpdate(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Orders() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrders(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrdersRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrdersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Positions() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositions(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::PositionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::PositionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidablePositions(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FundingPayments() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingPayments(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FundingRates() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingRates(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::FundingRatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamPositions() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamPositions(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamPositionsRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(17, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamOrders() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrders(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamOrdersRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Trades() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrades(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::TradesRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::TradesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamTrades() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamTrades(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamTradesRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrdersList(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTradesList(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersHistory(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrdersHistory(::grpc::ServerContext* context, ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* request, ::grpc::ServerAsyncWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Markets<WithAsyncMethod_Market<WithAsyncMethod_StreamMarket<WithAsyncMethod_BinaryOptionsMarkets<WithAsyncMethod_BinaryOptionsMarket<WithAsyncMethod_Orderbook<WithAsyncMethod_OrderbookV2<WithAsyncMethod_Orderbooks<WithAsyncMethod_OrderbooksV2<WithAsyncMethod_StreamOrderbook<WithAsyncMethod_StreamOrderbookV2<WithAsyncMethod_StreamOrderbookUpdate<WithAsyncMethod_Orders<WithAsyncMethod_Positions<WithAsyncMethod_LiquidablePositions<WithAsyncMethod_FundingPayments<WithAsyncMethod_FundingRates<WithAsyncMethod_StreamPositions<WithAsyncMethod_StreamOrders<WithAsyncMethod_Trades<WithAsyncMethod_StreamTrades<WithAsyncMethod_SubaccountOrdersList<WithAsyncMethod_SubaccountTradesList<WithAsyncMethod_OrdersHistory<WithAsyncMethod_StreamOrdersHistory<Service > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Markets() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::MarketsRequest, ::injective_derivative_exchange_rpc::MarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::MarketsRequest* request, ::injective_derivative_exchange_rpc::MarketsResponse* response) { return this->Markets(context, request, response); }));}
    void SetMessageAllocatorFor_Markets(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::MarketsRequest, ::injective_derivative_exchange_rpc::MarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::MarketsRequest, ::injective_derivative_exchange_rpc::MarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Markets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Market() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::MarketRequest, ::injective_derivative_exchange_rpc::MarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::MarketRequest* request, ::injective_derivative_exchange_rpc::MarketResponse* response) { return this->Market(context, request, response); }));}
    void SetMessageAllocatorFor_Market(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::MarketRequest, ::injective_derivative_exchange_rpc::MarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::MarketRequest, ::injective_derivative_exchange_rpc::MarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Market(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamMarket() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamMarketRequest, ::injective_derivative_exchange_rpc::StreamMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamMarketRequest* request) { return this->StreamMarket(context, request); }));
    }
    ~WithCallbackMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamMarketResponse>* StreamMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* response) { return this->BinaryOptionsMarkets(context, request, response); }));}
    void SetMessageAllocatorFor_BinaryOptionsMarkets(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* request, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* response) { return this->BinaryOptionsMarket(context, request, response); }));}
    void SetMessageAllocatorFor_BinaryOptionsMarket(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Orderbook() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbookRequest, ::injective_derivative_exchange_rpc::OrderbookResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrderbookRequest* request, ::injective_derivative_exchange_rpc::OrderbookResponse* response) { return this->Orderbook(context, request, response); }));}
    void SetMessageAllocatorFor_Orderbook(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrderbookRequest, ::injective_derivative_exchange_rpc::OrderbookResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbookRequest, ::injective_derivative_exchange_rpc::OrderbookResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbookV2Request, ::injective_derivative_exchange_rpc::OrderbookV2Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrderbookV2Request* request, ::injective_derivative_exchange_rpc::OrderbookV2Response* response) { return this->OrderbookV2(context, request, response); }));}
    void SetMessageAllocatorFor_OrderbookV2(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrderbookV2Request, ::injective_derivative_exchange_rpc::OrderbookV2Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbookV2Request, ::injective_derivative_exchange_rpc::OrderbookV2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrderbookV2(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Orderbooks() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbooksRequest, ::injective_derivative_exchange_rpc::OrderbooksResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrderbooksRequest* request, ::injective_derivative_exchange_rpc::OrderbooksResponse* response) { return this->Orderbooks(context, request, response); }));}
    void SetMessageAllocatorFor_Orderbooks(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrderbooksRequest, ::injective_derivative_exchange_rpc::OrderbooksResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbooksRequest, ::injective_derivative_exchange_rpc::OrderbooksResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orderbooks(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbooksV2Request, ::injective_derivative_exchange_rpc::OrderbooksV2Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* request, ::injective_derivative_exchange_rpc::OrderbooksV2Response* response) { return this->OrderbooksV2(context, request, response); }));}
    void SetMessageAllocatorFor_OrderbooksV2(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrderbooksV2Request, ::injective_derivative_exchange_rpc::OrderbooksV2Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrderbooksV2Request, ::injective_derivative_exchange_rpc::OrderbooksV2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrderbooksV2(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamOrderbookRequest, ::injective_derivative_exchange_rpc::StreamOrderbookResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* request) { return this->StreamOrderbook(context, request); }));
    }
    ~WithCallbackMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* StreamOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamOrderbookV2Request, ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* request) { return this->StreamOrderbookV2(context, request); }));
    }
    ~WithCallbackMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* StreamOrderbookV2(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest, ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* request) { return this->StreamOrderbookUpdate(context, request); }));
    }
    ~WithCallbackMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* StreamOrderbookUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Orders() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrdersRequest, ::injective_derivative_exchange_rpc::OrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrdersRequest* request, ::injective_derivative_exchange_rpc::OrdersResponse* response) { return this->Orders(context, request, response); }));}
    void SetMessageAllocatorFor_Orders(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrdersRequest, ::injective_derivative_exchange_rpc::OrdersResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrdersRequest, ::injective_derivative_exchange_rpc::OrdersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Positions() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::PositionsRequest, ::injective_derivative_exchange_rpc::PositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::PositionsRequest* request, ::injective_derivative_exchange_rpc::PositionsResponse* response) { return this->Positions(context, request, response); }));}
    void SetMessageAllocatorFor_Positions(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::PositionsRequest, ::injective_derivative_exchange_rpc::PositionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::PositionsRequest, ::injective_derivative_exchange_rpc::PositionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Positions(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::LiquidablePositionsRequest, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* request, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* response) { return this->LiquidablePositions(context, request, response); }));}
    void SetMessageAllocatorFor_LiquidablePositions(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::LiquidablePositionsRequest, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::LiquidablePositionsRequest, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LiquidablePositions(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FundingPayments() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::FundingPaymentsRequest, ::injective_derivative_exchange_rpc::FundingPaymentsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* request, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* response) { return this->FundingPayments(context, request, response); }));}
    void SetMessageAllocatorFor_FundingPayments(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::FundingPaymentsRequest, ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::FundingPaymentsRequest, ::injective_derivative_exchange_rpc::FundingPaymentsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FundingPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FundingRates() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::FundingRatesRequest, ::injective_derivative_exchange_rpc::FundingRatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::FundingRatesRequest* request, ::injective_derivative_exchange_rpc::FundingRatesResponse* response) { return this->FundingRates(context, request, response); }));}
    void SetMessageAllocatorFor_FundingRates(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::FundingRatesRequest, ::injective_derivative_exchange_rpc::FundingRatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::FundingRatesRequest, ::injective_derivative_exchange_rpc::FundingRatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FundingRates(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamPositions() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamPositionsRequest, ::injective_derivative_exchange_rpc::StreamPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* request) { return this->StreamPositions(context, request); }));
    }
    ~WithCallbackMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* StreamPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamOrders() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamOrdersRequest, ::injective_derivative_exchange_rpc::StreamOrdersResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* request) { return this->StreamOrders(context, request); }));
    }
    ~WithCallbackMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* StreamOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Trades() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::TradesRequest, ::injective_derivative_exchange_rpc::TradesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::TradesRequest* request, ::injective_derivative_exchange_rpc::TradesResponse* response) { return this->Trades(context, request, response); }));}
    void SetMessageAllocatorFor_Trades(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::TradesRequest, ::injective_derivative_exchange_rpc::TradesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::TradesRequest, ::injective_derivative_exchange_rpc::TradesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Trades(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamTrades() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamTradesRequest, ::injective_derivative_exchange_rpc::StreamTradesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamTradesRequest* request) { return this->StreamTrades(context, request); }));
    }
    ~WithCallbackMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamTradesResponse>* StreamTrades(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* request, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* response) { return this->SubaccountOrdersList(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountOrdersList(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrdersList(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::SubaccountTradesListRequest, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* request, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* response) { return this->SubaccountTradesList(context, request, response); }));}
    void SetMessageAllocatorFor_SubaccountTradesList(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::SubaccountTradesListRequest, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::SubaccountTradesListRequest, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTradesList(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrdersHistoryRequest, ::injective_derivative_exchange_rpc::OrdersHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* request, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* response) { return this->OrdersHistory(context, request, response); }));}
    void SetMessageAllocatorFor_OrdersHistory(
        ::grpc::MessageAllocator< ::injective_derivative_exchange_rpc::OrdersHistoryRequest, ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::injective_derivative_exchange_rpc::OrdersHistoryRequest, ::injective_derivative_exchange_rpc::OrdersHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrdersHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest, ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* request) { return this->StreamOrdersHistory(context, request); }));
    }
    ~WithCallbackMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* StreamOrdersHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Markets<WithCallbackMethod_Market<WithCallbackMethod_StreamMarket<WithCallbackMethod_BinaryOptionsMarkets<WithCallbackMethod_BinaryOptionsMarket<WithCallbackMethod_Orderbook<WithCallbackMethod_OrderbookV2<WithCallbackMethod_Orderbooks<WithCallbackMethod_OrderbooksV2<WithCallbackMethod_StreamOrderbook<WithCallbackMethod_StreamOrderbookV2<WithCallbackMethod_StreamOrderbookUpdate<WithCallbackMethod_Orders<WithCallbackMethod_Positions<WithCallbackMethod_LiquidablePositions<WithCallbackMethod_FundingPayments<WithCallbackMethod_FundingRates<WithCallbackMethod_StreamPositions<WithCallbackMethod_StreamOrders<WithCallbackMethod_Trades<WithCallbackMethod_StreamTrades<WithCallbackMethod_SubaccountOrdersList<WithCallbackMethod_SubaccountTradesList<WithCallbackMethod_OrdersHistory<WithCallbackMethod_StreamOrdersHistory<Service > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Markets() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Market() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamMarket() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Orderbook() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Orderbooks() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Orders() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Positions() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FundingPayments() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FundingRates() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamPositions() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamOrders() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Trades() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamTrades() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Markets() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Market() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamMarket() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBinaryOptionsMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Orderbook() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbookV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Orderbooks() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbooks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderbooksV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(9, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbookV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(10, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrderbookUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Orders() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Positions() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidablePositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FundingPayments() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingPayments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FundingRates() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFundingRates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamPositions() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamPositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(17, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamOrders() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrders(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(18, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Trades() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTrades(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamTrades() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamTrades(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(20, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountOrdersList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubaccountTradesList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamOrdersHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(24, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Markets() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Markets(context, request, response); }));
    }
    ~WithRawCallbackMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Markets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Market() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Market(context, request, response); }));
    }
    ~WithRawCallbackMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Market(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamMarket() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamMarket(context, request); }));
    }
    ~WithRawCallbackMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BinaryOptionsMarkets(context, request, response); }));
    }
    ~WithRawCallbackMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarkets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BinaryOptionsMarket(context, request, response); }));
    }
    ~WithRawCallbackMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BinaryOptionsMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Orderbook() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Orderbook(context, request, response); }));
    }
    ~WithRawCallbackMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderbookV2(context, request, response); }));
    }
    ~WithRawCallbackMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrderbookV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Orderbooks() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Orderbooks(context, request, response); }));
    }
    ~WithRawCallbackMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orderbooks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderbooksV2(context, request, response); }));
    }
    ~WithRawCallbackMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrderbooksV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamOrderbook(context, request); }));
    }
    ~WithRawCallbackMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamOrderbook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamOrderbookV2(context, request); }));
    }
    ~WithRawCallbackMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamOrderbookV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamOrderbookUpdate(context, request); }));
    }
    ~WithRawCallbackMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamOrderbookUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Orders() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Orders(context, request, response); }));
    }
    ~WithRawCallbackMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Orders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Positions() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Positions(context, request, response); }));
    }
    ~WithRawCallbackMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Positions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LiquidablePositions(context, request, response); }));
    }
    ~WithRawCallbackMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LiquidablePositions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FundingPayments() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FundingPayments(context, request, response); }));
    }
    ~WithRawCallbackMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FundingPayments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FundingRates() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FundingRates(context, request, response); }));
    }
    ~WithRawCallbackMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FundingRates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamPositions() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamPositions(context, request); }));
    }
    ~WithRawCallbackMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamOrders() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamOrders(context, request); }));
    }
    ~WithRawCallbackMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamOrders(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Trades() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Trades(context, request, response); }));
    }
    ~WithRawCallbackMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Trades(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamTrades() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamTrades(context, request); }));
    }
    ~WithRawCallbackMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamTrades(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountOrdersList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountOrdersList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubaccountTradesList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SubaccountTradesList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrdersHistory(context, request, response); }));
    }
    ~WithRawCallbackMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* OrdersHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->StreamOrdersHistory(context, request); }));
    }
    ~WithRawCallbackMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* StreamOrdersHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Markets() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::MarketsRequest, ::injective_derivative_exchange_rpc::MarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::MarketsRequest, ::injective_derivative_exchange_rpc::MarketsResponse>* streamer) {
                       return this->StreamedMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::MarketsRequest,::injective_derivative_exchange_rpc::MarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Market : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Market() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::MarketRequest, ::injective_derivative_exchange_rpc::MarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::MarketRequest, ::injective_derivative_exchange_rpc::MarketResponse>* streamer) {
                       return this->StreamedMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Market() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Market(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::MarketRequest* /*request*/, ::injective_derivative_exchange_rpc::MarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::MarketRequest,::injective_derivative_exchange_rpc::MarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BinaryOptionsMarkets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BinaryOptionsMarkets() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* streamer) {
                       return this->StreamedBinaryOptionsMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BinaryOptionsMarkets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BinaryOptionsMarkets(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBinaryOptionsMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::BinaryOptionsMarketsRequest,::injective_derivative_exchange_rpc::BinaryOptionsMarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BinaryOptionsMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BinaryOptionsMarket() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* streamer) {
                       return this->StreamedBinaryOptionsMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BinaryOptionsMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BinaryOptionsMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest* /*request*/, ::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBinaryOptionsMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::BinaryOptionsMarketRequest,::injective_derivative_exchange_rpc::BinaryOptionsMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Orderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Orderbook() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrderbookRequest, ::injective_derivative_exchange_rpc::OrderbookResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrderbookRequest, ::injective_derivative_exchange_rpc::OrderbookResponse>* streamer) {
                       return this->StreamedOrderbook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Orderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Orderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbookResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderbook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrderbookRequest,::injective_derivative_exchange_rpc::OrderbookResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderbookV2() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrderbookV2Request, ::injective_derivative_exchange_rpc::OrderbookV2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrderbookV2Request, ::injective_derivative_exchange_rpc::OrderbookV2Response>* streamer) {
                       return this->StreamedOrderbookV2(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbookV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbookV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderbookV2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrderbookV2Request,::injective_derivative_exchange_rpc::OrderbookV2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Orderbooks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Orderbooks() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrderbooksRequest, ::injective_derivative_exchange_rpc::OrderbooksResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrderbooksRequest, ::injective_derivative_exchange_rpc::OrderbooksResponse>* streamer) {
                       return this->StreamedOrderbooks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Orderbooks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Orderbooks(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksRequest* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderbooks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrderbooksRequest,::injective_derivative_exchange_rpc::OrderbooksResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderbooksV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderbooksV2() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrderbooksV2Request, ::injective_derivative_exchange_rpc::OrderbooksV2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrderbooksV2Request, ::injective_derivative_exchange_rpc::OrderbooksV2Response>* streamer) {
                       return this->StreamedOrderbooksV2(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderbooksV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderbooksV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrderbooksV2Request* /*request*/, ::injective_derivative_exchange_rpc::OrderbooksV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderbooksV2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrderbooksV2Request,::injective_derivative_exchange_rpc::OrderbooksV2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Orders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Orders() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrdersRequest, ::injective_derivative_exchange_rpc::OrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrdersRequest, ::injective_derivative_exchange_rpc::OrdersResponse>* streamer) {
                       return this->StreamedOrders(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Orders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Orders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrders(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrdersRequest,::injective_derivative_exchange_rpc::OrdersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Positions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Positions() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::PositionsRequest, ::injective_derivative_exchange_rpc::PositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::PositionsRequest, ::injective_derivative_exchange_rpc::PositionsResponse>* streamer) {
                       return this->StreamedPositions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Positions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Positions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::PositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::PositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPositions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::PositionsRequest,::injective_derivative_exchange_rpc::PositionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LiquidablePositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LiquidablePositions() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::LiquidablePositionsRequest, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::LiquidablePositionsRequest, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* streamer) {
                       return this->StreamedLiquidablePositions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LiquidablePositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LiquidablePositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::LiquidablePositionsRequest* /*request*/, ::injective_derivative_exchange_rpc::LiquidablePositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLiquidablePositions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::LiquidablePositionsRequest,::injective_derivative_exchange_rpc::LiquidablePositionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FundingPayments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FundingPayments() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::FundingPaymentsRequest, ::injective_derivative_exchange_rpc::FundingPaymentsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::FundingPaymentsRequest, ::injective_derivative_exchange_rpc::FundingPaymentsResponse>* streamer) {
                       return this->StreamedFundingPayments(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FundingPayments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FundingPayments(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingPaymentsRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingPaymentsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFundingPayments(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::FundingPaymentsRequest,::injective_derivative_exchange_rpc::FundingPaymentsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FundingRates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FundingRates() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::FundingRatesRequest, ::injective_derivative_exchange_rpc::FundingRatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::FundingRatesRequest, ::injective_derivative_exchange_rpc::FundingRatesResponse>* streamer) {
                       return this->StreamedFundingRates(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FundingRates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FundingRates(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::FundingRatesRequest* /*request*/, ::injective_derivative_exchange_rpc::FundingRatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFundingRates(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::FundingRatesRequest,::injective_derivative_exchange_rpc::FundingRatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Trades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Trades() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::TradesRequest, ::injective_derivative_exchange_rpc::TradesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::TradesRequest, ::injective_derivative_exchange_rpc::TradesResponse>* streamer) {
                       return this->StreamedTrades(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Trades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Trades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::TradesRequest* /*request*/, ::injective_derivative_exchange_rpc::TradesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTrades(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::TradesRequest,::injective_derivative_exchange_rpc::TradesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountOrdersList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountOrdersList() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* streamer) {
                       return this->StreamedSubaccountOrdersList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountOrdersList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountOrdersList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountOrdersListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountOrdersList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::SubaccountOrdersListRequest,::injective_derivative_exchange_rpc::SubaccountOrdersListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubaccountTradesList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubaccountTradesList() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::SubaccountTradesListRequest, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::SubaccountTradesListRequest, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* streamer) {
                       return this->StreamedSubaccountTradesList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubaccountTradesList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubaccountTradesList(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::SubaccountTradesListRequest* /*request*/, ::injective_derivative_exchange_rpc::SubaccountTradesListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubaccountTradesList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::SubaccountTradesListRequest,::injective_derivative_exchange_rpc::SubaccountTradesListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrdersHistory() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::injective_derivative_exchange_rpc::OrdersHistoryRequest, ::injective_derivative_exchange_rpc::OrdersHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::injective_derivative_exchange_rpc::OrdersHistoryRequest, ::injective_derivative_exchange_rpc::OrdersHistoryResponse>* streamer) {
                       return this->StreamedOrdersHistory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::OrdersHistoryRequest* /*request*/, ::injective_derivative_exchange_rpc::OrdersHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrdersHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::injective_derivative_exchange_rpc::OrdersHistoryRequest,::injective_derivative_exchange_rpc::OrdersHistoryResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Markets<WithStreamedUnaryMethod_Market<WithStreamedUnaryMethod_BinaryOptionsMarkets<WithStreamedUnaryMethod_BinaryOptionsMarket<WithStreamedUnaryMethod_Orderbook<WithStreamedUnaryMethod_OrderbookV2<WithStreamedUnaryMethod_Orderbooks<WithStreamedUnaryMethod_OrderbooksV2<WithStreamedUnaryMethod_Orders<WithStreamedUnaryMethod_Positions<WithStreamedUnaryMethod_LiquidablePositions<WithStreamedUnaryMethod_FundingPayments<WithStreamedUnaryMethod_FundingRates<WithStreamedUnaryMethod_Trades<WithStreamedUnaryMethod_SubaccountOrdersList<WithStreamedUnaryMethod_SubaccountTradesList<WithStreamedUnaryMethod_OrdersHistory<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamMarket() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamMarketRequest, ::injective_derivative_exchange_rpc::StreamMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamMarketRequest, ::injective_derivative_exchange_rpc::StreamMarketResponse>* streamer) {
                       return this->StreamedStreamMarket(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamMarket(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamMarketRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamMarketResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamMarket(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamMarketRequest,::injective_derivative_exchange_rpc::StreamMarketResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamOrderbook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamOrderbook() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamOrderbookRequest, ::injective_derivative_exchange_rpc::StreamOrderbookResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamOrderbookRequest, ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* streamer) {
                       return this->StreamedStreamOrderbook(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamOrderbook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamOrderbook(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamOrderbook(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamOrderbookRequest,::injective_derivative_exchange_rpc::StreamOrderbookResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamOrderbookV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamOrderbookV2() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamOrderbookV2Request, ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamOrderbookV2Request, ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* streamer) {
                       return this->StreamedStreamOrderbookV2(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamOrderbookV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamOrderbookV2(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookV2Request* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamOrderbookV2(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamOrderbookV2Request,::injective_derivative_exchange_rpc::StreamOrderbookV2Response>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamOrderbookUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamOrderbookUpdate() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest, ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest, ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* streamer) {
                       return this->StreamedStreamOrderbookUpdate(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamOrderbookUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamOrderbookUpdate(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamOrderbookUpdate(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamOrderbookUpdateRequest,::injective_derivative_exchange_rpc::StreamOrderbookUpdateResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamPositions() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamPositionsRequest, ::injective_derivative_exchange_rpc::StreamPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamPositionsRequest, ::injective_derivative_exchange_rpc::StreamPositionsResponse>* streamer) {
                       return this->StreamedStreamPositions(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamPositions(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamPositionsRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamPositionsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamPositions(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamPositionsRequest,::injective_derivative_exchange_rpc::StreamPositionsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamOrders : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamOrders() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamOrdersRequest, ::injective_derivative_exchange_rpc::StreamOrdersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamOrdersRequest, ::injective_derivative_exchange_rpc::StreamOrdersResponse>* streamer) {
                       return this->StreamedStreamOrders(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamOrders() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamOrders(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamOrders(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamOrdersRequest,::injective_derivative_exchange_rpc::StreamOrdersResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamTrades : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamTrades() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamTradesRequest, ::injective_derivative_exchange_rpc::StreamTradesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamTradesRequest, ::injective_derivative_exchange_rpc::StreamTradesResponse>* streamer) {
                       return this->StreamedStreamTrades(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamTrades() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamTrades(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamTradesRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamTradesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamTrades(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamTradesRequest,::injective_derivative_exchange_rpc::StreamTradesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamOrdersHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_StreamOrdersHistory() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest, ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest, ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* streamer) {
                       return this->StreamedStreamOrdersHistory(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_StreamOrdersHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamOrdersHistory(::grpc::ServerContext* /*context*/, const ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest* /*request*/, ::grpc::ServerWriter< ::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamOrdersHistory(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::injective_derivative_exchange_rpc::StreamOrdersHistoryRequest,::injective_derivative_exchange_rpc::StreamOrdersHistoryResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamMarket<WithSplitStreamingMethod_StreamOrderbook<WithSplitStreamingMethod_StreamOrderbookV2<WithSplitStreamingMethod_StreamOrderbookUpdate<WithSplitStreamingMethod_StreamPositions<WithSplitStreamingMethod_StreamOrders<WithSplitStreamingMethod_StreamTrades<WithSplitStreamingMethod_StreamOrdersHistory<Service > > > > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Markets<WithStreamedUnaryMethod_Market<WithSplitStreamingMethod_StreamMarket<WithStreamedUnaryMethod_BinaryOptionsMarkets<WithStreamedUnaryMethod_BinaryOptionsMarket<WithStreamedUnaryMethod_Orderbook<WithStreamedUnaryMethod_OrderbookV2<WithStreamedUnaryMethod_Orderbooks<WithStreamedUnaryMethod_OrderbooksV2<WithSplitStreamingMethod_StreamOrderbook<WithSplitStreamingMethod_StreamOrderbookV2<WithSplitStreamingMethod_StreamOrderbookUpdate<WithStreamedUnaryMethod_Orders<WithStreamedUnaryMethod_Positions<WithStreamedUnaryMethod_LiquidablePositions<WithStreamedUnaryMethod_FundingPayments<WithStreamedUnaryMethod_FundingRates<WithSplitStreamingMethod_StreamPositions<WithSplitStreamingMethod_StreamOrders<WithStreamedUnaryMethod_Trades<WithSplitStreamingMethod_StreamTrades<WithStreamedUnaryMethod_SubaccountOrdersList<WithStreamedUnaryMethod_SubaccountTradesList<WithStreamedUnaryMethod_OrdersHistory<WithSplitStreamingMethod_StreamOrdersHistory<Service > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace injective_derivative_exchange_rpc


#endif  // GRPC_exchange_2finjective_5fderivative_5fexchange_5frpc_2eproto__INCLUDED
